{"aid": "40000919", "title": "Metaprogramming custom control structures in C (2012)", "url": "https://www.chiark.greenend.org.uk/~sgtatham/mp/", "domain": "greenend.org.uk", "votes": 1, "user": "Tomte", "posted_at": "2024-04-11 11:15:35", "comments": 0, "source_title": "Metaprogramming custom control structures in C", "source_text": "Metaprogramming custom control structures in C\n\n# Metaprogramming custom control structures in C\n\nby Simon Tatham\n\nThis article describes a technique for using the C preprocessor to implement a\nform of metaprogramming in C, allowing a programmer to define custom looping\nand control constructions which behave syntactically like C's own for, while\nand if but manage control flow in a user-defined way. The technique is almost\nall portable C89, except that some constructions need the feature (available\nin both C99 and C++) of defining a variable in the initialiser of a for\nstatement. Sample code is provided.\n\n## 1\\. Motivation\n\nThe existing control constructions in C need no introduction. Every C\nprogrammer is familiar with if, while, do...while, and for statements, and\ntheir effects on control flow. Every so often, though, you might come across a\nsituation in which it might be nice to be able to invent slightly different\ncontrol mechanisms.\n\nAs one example, if you're iterating over a circularly linked list without a\ndistinguished head element, you might find it inconvenient that for does its\ntest at the head of the loop, because the apparently obvious way to iterate\nover such a list (comparing your current-element pointer to the list head in\nthe test clause) will execute zero times. So you might like a variant of for\nthat does its test at the end of the loop:\n\n    \n    \n    for_after (elephant *e = head; e != head; e = e->next) do_stuff_with(e);\n\nor, better still, one that has a separate test for the first iteration, so you\ncan also check if the list is completely empty:\n\n    \n    \n    for_general (elephant *e = head; e != NULL; e != head; e = e->next) do_stuff_with(e);\n\nThere's also a lot of scope for program-specific control constructions, if you\nfind yourself writing some particular kind of loop a lot in a specific code\nbase. For instance, suppose you have some kind of API for retrieving a list of\nthings, and the API requires a lot of setup and teardown and function calls.\nYou might find that even the simplest of loops to actually do something with\nyour list looks a bit like this:\n\n    \n    \n    { hippo_retrieval_context *hc; hc = new_hippo_retrieval_context(); while (hippo_available(hc)) { hippo *h = get_hippo(hc); printf(\"We have a hippo called %s\\n\", h->name); free_hippo(hc, h); } free_hippo_retrieval_context(hc); }\n\nand if you find yourself needing to iterate over these lists a lot, then your\nprogram will become tediously full of copies of that kind of boilerplate. In\nsuch a program you might feel that it would be nice to wrap all that machinery\nup into a macro defined in your own program's headers, so that you could write\njust the part of the loop that needed to change every time:\n\n    \n    \n    FOR_EACH_HIPPO (hippo *h) printf(\"We have a hippo called %s\\n\", h->name);\n\nIf you were doing it like this, you'd probably also like to arrange that break\nstatements were handled sensibly. In the above example, if the code which\nactually deals with a list element wants to terminate the loop, it probably\nhas to make sure to write a second copy of the free_hippo call before its\nbreak statement, because the copy at the end of the while loop body will be\nskipped by the break. If you were inventing a custom loop construction, you'd\nlike to arrange that break had configurable handling, so that it automatically\ncleaned up this sort of thing.\n\nIt's easy to imagine that if you felt strongly enough about wanting this sort\nof thing in your language, you could do it by inventing a sort of secondary\npreprocessor, which ran after the standard C preprocessor and knew enough\nabout C syntax to be able to recognise things like statements, blocks,\ndeclarations and expressions. Then you could define \u2018macros\u2019 which looked\nrather like additional grammar rules, and implement your extra loop\nconstructions as those.\n\nBut in fact, one need not go that far. There is already a way to implement\nalmost exactly the above control constructions in standard C, if you're\nprepared to be devious enough with the existing C preprocessor. In this\narticle, I'll show how, and provide sample code.\n\n(I say \u2018almost\u2019, because due to limitations of C macro syntax, the one thing\nin the above snippets that can't be arranged is the separation of clauses in\nfor_after and for_general with semicolons rather than commas.)\n\n## 2\\. Mechanism\n\nIf we're going to build custom loop constructions of this type, then how can\nwe do it?\n\nIf we want our finished loop construction to be used by means of syntax like\nthis:\n\n    \n    \n    MY_LOOP_KEYWORD (parameters) statement or braced block\n\nthen it's clear that we're going to have to define MY_LOOP_KEYWORD as a macro,\nand also that the macro must expand to a statement prefix: that is, something\nwhich you can put on the front of a valid C statement to yield another valid C\nstatement.\n\nSo what do those constraints allow us to do? Well, there are several types of\nstatement prefix in the C syntax:\n\n  * a label\n  * while (stuff)\n  * for (stuff; stuff; stuff)\n  * if (stuff) {stuff} else\n  * more than one of the above, one after another.\n\n(There's also switch (stuff) and case labels, but we'd like to avoid those if\npossible because of their side effect of interfering with case labels from an\nouter switch. It turns out we don't need them anyway; the above list is\nsufficient.)\n\nSo we're going to explore the range of possibilities allowed by defining a\nmacro to expand to a chain of those types of thing, and then prefixing it to a\nuser-supplied statement.\n\nThe critical component in the list above is the if...else statement prefix,\nbecause it allows us to provide a braced statement block of our own, in which\nwe can put code of our choice. This will of course be vital for any loop\nconstruction which has to run specialist code at the start and end, or between\niterations.\n\nSo, to begin with, here's a construction that lets us run code of our choice\nand then run the user's code. Suppose we define our macro so that, when\nfollowed by a statement or block, it expands to this:\n\n    \n    \n    if (1) { /* code of our choice */ goto body; } else body: { /* block following the expanded macro */ }\n\nYou can see how this works by following the control flow through from the top.\nWe come into the if statement; the condition is always true, so we execute the\n\u2018code of our choice\u2019 section first; then we reach the goto, which conveniently\nlets us get into the else clause of the same if statement even though that\nwould not otherwise have been executed at all. So we execute our code, and\nthen the user's code.\n\nThat was nice and easy. Now what if we want to run code of our choice after\nthe user's loop body?\n\nWell, we certainly can't do that using only if and labels, because those can't\nstop execution from falling off the end of the user's block and on to the\nfollowing code. The code we want to run afterwards has to be written above the\nuser's code, which means control flow has to move backwards in the source file\n\u2013 and to do that, we have to use a loop statement. So we can do this, for\nexample:\n\n    \n    \n    if (1) goto body; else while (1) if (1) { /* code of our choice */ break; } else body: { /* block following the expanded macro */ }\n\nAs before, we first go into the then-clause of the outermost if, which\ncontains a goto that jumps us directly to the user's block. We execute that\nblock, but then what? Well, that block is enclosed in a while (1) statement,\nso we now go back round to the top of the while and enter the then-clause of\nthe inner if \u2013 where we then run code of our choice, and after that, execute\nthe break statement which terminates the loop. So we've successfully injected\ncode to be run after the user's code has been executed. And still the whole\nconstruction consists solely of a chain of statement prefixes prepended to the\nuser's block, so we could feasibly define a macro to expand to all but the\nlast line of the above snippet.\n\nSo this is beginning to look pretty promising. We can use both of the\ntechniques above to get code to run before and after the user's code; we can\nfurther mess about with the control flow by scattering extra labels all over\nthe place and have our inserted code blocks test conditions, think hard about\nwhat to do, and then issue an appropriate goto.\n\nAnother thing we may well want to do is to bring variable declarations into\nscope, so that they can be accessed both by our added code in if blocks and by\nthe user's code itself. This is unfortunately not feasible in old-style C89,\nsince in that you can only open a new scope with an open brace character, and\nthat would mean the user would have to provide an extra closing brace after\ntheir statement, which would look ugly and (worse still) confuse editors'\nautomatic C indentation policies.\n\nBut if you're willing to allow yourself the one extra language feature of\nbeing able to use a declaration as the initialiser clause of a for statement\n(which is legal in both C99 and C++, so the chances are that your compiler\nprobably has some mode that supports it), then suddenly it becomes possible to\nbring any declaration you like into scope.\n\nSo an obvious approach is to put the declaration in a for, and then use\nexactly the same technique as above to stop the for from actually causing a\nloop: i.e. repeat exactly the previous code snippet but replace the while with\na for.\n\nThat's not quite ideal, though, because execution jumps over the declaration\nrather than passing through it. If the declaration doesn't include an\ninitialiser, that makes no difference; but you might want to declare and\ninitialise the declaration in one go. One reason for that might be if you're\nworking in C++ and need the constructor to be called; another reason might be\nif the user was providing a parameter to the loop macro which you wanted to\ntreat as part of a combined declaration and initialiser, such as the \u2018hippo\n*h\u2019 in one of the examples in section 1. (If the user provides a macro\nparameter of the form \u2018type *var\u2019, then we can put that parameter before an\nassignment to produce a declaration-with-initialiser, but we can't extract the\nvariable name on its own in order to do the declaration and initialisation\nseparately.)\n\nSo, can we fix that? Well, we'll have to do two things. One is to recover\ncontrol after the user's block runs (but we can do that using the while-based\nconstruction above), and the other is to find a way to transfer control back\nout of the for without falling into the trap of writing a break which is\nexecuted in the context of the while.\n\nFor this, a helpful trick is to put a label inside an if (0). Like this:\n\n    \n    \n    if (0) finished: ; else for (/* declaration of our choice */ ;;) if (1) goto body; else while (1) if (1) goto finished; else body: { /* block following the expanded macro */ }\n\nSo the initial if (0) is ignored and we begin executing the for statement,\nincluding its declaration. The construction inside the for should now be\nfamiliar from the previous example: its job is to execute the user's block and\nthen loop back round to the goto finished statement, which transfers control\ninto the then-clause of the outermost if. From there, control bypasses the\nwhole else-clause and drops out of the bottom. So this approach to\ndeclarations works.\n\nNow what about handling break? If you think about what would happen to some of\nthe above snippets if the suffixed block executes break, you find that the\nfirst one (that executes code of our choice before the user's code) doesn't\ninterfere with break at all, so that it would still terminate the next\noutermost loop or switch; but the other two, in which the user's code is\nembedded in a while or a for, both have the side effect of changing the\nmeaning of break within the suffixed block so that it just terminates the\nwhile or for. This will be nasty if we have to embed either of those\nconstructs inside an actual loop (by which I mean one intended to execute the\nuser's code multiple times, unlike the above dummy loops that we always break\nout of after one iteration), because then a break in the user's code won't\nterminate the real loop, only the current iteration of the loop body \u2013 in\nother words, it'll become synonymous with continue, which isn't very useful.\n\nAt first sight one is inclined to think that since the problem arose due to a\nside effect of using a C loop keyword, we surely can't solve the problem\nexcept by removing the loop. But in fact, we head in the other direction: we\ncan recover useful handling of break by adding another layer of loop!\nSpecifically, we put the user's code inside two nested while loops, like this:\n\n    \n    \n    if (1) goto body; else while (1) if (1) { /* we reach here if the block terminated by break */ } else while (1) if (1) { /* we reach here if the block terminated normally */ } else body: { /* block following the expanded macro */ }\n\nAs in the previous examples, the outermost if jumps us into the innermost loop\nand executes the user's code block. If that block terminates normally, then we\nloop round to the top of the inner while, and execute a code snippet of our\nown choice. But if the user's block terminated by means of a break statement,\nthat will terminate the inner while and cause us to loop round to the top of\nthe other one. So we've now arranged for control flow to go to different\nplaces based on whether the user issued a break or not; and of course each of\nthe code snippets we provide above can act on that information as it sees fit,\nincluding in particular jumping to a location of its choice via goto.\n\n## 3\\. Handling else clauses\n\nI've shown that it's possible to write an almost arbitrary control structure\nby this mechanism which expects a single block of code after it and arranges\nto call that block in a user-defined looping setup.\n\nWhat if you want to pass more than one block of code to your control\nstructure, as you can with the built-in if...else?\n\nFor instance, Python allows an else clause on the end of a for loop, which is\nexecuted if the loop terminates normally but skipped if it terminates by\nbreak. This is ideal for situations in which the for loop is searching for a\nsuitable element of a list, and you want special-case handling if no such\nelement turned out to exist. If C had that feature too, then you'd be able to\nwrite things like:\n\n    \n    \n    for (i = 0; i < n; i++) { if (array[i] == the_droid_we_are_looking_for) break; } else { /* only executed if no array element matched */ move_along(); }\n\nwhereas currently you have to do this by testing after the loop to see if\ni==n, or if the loop conditions weren't as simple as that then you might\nresort to something even uglier like declaring an extra flag variable.\n\nOr you might make up your own constructions. I occasionally feel that it would\nbe nice to put an else clause on a while loop, with the semantics (this time\nnot like Python's) that the else clause is executed if and only if the main\nloop body was run zero times. This would be handy, for example, in cases where\nyou're printing a message to the user every time you go round the loop but you\nfeel it would be unfriendly not to print anything if you're not going round at\nall:\n\n    \n    \n    while ((p = get_a_thing()) != NULL) { printf(\"Processing %s\\n\", p->name); do_stuff_with(p); } else { /* only executed if the condition was false the first time */ printf(\"No things to process\\n\"); }\n\nAgain, to do this in standard C you have to do something fairly ugly, such as\nputting the while inside an if with the same condition, and also turning it\ninto a do...while if the condition (like this one) has side effects that you\nneed to avoid duplicating the first time round the loop.\n\nAnother output-related example is that of printing a collection of strings\nwith commas between them, so that however many actual output values you're\nprinting (at least, if it was non-zero) you print one comma fewer. I've always\ndone that by means of a variable storing a separator string:\n\n    \n    \n    sep = \"\"; /* the first value has nothing before it */ while ((p = get_a_thing()) != NULL) { printf(\"%s%d\", sep, p->value); sep = \",\"; /* all subsequent values are preceded by a comma */ }\n\nBut it would be cute if you could avoid the extra variable declaration, by\nwriting something like\n\n    \n    \n    while_interleaved ((p = get_a_thing()) != NULL) printf(\"%d\", p->value); and_in_between putchar(',');\n\nand relying on the loop construct to do the job of arranging to run the second\nblock one fewer times than the first.\n\nAll of these types of control structure can be implemented by extending the\nmechanism described in section 2. If we want to define a loop macro whose\ninvocation has a syntactic form like this:\n\n    \n    \n    MY_LOOP_KEYWORD (parameters) statement or braced block else statement or braced block\n\nthen all we have to do is to insert an unmatched if statement somewhere in our\nchain of statement prefixes, and then it will match an else written by the\nuser after their first statement or block.\n\nA reasonably general way to arrange this is by using an if (0) with a label on\neach side, like this:\n\n    \n    \n    else_clause: if (0) then_clause: { /* first block following the expanded macro */ } else { /* second block following the expanded macro */ }\n\n(In case it's becoming unclear, our macro in this case would expand to\neverything up to and including the then_clause label; everything after that is\ncode written by the user following the invocation of our control macro.)\n\nNow we place other control constructions outside that one which can execute\neither goto then_clause (which will jump straight to the user's main loop\nbody) or goto else_clause (which will jump to just before the if (0), and\ntherefore head for the else clause).\n\nDoing that has the unfortunate effect that control flow will go to the same\nplace after executing either of the user's blocks. To get around that, we can\nput additional control constructions just before or after the then_clause\nlabel; those will only be run for one of the two clauses, so now we can\narrange (by the techniques shown above) to redirect control to a different\nplace after each one. For example, a general approach might look like this:\n\n    \n    \n    while (1) if (1) { /* we reach here after the user's else clause */ goto somewhere; } else else_clause: if (0) while (1) if (1) { /* we reach here after the then clause */ goto somewhere_else; } else then_clause: { /* user's first block */ } else { /* user's second block */ }\n\nI'm assuming that code further up will jump to either the then_clause label or\nthe else_clause one. If the former, we immediately execute the user's then-\nclause, then we go round to the top of the inner while and reach one of our\ntwo code snippets. If the latter, then we execute the if (0), which drops us\nthrough to the user's else clause (shown above with indentation reflecting its\nplace in the real syntactic structure, though of course the user will indent\nit rather differently), and since that's not inside the inner while at all, we\nwould then loop round to the top of the outer while and execute a different\nsnippet.\n\nSo that demonstrates how to make use of two code blocks provided by the user.\nThey will have to be separated by the keyword else, or else none of this\ntrickery will work; but of course you can always trivially #define some\nsynonyms for else to make the code look nicer, such as and_in_between in the\nlast example above.\n\n## 4\\. Construction kit\n\nHopefully the previous sections have shown that the general technique of\nexpanding a macro into a well-chosen collection of statement prefixes is\nsurprisingly powerful, and contains all the needed functionality to implement\na wide range of looping constructions.\n\nHowever, actually doing it by chaining together ifs and whiles and labels is a\nbit of a headache, and if you were trying to define a custom loop construction\nin a particular application to cope with some inconvenient piece of API (as in\none of my motivating examples above) then you might very well run out of\npatience before getting the sequence of bits and pieces quite right. It would\nbe nicer to have a pre-packaged collection of the snippets in the previous\nsections, in a form that was reasonably easy for a user to put together into\nwhatever loop construct was most useful to them that day. A sort of \u2018loop\nconstruction kit\u2019.\n\nWell, all of the trickery shown above has a nice property: because it's all in\nthe form of statement prefixes, it's all composable. So you could quite\nfeasibly define macros to do jobs like \u2018execute this code before the suffixed\nblock\u2019, \u2018execute this code after the suffixed block\u2019, \u2018bring this declaration\ninto scope\u2019, \u2018catch and handle break\u2019, and so on, and have each of those\nmacros expand to a statement prefix. Then a user could define a loop macro\nsimply by means of chaining together a collection of those prefixes.\n\nSo I've written one of these, and it's available for download at the bottom of\nthis page. I won't document it in full in this article, because the main\ndocumentation is in comments in the header file itself and it's easier not to\ntry to keep it in sync in two places; but here's an example of it in use. The\nfollowing definition, if you've included my header file first, constructs\nexactly the FOR_EACH_HIPPO loop type described in an earlier secion:\n\n    \n    \n    #define FOR_EACH_HIPPO(loopvar) \\ MPP_DECLARE(1, hippo_retrieval_context *_hc) \\ MPP_BEFORE(2, _hc = new_hippo_retrieval_context()) \\ MPP_AFTER(3, free_hippo_retrieval_context(_hc)) \\ MPP_WHILE(4, hippo_available(_hc)) \\ MPP_BREAK_CATCH(5) \\ MPP_DECLARE(6, hippo *_h = get_hippo(_hc)) \\ MPP_DECLARE(7, loopvar = _h) \\ MPP_BREAK_THROW(5) \\ MPP_FINALLY(8, free_hippo(_hc, _h))\n\nI hope you'll agree that that sort of thing is a lot easier to write (and\nread) than the elaborate constructions in the previous sections! And yet it\nachieves more, by pasting together many things of about the size of the above\nsnippets.\n\nMost of the example should be reasonably clear, but I'll talk through it\nanyway just in case:\n\n  * MPP_DECLARE brings a declaration into scope, specifically the hippo_retrieval_context that the original version of the loop had to instantiate surrounding the loop as a whole.\n  * MPP_BEFORE and MPP_AFTER arrange to run the supplied pieces of code before and after the code that follows, i.e. before and after the whole loop. So the hippo_retrieval_context is allocated at the start of the loop, and freed when the loop terminates.\n  * MPP_WHILE is the loop itself, and includes the termination condition.\n  * The next two MPP_DECLAREs declare variables with scope inside the loop, holding the actual value retrieved by get_hippo. The second one refers to loopvar, the macro parameter passed in by the user.\n  * MPP_BREAK_CATCH and MPP_BREAK_THROW are used to get round the problem discussed in section 2, where using a for loop to bring a declaration into scope has the side effect of causing break to do something unhelpful. MPP_BREAK_THROW is a macro which detects when the user's code has issued a break (by the technique shown in section 2), and responds by issuing a goto to a label defined by the corresponding MPP_BREAK_CATCH, which in turn issues another break statement. So any break written by the user will be propagated past the two dangerous MPP_DECLAREs, and instead will terminate the MPP_WHILE loop as the user really wanted.\n  * MPP_FINALLY is another break-handling macro. It arranges that the free_hippo call takes place no matter whether the user exited the block naturally (by falling off the end) or by break.\n\nThe numbers used as the first parameter to each MPP_ macro are called \u2018label\nIDs\u2019. Most of those macros have to define labels somewhere in their structure\nand jump to them using gotos, as you can see in the code snippets in the\nprevious sections. Those code snippets use fixed label names for simplicity;\nbut of course in serious use you can't do that, or else you'd never be able to\nuse the same MPP_ macro even twice in the same function, let alone twice in\nthe same loop macro (as we do above, with three instances of MPP_DECLARE). We\nget round this by constructing label names using the C preprocessor's token-\npasting operator ##: each label includes __LINE__ to ensure that multiple\ninvocations of the same loop macro define different labels, and also includes\nthe label ID passed to the macro defining the label. So the constraint is just\nthat each separate MPP_ macro used in a loop construct definition must have a\ndifferent label ID, to stop them colliding with each other. But it doesn't\nmatter what the label IDs actually are; I use numbers above for brevity, but\nyou could use descriptive names if you prefer.\n\n(One exception to the unique-IDs rule is that corresponding instances of\nMPP_BREAK_THROW and MPP_BREAK_CATCH must have the same number, so that one can\njump to a label defined in the other. In more complex macros you might have to\nuse two instances of each, and then the numbering makes it clear how they\nmatch up.)\n\nYou might notice that the variable names invented by the above macro begin\nwith underscores (_hc and _h). This is just a convention I chose to make it\nunlikely that they'll clash with variable names used by the end user calling\nthe loop macro. You don't have to follow the same convention, of course, but\nI'd suggest that some convention along those lines is probably useful.\n\nAlso on the subject of variable declarations, here's a useful feature of\nMPP_DECLARE. It places the declaration you give it in the initialisation\nclause of a for statement \u2013 but there's no actual need for the thing in a for\nstatement to be a declaration. So MPP_DECLARE can take a declaration or an\nordinary assignment. This is useful in the case where we're assigning to a\nmacro parameter passed in by the user, as in the declaration above assigning\nto loopvar. It means that the user can call the loop macro as either\nFOR_EACH_HIPPO(hippo *h), declaring a new variable with scope limited to the\nloop body, or if they prefer they could instead call it as just\nFOR_EACH_HIPPO(h) where h is some variable of the right type which was already\nin scope. By writing the loop macro in the above form, we can arrange for both\nuses to work.\n\nAnother thing in the above code that needs explaining is the distinction\nbetween MPP_AFTER and MPP_FINALLY, and why I had to use both in the above\ndefinition. Both arrange for code to be run after the suffixed statement\nterminates, but they have different semantics. Firstly, MPP_AFTER only\nexecutes its code snippet if the suffixed statement terminated normally, not\nby break, whereas MPP_FINALLY executes its statement either way. But the\nsuffixed statement of MPP_AFTER, in the above, is a loop, so any break will\nstop there. So why wouldn't MPP_FINALLY have done just as well?\n\nThe answer is that MPP_FINALLY doesn't just handle break by running some code:\nit also reissues the break, so that it continues propagating upwards and (in\nthe above example) eventually terminates the loop. That means that MPP_FINALLY\nexpands to a statement prefix which includes a break statement that's not\ncontained in any loop \u2013 so it would be illegal C to use MPP_FINALLY in any\ncontext where there wasn't a surrounding loop. So I can't use MPP_FINALLY at\nthe top level of my loop construction, even if the break statement in it would\nnever actually be reached.\n\nAll of this is documented more fully in comments in the header file itself,\nalong with some additional macros to the ones shown, including ones that\nabsorb a following else clause as discussed in section 3. But the example\nabove should give you an idea of what sort of thing this system can do.\n\n## 5\\. Use with coroutines\n\nFor my pi\u00e8ce de r\u00e9sistance, here's a mechanism for implementing something very\nsimilar to Ruby's \u2018iterator method\u2019 mechanism, in which you can define an\narbitrary function which is called with a suffixed block of code and can\n\u2018call\u2019 that block, with arguments, anywhere in its own control flow.\n\nIf you combine the loop-definition macros described above with my other C\npreprocessor hack to implement coroutines, you can achieve pretty much the\nsame thing in standard C99!\n\nAs an example, let's write some code that generates a sequence of integers:\nspecifically, all those integers which are either a power of 2 or three times\na power of 2, in increasing order. If we just wanted to print those numbers,\nwe could use the following snippet of code:\n\n    \n    \n    void twothree_up_to(int limit) { int i, tmp; for (i = 1; i < limit; i *= 2) { printf(\"%d\\n\", i); /* a power of 2 */ if (i > 1) { tmp = i + (i >> 1); if (tmp < limit) printf(\"%d\\n\", tmp); /* 3 times a power of 2 */ } } }\n\nI've deliberately picked an example with slightly fiddly control flow, to show\noff the technique to the full. It's more convenient to call printf twice in\neach loop iteration, printing first a power of two and then one-and-a-half\ntimes that value, than to fiddle with the loop conditions to arrange exactly\none iteration per output number; we also need to allow for the special case\nthat when the power of two is 1 we have to skip the one-and-a-half value, and\nwe must also check the second number printed in each iteration against the\nprovided limit to avoid overrunning by one.\n\nSo now let's rewrite that as an \u2018iterator\u2019 with more or less Rubyish\nsemantics.\n\nFirst we must define a set of coroutine macros. For full details of the\ngeneral technique, see my article \u2018Coroutines in C\u2019. Here I'll just observe\nthat the details have to be adjusted from the ones in that article to allow\nfor the state structure being allocated on the stack of the calling function\nrather than being either dynamically allocated or static:\n\n    \n    \n    #define MPCR_BEGIN switch (s->_line) { case 0: #define MPCR_END(dummyval) s->_line = -1; } #define MPCR_YIELD(value) do \\ { \\ s->_line = __LINE__; \\ s->_val = (value); \\ return; \\ case __LINE__:; \\ } while (0)\n\nThese macros expect to be used in a function which takes a parameter called\n\u2018s\u2019, which is a pointer to a structure that contains the coroutine's state.\nThe state structure must in turn contain a member called _line, which tracks\nthe coroutine's next resumption point (and is initialised to zero, and set to\nthe special value -1 to indicate that the coroutine has finished and isn't\nyielding another value), and another member called _val which is the value\npassed out of the coroutine to the user's code block in each yield operation.\n\nSo now we can rewrite the above function as an iterator using those macros. Of\ncourse any local variable in the above function which has to persist across a\nyield must become an extra field in the state structure, which in the above\ncase means that \u2018limit\u2019 and \u2018i\u2019 must move but \u2018tmp\u2019 is OK as it is:\n\n    \n    \n    struct twothree_state { int _line, _val; int limit; int i; }; void twothree_iterator(struct twothree_state *s) { int tmp; MPCR_BEGIN; for (s->i = 1; s->i < s->limit; s->i *= 2) { MPCR_YIELD(s->i); if (s->i > 1) { tmp = s->i + (s->i >> 1); if (tmp < s->limit) MPCR_YIELD(tmp); } } MPCR_END(0); }\n\nNow the other end of the mechanism has to be a loop macro which declares an\ninstance of struct twothree_state to keep the iterator's persistent state in,\nthen repeatedly calls the iterator function on that state structure to get an\noutput value, and stops when it terminates. We can build such a macro without\nany difficulty using the loop construction kit discussed in section 4:\n\n    \n    \n    #define TWOTHREE_UP_TO(loopvar, limitval) \\ MPP_DECLARE(1, struct twothree_state _state) \\ MPP_BEFORE(2, _state._line = 0; \\ _state.limit = limitval; \\ twothree_iterator(&_state)) \\ MPP_WHILE(3, _state._line >= 0) \\ MPP_BREAK_CATCH(4) \\ MPP_AFTER(5, twothree_iterator(&_state)) \\ MPP_DECLARE(6, loopvar = _state._val) \\ MPP_BREAK_THROW(4)\n\n(So we have to declare the coroutine's state; set it all up and call the\niterator to get the first value; loop until the _line field becomes negative,\nwhich happens as a result of reaching MPCR_END and is the signal to terminate\nthe loop; arrange to call the iterator again after executing the loop body;\nassign the yielded value into the user's specified loop variable; and finally\nhandle break by propagating it past the MPP_AFTER and MPP_DECLARE macros. All\nof this is more or less the same as the example in section 4.)\n\nAfter all those definitions, we can now call our loop macro with a statement\nor block of our choice:\n\n    \n    \n    TWOTHREE_UP_TO(int k, 1000) printf(\"%d\\n\", k);\n\n## 6\\. Limitations\n\nOf course, whenever you use macros to extend C's syntax, the mechanism comes\nwith a few extra constraints. Only a proper language extension, implemented in\nthe compiler itself, would be able to avoid that.\n\nTo begin with, though, here are some things that aren't limitations.\n\nLoops constructed by this mechanism are valid standard C99, or valid standard\nC++. If you avoid using declarations in for loops (so no MPP_DECLARE, if\nyou're using my construction-kit header) then they're valid C89 as well.\n\nAll of these macros are switch/case safe, in the sense that a case label\ninside the user's block will still be associated with a switch completely\noutside the loop construction. (That's a consequence of not having used switch\nin the macros themselves.) Of course, jumping into a loop like that will skip\nany implicit initialisations and allocations and so on that might be hidden in\nthe loop macro, but nothing in the macros themselves forbids the technique.\n\nAll of these macros can handle being followed by either a single statement or\na braced block, just like C's built-in loop statements. They're if/else safe\n(in the sense that you can put an unbraced if...else inside one, or put an\nunbraced one inside if...else, without causing syntactic confusion), unless of\ncourse you've deliberately set them up to eat a following else clause.\n\nThose are the good points. Now for the actual limitations of the technique.\n\nAs discussed in the previous sections, the loop-construction macros use goto\nwith labels constructed programmatically using __LINE__. So don't put two loop\nmacros defined using these building blocks on the same source line, or they'll\nmost likely define the same labels twice and cause a compile error.\n\nLoops defined using these macros have no way to control the handling of\ncontinue. Fortunately, the default handling is probably the right one anyway:\nin any loop defined using this system, continue will be equivalent to a jump\nto just before the end of the loop body. (So any post-loop machinery concealed\nin the loop macro will still be run.)\n\nThe mechanism for catching break can only catch break, and won't catch any\nother kinds of non-local exit from the loop body such as return, goto,\nlongjmp() or exit(). The fact that I called one of my component macros\nMPP_FINALLY should not mislead you into thinking it's as good as a \u2018real\u2019\nfinally. So if you define a loop by this mechanism which sets up state that\nhas to be cleaned up when the loop finishes, don't write any returns (or\nanything else on the above list) in the loop body.\n\nThe mechanism for accepting an else clause relies on the C syntax rule that\nevery else binds to the nearest unmatched if. This isn't a problem per se, in\nthat no compiler I've ever heard of gets that rule wrong, but unfortunately\nsome compilers (e.g. GCC) give a warning whenever you write code that actually\ndepends on the rule. So although in principle else clauses on constructions\ndefined like this are optional, you might find that in practice they're\nmandatory to avoid those annoying warnings.\n\nAnd last but not least, if you use this sort of trickery in code you write for\nyour employer, don't be surprised if your next performance review contains a\nraised eyebrow or two!\n\n## 7\\. Downloads\n\nThe header file I describe above is available here: mp.h.\n\nYou can also download a test program that uses that header file: mptest.c. If\ncompiled normally, that file sets up a number of these loops and test-runs\nthem in various ways; if compiled with the macro EXPECTED defined, it instead\ncompiles to equivalent \u2018normal\u2019 C code, so you can check that the two versions\ngive the same output. Compile with C89 defined as well to cut out all the\ntests that depend on declaring variables in for statements.\n\nCopyright \u00a9 2012 Simon Tatham. This document is OpenContent. You may copy and\nuse the text under the terms of the OpenContent Licence. Please send comments\nand criticism on this article to anakin@pobox.com.\n\n", "frontpage": false}
