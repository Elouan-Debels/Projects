{"aid": "40002680", "title": "Bazel Remote Caching API", "url": "https://bitrise.io/blog/post/bazel-remote-caching-api", "domain": "bitrise.io", "votes": 1, "user": "szabolcsg", "posted_at": "2024-04-11 14:37:36", "comments": 0, "source_title": "Bazel remote caching API - Bitrise Blog", "source_text": "Bazel remote caching API - Bitrise Blog\n\n\ud83c\udf89 Latest updates from March: Alerts for stuck builds, configuring SCIM with\nOkta and more \u2192\n\nBlog\n\nDocs\n\nTalk to Sales\n\nLogin\n\nStart for free\n\nApp Development\n\n-\n\n5\n\nmin read\n\n# Bazel remote caching API\n\nSpeed up your builds. In this blog post, we take a closer look at Bazel's\nRemote Caching. We explore how the API specification and client-side\nimplementation can dramatically reduce build times through efficient cache\nreuse. A must-read for developers seeking efficiency.\n\nSzabolcs Gelencser\n\nDistinguished Software Engineer\n\nPUBLISHED:\n\nApril 11, 2024\n\nWelcome to our series on Bazel remote caching: understanding how Bitrise\nenables you to fully harness the power of Bazel's build and test automation\ncapabilities.\n\nWhether you are new to Bazel or already a user of it and you want to learn\nmore about how Bazel works under the hood, you are in the right place. You can\nuse Bazel without knowing most of what we cover here, but we think it is\npretty cool and worth doing a deep dive.\n\nWhat to expect in this series:\n\n  * Bazel remote caching API technical deep dive\n  * Server-side implementation of the remote cache API at Bitrise\n  * Remote execution\n\nIn this first post, we introduce Bazel's remote caching, specifically the API\nspecification and client-side implementation, to enhance build times through\ncache reuse across different environments.\n\n# What is bazel?\n\nBazel is an open-source build and test automation tool designed to support\nmultiple languages and platforms, often used for large, multi-language\nprojects with complex dependencies. Its remote caching capabilities allow it\nto store and retrieve build outputs from a remote server, enabling faster\nbuild times and incremental builds across different machines and environments.\n\nIf you already use Bazel, with Bitrise remote build cache for Bazel you can\nset up remote caching in just a few minutes without being familiar with its\ninternal details, and you can do that regardless what CI provider you use. If\nyou want to enjoy the additional performance and cost benefits of the\ncolocated build machines and build cache, you can use it with Bitrise CI, but\nit is not a requirement. Bitrise remote build cache for Bazel will work\nperfectly fine with any other CI vendor or self hosted CI.\n\nLet\u2019s start the deep dive into the internal details of Bazel, starting with\nthe API specification and client-side implementation.\n\n# Specification v2.3.0\n\nGoogle released a Protobuf-based specification that outlines how caching\nclients and remote servers interact. Bazel is one such client, but the API\ncould also work with other build tools. For instance, we're considering\nupdating our Bitrise remote build cache for the Gradle plugin to align with\nthis specification, given its similarities to our current approach. There are\nvarious server-side implementations, however, we'll focus on Bitrise's design\nand implementation in our next post.\n\nThe specification may initially appear daunting, so I've summarized the key\nconcepts into simple diagrams below, concentrating solely on caching and\nomitting aspects related to remote execution.\n\nThe most common entities.\n\nThe core entity is Action, which is a Command (with arguments, environment\nvariables, etc) that will be executed on a given platform (eg. Linux, macOS,\netc).\n\nAll entities but one are referenced by their digest (hash). For example, each\nAction has a command_digest field with the value of the hash of the related\nCommand entity.\n\nThe only exception is ActionResult which represents the results (stdout,\nstderr, exit code, produced files and directories, etc) of an already executed\nAction and is referenced by the digest of the Action. These enable a client\nflow such as:\n\n  * Execute Action (let's say it has a digest of a1), and upload its ActionResult under key a1. The ActionResult itself will probably reference other blobs produced as part of the Command execution (let's say they are uploaded under and referenced by digests b1, b2, and b3).\n  * Whenever the same exact Action (the same exact Command on the same exact platform) is executed, the client can skip it by hashing the Action and looking for the already existing ActionResult for digest a1. Related blobs (b1, b2, and b3) can also be read from the cache using their digest as a key.\n\nAn example Action and its results.\n\nTo showcase what these entities might correspond to, let's take a look at the\nexample above. An Action was executed, running the dotnet build Command on the\nWindows platform. It resulted in three files (some.dll, other.dll, and\nmy.exe), printed the Build succeeded. message to its stdout and terminated\nwith a 0 exit code.\n\nThe usual client flow.\n\nThe specification also documents the usual client flow. It starts with calling\nthe GetCapabilities endpoint to check what compression, digest algorithm, API\nversion, etc, are supported by the server (and the client should conform to\nthem or not use the remote cache API at all in case of incompatibility). It\ncontinues with building an Action graph (what Actions to execute in which\norder in case they depend on each other).\n\nFor each Action, it checks whether there is already a cached result. It calls\nthe GetActionResult endpoint of the remote cache API, passing the digest of\nthe given Action (which is the key of the desired ActionResult). Remote caches\nhave finite space, therefore they usually evict old entries based on some\nlogic (eg. LRU/LFU) to make room for new entries. The server should ensure\nthat all blobs referenced by the ActionResult (stdout, stderr, produced files)\nare also available in the remote cache (further increasing their lifetimes to\navoid their eviction before reading them).\n\nIf an ActionResult is found in the remote cache, it also downloads the related\nblobs by their digests using the Content Addressable Storage (CAS) with one of\nthe related endpoints. As per the specification, the BatchReadBlobs endpoint\n(supports reading multiple blobs at once) should be used for small blobs, and\nthe ByteStream API\u2019s Read endpoint (supports streaming read for a single blob)\nshould be used for large blobs.\n\nIf no ActionResult is found, the Action is executed locally, and its results\nare uploaded to the remote cache as part of a three-step process.\n\n  1. It checks what blobs are missing from the remote cache using the FindMissingBlobs API endpoint (as it might be the case that two different actions produced some overlapping blobs).\n  2. Missing blobs are uploaded using the CAS with either the BatchUpdateBlobs or the ByteStream API\u2019s Write endpoint (similarly to the read path).\n  3. The last step is calling UpdateActionResult, referencing the corresponding Action and related blobs that were already uploaded previously.\n\n# A client-side implementation: Bazel v7.0.2\n\nOverview.\n\nBazel is open source with a large and active community behind it. We looked\ninto its codebase to better understand what to expect on the API side and\nprepare for deep-dive debugging if users report issues with their workloads.\n\nNotation.\n\nI will walk you through it very briefly using diagrams using the notation\nabove (trying to simplify many layers of abstraction in the Java code).\n\nBootstrapping Bazel.\n\nEverything starts with BAZEL_MODULES which is a long list of loosely coupled\nmodules (classes implementing extending BlazeModule) that are loaded by the\nBazel runtime. Each module is responsible for a specific feature of Bazel. We\nare interested in remote caching, which is implemented by the RemoteModule. It\ncalls the GetCapabilites endpoint on the configured remote caching API,\nchecking if it's compatible with the Bazel client, and configures it for usage\nthroughout the rest of the execution.\n\nParallel execution of action graph with remote caching.\n\nSoon after bootstrapping modules, Bazel starts parallel building and executing\nof the action graph using a component called Skyframe. For each action, it\nchecks whether it was already executed and cached remotely (in which case\nlocal execution can be skipped by reading the existing ActionResult and\nrelated blobs) or if it should be executed locally and cached remotely.\n\nReading from the remote cache.\n\nThe read path starts by calling the GetActionResult endpoint on the remote\ncache API.\n\n  * Suppose a result isn\u2019t present for the given Action in the cache. In that case, it signals it to the caller, returning an empty CacheHandle that can be used to upload the ActionResult later on.\n  * If it is successful, Bazel downloads all of the blobs referenced by the ActionResult (all of which should also be present in the cache according to the spec) using the Read endpoint of the ByteStream API (never using BatchReadBlobs): stdout and stderr, all corresponding files, etc.\n\nWriting to the remote cache.\n\nWriting the results of locally executed actions starts by calling the\nFindMissingDigests endpoint of the API. For all missing blobs, the Write\nendpoint of the ByteStream API (never using BatchWriteBlobs) is used either by\nstreaming a file from the filesystem or passing it from memory (depending on\nthe blob type). Interrupted writes are resumed using the QueryWriteStatus\nendpoint of the API, which should return the number of bytes already\nsuccessfully written to the cache, enabling Bazel to continue writing the\nmissing parts only.\n\nOnce all referenced blobs are written, Bazel persists the result for the given\nAction by calling the UpdateActionResult endpoint.\n\n# Conclusion\n\nAt Bitrise, we continuously enhance our build caching capabilities to provide\nthe best support possible. This article explored the Bazel remote caching API\nspecification and its client-side implementation. Next, we will delve into the\nserver-side implementation of the remote cache API at Bitrise.\n\nInterested in optimizing your Bazel builds? For a comprehensive guide, visit\nour DevCenter.\n\nNot using Bitrise Build Cache yet? Start streamlining your builds with Bazel\nor Gradle by signing up for a 30-day free trial at Bitrise\u2014no strings\nattached. Alternatively, feel free to talk to a mobile expert.\n\nJoin our team! Explore career opportunities on our careers page.\n\nShare\n\nGet Started for free\n\nStart building now, choose a plan later.\n\nSign Up\n\n## Articles you might like\n\nApp Development\n\n-\n\n10\n\nmin read\n\n### Transitioning from App Center to Bitrise: A Comprehensive Guide\n\nExplore why Bitrise is the top choice for mobile app developers seeking\npowerful alternatives to the retiring Visual Studio App Center. Dive into why,\nand read our migration guide.\n\nMadr\u00e9 Roothman\n\nProduct Marketing Manager\n\nApp Development\n\n-\n\n5\n\nmin read\n\n### Continuous Deployment Challenges in Native Mobile Applications\n\nIn this blog post, explore the unique challenges of Continuous Deployment in\nnative mobile apps, including the complexities of app store distribution and\nrollback limitations, and discover insights on navigating these hurdles while\nstriving for efficient CI/CD workflows in mobile development.\n\nVasiliy Zukanov\n\nGuest Contributor/Android Developer\n\nApp Development\n\n-\n\n8\n\nmin read\n\n### Build Pipelines series: How to conditionally run workflows in Bitrise\nPipelines\n\nDive deeper into our Bitrise build pipeline series with a focus on\nconditionally running workflows for optimized CI/CD processes. Discover how to\nuse resources more efficiently, achieve faster build times, and enhance your\ndeployment strategy.\n\nZsolt Vicze\n\nStaff Software Engineer\n\n## Get started for free\n\nStart building now, choose a plan later.\n\nSign up for free\n\nTalk to Sales\n\nBitrise is a top mobile CI/CD platform, streamlining build, test, and\ndeployment for mobile apps. It offers a user-friendly interface, robust\nintegrations, and scalable infrastructure to simplify development and ensure\nefficient delivery of high-quality apps.\n\nStart for freeBook a demo\n\n###### Product\n\nContinuous Integration\n\nFor iOS\n\nFor Android\n\nSecurity\n\nMobile DevOps\n\nMigrating from Jenkins\n\nPricing\n\nContact\n\n###### Platform\n\nTechnology Partner Program\n\nIntegrations\n\nAudit Log Connector\n\n###### Support\n\nSupport Center\n\nDocs\n\nChangelog\n\nCommunity Forum\n\nRoadmap\n\nStatus\n\n###### Company\n\nAbout\n\nOur impact\n\nBlog\n\nCareers\n\nWe're hiring\n\nNewsroom\n\nPress Kit\n\nLegal Terms\n\nCompiled with \ud83d\udc9c remotely, worldwide\n\n## Is it okay if we use cookies?\n\nWe need some cookies to make Bitrise work. We\u2019d like to use additional cookies\nto store your preferences, gather statistics and assist with our marketing -\nthis helps us improve Bitrise.\n\n## Privacy Preference Center\n\nWhen you visit any website, it may store or retrieve information on your\nbrowser, mostly in the form of cookies. This information might be about you,\nyour preferences or your device and is mostly used to make the site work as\nyou expect it to. The information does not usually directly identify you, but\nit can give you a more personalized web experience. Because we respect your\nright to privacy, you can choose not to allow some types of cookies. Click on\nthe different category headings to find out more and change our default\nsettings. However, blocking some types of cookies may impact your experience\nof the site and the services we are able to offer. More information\n\n### Manage Consent Preferences\n\n#### Functional Cookies\n\nThese cookies enable the website to provide enhanced functionality and\npersonalisation. They may be set by us or by third party providers whose\nservices we have added to our pages. If you do not allow these cookies then\nsome or all of these services may not function properly.\n\n#### Performance Cookies\n\nThese cookies allow us to count visits and traffic sources so we can measure\nand improve the performance of our site. They help us to know which pages are\nthe most and least popular and see how visitors move around the site. All\ninformation these cookies collect is aggregated and therefore anonymous. If\nyou do not allow these cookies we will not know when you have visited our\nsite, and will not be able to monitor its performance.\n\n#### Targeting Cookies\n\nThese cookies may be set through our site by our advertising partners. They\nmay be used by those companies to build a profile of your interests and show\nyou relevant adverts on other sites. They do not store directly personal\ninformation, but are based on uniquely identifying your browser and internet\ndevice. If you do not allow these cookies, you will experience less targeted\nadvertising.\n\n#### Strictly Necessary Cookies\n\nAlways Active\n\nThese cookies are necessary for the website to function and cannot be switched\noff in our systems. They are usually only set in response to actions made by\nyou which amount to a request for services, such as setting your privacy\npreferences, logging in or filling in forms. You can set your browser to block\nor alert you about these cookies, but some parts of the site will not then\nwork. These cookies do not store any personally identifiable information.\n\n### Back\n\nlabel\n\nConsent Leg.Interest\n\nlabel\n\nlabel\n\nlabel\n\n", "frontpage": false}
