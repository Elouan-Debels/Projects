{"aid": "39986643", "title": "EnerJ \u2013 The Language of Good Enough Computing", "url": "https://spectrum.ieee.org/enerj-the-language-of-goodenough-computing", "domain": "ieee.org", "votes": 1, "user": "mindcrime", "posted_at": "2024-04-10 03:18:56", "comments": 0, "source_title": "EnerJ, the Language of Good-Enough Computing", "source_text": "EnerJ, the Language of Good-Enough Computing - IEEE Spectrum\n\nOpens in a new window Opens an external website Opens an external website in a\nnew window\n\nThis website utilizes technologies such as cookies to enable essential site\nfunctionality, as well as for analytics, personalization, and targeted\nadvertising purposes. You may change your settings at any time or accept the\ndefault settings. You may close this banner to continue with only essential\ncookies. Privacy Policy\n\nStorage Preferences\n\nIEEE.orgIEEE Xplore Digital LibraryIEEE StandardsMore Sites\n\nSign InJoin IEEE\n\nEnerJ, the Language of Good-Enough Computing\n\nShare\n\nFOR THE TECHNOLOGY INSIDER\n\nExplore by topic\n\nAerospaceArtificial IntelligenceBiomedicalClimate TechComputingConsumer\nElectronicsEnergyHistory of\nTechnologyRoboticsSemiconductorsTelecommunicationsTransportation\n\nIEEE Spectrum\n\nFOR THE TECHNOLOGY INSIDER\n\n### Topics\n\nAerospaceArtificial IntelligenceBiomedicalClimate TechComputingConsumer\nElectronicsEnergyHistory of\nTechnologyRoboticsSemiconductorsTelecommunicationsTransportation\n\n### Sections\n\nFeaturesNewsOpinionCareersDIYEngineering Resources\n\n### More\n\nNewslettersPodcastsSpecial ReportsCollectionsExplainersTop Programming\nLanguagesRobots Guide \u2197IEEE Job Site \u2197\n\n### For IEEE Members\n\nCurrent IssueMagazine ArchiveThe InstituteThe Institute Archive\n\n### For IEEE Members\n\nCurrent IssueMagazine ArchiveThe InstituteThe Institute Archive\n\n### IEEE Spectrum\n\nAbout UsContact UsReprints & Permissions \u2197Advertising \u2197\n\n### Follow IEEE Spectrum\n\n### Support IEEE Spectrum\n\nIEEE Spectrum is the flagship publication of the IEEE \u2014 the world\u2019s largest\nprofessional organization devoted to engineering and applied sciences. Our\narticles, podcasts, and infographics inform our readers about developments in\ntechnology, engineering, and science.\n\nJoin IEEE\n\nSubscribe\n\nAbout IEEEContact & SupportAccessibilityNondiscrimination PolicyTermsIEEE\nPrivacy PolicyCookie PreferencesAd Privacy Options\n\n\u00a9 Copyright 2024 IEEE \u2014 All rights reserved. A not-for-profit organization,\nIEEE is the world's largest technical professional organization dedicated to\nadvancing technology for the benefit of humanity.\n\n## Enjoy more free content and benefits by creating an account\n\n## Saving articles to read later requires an IEEE Spectrum account\n\n## The Institute content is only available for members\n\n## Downloading full PDF issues is exclusive for IEEE Members\n\n## Downloading this e-book is exclusive for IEEE Members\n\n## Access to Spectrum 's Digital Edition is exclusive for IEEE Members\n\n## Following topics is a feature exclusive for IEEE Members\n\n## Adding your response to an article requires an IEEE Spectrum account\n\n## Create an account to access more content and features on IEEE Spectrum ,\nincluding the ability to save articles to read later, download Spectrum\nCollections, and participate in conversations with readers and editors. For\nmore exclusive content and features, consider Joining IEEE .\n\n## Join the world\u2019s largest professional organization devoted to engineering\nand applied sciences and get access to all of Spectrum\u2019s articles, archives,\nPDF downloads, and other benefits. Learn more \u2192\n\n## Join the world\u2019s largest professional organization devoted to engineering\nand applied sciences and get access to this e-book plus all of IEEE Spectrum\u2019s\narticles, archives, PDF downloads, and other benefits. Learn more \u2192\n\nCREATE AN ACCOUNTSIGN IN\n\nJOIN IEEESIGN IN\n\nClose\n\n## Access Thousands of Articles \u2014 Completely Free\n\n## Create an account and get exclusive content and features: Save articles,\ndownload collections, and talk to tech insiders \u2014 all free! For full access\nand benefits, join IEEE as a paying member.\n\nCREATE AN ACCOUNTSIGN IN\n\nComputingFeature\n\n# EnerJ, the Language of Good-Enough Computing\n\n## We could save energy in everything from smartphones to supercomputers by\nletting them make mistakes\n\nAdrian Sampson\n\nLuis Ceze\n\nDan Grossman\n\n26 Sep 2013\n\n10 min read\n\nIllustration: Jude Buffum\n\nVoltaire once wrote, \u201cThe best is the enemy of the good.\u201d\n\nThat\u2019s just one of the many ways of saying that perfectionism is not always a\nvirtue. Yet computers today are relentless perfectionists, because even rare\nflaws in their output can be expensive, if not disastrous. A bug in Intel\u2019s P5\nPentium chip, for example, cost the company almost half a billion U.S.\ndollars, even though it caused only slightly inaccurate answers in about one\nin 9 billion computations.\n\nThe extraordinary reliability of computers makes them useful for many tasks,\nespecially ones that we error-prone humans would never be able to do well. But\nthis wonderful quality comes at a price\u2014energy. You see, to ensure that errors\nare so rare that you can safely assume they never happen, computers consume\ngobs of energy.\n\nThat near-perfect correctness was a foregone conclusion by 1971, when the\nfirst commercial microprocessor, the Intel 4004, hit the market. For the next\nthree decades, the main goal of microprocessor designers was to maintain that\nattribute while stuffing ever more transistors onto each chip; energy\nefficiency was, if anything, an after thought. Today, however, energy use is\nfront and center in chip designers\u2019 minds, for several reasons.\n\nFirst off, the processors that go into the mobile computers we\u2019ve all grown so\nfond of, like smartphones and tablets, must be energy efficient to conserve\nbattery life. Those found in supercomputers and data centers need to be\nsimilarly thrifty with power, because the electricity to run these facilities\noften costs their owners millions of dollars a year. And in contrast to the\nsituation in 1971, designers can no longer count on advances in semiconductor\ntechnology to bring drastically better per-transistor energy efficiency year\nafter year.\n\nIndeed, they now face the \u201cdark silicon\u201d problem: While Moore\u2019s Law remains\nintact, consistently delivering more transistors per chip with each new\ngeneration of manufacturing, microprocessors can\u2019t use all these additional\ntransistors at the same time. Only a portion of them can be powered up before\nthe chip becomes impossible to cool. So chip designers must arrange things to\nleave much of the microprocessor unpowered, or \u201cdark,\u201d at any given moment\u2014the\nrolling blackouts of the silicon world.\n\nIn this energy-constrained era, computer scientists of all stripes need to\nreexamine each of the things computers devote power to\u2014including error-free\noperation. Absolute correctness was a great attribute when energy didn\u2019t\nmatter. But now it\u2019s time to embrace the occasional slipup.\n\nCompromising on correctness may seem to be a dangerous strategy. After all,\nwhen computers make mistakes, the results can be catastrophic. So if you let\nthem make more mistakes, wouldn\u2019t they run the risk of becoming useless? Not\nreally. The trick is controlling when the goofs can happen. Sometimes they\nwon\u2019t pose a problem, because many of the things we use computers for today\ndon\u2019t demand strict correctness.\n\nLet\u2019s say you\u2019re on a long flight, watching a movie on your tablet computer.\nWhen the original movie file was compressed, the software that encoded it\nthrew away unimportant details from each frame to produce a file that\u2019s a lot\nsmaller. If the software decoder running on your tablet messes up a few pixels\nwhile playing the movie back, you probably won\u2019t object\u2014especially if it means\nmore battery life remains by the time the credits roll.\n\nThis situation is not unique to media players. For many kinds of\nsoftware\u2014speech recognition, augmented reality, machine learning, big-data\nanalytics, and game graphics, to give a few examples\u2014perfection in the output\nisn\u2019t the goal. Indeed, completely correct answers to the problem at hand may\nbe impossible or infeasible to compute. All that\u2019s desired is an approximate\nanswer. And when today\u2019s perfectionist computers execute these fundamentally\napproximate programs, they squander energy.\n\nTo seize the opportunity this extravagance presents, computer designers could\nbuild machines that can switch into an energy-saving\u2014albeit somewhat error-\nprone\u2014mode on demand. The machine might turn down the CPU voltage, for\nexample, at the expense of causing arithmetic errors every once in a while.\nReducing the refresh rate on dynamic random-access memory (DRAM) chips could\nalso save energy, with the trade-off being a few unwanted bit flips. And\nwireless devices could cut back on the power they draw if some communication\nerrors were allowed.\n\nMany researchers are working on such energy-saving hardware modifications. We\nhave been exploring how programmers could make use of them. To that end, our\nresearch group at the University of Washington, in Seattle, has developed a\ncomputer language that lets benign errors occur every now and then while\npreventing the catastrophic ones. We call it EnerJ. It\u2019s our contribution to a\nnew approach for boosting energy efficiency called approximate computing.\n\nThe key difficulty with approximate computing is that even an approximate\nprogram sometimes needs to produce absolutely correct results. Consider a\nphoto-manipulation program. While a handful of incorrect pixels won\u2019t mar a\nlarge image, a single wrong bit in the file\u2019s JPEG header could render the\noutput useless.\n\nThis dichotomy is common to many kinds of software: Some parts of a program\ncan tolerate occasional mistakes or imprecision, while other parts must always\nbe executed precisely and without error. Approximate computers need to support\nboth modes, and approximate programs must be written to use the energy-\nefficient mode wherever possible while avoiding errors that would lead to\ncatastrophic failures.\n\nBut how does a computer distinguish between the parts of a program that can\ntolerate approximation and those that can\u2019t? At this stage at least, the\nprogrammer needs to instruct the computer to do that, using a language that\noffers some mechanism for making the distinction.\n\nOur prototype language, EnerJ, works by letting the programmer mark data as\neither approximate or precise. Note that we\u2019re using those terms somewhat\nloosely here. The two kinds of data could differ in just numerical\nprecision\u2014that is, in the number of bits devoted to holding a value. Or they\ncould differ in how prone they are to errors: An \u201capproximate\u201d datum would\nhave a small but non-negligible chance of being garbage, whereas a \u201cprecise\u201d\ndatum can for all practical purposes be considered error free. Some of the\nhardware we\u2019ve been investigating mix these two energy-saving approaches,\nallowing occasional errors in the least significant bits while making sure\nthat the most significant ones are always correct.\n\nEnerJ is an extension of the Java programming language, but its overall design\ncan be applied to most languages with data types that the programmer declares\nexplicitly. Such declarations are used to indicate whether a data element is\nmeant to hold a Boolean (true/false) value, a byte, a 32-bit integer, a 64-bit\ninteger, a 32-bit floating-point number, a 64-bit floating-point number, or\nvarious other possibilities. Everywhere the programmer declares a Java data\nelement, he or she can mark it as approximate by writing \u201c@Approx\u201d before the\ndeclaration. Data types declared without such an annotation are implicitly\nmade precise. In other words, the system uses approximation only where the\nprogrammer has specifically allowed it.\n\nIllustration: Jude Buffum\n\nAs a concrete example, imagine that you want to write some code that\ncalculates the average shade of a black-and-white image that measures 1000 by\n1000 pixels. Your code might start with the first pixel of the first row and\nnote its value. It would then go on to the second pixel in the first row and\nadd its value to the first. Then it would do the same with the third pixel,\nand so on, each time adding the pixel\u2019s value to a running sum it\u2019s\nmaintaining in some variable\u2014let\u2019s call it TOTAL. When it gets to the 1000th\npixel in row one, the program starts all over on the second row of pixels and\ncontinues in that manner until it finishes up with the 1000th pixel of the\n1000th row. At the end, it divides TOTAL by 1 million to calculate the average\npixel value. Easy enough.\n\nIn addition to the variable TOTAL, the code requires two counter variables:\none to keep track of the row number and one for the column number of the pixel\nit\u2019s adding to the sum. After the column counter gets to 999, it resets to 0\nand progresses to the next row. When both row and column counters reach 999,\nthe program can divide by a million to get the average.\n\nIf along the way one of the million pixel values is a little off or doesn\u2019t\nget added correctly to the sum, well, it\u2019s no big deal: The answer will be\naffected, but not by much. If, however, one of the row or column counters\ndoesn\u2019t increase correctly, the program might throw an error, terminate\nprematurely, or even go into an infinite loop.\n\nWith EnerJ, the programmer simply marks TOTAL and the array holding the pixel\nvalues with \u201c@Approx\u201d when he or she declares them. The two counter\nvariables\u2014let\u2019s call them I and J\u2014remain precise.\n\nIllustration: Jude Buffum\n\nThe yet-to-be-built energy-saving computer this EnerJ program runs on would\nthen be allowed to use approximate computation indiscriminately\u2014as long as it\ndidn\u2019t affect the program\u2019s precise data. For example, the computer might\nstore the individual pixel values in unreliable, low-refresh-rate DRAM, but it\nwould have to use the normal, reliable part of its memory to store I and J. Or\nthe addition operations that add the pixel values to TOTAL could be run at a\nlower voltage level because both of the operands are approximate, but the\noperations that increase the two counter variables would have to be run at the\nnormal voltage so that they were always computed exactly. That is, just by\nannotating the type declarations in the code, the programmer specifies where\napproximate storage and operations can be used and where such approximation is\nforbidden.\n\nEnerJ also helps programmers avoid bugs that would let approximate\ncomputations contaminate data that need to stay precise. Specifically, it\nforbids the program from putting approximate data into precise variables.\nContinuing with our example, this assignment would be illegal:\n\nI = TOTAL;\n\nBecause I is precise, EnerJ guarantees that no approximation can be used to\ncompute it. TOTAL is approximate, so copying its value into I would introduce\napproximation into a part of the program that the programmer wants to keep\nprecise and free of errors. On the other hand, the opposite assignment has no\nsuch issues:\n\nTOTAL = I;\n\nPrecise-to-approximate assignments like this one do not violate any guarantees\nof precision because they affect only approximate data.\n\nBy allowing one kind of assignment while prohibiting the other, EnerJ ensures\nthat data move in just one direction. This constraint acts like a one-way\nvalve: Precise data can flow freely into the approximate part of the program,\nbut not vice versa.\n\nThe researchers who pioneered systems for enforcing unidirectional data\nmovement, called information-flow tracking, were not interested in saving\nenergy. They were concerned about software security. They wanted their\nprograms to distinguish between low-integrity (possibly compromised) data and\ndata deemed to be of high integrity.\n\nInformation-flow languages can, for example, prevent a kind of computer attack\ncalled SQL injection. (Structured Query Language, or SQL, is used for database\nmanagement.) Here, the attacker provides the system with a database command\nwhen it\u2019s expecting just some ordinary input data. The system then carries out\nthat command\u2014 perhaps doing great mischief in the process. Information-flow\ntracking can prevent such attacks by assuring that no inputs from the user\nflow to SQL statements. EnerJ borrows this idea to keep imprecision or rare\nerrors from contaminating good data.\n\nThere\u2019s another way, though, that approximate data can affect precise data:\nthrough control-flow statements. Consider this code:\n\nif (TOTAL > 0.0)\n\nI = 1;\n\nelse\n\nI = 2;\n\nThere are no illegal assignments, but the approximate value TOTAL still\ninfluences the precise variable I. This situation is called implicit\ninformation flow and must also be avoided.\n\nEnerJ prevents implicit information flow simply enough: It forbids approximate\nconditions in any control-flow statement. The expression \u201cTOTAL > 0.0\u201d is\napproximate because one of the operands is approximate. So the compiler\u2014the\nsoftware that translates EnerJ statements into the low-level code that runs on\nwhatever machine you\u2019re using\u2014 issues an error when it sees that expression as\nthe condition in an \u201cif\u201d statement.\n\nThe strict isolation that EnerJ enforces between the approximate and the\nprecise can in some cases be overly limiting, though. Sometimes programs\nproduce approximate data that then need to move into a precise part of the\nprogram\u2014say, for checking or output. For example, we experimented with a\nsmartphone app for reading bar codes that used several approximation-tolerant\nimage-analysis algorithms to produce a string of bits from a photo of a QR\ncode. It then calculated a \u201cchecksum\u201d\u2014a number used to ensure the integrity of\nsome other block of data.\n\nChecksums are very handy for detecting errors. Here\u2019s a simple example: Say\nyou\u2019ve got a million bytes (a byte is a group of 8 bits) that you want to\ntransmit in a way that is less than perfectly reliable. You might start by\nadding those million bytes together and then throwing away all but the least\nsignificant 8 bits of the answer. The result is the checksum, which you send\nafter you send the data. This single-byte checksum can now be used to judge\ndata integrity after transmission. Just compute the checksum again at the far\nend and compare it with the value that was sent. If even a single bit of the\ndata got corrupted during transmission, the original and recalculated\nchecksums will not match.\n\nFor our bar-code-reading app, we wanted to keep the checksum computation\nprecise to catch any errors that might crop up because of the approximations\nused elsewhere. But that required the output of an approximate computation\n(the bar-code-reading algorithm) to flow into a precise computation\u2014the\nchecksum. Normally, that wouldn\u2019t be possible. But EnerJ provides an escape\nhatch in the form of something called endorsements\u2014markers that indicate that\nthe programmer gives permission to break the strict isolation EnerJ otherwise\nenforces.\n\nEnerJ\u2019s data-type annotations, endorsements, and the isolation guarantees they\nprovide make it possible to write programs that take advantage of approximate\ncomputation while retaining enough precise computation to stay reliable. With\nthem, programmers can safely trade precision and strict correctness for\nincreased energy efficiency. Just as programmers are accustomed to optimizing\nsoftware for performance, EnerJ lets them optimize for energy savings.\n\nHow much savings? It\u2019s a little hard to say, because nobody has yet built the\nkind of two-mode, energy-saving computers EnerJ needs to run on. But our group\nhas written many EnerJ programs and run them in an environment that simulates\nhardware with various energy-saving features in its memory or central\nprocessing. Depending on what kind of program it is and how aggressively the\nsimulated hardware seeks to reduce energy consumption, EnerJ saves anywhere\nfrom 10 to 40 percent.\n\nImages: Adrian SampsonA Bit Off: This illustration shows the output of a\n3-D-rendering program run on simulated hardware. The top panel is the result\nof exact calculations, with increasing levels of energy-saving approximation\nshown in the panels below.\n\nWe were happy that our newly minted computer language did so well in these\ntrials. We were also pleasantly surprised to discover the great variety of\nprograms that have parts where approximation makes sense. Image rendering and\nimage recognition are both natural fits for EnerJ. Signal-processing\nalgorithms and geometry problems in 3-D gaming were less obvious candidates,\nbut they too could be readily split into approximate and precise components.\nIndeed, when you have EnerJ or another approximate-computing hammer at your\ndisposal, every program starts to look like a nail.\n\nWe now need realistic CPU designs that can save energy when running EnerJ\nprograms. With our former University of Washington colleague Hadi\nEsmaeilzadeh, who is now at Georgia Tech, and Doug Burger at Microsoft\nResearch, we have begun designing processors that can run at two different\nvoltage levels. When a program needs error-free behavior, it uses the higher\nvoltage. For calculations that can tolerate the occasional glitch, the\nprocessor switches to the lower voltage and saves energy. We\u2019ve also been\nexploring some more radical designs for hardware that can act as dedicated\napproximate coprocessors.\n\nTo make approximate computing blossom, programmers will also need tools to\nhelp them understand the trade-offs involved in sacrificing precision for\nenergy savings. Programming-language researchers, including those in our\ngroup, are beginning to design tools that are analogous to today\u2019s debuggers\nand performance profilers. With them, a programmer can find the answer to a\nquestion like \u201cWhat will happen to the playback quality of a video file if I\nmark this part of my media player as approximate?\u201d The right tools should let\nthe programmer save quite a bit of energy without the user even noticing a\ndifference.\n\nIndeed, the energy that computers expend avoiding mistakes\u2014even the rarest of\nsmall errors\u2014looks increasingly wasteful when so much of today\u2019s software\nalready incorporates imperfections in the form of error-prone data or\napproximate output. To rectify things, the computing industry needs some new\napproximate programming languages, some new approximate hardware designs, and\ntools to help programmers understand how best to use them. Together, they\nshould help computers become a little more like human brains, which are less\nthan perfect but amazingly energy efficient.\n\nThis article originally appeared in print as \u201cGood-Enough Computing.\u201d\n\n## About the Authors\n\nLead author Adrian Sampson studies computer science and engineering at the\nUniversity of Washington, in Seattle, where his two coauthors, Luis Ceze and\nDan Grossman, are his Ph.D. advisors. One specializes in programming\nlanguages, the other in computer architecture. Sampson likens their often\ndisparate guidance to \u201chaving an angel perched on one shoulder and the devil\non the other,\u201d though he won\u2019t say which is which.\n\n## This article is for IEEE members only. Join IEEE to access our full\narchive.\n\nJoin the world\u2019s largest professional organization devoted to engineering and\napplied sciences and get access to all of Spectrum\u2019s articles, podcasts, and\nspecial reports. Learn more \u2192\n\nIf you're already an IEEE member, please sign in to continue reading.\n\nBECOME A MEMBERSIGN IN\n\n## Membership includes:\n\n  * Get unlimited access to IEEE Spectrum content\n  * Follow your favorite topics to create a personalized feed of IEEE Spectrum content\n  * Save Spectrum articles to read later\n  * Network with other technology professionals\n  * Establish a professional profile\n  * Create a group to share and collaborate on projects\n  * Discover IEEE events and activities\n  * Join and participate in discussions\n\n", "frontpage": false}
