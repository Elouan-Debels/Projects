{"aid": "40037345", "title": "Multi Purpose Traversal", "url": "https://github.com/SPLWare/esProc/wiki/Multi-purpose-traversal", "domain": "github.com/splware", "votes": 1, "user": "Judyrabbit", "posted_at": "2024-04-15 05:31:12", "comments": 0, "source_title": "Multi purpose traversal", "source_text": "Multi purpose traversal \u00b7 SPLWare/esProc Wiki \u00b7 GitHub\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nSPLWare / esProc Public\n\n  * Notifications\n  * Fork 308\n  * Star 4.4k\n\n# Multi purpose traversal\n\nJump to bottom\n\nesProcSPL edited this page Mar 12, 2024 \u00b7 1 revision\n\nReducing external storage (hard disk) access has always been an eternal topic\nfor improving big data computing performance. We have also discussed methods\nsuch as columnar storage and compression that directly reduce access and even\nstorage. In addition to these storage level methods, methods can also be found\nto reduce external storage access in the algorithm and computational\nimplementation stages.\n\nTraversing is an essential part of big data computing. Sometimes, we may find\nthat in a computing task, there are two (or more) traversal actions involving\nthe same batch of data. If we can find a way to merge two traversals into one,\nthen the total computational load (CPU action) will not differ, but the access\nto the hard disk will be reduced by half. This can still improve computational\nperformance, and the improvement effect on data intensive computing is quite\nsignificant.\n\nIn the data structure of simplified account table T, the following fields are\nincluded: account A, date D, place of occurrence P, and amount M\n\nNow we want to calculate the balance of accounts a1 and a2, and write it in\nSQL as follows:\n\n    \n    \n    SELECT SUM(M) FROM T WHERE A=a1 SELECT SUM(M) FROM T WHERE A=a2\n\nThe calculation of these two statements will result in traversing table T\ntwice. If table T is very large, the calculation efficiency will be very low.\n\nIf we write this SQL as follows:\n\n    \n    \n    SELECT SUM(CASE WHEN A=a1 THEN M ELSE 0 END), SUM(CASE WHEN A=a2 THEN M ELSE 0 END) FROM T\n\nOne statement that calculates both of these statistical values makes the\nstatement more complex, and the total computational load of the database\nslightly increases (with the same number of judgments, more cumulative times,\nand many more zeros added). However, table T only needs to be traversed once,\nresulting in much higher computational efficiency.\n\nAs a database programmer, you need to learn this skill.\n\nHowever, not all operations can be handled with CASE WHEN.\n\nWe want to separately calculate the total amount for each day and the total\namount for each location. The SQL statement is:\n\n    \n    \n    SELECT D,SUM(M) FROM T GROUP BY D SELECT P,SUM(M) FROM T GROUP BY P\n\nDifferent WHERE can be wrapped using CASE WHEN, but different GROUP BYs cannot\nbe merged anymore, and table T can only be traversed twice.\n\nIn theory, SQL can also traverse once and be written as\n\n    \n    \n    SELECT D,P,SUM(M) FROM T GROUP BY D,P\n\nThen program and calculate the operations for GROUP BY D and GROUP BY P based\non this intermediate result. But it's really too complicated to implement, and\nthese are just two field grouping, if there are more fields, the intermediate\nresult set may be too large to fit in memory, and it will actually be much\nslower.\n\nThe SQL system cannot solve this problem anymore. We need to design new\nconcepts and syntax to implement multi-purpose traversal operations.\n\nThe concept of channel is introduced in the cursor of SPL. When a cursor\ntraverses data and performs a certain operation, it pushes the data into a\nchannel, and another operation can be defined on the channel. This way, One\ndata traversal can obtain two calculation results of the cursor itself and the\nattached channel. The above operation can be written as follows:\n\n    \n    \n    cs = T.cursor(...) ch = channel(cs).groups( P; sum(M) ) dg = cs.groups( D; sum(M) ) pg = ch.result()\n\nchannel(cs) binds a channel ch to the cursor cs and defines a grouping\noperation by P. Then, the cursor cs continues to traverse and implement the\ngrouping operation by D. After the traversal is completed, the relevant\nresults are taken from the channel ch.\n\nThe task of aggregation on different conditions mentioned earlier can also be\nwritten using cursor and channel mechanisms:\n\n    \n    \n    cs = T.cursor() ch = channel(cs).select( A==a2 ).sum(M)) m1 = cs.select( A==a1 ).sum(M) m2 = ch.result()\n\nThe code structure is the same.\n\nOf course, multiple channels can also be attached to one cursor. For example,\nthe two tasks mentioned earlier (conditional aggregation and different\ngrouping) can also be done in one traversal:\n\n    \n    \n    cs = T.cursor() ch1 = channel(cs).select( A==a2 ).sum(M)) ch2 = channel(cs).groups( P; sum(M) ) ch3 = channel(cs).groups( D; sum(M) ) m1 = cs.select( A==a1 ).sum(M) m2 = ch1.result() dg = ch2.result pg = ch3.result()\n\nLet\u2019s take another example of calculating the median.\n\nWhen calculating the median, sorting is required, but in general, sorting\noperations only focus on the sorting itself and do not care about counting.\nAfter sorting is completed, it is not even known how much data there is in\ntotal. In this case, to find the median, it is necessary to do another COUNT\nto traverse the data, which wastes time. If there is a channel mechanism, we\ncan implement the counting while sorting.\n\n    \n    \n    cs = T.cursor() ch = channel(cs).count() s = cs.sortx(M) // Implement the counting on the channel during the traversal sorting process k = ch.result() m = s.skip( (k-1)\\2 ).fetch@x(2-k%2).avg(M) //Find the one or two number in the middle\n\nSPL Resource: SPL Official Website | SPL Blog | Download esProc SPL | SPL Source Code\n\n  * Learn performance optimization skills from TPCH tests\n  * Ordered storage of SPL\n  * The impasse of SQL performance optimizing\n  * The Open-source SPL Redefines OLAP Server\n\n##### Clone this wiki locally\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
