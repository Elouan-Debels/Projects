{"aid": "40045855", "title": "Refal", "url": "https://en.wikipedia.org/wiki/Refal", "domain": "wikipedia.org", "votes": 1, "user": "gone35", "posted_at": "2024-04-15 21:30:40", "comments": 0, "source_title": "Refal", "source_text": "Refal - Wikipedia\n\nJump to content\n\nSearch\n\n# Refal\n\n  * \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438\n  * \u65e5\u672c\u8a9e\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * \u0422\u043e\u04b7\u0438\u043a\u04e3\n  * \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430\n\nEdit links\n\nFrom Wikipedia, the free encyclopedia\n\nFunctional programming language\n\nThis article relies excessively on references to primary sources. Please\nimprove this article by adding secondary or tertiary sources. Find sources:\n\"Refal\" \u2013 news \u00b7 newspapers \u00b7 books \u00b7 scholar \u00b7 JSTOR (August 2020) (Learn how\nand when to remove this template message)  \n---  \nRefalParadigm| Pattern-matching and term-rewriting  \n---|---  \nDesigned by| Valentin Turchin  \nDeveloper| Valentin Turchin, S. Florentsev, V. Olyunin, et al.  \nFirst appeared| 1968 (1968)  \nTyping discipline| strong, dynamic  \nWebsite| http://www.refal.net  \nMajor implementations  \nRefal-2, Refal-5, Refal-6, Refal+  \n  \nRefal (\"Recursive functions algorithmic language\"; Russian: \u0420\u0415\u0424\u0410\u041b) \"is a\nfunctional programming language oriented toward symbolic computations\",\nincluding \"string processing, language translation, [and] artificial\nintelligence\".^[1] It is one of the oldest members of this family, first\nconceived of in 1966 as a theoretical tool, with the first implementation\nappearing in 1968. Refal was intended to combine mathematical simplicity with\npracticality for writing large and sophisticated programs.\n\nOne of the first functional programming languages to do so, and unlike Lisp of\nits time, Refal is based on pattern matching. Its pattern matching works in\nconjunction with term rewriting.\n\nThe basic data structure of Lisp and Prolog is a linear list built by cons\noperation in a sequential manner, thus with O(n) access to list's nth element.\nRefal's lists are built and scanned from both ends, with pattern matching\nworking for nested lists as well as the top-level one. In effect, the basic\ndata structure of Refal is a tree rather than a list. This gives freedom and\nconvenience in creating data structures while using only mathematically simple\ncontrol mechanisms of pattern matching and substitution.\n\nRefal also includes a feature called the freezer to support efficient partial\nevaluation.\n\nRefal can be applied to the processing and transformation of tree structures,\nsimilarly to XSLT.^[2]\n\n## Basics[edit]\n\nThis section reads like a textbook. Please improve this article to make it\nneutral in tone and meet Wikipedia's quality standards. (August 2020)  \n---  \n  \nA Refal Hello World example is shown below.\n\n    \n    \n    $ENTRY Go { = <Hello>;} Hello { = <Prout 'Hello world'>; }\n\nThe program above includes two functions named Go and Hello. A function is\nwritten as the name of the function followed by the function body in curly\nbraces. The Go function is marked as the entry point of the program using the\n$ENTRY directive.\n\nOne could think of expressions in the function bodies as function \"calls\" in\nLisp-like syntax. For example, the Hello function appears to call the built-in\nProut function with the string 'Hello world' as the argument. The meaning and\nthe mechanism of the call, however, is quite different. To illustrate the\ndifference, consider the following function that determines whether a string\nis a palindrome.\n\n    \n    \n    Pal { = True; s.1 = True; s.1 e.2 s.1 = <Pal e.2>; e.1 = False; }\n\nThis example shows a function with a more complex body, consisting of four\nsentences (clauses). A sentence begins with a pattern followed by an equal\nsign followed by a general expression on the right hand side. A sentence is\nterminated with a semicolon. For example, the pattern of the second sentence\nof the function is \"s.1\" and the expression is \"True\".\n\nAs the example shows, patterns include pattern variables that have the form of\na character identifying the type of the variable (what the variable matches)\nfollowed by the variable identifier. The variables that begin with an \"s\"\nmatch a single symbol, those that begin with an \"e\" match an arbitrary\nexpression. The variable identifier can be an arbitrary alphanumeric sequence\noptionally separated from the type identifier by a dot.\n\nA function executes by comparing its argument with the patterns of its\nsentences in the order they appear in the definition, until the first pattern\nthat matches. The function then replaces the argument with the expression on\nthe right hand side of the matched sentence.\n\nIf the result of a function application includes a subexpression in angle\nbrackets (as it will after the third sentence of our example is applied), the\nresult is further processed by Refal by invoking the function identified by\nthe first symbol in the brackets. Execution stops when the result has no more\nangle brackets to expand in this way.\n\nThe function Pal can thus be read informally as: \"If the expression is empty,\nreplace it with True. Otherwise if the expression is a single symbol, replace\nit with True. Otherwise if the expression is a symbol followed by an arbitrary\nexpression e.2 followed by the same symbol, replace it with the expression\n<Pal e.2>. (In other words, throw away the two identical symbols at the\nbeginning and the end and recurse). Otherwise replace the expression with\nFalse. (The pattern e.1 always matches).\"\n\nThe following are three step-by-step execution traces annotated with the\nsentence numbers applied at each step to produce the next\n\n    \n    \n    <Pal 'noon'> (#3) <Pal 'oo'> (#3) <Pal > (#1) True\n    \n    \n    <Pal 'wow'> (#3) <Pal 'o'> (#2) True\n    \n    \n    <Pal 'revolver'> (#3) <Pal 'evolve'> (#3) <Pal 'volv'> (#3) <Pal 'ol'> (#4) False\n\nWe can now see that the Hello World example in fact executes as the sequence\nof the following expression transformations:\n\n    \n    \n    Seed the machine with the initial expression marked by $ENTRY: <Go > (apply the sentence in Go) <Hello > (apply the sentence in Hello) <Prout 'Hello world'> (Prout is a built-in that prints and expands to nothing) (nothing to apply; stop)\n\n## Other examples[edit]\n\n### Factorial[edit]\n\n    \n    \n    Fact { 0 = 1; s.N = <* s.N <Fact <- s.N 1>>>; }\n\nHere 0 matches 0 the number and produces 1. On any other symbol which is a\nnumber, multiply it with the result of (Fact (- s.N 1)) Note the prefix style\nof operators.\n\n### Factorial with loops[edit]\n\n    \n    \n    Fact { s.n = <Loop s.n 1>; }; Loop { 0 s.f = s.f; s.n s.f = <Loop <- s.n 1> <* s.n s.f>>; }\n\nAs can be seen s.n acts as the loop counter.\n\n### Equality[edit]\n\n    \n    \n    Equal { (e.1)(e.1) = T; (e.1)(e.2) = F; }\n\nHere the function is defined as, if given two terms, and the terms are same\nthen the first clause matches and produces True. else the second clause\nmatches and produces False.\n\nAn important property of Refal is that all functions in refal are single\nargument. (But may be decomposed into terms in an expression as above.)\n\n### If[edit]\n\nDefining control structures is easy\n\n    \n    \n    If { T Then (e.1) Else (e.2) = e.1; F Then (e.1) Else (e.2) = e.2; }\n\nHere the e1 is evaluated only when the expression entered matches 'True' Then\ne1 Else e2 the same for e2.\n\n### Squeeze blanks[edit]\n\n    \n    \n    Squeeze { e.1'__'e.2 = <Squeeze e.1'_'e.2>; e.1 = e.1; }\n\n(Using '_' in place of space char so as to make the function call clear.) The\nfirst clause matches whenever the function Squeeze encounters double blanks in\nits input expression, and replaces it with a single blank. The second clause\nmatches only when the first one did not, and returns the resultant value which\nis the current expression.\n\n### Squeeze using explicit looping[edit]\n\n    \n    \n    Squeeze { '__'e.1 = <Squeeze '_'e.1>; s.A e.1 = s.A <Squeeze e.1>; = ; };\n\n## References[edit]\n\n  * Turchin, Valentin F. (1989). \"REFAL-5 Programming Guide and Reference Manual\". The City College of New York, New England Publishing Co., Holyoke.\n\n  1. ^ Turchin, Valentin F. (1989). \"Introduction to Refal\". REFAL-5 programming guide & reference manual. Holyoke: New England Publishing Co. Archived from the original on 2008-07-03. Retrieved 2010-04-05.\n  2. ^ \"Refal: The Language for Processing XML Documents\". Archived from the original on 2007-12-06. Retrieved 2008-03-18.\n\n## External links[edit]\n\n  * Refal homepage\n\nAuthority control databases: National|\n\n  * Israel\n  * United States\n\n  \n---|---  \n  \nRetrieved from\n\"https://en.wikipedia.org/w/index.php?title=Refal&oldid=1217753157\"\n\nCategories:\n\n  * Programming languages\n  * Pattern matching programming languages\n  * Functional languages\n  * Term-rewriting programming languages\n  * Homoiconic programming languages\n\nHidden categories:\n\n  * Articles with short description\n  * Short description is different from Wikidata\n  * Articles lacking reliable references from August 2020\n  * All articles lacking reliable references\n  * Articles containing Russian-language text\n  * Wikipedia articles with style issues from August 2020\n  * All articles with style issues\n  * Articles with J9U identifiers\n  * Articles with LCCN identifiers\n\n  * This page was last edited on 7 April 2024, at 17:45 (UTC).\n  * Text is available under the Creative Commons Attribution-ShareAlike License 4.0; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.\n\n  * Privacy policy\n  * About Wikipedia\n  * Disclaimers\n  * Contact Wikipedia\n  * Code of Conduct\n  * Developers\n  * Statistics\n  * Cookie statement\n  * Mobile view\n  * Edit preview settings\n\n", "frontpage": false}
