{"aid": "40045848", "title": "Markov Algorithm", "url": "https://en.wikipedia.org/wiki/Markov_algorithm", "domain": "wikipedia.org", "votes": 1, "user": "gone35", "posted_at": "2024-04-15 21:30:18", "comments": 0, "source_title": "Markov algorithm", "source_text": "Markov algorithm - Wikipedia\n\nJump to content\n\nSearch\n\n# Markov algorithm\n\n  * Deutsch\n  * \u0641\u0627\u0631\u0633\u06cc\n  * Fran\u00e7ais\n  * Italiano\n  * \u65e5\u672c\u8a9e\n  * Portugu\u00eas\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430\n  * \u7cb5\u8a9e\n  * \u4e2d\u6587\n\nEdit links\n\nFrom Wikipedia, the free encyclopedia\n\nThis article includes a list of references, related reading, or external\nlinks, but its sources remain unclear because it lacks inline citations.\nPlease help improve this article by introducing more precise citations. (May\n2020) (Learn how and when to remove this template message)  \n---  \n  \nIn theoretical computer science, a Markov algorithm is a string rewriting\nsystem that uses grammar-like rules to operate on strings of symbols. Markov\nalgorithms have been shown to be Turing-complete, which means that they are\nsuitable as a general model of computation and can represent any mathematical\nexpression from its simple notation. Markov algorithms are named after the\nSoviet mathematician Andrey Markov, Jr.\n\nRefal is a programming language based on Markov algorithms.\n\n## Description[edit]\n\nNormal algorithms are verbal, that is, intended to be applied to strings in\ndifferent alphabets.\n\nThe definition of any normal algorithm consists of two parts: an alphabet,\nwhich is a set of symbols, and a scheme. The algorithm is applied to strings\nof symbols of the alphabet. The scheme is a finite ordered set of substitution\nformulas. Each formula can be either simple or final. Simple substitution\nformulas are represented by strings of the form , where and are two arbitrary\nstrings in the alphabet. Similarly, final substitution formulas are\nrepresented by strings of the form .\n\nHere is an example of a normal algorithm scheme in the five-letter alphabet :\n\nThe process of applying the normal algorithm to an arbitrary string in the\nalphabet of this algorithm is a discrete sequence of elementary steps,\nconsisting of the following. Let\u2019s assume that is the word obtained in the\nprevious step of the algorithm (or the original word , if the current step is\nthe first). If of the substitution formulas there is no left-hand side which\nis included in the , then the algorithm terminates, and the result of its work\nis considered to be the string . Otherwise, the first of the substitution\nformulae whose left sides are included in is selected. If the substitution\nformula is of the form , then out of all of possible representations of the\nstring of the form (where and are arbitrary strings) the one with the shortest\nis chosen. Then the algorithm terminates and the result of its work is\nconsidered to be . However, if this substitution formula is of the form , then\nout of all of the possible representations of the string of the form of the\none with the shortest is chosen, after which the string is considered to be\nthe result of the current step, subject to further processing in the next\nstep.\n\nFor example, the process of applying the algorithm described above to the word\nresults in the sequence of words , , , , , , , , , and , after which the\nalgorithm stops with the result .\n\nFor other examples, see below.\n\nAny normal algorithm is equivalent to some Turing machine, and vice versa \u2013\nany Turing machine is equivalent to some normal algorithm. A version of the\nChurch-Turing thesis formulated in relation to the normal algorithm is called\nthe \"principle of normalization.\"\n\nNormal algorithms have proved to be a convenient means for the construction of\nmany sections of constructive mathematics. Moreover, inherent in the\ndefinition of a normal algorithm are a number of ideas used in programming\nlanguages aimed at handling symbolic information \u2013 for example, in Refal.\n\n## Algorithm[edit]\n\nThe Rules are a sequence of pairs of strings, usually presented in the form of\npattern \u2192 replacement. Each rule may be either ordinary or terminating.\n\nGiven an input string:\n\n  1. Check the Rules in order from top to bottom to see whether any of the patterns can be found in the input string.\n  2. If none is found, the algorithm stops.\n  3. If one (or more) is found, use the first of them to replace the leftmost occurrence of matched text in the input string with its replacement.\n  4. If the rule just applied was a terminating one, the algorithm stops.\n  5. Go to step 1.\n\nNote that after each rule application the search starts over from the first\nrule.\n\n## Example[edit]\n\nThe following example shows the basic operation of a Markov algorithm.\n\n### Rules[edit]\n\n  1. \"A\" -> \"apple\"\n  2. \"B\" -> \"bag\"\n  3. \"S\" -> \"shop\"\n  4. \"T\" -> \"the\"\n  5. \"the shop\" -> \"my brother\"\n  6. \"a never used\" -> .\"terminating rule\"\n\n### Symbol string[edit]\n\n\"I bought a B of As from T S.\"\n\n### Execution[edit]\n\nIf the algorithm is applied to the above example, the Symbol string will\nchange in the following manner.\n\n  1. \"I bought a B of As from T S.\"\n  2. \"I bought a B of apples from T S.\"\n  3. \"I bought a bag of apples from T S.\"\n  4. \"I bought a bag of apples from T shop.\"\n  5. \"I bought a bag of apples from the shop.\"\n  6. \"I bought a bag of apples from my brother.\"\n\nThe algorithm will then terminate.\n\n## Another example[edit]\n\nThese rules give a more interesting example. They rewrite binary numbers to\ntheir unary counterparts. For example, 101 will be rewritten to a string of 5\nconsecutive bars.\n\n### Rules[edit]\n\n  1. \"|0\" -> \"0||\"\n  2. \"1\" -> \"0|\"\n  3. \"0\" -> \"\"\n\n### Symbol string[edit]\n\n\"101\"\n\n### Execution[edit]\n\nIf the algorithm is applied to the above example, it will terminate after the\nfollowing steps.\n\n  1. \"101\"\n  2. \"0|01\"\n  3. \"00||1\"\n  4. \"00||0|\"\n  5. \"00|0|||\"\n  6. \"000|||||\"\n  7. \"00|||||\"\n  8. \"0|||||\"\n  9. \"|||||\"\n\n## See also[edit]\n\n  * Thue (programming language)\n  * Formal grammar\n\n## References[edit]\n\n  * Caracciolo di Forino, A. String processing languages and generalized Markov algorithms. In Symbol manipulation languages and techniques, D. G. Bobrow (Ed.), North-Holland Publ. Co., Amsterdam, the Netherlands, 1968, pp. 191\u2013206.\n  * Andrey Andreevich Markov (1903-1979) 1960. The Theory of Algorithms. American Mathematical Society Translations, series 2, 15, 1-14. (Translation from the Russian, Trudy Instituta im. Steklova 38 (1951) 176-189^[1])\n\n  1. ^ Kushner, Boris A. (1999-05-28). \"Markov's constructive analysis; a participant's view\". Theoretical Computer Science. 219 (1\u20132): 268, 284. doi:10.1016/S0304-3975(98)00291-6.\n\n## External links[edit]\n\n  * Yad Studio - Markov algorithms IDE and interpreter (Open Source)\n  * Markov algorithm interpreter\n  * Markov algorithm interpreter\n  * Markov algorithm interpreters at Rosetta-Code\n\n  * v\n  * t\n  * e\n\nStrings  \n---  \nString metric|\n\n  * Approximate string matching\n  * Bitap algorithm\n  * Damerau\u2013Levenshtein distance\n  * Edit distance\n  * Gestalt pattern matching\n  * Hamming distance\n  * Jaro\u2013Winkler distance\n  * Lee distance\n  * Levenshtein automaton\n  * Levenshtein distance\n  * Wagner\u2013Fischer algorithm\n\n  \nString-searching algorithm|\n\n  * Apostolico\u2013Giancarlo algorithm\n  * Boyer\u2013Moore string-search algorithm\n  * Boyer\u2013Moore\u2013Horspool algorithm\n  * Knuth\u2013Morris\u2013Pratt algorithm\n  * Rabin\u2013Karp algorithm\n  * Raita algorithm\n  * Trigram search\n  * Two-way string-matching algorithm\n  * Zhu\u2013Takaoka string matching algorithm\n\n  \nMultiple string searching|\n\n  * Aho\u2013Corasick\n  * Commentz-Walter algorithm\n\n  \nRegular expression|\n\n  * Comparison of regular-expression engines\n  * Regular grammar\n  * Thompson's construction\n  * Nondeterministic finite automaton\n\n  \nSequence alignment|\n\n  * BLAST\n  * Hirschberg's algorithm\n  * Needleman\u2013Wunsch algorithm\n  * Smith\u2013Waterman algorithm\n\n  \nData structure|\n\n  * DAFSA\n  * Suffix array\n  * Suffix automaton\n  * Suffix tree\n  * Generalized suffix tree\n  * Rope\n  * Ternary search tree\n  * Trie\n\n  \nOther|\n\n  * Parsing\n  * Pattern matching\n  * Compressed pattern matching\n  * Longest common subsequence\n  * Longest common substring\n  * Sequential pattern mining\n  * Sorting\n  * String rewriting systems\n  * String operations\n\n  \n  \nRetrieved from\n\"https://en.wikipedia.org/w/index.php?title=Markov_algorithm&oldid=1173173787\"\n\nCategories:\n\n  * Theory of computation\n  * Rewriting systems\n  * Models of computation\n\nHidden categories:\n\n  * Articles lacking in-text citations from May 2020\n  * All articles lacking in-text citations\n\n  * This page was last edited on 31 August 2023, at 19:05 (UTC).\n  * Text is available under the Creative Commons Attribution-ShareAlike License 4.0; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.\n\n  * Privacy policy\n  * About Wikipedia\n  * Disclaimers\n  * Contact Wikipedia\n  * Code of Conduct\n  * Developers\n  * Statistics\n  * Cookie statement\n  * Mobile view\n  * Edit preview settings\n\n", "frontpage": false}
