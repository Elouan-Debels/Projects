{"aid": "39993142", "title": "Some notes on For loops", "url": "https://buttondown.email/hillelwayne/archive/some-notes-on-for-loops/", "domain": "buttondown.email/hillelwayne", "votes": 1, "user": "azhenley", "posted_at": "2024-04-10 17:11:14", "comments": 0, "source_title": "Some notes on for loops", "source_text": "Some notes on for loops \u2022 Buttondown\n\nComputer Things\n\nApril 10, 2024\n\n# Some notes on for loops\n\n## Experts can learn a lot by looking at the basics.\n\n### New Blogpost\n\nDon't let Alloy facts make your specs a fiction, about formal methods\npractices (and a lot of Alloy). Patreon link here.\n\n# Some notes on for loops\n\nI sometimes like to sharpen the axe by looking at a basic programming concept\nand seeing what I can pull out. In this case, for loops.\n\nThere are two basic forms of for loops:\n\n    \n    \n    for(i = 0; i < 10; i++) for val in [\"a\", \"b\", \"c\"]:\n\nThe second is usually called a foreach loop, and I'll call the former\n\"forstep\", after the ALGOL-60 construct. Almost all languages have one of the\ntwo, some have both. While forstep loops show up early, foreach loops only\nappear in PLs ~20 years later.\n\nLooking at this, here's some things I see:\n\n### Construct reduction\n\nGiven a foreach loop, I can syntactically translate it into a forstep loop:\n\n    \n    \n    for val in arr: # ... --> for(i = 0; i < arr.len; i++) { val = arr[i]; // ... }\n\nThere's a lot of terms we use to express this property. We can say that\nforeach is homomorphic or reducible to forstep, or that foreach can be\nconstructed out of forstep, or others I can't think of rn.\n\nIf we could also construct forstep from foreach, we could say the two are\nequivalent or isomorphic. In theory we can do this if we had a range operator:\n\n    \n    \n    for(i = 0; i < 10; i += 2) --> for i in range(0, 10, step=2);\n\nMost forstep implementations, though, can do things like modify the iterator\nin the middle of the loop:\n\n    \n    \n    for(i = 0; i < 10; i++) { // stuff if(cond) i = 0; // stuff }\n\nYou can't convert this to a foreach loop: it's an \"irreducible\" feature.\n\nMost people consider modifying the index bad practice, though. 99% of the use\ncases of forstep loops are constructible with foreach loops, so the two are\nmorally equivalent. I'll treat them as roughly interchangeable going forward.\n\n### Primitives and Expressivity\n\nFor loops are reducible to while loops:\n\n    \n    \n    for(i = 0; i < 10; i += 1) --> i = 0; while i < 10 { // ... i++; }\n\nBut while loops are not reducible to for loops:\n\n    \n    \n    while(user_cmd != \"quit\") --> ???\n\nAgain, lots of terms to cover this: while loops are more \"primitive\", more\n\"powerful\", more \"low-level\", more \"expressive\", etc. If you have while loops,\nyou don't need for loops, and if you have goto, you don't need either.\n\nBut you shouldn't use a goto when a while loop works or a while loop where a\nfor loop works. This is a generalization of the rule of least power (RLP):\ngiven a problem, use the tool that is most specific to the problem. If you can\niterate through a list with a foreach loop, don't use a while instead!\n\nThere's two reasons for this. One is that it's more communicative to other\nprogrammers. If they see a foreach loop, they know it's going to be used for\nsome kind of iteration, while that's not clear with the while loop. Two is the\ncapability/tractability tradeoff: the more limited a construct is, the easier\nit is to understand and work with. A foreach loop can do less than a while\nloop, but it's much easier to guarantee that it processes each item only once.\n\nProgramming languages evolve to replace the all-powerful \"low-level\"\nconstructs with more limited constructs that reduce to the low-level ones.\nIt's why you get things like interfaces over inheritance.\n\nThe corollary of this is that if you use a powerful construct, it should be\nbecause the limited one can't do what you want. Don't force an infinite for-\nloop!\n\n#### Extensions to for loops\n\nFor loops reduce to while loops, while loops reduce to goto, everything\nreduces to goto. So there are some kinds of looping goto can do that for and\nwhile cannot.\n\nThey get a little closer to feature-parity by adding flow-control inside the\nloop: continue for advancing the loop early, break for terminating it. I\ndidn't look into when or how these were added, but I'd guess they come from\nlooking at what goto can do that loops could not, and adding features as\nneeded.\n\nSubscribe\n\n### \"Imperative programming\" is just for loops\n\nI think one of the most basic functions of a programming language is to\niterate through an array. So much so that you can distinguish different\nprogramming paradigms by how they iterate.\n\n  * Imperative programming: for loops\n  * OOP: a foreach method on iterable objects[^python]\n  * Functional programming: recursion, reduce (we'll talk about this later)\n  * Logic programming: I'm less familiar with this, but I think it's recursion + pattern matching (which ML and Haskell adopted)\n  * Array programming: all operations take arrays by default.\n\nI think this explains why arrays are universal while dictionaries are\nrelatively new: there's no obvious basic operation that covers what you do\nwith dicts to the degree that for covers what arrays do.\n\n(Question: do list comprehensions lead to a new paradigm? How do you describe\n\"iteration\" in spreadsheet languages?)\n\n### Functional replacements\n\nWhen people talk about replacements for foreach loops in FP, they usually\nbring up map and filter. But these are not equivalent. Rather map and filter\nare \"preferred\" to loops because they are more limited. It's another instance\nof RLP.\n\nAs far as I can tell, reduce is equivalent to foreach. Morally, anyway. This\nis interesting because reduce is considered part of the \"big three\" (along\nwith map and filter), but it's also the one that's the \"odd one out\". It's the\nhardest for people to understand, and Haskell even has three versions of it.\nIs it confusing because it's so powerful?\n\nMap and filter are composable in a way that foreach loops are not, but they're\nalso weirdly less \"composable\" in one very specific way? Consider something of\nthe form\n\n    \n    \n    map f (filter p arr)) --> out = [] for x in arr: if p(x): out.append(f(x))\n\nThe map/filter iterates over the list twice, while the foreach loop iterates\nonly once. I know Haskell can fuse maps together as an optimization but I\ndon't think you safely fuse arbitrary map/filters? I dunno.\n\nYou can fuse map and filter with a reduce:\n\n    \n    \n    reduce ((out, x) => if p(x) then out ++ f(x) else out ), [], arr\n\nThis gets really awkward though.\n\nI wonder if \"reduce is equivalent to for loops\" plus \"reduce is awkward for\nfusion\" somehow inspired clojure transducers.\n\n### I'll be writing this forever\n\nThings I could have looked at in more detail but ran out of time and energy:\n\n  * \"Iterators\" as a general concept.\n  * Loop invariants and variants. This is really relevant to formal methods in particular.\n  * Specific implementations of for loops in languages. ALGOL's loop expression-lists, Python's for else, Raku's phasers, javascript's for in/for of distinction, Ada and Chapel loop parallelization constructs... If I keep going I'll get something as long as this.\n\nFollowing any of those leads would get us to different insights, as opposed to\nmain thing that ended up catching my interest with these notes, which is how\nthe rule of least power applies to language constructs. I should probably\nwrite a blog post about it!\n\nAnyway I think this kind of exercise, looking at something everybody takes for\ngranted and try to learn things from it, is really valuable for understanding\nsoftware better. I don't know how interesting it is to read about, though.\nLemme know if you think you'd like to see this for other stuff, or just share\nthe essays that are downstream of the practice (like writing about RLP).\n\n### Podcast appearance: are we engineers?\n\nI was on a podcast, talking about the crossover project and what software\nengineers can learn from traditional engineering. Check it out here!\n\nIf you're reading this on the web, you can subscribe here. Updates are once a\nweek. My main website is here.\n\nDon't miss what's next. Subscribe to Computer Things:\n\nSubscribe\n\nBrought to you by Buttondown, the easiest way to start and grow your\nnewsletter.\n\n", "frontpage": false}
