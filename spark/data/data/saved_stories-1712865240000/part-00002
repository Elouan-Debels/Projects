{"aid": "40002156", "title": "JumpBackHash: Say Goodbye to the Modulo Operation to Distribute Keys Uniformly", "url": "https://engineering.dynatrace.com/blog/jumpbackhash-say-goodbye-to-the-modulo-operation-to-distribute-keys-uniformly-to-buckets/", "domain": "dynatrace.com", "votes": 2, "user": "Malp", "posted_at": "2024-04-11 13:52:30", "comments": 0, "source_title": "JumpBackHash: Say Goodbye to the Modulo Operation to Distribute Keys Uniformly to Buckets", "source_text": "JumpBackHash: Say Goodbye to the Modulo Operation to Distribute Keys Uniformly to Buckets | Dynatrace Engineering\n\n# JumpBackHash: Say Goodbye to the Modulo Operation to Distribute Keys\nUniformly to Buckets\n\nOtmar Ertl\n\nApril 10, 2024\n\nDistributed data processing and storage requires a strategy for mapping tasks\nor data across available resources. In more abstract terms, the strategy must\nbe able to distribute keys to a given number of buckets. Ideally, the keys are\nuniformly assigned to the buckets to achieve a balanced utilization of\nresources. If there are n buckets labeled 0, 1, 2, . . . , n \u2212 1, a prevalent\nand straightforward pattern to map a key to a bucket index is to take the\nremainder after dividing the hash of the key k by the number of buckets n. The\nfollowing Java code snippet illustrates such approach:\n\n    \n    \n    int getBucket(long k, int n) { return (int) ((k & 0x7FFFFFFFFFFFFFFFL) % n); // mask to ignore sign bit and to ensure a nonnegative result }\n\nWe assume that the hash value of the key k is the result of some high-quality\nhash function, such as WyHash, KomiHash, or PolymurHash, and can be considered\nas a random value. Further, suppose that the number of buckets is much smaller\nthan the maximum possible hash value, which is usually the case for 64-bit\nhash values. Then, the keys will be uniformly distributed over the buckets as\ndesired.\n\n#### What is the problem?\n\nUnfortunately, with the modulo-based approach, a change in the number of\nbuckets n will also change the mapping of nearly all keys. If n is increased\nto n + 1, every key will be mapped to a different bucket with a probability of\nn/(n+1), meaning nearly all keys get reassigned for large n. The same is true\nif the number of buckets is reduced. All those reassignments would happen\nsimultaneously and cause pressure on a distributed system. For example, this\nmight lead to a timely concentrated higher network load as data needs to be\nshifted to other physical instances. This could also result in a short-term\nincrease of database requests to load key-specific settings or missing cache\nentries, which may cause backpressure on data streams as a further\nconsequence.\n\n#### The solution: Consistent hash functions\n\nConsistent hash functions can be used as a replacement for the modulo\noperation to distribute keys uniformly to buckets. They minimize the number of\nkeys reassigned to a different bucket to restore balance. On average, only\n1/(n+1) of all keys must be mapped to a different bucket when the number of\nbuckets is increased from n to n + 1. This is a massive improvement over the\nmodulo approach. The illustration below shows an example of how the mapping of\n11 objects changes after increasing the number of buckets from 3 to 4 when\napplying the modulo operation on the key hashes and when using consistent\nhashing to minimize the number of reassignments.\n\nReassignments when adding a new bucket using the modulo operation vs.\nconsistent hashing.\n\n#### State of the art: JumpHash\n\nA widely used consistent hash function is JumpHash. It is deterministic, based\non a standard pseudorandom number generator, and its implementation is simple:\n\n    \n    \n    int getBucket(long k, int n) { randomGenerator.resetWithSeed(k); int b = -1; int bPrime = 0; while (bPrime < n) { b = bPrime; bPrime = (int) ((b + 1) / randomGenerator.nextDouble()); } return b; }\n\nIt uses a hash of the key k to seed a random generator, which is then used to\nproduce a sequence of random values until the loop\u2019s stop condition is\nsatisfied. The loop is left on average after approximately ln(n) iterations,\nmeaning the execution time scales logarithmically with the number of buckets\nn. As the implementation is also very compact and needs only a standard\npseudorandom generator, which can be found in most standard libraries,\nJumpHashCode has become very popular. For example, it is used by Booking.com\nfor their customer review system.\n\nDepending on the system and chosen pseudorandom generator, execution typically\ntakes around 100 nanoseconds on modern CPUs for thousands or millions of\nbuckets. This is fast but still significantly slower than a modulo operation.\nFurthermore, floating-point division may be problematic for devices without\ncorresponding hardware support.\n\n#### Our proposal: JumpBackHash\n\nWe have developed a new consistent hash algorithm called JumpBackHash, as\npresented in a recent research paper. It is faster than JumpHash, has a\nbounded expected execution time independent of the number of buckets, and can\neven compete with the speed of the modulo-based bucket assignment.\nFurthermore, JumpBackHash does not require floating-point arithmetic, making\nit suitable for low-power devices. As JumpHash, it only needs a standard\npseudorandom number generator and can still be compactly implemented according\nto this Java code snippet:\n\n    \n    \n    int getBucket(long k, int n) { if (n <= 1) return 0; randomGenerator.resetWithSeed(k); long v = randomGenerator.nextLong(); int u = (int) (v ^ (v >>> 32)) & (~0 >>> numberOfLeadingZeros(n - 1)); while (u != 0) { int q = 1 << ~numberOfLeadingZeros(u); int b = q + ((int) (v >>> (bitCount(u) << 5)) & (q - 1)); while (true) { if (b < n) return b; long w = randomGenerator.nextLong(); b = (int) w & ((q << 1) - 1); if (b < q) break; if (b < n) return b; b = (int) (w >>> 32) & ((q << 1) - 1); if (b < q) break; } u ^= q; } return 0; }\n\n#### Benchmark Results\n\nWe measured the performance of JumpBackHash and JumpHash using the fast and\nwell-tested SplitMix algorithm as a pseudorandom number generator for both to\nallow a fair comparison. In addition, we considered bucket assignment using\nthe modulo operation. The results obtained on an Amazon EC2 c5.metal instance\nwith disabled Turbo Boost (P-state set to 1) for different numbers of buckets\nare plotted below.\n\nOur measurements show that JumpBackHash is always faster than JumpHash. While\nthe computation times of JumpHash scale logarithmically, those of JumpBackHash\nare bounded by a constant independent of the number of buckets and are even\ncomparable to the modulo-based assignment because the modulo operation is\ngenerally quite expensive due to the involved integer division. JumpBackHash\nis particularly fast if the number of buckets is close to the next power of\ntwo, which explains the sawtooth pattern.\n\n#### Conclusion\n\nIn summary, there is no longer a good reason to distribute keys by applying\nthe modulo operation on the hashed key. JumpBackHash achieves a similar speed\nbut gives assignment stability of a consistent hash function for free. This\ncan improve your overall system stability during critical phases when\nresources get added or removed, planned or unplanned. A production-ready\nimplementation of JumpBackHash was released as part of our open source Hash4j\nJava library under the Apache 2.0 license.\n\nJumpBackHash: Say Goodbye to the Modulo Operation to Distribute Keys Uniformly\nto Buckets was originally published in Dynatrace Engineering on Medium, where\npeople are continuing the conversation by highlighting and responding to this\nstory.\n\n### Written by\n\nOtmar Ertl\n\n## Other blog posts\n\nMarch 22, 2021\n\n##### How online innovation days brought our remote labs closer together\n\nGiulia Di Pietro\n\nread full article\n\nDecember 7, 2021\n\n##### Tips from the trenches of performance engineering\n\nAndreas Grabner\n\nread full article\n\nApril 15, 2021\n\n##### \u201cWe aim to find a common language\u201d\n\nGiulia Di Pietro\n\nread full article\n\n  * Sitemap\n  * Policies\n  * Terms of use\n  * Contact\n\n\u00a9 2021 Dynatrace LLC. All rights reserved.\n\nThis site uses cookies to collect data on usage. By continuing to use this\nsite, you consent to ourCookies Policy\n\n", "frontpage": false}
