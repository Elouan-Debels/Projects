{"aid": "40002157", "title": "Show HN: In memory Rust database to query your data like a Venn diagram", "url": "https://github.com/plabayo/venndb", "domain": "github.com/plabayo", "votes": 3, "user": "gdcbe", "posted_at": "2024-04-11 13:52:41", "comments": 0, "source_title": "GitHub - plabayo/venndb: in memory Rust database to query your data like a Venn diagram", "source_text": "GitHub - plabayo/venndb: in memory Rust database to query your data like a\nVenn diagram\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nplabayo / venndb Public\n\n  * Sponsor\n  * Notifications\n  * Fork 1\n  * Star 8\n\nin memory Rust database to query your data like a Venn diagram\n\nvenndb.rs\n\n### License\n\n8 stars 1 fork Branches Tags Activity\n\nStar\n\nNotifications\n\n# plabayo/venndb\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n2 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nglendcprepare for 0.1.1 release: clippy missing-doc linter warnings72cdd90 \u00b7\n\n## History\n\n55 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| add semver checks  \n  \n### benches\n\n|\n\n### benches\n\n| fix linter code and confirm all tests still pass  \n  \n### docs/img\n\n|\n\n### docs/img\n\n| add merch info to README sponsorship  \n  \n### fuzz\n\n|\n\n### fuzz\n\n| add fuzzing to the CI + dev tools  \n  \n### scripts\n\n|\n\n### scripts\n\n| add benchmarks  \n  \n### src\n\n|\n\n### src\n\n| start to document the public API for the generated code more  \n  \n### venndb-macros\n\n|\n\n### venndb-macros\n\n| prepare for 0.1.1 release: clippy missing-doc linter warnings  \n  \n### venndb-usage\n\n|\n\n### venndb-usage\n\n| support extend method + add tests for dup keys  \n  \n### www\n\n|\n\n### www\n\n| start to add functionality to db  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| init content commit  \n  \n### CHANGELOG.md\n\n|\n\n### CHANGELOG.md\n\n| prepare for 0.1.1 release: clippy missing-doc linter warnings  \n  \n### CODE_OF_CONDUCT.md\n\n|\n\n### CODE_OF_CONDUCT.md\n\n| init content commit  \n  \n### CONTRIBUTING.md\n\n|\n\n### CONTRIBUTING.md\n\n| start preparing for the project  \n  \n### Cargo.toml\n\n|\n\n### Cargo.toml\n\n| prepare for 0.1.1 release: clippy missing-doc linter warnings  \n  \n### LICENSE-APACHE\n\n|\n\n### LICENSE-APACHE\n\n| start preparing for the project  \n  \n### LICENSE-MIT\n\n|\n\n### LICENSE-MIT\n\n| start preparing for the project  \n  \n### README.md\n\n|\n\n### README.md\n\n| add index to README  \n  \n### SECURITY.md\n\n|\n\n### SECURITY.md\n\n| mv SECURITY.md doc to correct location  \n  \n### deny.toml\n\n|\n\n### deny.toml\n\n| init content commit  \n  \n### justfile\n\n|\n\n### justfile\n\n| add bench setup + bump max input size for fuzzing  \n  \n## Repository files navigation\n\n# VennDB\n\nAn append-only in-memory database in Rust for rows queried using bit (flag)\ncolumns. This database is designed for a very specific use case where you have\nmostly static data that you typically load at startup and have to query\nconstantly using very simple filters. Datasets like these can be large and\nshould be both fast and compact.\n\nFor the limited usecases where venndb can be applied to, ithas less\ndependencies and is faster then traditional choices, such as a naive\nimplementation or a more heavy lifted dependency then Sqlite.\n\n> See the benchmarks for more information on this topic.\n\nThis project was developed originally in function of rama, where you can see\nit being used for example to provide an in-memory (upstream) proxy database.\nDo let us know in case you use it as well in your project, such that we can\nassemble a showcase list.\n\n\ud83d\udcac Come join us at Discord on the #venndb public channel. To ask questions,\ndiscuss ideas and ask how venndb may be useful for you.\n\n## Index\n\nvenndb manual:\n\n  * Usage: quick introduction on how to use venndb;\n  * Benchmarks: benchmark results to give you a rough idea how venndb peforms for the use case it is made for (write once, read constantly, using binary filters mostly);\n  * Q&A: Frequently Asked Questions (FAQ);\n  * Example: the full example (expanded version from Usage), tested and documented;\n  * Generated Code Summary: a documented overview of the API that venndb will generate for you when using #[derive(VennDB)] on your named field struct;\n\ntechnical information:\n\n  * Safety\n  * Compatibility\n  * MSRV (older versions might work but we make no guarantees);\n  * Roadmap\n  * License: MIT license and Apache 2.0 License\n\nmisc:\n\n  * Contributing\n  * Sponsors\n\n## Usage\n\nAdd venndb as a dependency:\n\n    \n    \n    cargo add venndb\n\nand import the derive macro in the module where you want to use it:\n\n    \n    \n    use venndb::VennDB #[derive(Debug, VennDB)] pub struct Employee { #[venndb(key)] id: u32, name: String, is_manager: bool, is_admin: bool, #[venndb(skip)] foo: bool, #[venndb(filter)] department: Department, } fn main() { let db = EmployeeDB::from_iter(/* .. */); let mut query = db.query(); let employee = query .is_admin(true) .is_manager(false) .department(Department::Engineering) .execute() .expect(\"to have found at least one\") .any(); println!(\"non-manager admin engineer: {:?}\", employee); }\n\nSee the full example or the \"Generated Code Summary\" chapter below to learn\nhow to use the VennDB and its generated code.\n\n## Benchmarks\n\nBenchmarks displayed here are taken on a dev machine with following specs:\n\n    \n    \n    Macbook Pro \u2014 16 inch (2023) Chip: Apple M2 Pro Memory: 16 GB OS: Sonoma 14.2\n\nThe benchmarks tests 3 different implementations of a proxy database\n\n  * venndb version (very similar to the example below)\n  * a naive version, which is just a Vec<Proxy>, over which is iterated\n  * an sqlite version (using the sqlite crate (version: 0.34.0))\n\nThe benchmarks are created by:\n\n  1. running just bench\n  2. copying the output into ./scripts/plot_bench_charts and running it\n\n### Benchmark Performance Results\n\nPerformance for Database with 100 records:\n\nProxy DB| Fastest (\u03bcs)| Median (\u03bcs)| Slowest (\u03bcs)  \n---|---|---|---  \nnaive_proxy_db_100| 6.87| 7.48| 19.16  \nsql_lite_proxy_db_100| 34.16| 36.33| 78.04  \nvenn_proxy_db_100| 0.92| 0.99| 8.50  \n  \nPerformance for Database with 12_500 records:\n\nProxy DB| Fastest (\u03bcs)| Median (\u03bcs)| Slowest (\u03bcs)  \n---|---|---|---  \nnaive_proxy_db_12_500| 402.20| 407.60| 434.30  \nsql_lite_proxy_db_12_500| 1099.00| 1182.00| 1519.00  \nvenn_proxy_db_12_500| 16.79| 17.54| 23.16  \n  \nPerformance for Database with 100_000 records:\n\nProxy DB| Fastest (\u03bcs)| Median (\u03bcs)| Slowest (\u03bcs)  \n---|---|---|---  \nnaive_proxy_db_100_000| 3769.00| 3882.00| 5285.00  \nsql_lite_proxy_db_100_000| 8334.00| 8628.00| 10070.00  \nvenn_proxy_db_100_000| 128.30| 136.50| 152.10  \n  \nWe are not database nor hardware experts though. Please do open an issue if\nyou think these benchmarks are incorrect or if related improvements can be\nmade. Contributions in the form of Pull requests are welcomed as well.\n\nSee the Contribution guidelines for more information.\n\n### Benchmark Allocations Results\n\nAllocations for Database with 100 records:\n\nProxy DB| Fastest (KB)| Median (KB)| Slowest (KB)  \n---|---|---|---  \nnaive_proxy_db_100| 0.38| 0.38| 0.38  \nsql_lite_proxy_db_100| 4.53| 4.53| 4.53  \nvenn_proxy_db_100| 0.05| 0.05| 0.05  \n  \nAllocations for Database with 12_500 records:\n\nProxy DB| Fastest (KB)| Median (KB)| Slowest (KB)  \n---|---|---|---  \nnaive_proxy_db_12_500| 40.22| 40.22| 40.22  \nsql_lite_proxy_db_12_500| 5.02| 5.03| 5.03  \nvenn_proxy_db_12_500| 3.15| 3.15| 3.15  \n  \nAllocations for Database with 100_000 records:\n\nProxy DB| Fastest (KB)| Median (KB)| Slowest (KB)  \n---|---|---|---  \nnaive_proxy_db_100_000| 324.00| 324.00| 324.00  \nsql_lite_proxy_db_100_000| 5.02| 5.02| 5.03  \nvenn_proxy_db_100_000| 25.02| 25.02| 25.02  \n  \nWe are not database nor hardware experts though. Please do open an issue if\nyou think these benchmarks are incorrect or if related improvements can be\nmade. Contributions in the form of Pull requests are welcomed as well.\n\nSee the Contribution guidelines for more information.\n\n## Q&A\n\n> \u2753 Why use this over Database X?\n\nvenndb is not a database, but is close enough for some specific purposes. It\nshines for long-lived read-only use cases where you need to filter on plenty\nof binary properties and get a rando matching result.\n\nDo not try to replace your usual database needs with it.\n\n> \u2753 Where can I propose a new feature X or some other improvement?\n\nPlease open an issue and also read the Contribution guidelines. We look\nforward to hear from you.\n\nAlternatively you can also join our Discord and start a conversation /\ndiscussion over there.\n\n> \u2753 Can I use any type for a #[venndb(filter)] property?\n\nYes, as long as it implements PartialEq + Eq + Hash + Clone. That said, we do\nrecommend that you use enum values if you can, or some other highly restricted\nform.\n\nUsing for example a String directly is a bad idea as that would mean that bE\n!= Be != BE != Belgium != Belgique != Belgi\u00eb. Even though these are really\nreferring all to the same country. In such cases a much better idea is to at\nthe very least create a wrapper type such as struct Country(String), to allow\nyou to enforce sanitization/validation when creating the value and ensuring\nthe hashes will be the same for those values that are conceptually the same.\n\n## Example\n\nHere follows an example demonstrating all the features of VennDB.\n\nIf you prefer a summary of what is generated, or do not understand something\nfrom the example below, you can also read the \"Generated Code Summary\" chapter\nbelow.\n\n    \n    \n    use itertools::Itertools; use venndb::VennDB; #[derive(Debug, VennDB)] // These attributes are optional, // e.g. by default the database would be called `EmployeeDB` (name + 'DB'). #[venndb(name = \"EmployeeInMemDB\")] pub struct Employee { // you can use the `key` arg to be able to get an `Employee` instance // directly by this key. It will effectively establishing a mapping from key to a reference // of that Employee in the database. As such keys have to have unique values, // or else you get an error while appending / creating the DB. // // NOTE: keys do not only have to be unique, they also have to implement `Clone`!! // // A property cannot be a filter and a key at the same time, // trying to do so will result in a compile-team failure. #[venndb(key)] id: u32, name: String, is_manager: bool, is_admin: bool, is_active: bool, // booleans are automatically turned into (query) filters, // use the `skip` arg to stop this. As such it is only really needed for // bool properties :) #[venndb(skip)] foo: bool, // non-bool values can also be turned into filters, turning them into 2D filters. // For each uniquely inserted Department variant that is inserted, // a new filter is kept track of. This allows you to apply a (query) filter // based on department, a pretty useful thing to be able to do. // // NOTE: this does mean that such filter-map types have to also be: // `PartialEq + Eq + Hash + Clone`!! // // A property cannot be a filter and a key at the same time, // trying to do so will result in a compile-team failure. #[venndb(filter)] department: Department, } fn main() { let db = EmployeeInMemDB::from_iter([ RawCsvRow(\"1,John Doe,true,false,true,false,Engineering\"), RawCsvRow(\"2,Jane Doe,false,true,true,true,Sales\"), RawCsvRow(\"3,John Smith,false,false,true,false,Marketing\"), RawCsvRow(\"4,Jane Smith,true,true,false,true,HR\"), RawCsvRow(\"5,John Johnson,true,true,true,true,Engineering\"), RawCsvRow(\"6,Jane Johnson,false,false,false,false,Sales\"), RawCsvRow(\"7,John Brown,true,false,true,false,Marketing\"), RawCsvRow(\"8,Jane Brown,false,true,true,true,HR\"), ]) .expect(\"MemDB created without errors (e.g. no duplicate keys)\"); println!(\">>> Printing all employees...\"); let all_employees: Vec<_> = db.iter().collect(); assert_eq!(all_employees.len(), 8); println!(\"All employees: {:#?}\", all_employees); println!(\">>> You can lookup an employee by any registered key...\"); let employee = db .get_by_id(&2) .expect(\"to have found an employee with ID 2\"); assert_eq!(employee.name, \"Jane Doe\"); println!(\">>> Querying for all managers...\"); let mut query = db.query(); query.is_manager(true); let managers: Vec<_> = query .execute() .expect(\"to have found at least one\") .iter() .collect(); assert_eq!(managers.len(), 4); assert_eq!( managers.iter().map(|e| e.id).sorted().collect::<Vec<_>>(), [1, 4, 5, 7] ); println!(\">>> Querying for all managers with a last name of 'Johnson'...\"); let managers_result = query .execute() .expect(\"to have found at least one\") .filter(|e| e.name.ends_with(\"Johnson\")) .expect(\"to have found a manager with a last name of Johnson\"); let managers = managers_result.iter().collect::<Vec<_>>(); assert_eq!(managers.len(), 1); assert_eq!(managers.iter().map(|e| e.id).collect::<Vec<_>>(), [5]); println!(\">>> You can also just get the first result if that is all you care about...\"); let manager = managers_result.first(); assert_eq!(manager.id, 5); println!(\">>> Querying for a random active manager in the Engineering department...\"); let manager = query .reset() .is_active(true) .is_manager(true) .department(Department::Engineering) .execute() .expect(\"to have found at least one\") .any(); assert!(manager.id == 1 || manager.id == 5); println!(\">>> If you want you can also get the Employees back as a Vec, dropping the DB data all together...\"); let employees = db.into_rows(); assert_eq!(employees.len(), 8); println!(\">>> You can also get the DB back from the Vec, if you want start to query again...\"); // of course better to just keep it as a DB to begin with, but let's pretend this is ok in this example let mut db = EmployeeInMemDB::from_rows(employees).expect(\"DB created without errors\"); assert_eq!(db.iter().count(), 8); println!(\">>> Querying for all active employees in the Sales department...\"); let mut query = db.query(); query.is_active(true); query.department(Department::Sales); let sales_employees: Vec<_> = query .execute() .expect(\"to have found at least one\") .iter() .collect(); assert_eq!(sales_employees.len(), 1); assert_eq!(sales_employees[0].name, \"Jane Doe\"); println!(\">>> At any time you can also append new employees to the DB...\"); assert!(db .append(RawCsvRow(\"8,John Doe,true,false,true,false,Engineering\")) .is_err()); println!(\">>> This will fail however if a property is not correct (e.g. ID (key) is not unique in this case), let's try this again...\"); assert!(db .append(RawCsvRow(\"9,John Doe,false,true,true,false,Engineering\")) .is_ok()); assert_eq!(db.len(), 9); println!(\">>> This new employee can now also be queried for...\"); let mut query = db.query(); query.department(Department::Engineering).is_manager(false); let new_employee: Vec<_> = query .execute() .expect(\"to have found at least one\") .iter() .collect(); assert_eq!(new_employee.len(), 1); assert_eq!(new_employee[0].id, 9); println!(\">>> You can also extend it using an IntoIterator...\"); db.extend([ RawCsvRow(\"10,Glenn Doe,false,true,true,true,Engineering\"), RawCsvRow(\"11,Peter Miss,true,true,true,true,HR\"), ]).unwrap(); let mut query = db.query(); query .department(Department::HR) .is_manager(true) .is_active(true) .is_admin(true); let employees: Vec<_> = query .execute() .expect(\"to have found at least one\") .iter() .collect(); assert_eq!(employees.len(), 1); assert_eq!(employees[0].id, 11); println!(\">>> All previously data is still there as well of course...\"); query .reset() .is_active(true) .is_manager(true) .department(Department::Engineering); let managers: Vec<_> = query .execute() .expect(\"to have found at least one\") .iter() .collect(); assert_eq!(managers.len(), 2); assert_eq!( managers.iter().map(|e| e.id).sorted().collect::<Vec<_>>(), [1, 5] ); } #[derive(Debug)] struct RawCsvRow<S>(S); impl<S> From<RawCsvRow<S>> for Employee where S: AsRef<str>, { fn from(RawCsvRow(s): RawCsvRow<S>) -> Employee { let mut parts = s.as_ref().split(','); Employee { id: parts.next().unwrap().parse().unwrap(), name: parts.next().unwrap().to_string(), is_manager: parts.next().unwrap().parse().unwrap(), is_admin: parts.next().unwrap().parse().unwrap(), is_active: parts.next().unwrap().parse().unwrap(), foo: parts.next().unwrap().parse().unwrap(), department: parts.next().unwrap().parse().unwrap(), } } } #[derive(Debug, PartialEq, Eq, Hash, Clone)] pub enum Department { Engineering, Sales, Marketing, HR, } impl std::str::FromStr for Department { type Err = (); fn from_str(s: &str) -> Result<Self, Self::Err> { match s { \"Engineering\" => Ok(Department::Engineering), \"Sales\" => Ok(Department::Sales), \"Marketing\" => Ok(Department::Marketing), \"HR\" => Ok(Department::HR), _ => Err(()), } } }\n\n### Generated Code Summary\n\nIn this chapter we'll list the API as generated by VennDB for the following\nexample code from above:\n\n    \n    \n    #[derive(Debug, VennDB)] #[venndb(name = \"EmployeeInMemDB\")] pub struct Employee { #[venndb(key)] id: u32, name: String, is_manager: bool, is_admin: bool, is_active: bool, #[venndb(skip)] foo: bool, #[venndb(filter)] department: Department, }\n\nThe following public-API datastructures will be generated:\n\n  * struct EmployeeInMemDB: the database, that can be used to query (by filters) or look up data (by keys);\n  * enum EmployeeInMemDBError: the error type that is returned when mutating the DB and a property of the to be inserted row;\n  * enum EmployeeInMemDBErrorKind: the kind of error that can happen as described for EmployeeInMemDBError;\n  * struct EmployeeInMemDBQuery: the query builder that is used to build a query that can be executed to query data from the db using filters;\n  * struct EmployeeInMemDBQueryResult: the result when querying using EmployeeInMemDBQuery and at least one row was found that matched the defined filters;\n  * struct EmployeeInMemDBQueryResultIter: the iterator type that is used when calling EmployeeInMemDBQueryResult::iter. It has no methods/api other then the fact that it is an Iterator and can be used as one;\n\nThe visual specifiers of these datastructures will be the same as the struct\nthat the VennDB macro is applied to. E.g. in this example Employee has a\nspecifier of pub so the above datastructures and their public-apy methods will\nalso be pub.\n\nThere are also some other helper datastructures generated \u2014 all prefixed with\nthe database name, e.g. EmployeeInMemDB in this example \u2014 but we do not\nmention here as they should not be relied upon and given the prefix it should\ncause no conflict. In case you do not want to expose these structures to the\noutside you can wrap your struct within its own mod (module).\n\n#### Generated Code Summary: Method API\n\nDatabase: (e.g. EmployeeInMemDB):\n\nfn signature| description  \n---|---  \nEmployeeInMemDB::new() -> EmployeeInMemDB| create a new database with zero\ncapacity  \nEmployeeInMemDB::default() -> EmployeeInMemDB| same as EmployeeInMemDB::new()\n-> EmployeeInMemDB  \nEmployeeInMemDB::capacity(capacity: usize) -> EmployeeInMemDB| create a new\ndatabase with the given capacity, but no rows already inserted  \nEmployeeInMemDB::from_rows(rows: ::std::vec::Vec<Employee>) -> EmployeeInMemDB\nor EmployeeInMemDB::from_rows(rows: ::std::vec::Vec<Employee>) ->\nResult<EmployeeInMemDB, EmployeeInMemDBError<::std::vec::Vec<Employee>>>|\nconstructor to create the database directly from a heap-allocated list of data\ninstances. The second version is the one used if at least one #[venndb(key)]\nproperty is defined, otherwise it is the first one (without the Result).  \nEmployeeInMemDB::from_iter(iter: impl ::std::iter::IntoIterator<Item = impl\n::std::convert::Into<Employee>>) -> EmployeeInMemDB or\nEmployeeInMemDB::from_rows(iter: impl ::std::iter::IntoIterator<Item = impl\n::std::convert::Into<Employee>>) -> Result<EmployeeInMemDB,\nEmployeeInMemDBError<::std::vec::Vec<Employee>>>| Same as from_rows but using\nan iterator instead. The items do not have to be an Employee but can be\nanything that can be turned into one. E.g. in our example above we defined a\nstruct RawCsvRow that was turned on the fly into an Employee. This happens all\nat once prior to inserting the database, which is why the version with a\nresult does return a Vec and not an iterator.  \nEmployeeInMemDB::append(&mut self, data: impl ::std::convert::Into<Employee>)\nor EmployeeInMemDB::append(&mut self, data: impl\n::std::convert::Into<Employee>) -> Result<(), EmployeeInMemDBError<Employee>>|\nappend a single row to the database. Depending on whether or not a\n#[venndb(key)] property is defined it will generate the Result version or not.\nSame as from_rows and from_iter  \nEmployeeInMemDB::extend<I, Item>(&mut self, iter: I) where I:\n::std::iter::IntoIterator<Item = Item>, Item: ::std::convert::Into<Employee>\nor EmployeeInMemDB::extend<I, Item>(&mut self, iter: I) -> Result<(),\nEmployeeInMemDBError<(Employee, I::IntoIter)>> where I:\n::std::iter::IntoIterator<Item = Item>, Item: ::std::convert::Into<Employee>|\nextend the database with the given iterator, once again returning a result in\ncase such insertion can go wrong (e.g. because keys are used (duplication)).\nOtherwise this function will return nothing.  \nEmployeeInMemDB::get_by_id<Q>(&self, data: impl\n::std::convert::Into<Employee>) -> Option<&Employee> where Employee\n::std::borrow::Borrow<Q>, Q: ::std::hash::Hash + ::std::cmp::Eq +\n?::std::marker::Sized| look up a row by the id key property. This method will\nbe generated for each property marked with #[venndb(key). e.g. if you have key\nproperty named foo: MyType property there will be also a get_by_foo(&self,\n...) method generated.  \nEmployeeInMemDB::query(&self) -> EmployeeInMemDBQuery| create a\nEmployeeInMemDBQuery builder to compose a filter composition to query the\ndatabase. The default builder will match all rows. See the method API for\nEmployeeInMemDBQuery for more information  \n  \nQuery (e.g. EmployeeInMemDBQuery)\n\nfn signature| description  \n---|---  \nEmployeeInMemDBQuery::reset(&mut self) -> &mut Self| reset the query, bringing\nit back to the clean state it has on creation  \nEmployeeInMemDBQuery::execute(&self) ->\nOption<EmployeeInMemDBQueryResult<'a>>| return the result of the query using\nthe set filters. It will be None in case no rows matched the defined filters.\nOr put otherwise, the result will contain at least one row when Some(_) is\nreturned.  \nEmployeeInMemDBQuery::is_manager(&mut self, value: bool) -> &mut Self| a\nfilter setter for a bool filter. One such method per bool filter (that isn't\nskipped) will be available. E.g. if you have foo filter then there will be a\nEmployeeInMemDBQuery:foo method.  \nEmployeeInMemDBQuery::department(&mut self, value: Department) -> &mut Self| a\nfilter (map) setter for a non-bool filter. One such method per non-bool filter\nwill be available. You can also skip these, but that's of course a bit\npointless. The type will be equal to the actual field type. And the name will\nonce again be equal to the original field name.  \n  \nQuery Result (e.g. EmployeeInMemDBQueryResult)\n\nfn signature| description  \n---|---  \nEmployeeInMemDBQueryResult::first(&self) -> &Employee| return a reference to\nthe first matched employee found. An implementation detail is that this will\nbe the matched row that was first inserted, but for compatibility reasons you\nbest not rely on this if you do not have to.  \nEmployeeInMemDBQueryResult::any(&self) -> &Employee| return a reference to a\nrandomly selected matched employee. The randomness can be relied upon to be\nfair.  \nEmployeeInMemDBQueryResult::iter(&self) -> EmployeeInMemDBQueryResultIter`|\nreturn an iterator for the query result, which will allow you to iterate over\nall found results, and as such also collect them into an owned data structure\nshould you wish.  \nEmployeeInMemDBQueryResult::filter<F>(&self, predicate: F) ->\nOption<#EmployeeInMemDBQueryResult> where F: Fn(&#name) -> bool| return\nSome(_) EmployeeInMemDBQueryResult with the same reference data, but\ncontaining (and owning) only the indexes for which the linked row matches\narcoding to the given Fn predicate  \n  \n## \u26e8 | Safety\n\nThis crate uses #![forbid(unsafe_code)] to ensure everything is implemented in\n100% safe Rust.\n\n## \ud83e\udd80 | Compatibility\n\nvenndb is developed mostly on MacOS M-Series machines and run in production on\na variety of Linux systems. Windows support is not officially guaranteed, but\nis tested using Github Actions with success.\n\nplatform| tested| test platform  \n---|---|---  \nMacOS| \u2705| M2 (developer laptop) and macos-12 Intel (GitHub Action)  \nWindows| \u2705| Windows 2022 (GitHub Action)  \nLinux| \u2705| Ubuntu 22.04 (GitHub Action)  \n  \nPlease open a ticket in case you have compatibility issues for your\nsetup/platform. Our goal is not to support all possible platformns in the\nworld, but we do want to support as many as we reasonably can.\n\n### Minimum supported Rust version\n\nvenndb's MSRV is 1.75.\n\nUsing GitHub Actions we also test if venndb on that version still works on the\nstable and beta versions of rust as well.\n\n## \ud83e\udded | Roadmap\n\nPlease refer to https://github.com/plabayo/venndb/milestones to know what's on\nthe roadmap. Is there something not on the roadmap for the next version that\nyou would really like? Please create a feature request to request it and\nbecome a sponsor if you can.\n\n## \ud83d\udcbc | License\n\nThis project is dual-licensed under both the MIT license and Apache 2.0\nLicense.\n\n## \ud83d\udc4b | Contributing\n\n\ud83c\udf88 Thanks for your help improving the project! We are so happy to have you! We\nhave a contributing guide to help you get involved in the venndb project.\n\nContributions often come from people who already know what they want, be it a\nfix for a bug they encountered, or a feature that they are missing. Please do\nalways make a ticket if one doesn't exist already.\n\nIt's possible however that you do not yet know what specifically to\ncontribute, and yet want to help out. For that we thank you. You can take a\nlook at the open issues, and in particular:\n\n  * good first issue: issues that are good for those new to the venndb codebase;\n  * easy: issues that are seen as easy;\n  * mentor available: issues for which we offer mentorship;\n  * low prio: low prio issues that have no immediate pressure to be finished quick, great in case you want to help out but can only do with limited time to spare;\n\nIn general, any issue not assigned already is free to be picked up by anyone\nelse. Please do communicate in the ticket if you are planning to pick it up,\nas to avoid multiple people trying to solve the same one.\n\nShould you want to contribure this project but you do not yet know how to\nprogram in Rust, you could start learning Rust with as goal to contribute as\nsoon as possible to venndb by using \"the Rust 101 Learning Guide\" as your\nstudy companion. Glen can also be hired as a mentor or teacher to give you\npaid 1-on-1 lessons and other similar consultancy services. You can find his\ncontact details at https://www.glendc.com/.\n\n### Contribution\n\nUnless you explicitly state otherwise, any contribution intentionally\nsubmitted for inclusion in venndb by you, shall be licensed as both MIT and\nApache 2.0, without any additional terms or conditions.\n\n### Acknowledgements\n\nSpecial thanks goes to all involved in developing, maintaining and supporting\nthe Rust programming language. Also a big shoutout to the \"Write Powerful Rust\nMacros\" book by Sam Van Overmeire, which gave the courage to develop this\ncrate.\n\nSome code was also copied/forked from google/argh, for which thank you, we are\nbig fans of that crate. Go use it if you want to create a CLI App.\n\n## \ud83d\udc96 | Sponsors\n\nvenndb is completely free, open-source software which needs lots of effort and\ntime to develop and maintain.\n\nSupport this project by becoming a sponsor. One time payments are accepted at\nGitHub as well as at \"Buy me a Coffee\".\n\nSponsors help us continue to maintain and improve venndb, as well as other\nFree and Open Source (FOSS) technology. It also helps us to create educational\ncontent such as https://github.com/plabayo/learn-rust-101, and other open\nsource frameworks such as https://github.com/plabayo/rama.\n\nSponsors receive perks and depending on your regular contribution it also\nallows you to rely on us for support and consulting.\n\nFinally, you can also support us by shopping Plabayo <3 VennDB merchandise \ud83d\udecd\ufe0f\nat https://plabayo.threadless.com/.\n\n## About\n\nin memory Rust database to query your data like a Venn diagram\n\nvenndb.rs\n\n### Topics\n\nrust bitset database memory vector venn-diagram db sets bitvec\n\n### Resources\n\nReadme\n\n### License\n\n### Code of conduct\n\nCode of conduct\n\n### Security policy\n\nSecurity policy\n\nActivity\n\nCustom properties\n\n### Stars\n\n8 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n1 fork\n\nReport repository\n\n## Releases 2\n\n0.1.1 Latest\n\nApr 9, 2024\n\n\\+ 1 release\n\n## Sponsor this project\n\nplabayo Plabayo\n\nSponsor\n\nLearn more about GitHub Sponsors\n\n## Languages\n\n  * Rust 79.0%\n  * Python 14.8%\n  * HTML 4.2%\n  * CSS 1.2%\n  * Just 0.8%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
