{"aid": "40037885", "title": "Goto", "url": "http://www.azillionmonkeys.com/qed/goto.html", "domain": "azillionmonkeys.com", "votes": 1, "user": "luu", "posted_at": "2024-04-15 07:41:33", "comments": 0, "source_title": "Paul Hsieh's Goto Page", "source_text": "Paul Hsieh's Goto Page\n\n| GOTO  \n---  \n  \nby Paul Hsieh\n\nPaul Nettle (a programmer at Terminal Reality), recently pointed out some\nthings written (by Microsoftie's no less) about the use goto and the debate\nthat so commonly ensues about it. Here's an excerpt of what he posted to the\nrec.games.programmer newsgroup:\n\nHere's what \"Writing Solid Code\" (p. xxii) has to say on the subject of the\ngoto statement:\\---[excerpt begins]--- That's not to say that you should\nblindly follow the guidelines in this book. They aren't rules. Too many\nprogrammers have taken the guideline \"Don't use goto statements\" as a\ncommandment from God that should never be broken. When asked why they're so\nstrongly against gotos, they say that using goto statements results in\nunmaintainable spaghetti code. Experienced programmers often add that goto\nstatments can upset the compiler's code optimizer. Both points are valid. Yet\nthere are times when the judicious use of a goto can greatly improve the\nclarity and efficiency of the code. In such cases, clinging to the guideline\n\"Don't use goto statements\" would result in worse code, not better.\n---[excerpt ends]---And here's what \"Code Complete\" (p. 349) has to say on the\nsubject:\\---[excerpt begins]--- The Phony goto DebateA primary feature of most\ngoto discussions is a shallow approach to the question. The arguer on the\n\"gotos are evil\" side usually presents a trivial code fragment that uses gotos\nand then shows how easy it is to rewrite the fragment without gotos. This\nproves mainly that it's easy to write trivial code without gotos. ---[excerpt\nends]---  \n---  \n  \nIndeed it always surprises me how quickly people are willing to regurgitate\nthe age old argument against the use of goto. In my early days of programmer,\nI started as a BASIC spaghetti code programmer that over used goto's as a\nmatter of course. Then I went to university where I was told never to use goto\n(or suffer the wrath of the TA's grading penalties.) Indeed I trained myself\nto get out of using goto's and indeed, I've never come to an algorithm that I\ncouldn't some implement without gotos.\n\nBut then I got a job. On that job I had to really brush up my assembly skills\nas that was this language I was to use day-in, day-out. I have since merged my\nskills at high level and low level programming, and when I hear this debate it\nis enough to make me cringe. All the so called problems that goto's have are\nreally just limitations of the coder's skill level, not anything intrinsic\nabout the use of goto itself.\n\nSome points that I think should be made: Over-use or capricious use of goto\ncan definately lead to hard to follow and maintain \"spaghetti code\". Using\nhigh level flow control mechanisms helps the compiler and helps you see\nstructure in your code. On the other hand, well placed sparse use of goto is\nusually clear. Examples:\n\n  * \\- Using a single goto and single label to exit several levels of scope.\n  * \\- Using a goto in the middle of complex construction to short cut to the top of a loop.\n  * \\- Starting a highly optimized do { ... } while loop that is best initiated by jumping into the center first. (Because your compiler is not cooperating.)\n  * \\- Extensions of duff's device.\n\nWhen you reach a certain level of skill in programming, one eventually\nrealizes that the issue of writing clean maintainable code is not function of\nwhat specific language features you are using, but rather how clearly an\nalgorithm is expressed by its implementation with those language elements. For\nexample, if I am looking at code for the first time, and I see an isolated\nlabel, then I expect to see a corresponding goto and am not likely to be\nphased by how the flow of execution. Are you? On the other hand if I see a ton\nof nested if's, while's and so on that use expression side effects and other\nimplied (as opposed to explicit) constructs as conditionals, I will tend to\nhave a hard time with it. Exit and start conditions for loops can be hidden\nand convoluted just as easy using sanctioned flow control language elements as\nit can by over-using goto.\n\nOn the plus side to minimizing the use of goto's it can help a beginner who\nhas been raised on BASIC (like I was) break their bad habits. The biggest\nthing that a beginner can expect to learn from doing this is learning to\nprogram at a high level of abstraction that is different from what they are\nused to. Getting used to other ways of programming will help the beginner\nexpand their breadth of programming paradigms. But as mentioned in \"Writing\nSolid Code\" above you don't want to get into a mode where you are blindly\nfollowing rules that have nothing to do with writing clean maintainable code.\n\nUpdate: I recently looked at the book \"Compilers Principles, Techniques, and\nTools\". In it, it describes the intermediate languages that programs are\ncompiled to in which typically all branches are transformed to goto and if ...\ngoto constructions. The idea being that optimizations are done after the\nprogram has been transformed to a loopless goto riddled intermediate program.\nThat seals it for me -- I say use goto whenever it makes sense.\n\nThis page hosted by Pair.com.\n\n", "frontpage": false}
