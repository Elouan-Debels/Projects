{"aid": "39980750", "title": "Key to Simplicity: Squeezing the hassle out of encryption key recovery", "url": "https://www.juicebox.xyz/blog/key-to-simplicity-squeezing-the-hassle-out-of-encryption-key-recovery", "domain": "juicebox.xyz", "votes": 6, "user": "inmygarage", "posted_at": "2024-04-09 15:52:50", "comments": 0, "source_title": "Key to Simplicity: Squeezing the hassle out of encryption key recovery", "source_text": "Key to Simplicity: Squeezing the hassle out of encryption key recovery \u2013\nJuicebox\n\nKey to Simplicity: Squeezing the hassle out of encryption key recovery\n\nNora Trapp\n\nPublished on 9 April 2024\n\nCryptography transforms the impossible task of safeguarding extensive data\ntransmitted and stored across numerous systems and networks into the simpler\ntask of securing a small singular key in one location. It is a magical thing.\nHowever, as services increasingly adopt end-to-end encryption for privacy\nfeatures, this single small key has emerged as something with challenges and\nproblems of its own.\n\nOne of the most notable challenges is ensuring that someone (but only that\nsomeone!) has continued access to the encryption keys protecting their data,\nregardless of whether they reinstall an app, lose their phone, or encounter\nany of the other myriad pitfalls of life.\n\nUnfortunately, the default approach to these problems is often to place the\nburden directly onto the user by requiring them to manage a backup of their\nsecret key. These keys are too long to memorize and are challenging for users\nto store securely. This complexity becomes especially evident when users need\nto input their key material on a new device, leading some to opt for less\nsecure alternatives instead of navigating the secure platform.\n\n## Unlocking the key conundrum\n\nVarious solutions have been proposed to address this issue. In the web3/crypto\nspace, seed phrases offer a slight simplification by representing a key as a\nseries of words, but they still require users to manage lengthy and\nunmemorable strings. Passkeys prove more compelling by eliminating the need\nfor users to remember key material, but introduce their own UX challenges when\nstoring and transferring this material across devices, and their own security\nchallenges when considering how they are backed up themselves.\n\nThe field of \u201cpassword based encryption\u201d aimed to solve this issue by\ntransforming short user-memorable passwords into encryption keys through\niterative hashing or the like, such that an encryption key can always be\nrecovered from something that a user can remember. However, regardless of how\na key derivation function is tuned, these systems have proven very vulnerable\nto attackers that employ dictionary or brute force attacks to make guesses\nuntil they too are able to recover the correct key.\n\nSome of the most promising solutions to date leverage secure hardware, such as\nprogrammable Hardware Security Modules (HSMs). The innovation here is that\nsecure hardware can be used to limit an attacker\u2019s ability to make guesses, so\nthat short user-memorable inputs can be transformed into encryption keys\nwithout the same risks of brute forcing or dictionary attacks that came with\ntraditional password based encryption.\n\nIndeed, companies like Apple and WhatsApp use programmable HSMs in this way to\nenable end-to-end backup of keys protecting some user data. Their interface\ntypically involves logging into an account (using an Apple ID or phone number)\nand entering a 6-digit PIN. This PIN is indirectly used to protect a secret,\nand the HSM prevents an attacker (including the operator) from brute forcing.\nSignal\u2019s Secure Value Recovery was an initial proof of concept for this type\nof system, but relies on a weaker version of secure hardware (Intel\u2019s SGX) to\nprovide a simplified PIN based user interface using a similar underlying\nmechanism.\n\nHowever, while relying on hardware security reduces user burden, it assumes\nthe inherent security of a specific set of hardware and firmware. The safety\nof your secrets becomes contingent on the security of the hardware used to\nrecover them, which can lead to challenges in keeping up with evolving\nhardware vulnerabilities. Moreover, secure hardware is often performance-\nconstrained, outdated, and costly, posing sustainability issues at scale.\n\n## Juicebox: Blending ease and security without the pulp\n\nWe have designed Juicebox to solve these problems. Like some of the most\npromising solutions to date, Juicebox allows a user to recover their secret\nmaterial by remembering a short PIN, without having access to any previous\ndevices \u2013 but also without placing trust in any single party or hardware\nmanufacturer.\n\nAdditionally, Juicebox:\n\n  1. Never gives any service access to a user\u2019s secret material or PIN.\n  2. Distributes trust across mutually distrusting services, eliminating the need to trust any singular server operator or hardware vendor.\n  3. Prevents brute-force attacks by limiting attempts.\n  4. Allows auditing of secret access attempts.\n\nWe\u2019re able to achieve these goals without the security trade-offs seen in HSMs\nalone by combining existing, proven distributed cryptography techniques to\nminimize the risks traditionally associated with them. All while keeping user\nburden low by allowing recovery through memorable low-entropy PINs, and\nmaintaining similar security to solutions utilizing high-entropy keys.\n\n### Learning to share\n\nThe most straightforward version of standard HSM based key recovery looks like\nthis:\n\n  1. The client establishes a secure connection with the process running in the HSM.\n  2. The client transmits a key to the HSM, along with a PIN the user selects.\n  3. The HSM securely stores the key, the PIN, and a guess counter associated with that user.\n  4. In the future, the HSM will return the key to the client if it can present the correct PIN.\n  5. The HSM uses the guess counter to limit the total number of possible PIN attempts a client gets.\n\nObviously, if the HSM is compromised, all user data is compromised along with\nit. For Juicebox, our initial challenge was to sever this link between the\nsecurity of a user secret and the security of the single server where it is\nstored.\n\nThe first step is to allow for distributing trust beyond a single organization\nor HSM vendor. Juicebox employs a strategy of distributing secrets across n\nindependent services, each implementing the Juicebox Protocol, and retrieving\nthem from a threshold set where n >= threshold. We refer to each of these\nservices as a realm.\n\nAt a glance, distributing secrets seems straightforward \u2013 secret sharing\nschemes have been widely used for almost half a century. However, it is not\nthat simple. Running the naive approach outlined above across multiple realms,\nbut replacing a client key with a client key share (a threshold shard of a\nkey), does not actually help. If a single realm is compromised, the attacker\ncan get the PIN out and use it to retrieve a threshold of the other key shares\nfrom the other realms.\n\nInstead, a different approach is required that ensures neither a user\u2019s PIN\nnor their full key ever leaves their device. This is a place where oblivious\npseudorandom functions (OPRFs) can work their magic!\n\n### Oblivious, obviously\n\nAn OPRF is a cryptographic primitive that enables a realm to securely evaluate\na function on a client\u2019s input. This evaluation ensures the server learns\nnothing about the client\u2019s input and the client learns nothing about the\nserver\u2019s private key beyond the result of the function.\n\nHere's how it works:\n\n  1. The client generates a random blinding factor to obscure a user's PIN, creating a \"blinded\" version of the PIN.\n  2. This blinded PIN is sent to a realm, where a long-lived private key is used to compute a result without knowledge of the original PIN.\n  3. Upon receiving the blinded result from the realm, the client removes the blinding factor, revealing the final result for the realm's private key and the original PIN.\n\nThis final result can be used as a recoverable encryption key.\n\nHowever, when you're dealing with threshold realms, controlled by any number\nof operators, this model becomes impractical. Executing an OPRF evaluation for\neach realm (and calculating threshold independent results) incurs significant\nperformance costs. Moreover, if one realm's private key is compromised, it\nundermines trust in that realm for all users.\n\nEnter Threshold OPRFs (T-OPRFs) \u2013 a variant on the traditional OPRF\nspecifically designed to solve both of these problems by combining secret\nsharing with OPRFs. Each realm's private key becomes a unique share of a\nrandom root private key created on the client during secret storage. This\nmathematical association of realm private keys enables us to optimize the\noperation to a single T-OPRF evaluation across the entire threshold of realms.\n\nBy creating shares of a single blinded input, and later reconstructing the\nblinded result shares received from each realm, we can reduce an entire\nthreshold set to a single shared result. Additionally, since this approach\nrequires the client to generate the associated keys for each realm, the client\ncan also rotate those keys anytime it updates the stored secret.\n\nSince it requires threshold realms to acquire this new shared result, it can\nnow be used in place of the user\u2019s PIN in the original model when hashed with\na realm\u2019s address, greatly reducing the cost of the interaction.\n\n  1. The client generates a root OPRF key, and creates n shares of it.\n  2. The client computes an OPRF result locally using a PIN the user selects and the root key.\n  3. The client hashes the result with each realm\u2019s address, deriving threshold unlock tags.\n  4. The client establishes a secure connection with the process running in threshold HSMs.\n  5. The client creates shares of a key, and transmits a share to each HSM, along with the appropriate unlock tag and OPRF key share.\n  6. The HSM securely stores the key share, unlock tag, OPRF key share, and a guess counter associated with that user.\n  7. In the future, the client performs a T-OPRF evaluation with their PIN, and acquires the result.\n  8. When the client derives and presents a correct unlock tag, the HSM returns the key share.\n  9. The client reconstructs the key using the recovered key shares.\n  10. The HSM uses the guess counter to limit the total number of possible attempts a client gets.\n\n### Ensuring integrity\n\nWhen performing a T-OPRF over multiple realms, it becomes important to verify\nintegrity of the shares so that one misbehaving realm cannot prevent recovery\nof a secret. To achieve this, we need a way to detect misbehaving realms and\nexclude them from recovery.\n\nSince each realm maintains a unique private key share, the client can sign\nthese shares before providing them to the realm at storage time, discarding\nthe signing key. Then, during recovery, each realm can present its public\nverification key and signature at the start of the T-OPRF evaluation. This\nallows the client to quickly establish a threshold of realms that have\nmatching verification keys, with valid signatures.\n\nUnfortunately, this still leaves the door open for a threshold of realms\ncolluding to provide valid signatures that were not generated by the client.\nTo work around this issue, we need to additionally establish a consensus on a\nvalue which, if manipulated, would reveal itself to the client. Since the\nT-OPRF result is of sufficiently high entropy, we can split it into two parts:\none continues to be utilized for unlocking secrets, while the other serves as\na commitment stored with each realm. Now, we can establish consensus on a\nthreshold of realms based on commitments and verification keys, and during the\nT-OPRF evaluation we can validate that the produced result contains a matching\ncommitment. This prevents a colluding threshold of realms from substituting\ndifferent OPRF key shares and signatures without knowing the PIN.\n\nWith these protections established, we're in a much better place, but the door\nis still open for a realm to do everything right, while still returning a\nmalicious OPRF result share to deny a user access to their secrets. We need a\nway to filter individual malicious realms out of a set, so the user can still\nproceed as long as threshold correct realms are present. The simplest path to\nsolving this problem is allowing verification of the individual OPRF result\nshares, so we can reject a share and try a new realm without having to guess\nat random which realm has corrupted the set. Using zero-knowledge proofs, a\nrealm can share its public key share with clients and provide cryptographic\nproof that its result share was generated correctly using the associated\nprivate key share.\n\nThere's one last piece of information that realms have the chance to\nmanipulate \u2013 the user's secret share. Doing so could again potentially deny\nusers access to their secrets, since the user would be unable to reconstruct\nthem properly. We need a way to verify the secret has not been manipulated\nsince storage. Since we can already verify the T-OPRF result, which we know at\nstorage (and the realm never learns), we can solve this problem with a simple\nhash over the secret and T-OPRF result. We also want these hashes to be realm\nspecific (so a malicious realm can't copy them from another realm), so we mix\nin the realm's share of the secret as well. During recovery, we can validate\nthese values match, and remove any realms from the set that have tampered with\nthe secret.\n\n### Trusting deliberately\n\nThe new paradigm we've established gives us the opportunity to look at ways we\ncould supplement HSM realms in a threshold set with additional realms that are\nscalable and cost-effective.\n\nJuicebox supports two basic types of realm:\n\n  1. A hardware realm is a type of realm backed by secure hardware \u2014 specifically a hardware security module (HSM), like we\u2019ve been discussing. Hardware realms provide narrow trust boundaries as the HSM is designed such that only the hardware and the code it executes must be trusted. Not the operator.\n  2. A software realm is a type of realm that runs on commodity hardware or in common cloud providers. When paired with hardware realms, they can be used to distribute trust organizationally without the overhead of operating secure hardware.\n\nThe Juicebox Protocol is specifically designed such that, as long as you are\nperforming your operations on some hardware realms, with a threshold that\nrequires their presence, it\u2019s perfectly safe to include software realms in the\noperation to further distribute trust.\n\nA simple configuration could consist of one hardware realm hosted by one\norganization and one software realm hosted by another, with a threshold of\ntwo. More complex configurations with multiple HSM vendors and cloud providers\ncan be constructed to enable greater availability, reliability, and\nperformance.\n\n### Hardware hurdles\n\nIn traditional setups using HSMs, data is stored within the limited persistent\nmemory of these specialized devices. However, due to the constrained storage\ncapacity of HSMs, storing a large dataset entirely within them is often\nimpractical or even impossible, and any hardware failure can result in a loss\nof user data without the use of complicated replication schemes.\n\nOn the other hand, storing sensitive data in a traditional database would\nnegate the benefits of HSMs entirely. Even if the records were stored in\nencrypted form, an HSM could not reliably distinguish an old version of a\nrecord from the latest version, thereby allowing an adversary with access to\nthe hardware to roll back the state. Preventing roll-back attacks is crucial\nto ensuring realms cannot deny access to secrets, while maintaining strict\nlimits on attacker guesses before secret material becomes inaccessible.\n\nTo work around these challenges, Juicebox uses a Merkle-Radix tree, allowing\nthe service to scale to billions of secret records. These records are\norganized into trees, and the tree nodes can be safely stored in an external,\nuntrusted storage system. The Merkle-Radix tree allows the HSMs to verify they\nare operating on the latest version of the record.\n\nJuicebox\u2019s implementation enables:\n\n  * Efficient Scalability: HSMs with limited capacity can efficiently handle requests on very large trees (billions of records) while ensuring data confidentiality, integrity, and freshness.\n  * Logarithmic Performance: Tree operations' performance scales logarithmically with the number of records in the tree, a significant improvement over linear lookup key approaches.\n  * Dynamic Partitioning: The overall dataset can be dynamically partitioned across multiple trees, facilitating seamless scaling up or down with fast and inexpensive repartitioning.\n  * Parallelized Operations: Reads from each tree can be fully parallelized, even during ongoing writes, allowing HSMs to process continuous requests to mutate a tree without waiting for results to reach storage.\n  * Reduced Storage Cost: Tree nodes can be stored and cached freely on an untrusted, non-transactional storage system, reducing storage costs by enabling the use of highly scalable cloud storage solutions such as Bigtable.\n\nJuicebox also employs an authenticated consensus protocol to recover from\nhardware failures, wherein HSMs validate freshness and authenticity on top of\ncommodity hardware performing more traditional consensus. The ability to\nauthenticate the entire Merkle-Radix tree with a single hash allows this\nconsensus protocol to reach agreement on just a small amount of metadata as\nthe tree evolves, making operations simpler and more efficient.\n\n### Auditing attempts\n\nIn the context of the naive storage system we initially discussed, one\nsignificant drawback is the lack of transparency regarding a user's attempts\nto recover their secret material. Without this information, users are unable\nto gauge the security of their secret or take necessary precautions if their\nattempts are exhausted. Users have now come to expect a prompt notification of\nany attempts made against their stored secret, akin to receiving alerts for\nlogin attempts on their other accounts.\n\nTo address these concerns, each realm in our system logs recovery attempts \u2013\nsuccessful and unsuccessful \u2013 along with the remaining number of guesses. This\ndata is made accessible through an API that clients can subscribe to, enabling\nfunctionalities such as push notifications to alert users when attempts are\nmade against their accounts.\n\n## Wrapping up: try a sip of Juicebox\n\nJuicebox\u2019s source code is now available, and we encourage you to read our\nJuicebox Protocol and Merkle-Radix tree whitepapers for more detailed\ninformation. If you\u2019re ready to try it out, a demo is available, configured\nfor our sandbox realms.\n\nJuicebox represents our earnest effort to tackle the challenges of end-to-end\nencryption key recovery with pragmatism and care. We've combined proven\ntechniques like Threshold OPRFs and Merkle-Radix trees to create a solution\nthat prioritizes security without sacrificing user experience. Our doors are\nopen to feedback and collaboration as we continue to refine and enhance what\nwe\u2019ve created.\n\nJuicebox was created by Alex Bochannek, Simon Fell, Moxie Marlinspike, Diego\nOngaro, Daniela Perlein, and Nora Trapp. The project received valuable\nfeedback from Trevor Perrin and was audited by NCC in June 2023.\n\n\u00a9 2024 Juicebox Systems, Inc.\n\nFor media inquiries, contact press@juicebox.me\n\nThanks for subscribing!\n\nPlease enter a valid email address.\n\n", "frontpage": false}
