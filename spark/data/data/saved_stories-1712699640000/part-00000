{"aid": "39980737", "title": "How Phoenix LiveView Form Auto-Recovery Works", "url": "https://fly.io/phoenix-files/how-phoenix-liveview-form-auto-recovery-works/", "domain": "fly.io", "votes": 1, "user": "thibaut_barrere", "posted_at": "2024-04-09 15:51:33", "comments": 0, "source_title": "How Phoenix LiveView Form Auto-Recovery works", "source_text": "How Phoenix LiveView Form Auto-Recovery works \u00b7 The Phoenix Files\n\nReading time \u2022 6 min Share this post on Twitter Share this post on Hacker News\nShare this post on Reddit\n\n# How Phoenix LiveView Form Auto-Recovery works\n\nAuthor\n\n    \n\nName\n\n    Jason Stiebs\n@peregrine\n\n    @peregrine\nImage by Annie Ruygt\n\nWe\u2019re Fly.io and we transmute containers into VMs, running them on our\nhardware around the world. We have fast booting VM\u2019s, so why not take\nadvantage of them?\n\nPhoenix LiveView is a server-side frontend framework and with this great power\ncomes great responsibility on the developer. A very common source of\nfrustration is around Forms, their assigns values and connection resets or\ndeploys. In this post we\u2019ll discuss how this all works and how it enables Form\nAuto-Recovery.\n\nLet\u2019s say we have this basic LiveView with a form and a query input:\n\n    \n    \n    defmodule FormExamples.FormsLive do use FormExamplesWeb, :live_view def mount(_params, _session, socket) do {:ok, socket |> assign(form: to_form(%{\"query\" => nil})) } end def render(assigns) do ~H\"\"\" <.simple_form for={@form} phx-submit=\"save\" id=\"form\" class=\"mb-20\"> <.input field={@form[:query]} label=\"Search\" /> </.simple_form> \"\"\" end def handle_event(\"save\", %{\"query\" => q}, socket) do {:noreply, socket |> assign(form: to_form(%{\"query\" => nil})) |> put_flash(:info, \"Form submitted with query: #{q}\")} end end\n\nWhen we type into the text box and hit enter, our save callback is called and\nwe reset the form. Before we move on, can you see the problem with this form?\n\nOn our Form submit we are assigning \"query\" => nil but \"hello\" remains in our\ntext box. What\u2019s going on here?\n\nSpoiler: We did not change the assign value while we were typing the query, in\nLiveView\u2019s view of the world the form\u2018s query value is nil, and it never\nchanged. These implications will be discussed further in the article.\n\n## The Problem of State\n\nLiveView and, any good frontend framework, help us organize our front end code\naround encapsulating state within a component. Meaning the only place we need\nto think about the state of a view is in our assigns, there will be no other\nreferences mutating our values outside of the component.\n\nUnfortunately in all frameworks this a lie, or a helpful fiction. All frontend\nframeworks actually have to deal with three(!) separate local state\u2019s and keep\nthem in sync, for example here are the 3 state\u2019s for LiveView:\n\n  * Server, where we keep track of assigns, session and the WebSocket related state.\n  * Browser HTML DOM state.\n  * Browser Internal DOM state.\n\nIn react the first state would be the Component/state/props, they still need\nto maintain the HTML and the internal DOM State. This is why they have so many\nfunctions around use* now to encapsulate the many different ways you might\nwant to manage state and the dom.\n\nIn LiveView flow of state is as follows:\n\n  1. Developer changes assigns.\n  2. LiveView calculates the minimum HTML Diff changes and sends it down the WebSocket.\n  3. LiveView.js sends the changes to the virtual DOM library morphdom which alters the HTML DOM.\n  4. User changes inputs, which only changes the Browser Internal DOM State.\n\nKnowing this maybe we can guess what went wrong with our form, and it happens\nright at point 1, the assigns value for the query value never changed. No diff\nwas calculated, the browser HTML never changed so the HTML Input value never\nchanged, all the while the Browsers Internal DOM State value did change.\n\nHere is how we can change our example to reset the value on submit:\n\n    \n    \n    defmodule FormExamples.FormsLive do use FormExamplesWeb, :live_view def mount(_params, _session, socket) do {:ok, socket |> assign(form: to_form(%{\"query\" => nil})) } end def render(assigns) do ~H\"\"\" <.simple_form for={@form} phx-submit=\"save\" phx-change=\"validate\" id=\"form\" class=\"mb-20\"> <.input field={@form[:query]} label=\"Search\" /> </.simple_form> \"\"\" end def handle_event(\"validate\", %{\"query\" => q}, socket) do {:noreply, assign(socket, form: to_form(%{\"query\" => q}))} end def handle_event(\"save\", %{\"query\" => q}, socket) do {:noreply, socket |> assign(form: to_form(%{\"query\" => nil})) |> put_flash(:info, \"Form submitted with query: #{q}\")} end end\n\nHere we added a phx-change to our form, with handle_event function that\nchanges the form and query assigns whenever the form changes. Now when we hit\nsubmit our input would reset to nil because every single keypress we informed\nLiveView of this change! We can follow the flow of state here:\n\n  1. User changes the text box, firing a phx-change event.\n  2. Handle event assign changes the LiveView state.\n  3. LiveView calculate s a diff that is essentially set input.value to assigns.query\n  4. LiveView.js and morphdom sets the HTML DOM value of our input.\n  5. Which is the same as the current HTML Internal Dom value so no change happens that the user can see.\n\n## Enter A Server Restart\n\nNow this is where the Auto-Recovery Magic happens when we deploy or the\nprocess restarts:\n\n  1. On re-connect a phx-change event is fired with the current DOM for every Form that has the same id as a reconnect mounts html.\n  2. Handle event assign changes the LiveView internal state with the validate params.\n  3. LiveView calculate s a diff that is essentially set input.value to assigns.query.\n  4. LiveView.js and morphdom sets the HTML DOM value of our text box.\n  5. Which is the same as the current HTML Internal Dom value so no change happens that the user can see.\n\nThe only difference here a little bit of Magic that LiveView does when it\nknows it\u2019s reconnecting to an existing DOM State. If the current DOM has a\nForm with the same id, instead of replacing it, it fires the change event\nwhich should alter the LiveView\u2019s current assigns with the previous state! And\nthere you have it\u2014fully recoverable forms with no server-side state at all!\nThis works assuming the Form\u2019s id remains unchanged.\n\nAnd if you don\u2019t believe me I pushed a live example here with code here.\n\n## Takeways\n\n  1. Always give each Form a unique and consistent id.\n  2. Always have a phx-change event for Forms that updates the server side assign.\n\nBy understanding its inner workings of form handling and auto-recovery\nmechanisms, we can unlock the full potential of LiveView to create seamless\nuser experiences. I encourage you to check on your own forms and inputs and\nmake sure they have ids and phx-change events wired up to give your users a\nbetter user experience!\n\n# Fly.io \u2764\ufe0f Elixir\n\nFly.io is a great way to run your Phoenix LiveView apps. It\u2019s really easy to\nget started. You can be running in minutes.\n\nDeploy a Phoenix app today! \u2192\n\nLast updated\n\n\u2022\n\n    Apr 9, 2024\n\nShare this post on Twitter Share this post on Hacker News Share this post on\nReddit\n\nAuthor\n\n    \n\nName\n\n    Jason Stiebs\n@peregrine\n\n    @peregrine\n\nPrevious post \u2193\n\n    Easy at-home AI with Bumblebee and Fly GPUs\n\nPrevious post \u2193\n\n    Easy at-home AI with Bumblebee and Fly GPUs\n\nCompany\n\n    About Pricing Jobs\n\nArticles\n\n    Blog Phoenix Files Laravel Bytes Ruby Dispatch Django Beats JavaScript Journal\n\nResources\n\n    Docs Support Status\n\nContact\n\n    GitHub Twitter Community\n\nLegal\n\n    Security Privacy policy Terms of service\n\nCopyright \u00a9 2024 Fly.io\n\n", "frontpage": false}
