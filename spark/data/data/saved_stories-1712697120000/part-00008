{"aid": "39978216", "title": "Converting C437 to XNA Spritesheets with Zig and Raylib", "url": "http://blog.jamiejquinn.com/converting-c437-to-raylib", "domain": "jamiejquinn.com", "votes": 3, "user": "jamiejquinn", "posted_at": "2024-04-09 11:13:31", "comments": 0, "source_title": "Converting C437 to XNA-style Spritesheets", "source_text": "Converting C437 to XNA-style Spritesheets | JamieJQuinn\n\nConverting C437 to XNA-style Spritesheets | JamieJQuinn\n\n###\n\nJamieJQuinn Research Software Engineer\n\n# Converting C437 to XNA-style Spritesheets\n\nI\u2019ve been struggling to get C437 PNG fonts loaded in Raylib due to its default\nPNG loader using a slightly different format. Here, I\u2019ll detail a simple way\nof converting C437 PNGs to the format Raylib expects.\n\nRaylib is a wonderful library for writing quick and simple GUI applications,\nespecially games. I\u2019ve been using it for about a year on various prototypes,\nmost recently a roguelike in Zig. While Raylib\u2019s text rendering is generally\ngood, I wanted to be able to use old-school fonts using the Code page 437\ncharacter set. For context, this particular character set is often used for\ntext-based games due to it having useful extra characters like little faces \u263a\nand walls \u2560, but still sticking to a total number of 256 characters. Since\nfont files (like those found at The Oldschool PC Font Resource or Dwarf\nFortress\u2019s Tileset Repository) are actually just PNGs, it\u2019s trivial for a user\nto design a new tileset based on anything they like, not just characters. This\nis typically how traditional roguelikes like Nethack are tiled.\n\nHowever, Raylib cannot handle these PNGs natively. Its default PNG font loaded\nexpects the characters to be stored in an XNA format, that is every character\nis represented in a box completely surrounded by a single colour, for example\nmagenta:\n\nIn contrast, the C437 PNGs are typically stored as a regular grid of\ncharacters, each with the same width:\n\nAlthough this restricts the fonts to a fixed-width size, this is generally\nwhat is desired for textual, grid-based games like traditional roguelikes.\n\nTo load one of these PNGs as a font, we have to pre-process the image inside\nRaylib:\n\n    \n    \n    const std = @import(\"std\"); const rl = @import(\"raylib.zig\"); pub fn load_c437_font(fname: [:0]const u8, glyph_width: u8, glyph_height: u8) rl.Font { // Load original C437 PNG const c437_png = rl.LoadImage(fname); defer rl.UnloadImage(c437_png); std.debug.print(\"{}\\n\", .{c437_png}); // Calculate number of glyphs const glyphs_per_row = @divExact(c437_png.width, glyph_width); const glyphs_per_col = @divExact(c437_png.height, glyph_height); const padding = 1; // Create new image to store Raylib-style font var font_image = rl.GenImageColor(c437_png.width + glyphs_per_row * padding + padding, c437_png.height + glyphs_per_row * padding + padding, rl.MAGENTA); defer rl.UnloadImage(font_image); std.debug.print(\"{}\\n\", .{font_image}); for (0..@intCast(glyphs_per_row)) |i| { for (0..@intCast(glyphs_per_col)) |j| { const src = rl.Rectangle{ .x = @floatFromInt(i * glyph_width), .y = @floatFromInt(j * glyph_height), .width = @floatFromInt(glyph_width), .height = @floatFromInt(glyph_height), }; const dst = rl.Rectangle{ .x = @floatFromInt(i * (glyph_width + padding) + padding), .y = @floatFromInt(j * (glyph_height + padding) + padding), .width = @floatFromInt(glyph_width), .height = @floatFromInt(glyph_height), }; // Make sure we alpha-out the space in the new image rl.ImageDrawRectangleRec(&font_image, dst, .{ .r = 255, .g = 255, .b = 255, .a = 0 }); // Actually copy the character rl.ImageDraw(&font_image, c437_png, src, dst, .{ .r = 255, .g = 255, .b = 255, .a = 255 }); } } return rl.LoadFontFromImage(font_image, rl.MAGENTA, 0); }\n\nAlthough the above code is in Zig, it should be relatively straight-forward to\nread if you\u2019re used to C/C++. Here, I\u2019m using Raylib directly (as opposed to\none of the Zig bindings) since it exposes a build.zig file for easy\nintegration with Zig.\n\nNote, for a reason I cannot figure out, Raylib refuses to properly render\ncharacters when its numerical value is over 128 so I\u2019ve had to directly call\nDrawTextCodepoint instead of DrawText, which seems to avoid the issue.\n\nWritten on April 3rd , 2024 by Jamie Quinn\n\nFeel free to share!\n\n# You may also enjoy:\n\n  * ### Analysing the prevalence of continuous integration in JOSS\n\n  * ### Four pillars of a reproducible PhD\n\nJamieJQuinn | Research Software Engineer\n\n", "frontpage": true}
