{"aid": "39988298", "title": "Trying Out Rye", "url": "https://burakku.com/blog/rye-test-and-python-tools/", "domain": "burakku.com", "votes": 1, "user": "BerislavLopac", "posted_at": "2024-04-10 08:25:23", "comments": 0, "source_title": "Trying out Rye", "source_text": "Trying out Rye - \u30d6\u30e9\u30c3\u30af\n\n# \u30d6\u30e9\u30c3\u30af\n\n2024-03-29\n\n## Trying out Rye\n\nsoftware Python\n\nThe catch in the Rye.\n\nOne of my least popular takes as a Professional Python DeveloperTM seems to be\nthat I don\u2019t actually consider the Python ecosystem and its tooling to be \"hot\ngarbage\". I also haven\u2019t really bothered with project management tools like\nPoetry, since I think you can use virtual environments and pip and be just\nfine. Really, the only tools in my arsenal that I consider to be absolutely\nessential have been pipx, as distributing Python tools is kind of a pain, and\npyenv, because Homebrew will absolutely break your Python installation without\nany mercy if you so much as blink. Of course, I do also use other tools too,\nbut I don't consider them as essential as those two.\n\nHowever, I do recognise that there is some value in one-stop-shop tools like\nRust\u2019s Cargo, which bakes in a lot more project management stuff into your\nRust development workflow and is generally pretty nice to use. For this reason\nI was quite intrigued by Rye after watching Armin Ronacher\u2019s demonstration\nvideo, since it seems like a version of Cargo (and to some degree Rustup) for\nthe Python world.\n\nOn a conceptual level, it sounds very good. Instead of installing a bunch of\ntools and managing/using them individually, Rye would bundle together all\nsorts of tools and functionality, and let me write Python software with\nbasically Rye alone. The number of different tools that I use and Rye would\nreplace is actually rather long:\n\ncurrent tool| The Rye Way  \n---|---  \npyenv| Rye automatically installs whatever Python version your project uses.  \npip| Rye installs and pins your dependencies as you add them to your project.  \npipx| Rye allows installing Python tools in isolated environments just like\npipx.  \nVirtualFish| Rye automatically sets up a virtualenv in your project directory.  \nBlack| Rye bundles Ruff for formatting (rye fmt).  \nRuff| Rye bundles Ruff for linting (rye lint).  \n  \nI started off by migrating all of my pipx installs to Rye and it worked great.\nAll tools were ready and usable on my $PATH and I could even add optional\ndependencies with --extra-requirement flags. Not sure if there\u2019s a handy way\nof adding those extra requirements after the fact like you can in pipx with\npipx inject though. I imagine I could always just manually install them into\nthe virtual environment but I\u2019d prefer if there was a more straightforward and\nobvious way. Would make it even easier to use Rye as a drop-in replacement for\npipx.\n\nAs for actual development, I decided to start off small and convert a tiny\nPython script I use for fetching data from an API to work with Rye. Since this\nwas just a tiny script that I run in a Docker container, it wasn't exactly\norganized in the way that Rye would organize a script project, so I decided to\nalso make it a bit more structured with a script entry-point and everything.\nThis isn't actually a requirement but I figured that I should try to do it\nlike Rye would want me to. For what it's worth, the default Rye-tastic way of\norganizing code is fairly logical and probably good starting point for people\nnew to Python. Personally, I've never really used /src/ directories in Python\nbut I don't hate it either.\n\nFor this tiny project, everything worked very nicely. Granted, there was only\none dependency (requests), so it wasn't exactly a demanding test. But Rye\nwould bootstrap whatever Python version I had in the .python-version text\nfile, create a virtualenv out of it, install my dependencies into it and then\nallow me to run my script with just python like I didn't have a virtualenv at\nall.\n\nAnd if I upgraded or downgraded my Python version by changing the value in the\n.python-version file, it would bootstrap everything again to make sure my\ndevelopment environment matched the requirements. This would make version\nupgrades a lot easier for projects with lots of different developers, as you\ncould be pretty confident in everyone having an up-to-date development\nenvironment if they just run rye sync. I've had to work on projects that\nupgraded between major versions of Python, and you'd always have at least some\nissues bringing everyone up to speed.\n\nEmboldened by the success of using Rye with this tiny script, I moved onto the\nnext trial: using Rye to develop a Django project. And this is where the pain\nbegins, and not (just) because I picked an example with an ancient Django 2.0\ncodebase.\n\nI bootstrapped my Django project as a virtual package with Rye and managed to\ninstall all of the dependencies for my Django project that are required to run\nthe application locally. Then I started to add the dependencies I need to\nactually serve it on the web and I step on the big fat LEGO brick lying in\nwait: I just can't install uWSGI. The reason for this is actually quite\nsimple: uWSGI needs to compile C extensions, Rye uses static builds of Python,\nand static Python builds + compiling C extensions is a known house of pain.\n\nThe Rye FAQ even admits how the situation when it comes to C extensions is a\nproblem, and one with no real solution at the moment. It does however offer a\nworkaround: register a non-static Python build that you've obtained from\nsomewhere as a Rye toolchain. Since Homebrew has decided to grace my Mac\nStudio with a Python 3.9 installation suitable for my purposes*, I decided to\nregister that.\n\n* Technically Django 2.0 doesn't actually support Python 3.9 but fortune favours the bold.\n    \n    \n    $ which python3.9 /opt/homebrew/bin/python3.9 $ rye toolchain register --name=homebrew /opt/homebrew/bin/python3.9 Registered /opt/homebrew/bin/python3.9 as homebrew@3.9.18\n\nObviously I would never recommend actually using Homebrew-supplied Python\ninstallations for any kind of development work, but I figured it'd be fine for\ntesting. Now I can just pin my custom toolchain to my project and create the\nvirtualenv from that.\n\n    \n    \n    $ rye pin homebrew@3.9.18 pinned homebrew@3.9.18 in project/.python-version $ rye sync Python version mismatch (found cpython@3.9.18, expected homebrew@3.9.18), recreating. error: failed fetching toolchain ahead of sync Caused by: unknown version homebrew-aarch64-macos@3.9.18\n\nOops.\n\nTurns out that Rye is so set on managing your (static) Python toolchains that\nit will even attempt to download a toolchain already on your machine, and then\nfail because your custom toolchain doesn't actually exist beyond your machine.\nIt won't even work even if you omit the custom name from rye toolchain\nregister.\n\nSo yeah, Rye kinda sucks and is all sorts of broken if you ever need\ndependencies that compile C code. Obviously I didn't test out a wide array of\nC extensions, but considering that it's a very well-known problem with static\nbuilds, you'll probably trip up yourself sooner or later if you do a lot of\nPython development.\n\nOn one hand, I do understand that compiling software sucks because you need to\nhoard compile-time requirements and compiling software takes forever and makes\nyour laptop burn your thighs and so on. However, I do think that compiling\nsoftware like your Python development environment has some very significant\nupsides, such as the fact that your build of Python will reference paths\nactually present on your actual computer. Static Python builds are fine for\nsome stuff but I feel like they're a bad idea to be the default and a truly\nawful idea to be the only option. The support for static compilation of Python\njust isn't there yet.\n\nEven if the custom toolchain registering worked like it's supposed to, I find\nthis design approach to completely water down the \"one-stop-shop for all\nPython users\" idea put forth by Rye, since I'm still required to install pyenv\non my machine in order to have a toolchain to register in the first place. I\nthink Rye would be a much better tool if it offered pyenv-style compilation of\nPython, and preferably made that the default option. Or at the very least ask\nme which style I prefer during the installation process. It already asks you\nhow you want the python command work outside Rye-managed projects, so it's not\nunthinkable to have an option for compilation too.\n\nIn terms of ergonomics when it came to the Django project (the parts that\nworked), I also kinda miss the environment variable plugin that VirtualFish\nhad, where it would set environment variables when you activated a virtualenv.\nAs far as I can see, the way you're supposed to integrate environment\nvariables as part of your Python development is by adding them to your Rye\nscripts. So if I want to set DJANGO_SETTINGS_MODULE for when I run any of the\nDjango management commands, I'd chuck it in a separate file like .env and add\nthis to my pyproject.toml file:\n\n    \n    \n    [tool.rye.scripts] manage = { call = \"manage\", env-file = \".env\" }\n\nYou could also add environment variables directly to the script definition but\nthat sounds very not-portable if you work with other developers. But now I can\nrun tests against my development settings module. I just need to use rye run\nmanage to invoke the test management command instead of for example the\nmanage.py script that Django will give you.\n\n    \n    \n    $ rye run manage test Creating test database for alias 'default'... System check identified no issues (0 silenced). .................. --------------------------------------------------------------------- Ran 18 tests in 0.215s OK Destroying test database for alias 'default'...\n\nI think this is totally reasonable and maybe juggling shell session\nenvironment variables isn't the job of a Python development tool anyway, but I\ndo still kinda wish for there to be some kind of a better way for it.\n\nAll in all, I have mixed feelings about Rye. On one hand, many of the design\nideas are good and I think I'd like to use a Cargo-but-for-Python to develop\nsoftware, since I also like using Cargo. However, the insistence on using\nstatic Python builds leads to suffering and won't let me uninstall pyenv\nanyways. There's also some rough edges in implementation to cut yourself up\nfurther, like my attempt at getting Rye and Homebrew-Python to mingle shows.\nThe fact that rye test is also just an alias to run pytest with no possibility\nfor any other testing tool like the built-in unittest module, which is totally\nand absolutely a fine tool for testing that you get out of the box, seems very\nindicative of just how early in Rye's life we are at the moment.\n\nIf you have a working Python development environment, no matter how\nrudimentary its feature set might be, it might not be worth it to try out Rye\nnow. Its best value at the moment would probably rather be for newbs, who can\nbenefit from its easy setup and sane defaults for many things (like not using\nthe system Python if you've got one). However, I think that there's also a\ngood chance that Rye will actually be all-around great in like 12 months, so I\nalso wouldn't invest too heavily in an alternative tool like Poetry if you're\nshopping around for project management tools.\n\nNevertheless, Python is still a fun programming language and the tooling is\nfine.\n\nSteam GitHub Discord Bluesky Twitter AniList YouTube HowLongToBeat\n\n", "frontpage": false}
