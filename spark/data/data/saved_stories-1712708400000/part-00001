{"aid": "39982409", "title": "Immediate-Mode UI with Reactive State for the Web", "url": "https://hyperdiv.io/articles/reactive-state.html", "domain": "hyperdiv.io", "votes": 3, "user": "mondrian", "posted_at": "2024-04-09 18:18:44", "comments": 0, "source_title": "Hyperdiv - Immediate-Mode UI with Reactive State for the Web", "source_text": "Hyperdiv - Immediate-Mode UI with Reactive State for the Web\n\n### Hyperdiv\n\nDocs\n\n# Immediate-Mode UI with Reactive State for the Web\n\nMarius Nita\n\nIn this article, we describe how Hyperdiv adapts Immediate-Mode UI for web\ndevelopment by enhancing it with reactive state similar to Signals. This\ndesign enjoys the minimal and declarative syntax of Immediate-Mode UI, while\nre-rendering the UI on demand, only when its state dependencies change.\n\n## Contents and TL;DR\n\nBackground on Immediate-Mode UI\n\nImmediate-Mode UI (IMUI) frameworks offload UI state management to the\nframework user, and sync the UI to the state by rendering continuously at a\nhigh frame rate.\n\nIMUI for the Web\n\nRendering continuously at a high frame rate does not align with expectations\nin web development. We want to re-render only when necessary.\n\nIMUI Already Manages Component State\n\nDespite offloading state management to users, IMUI frameworks also manage some\ncomponent state internally. A core aspect of IMUI is assigning stable IDs to\ncomponents, in order to manage this internal state.\n\nAdding Reactive State\n\nHyperdiv embraces the existing state management of IMUI and extends it with\nuser-facing reactive state similar to Signals. With this addition, the app re-\nrenders only when dependent state changes.\n\nMaking UI Components Reactive\n\nIn additional to adding user-defined reactive state, built-in UI components\nare made stateful and reactive. All Hyperdiv components, including built-in UI\ncomponents and user-defined state, are based on the same reactive state\narchitecture.\n\nReactive State Enables Caching\n\nWe add a @cached decorator that avoids re-running function calls whose read\ndependencies have not changed.\n\nSummary\n\n## Background on Immediate-Mode UI\n\nImmediate-Mode UI (IMUI) is a paradigm for building user interfaces that has\nbeen popular in the game dev community. Two of the most popular IMUI\nframeworks are Dear ImGUI and Nuklear for C++/C.\n\nIn IMUI, you provide a function that (a) declaratively draws components and\n(b) simultaneously checks if events fired on those components, and handles\nthose events in-line. The framework, in principle, will then run that function\ncontinuously and redraw the UI on every run. (How exactly this is done\nvaries.)\n\n### Example\n\nA program in a hypothetical IMUI framework for Python might look like this:\n\n    \n    \n    from imui_framework import checkbox, text, run checked = False def main(): global checked checked = checkbox(\"Check Me\", checked) if checked: text(\"It is checked!\") run(main)\n\nThis program displays a UI with a checkbox. When the checkbox is checked, the\ntext \"It is checked!\" is also displayed under the checkbox.\n\nIn principle, the framework calls main() continuously in a loop. Within each\ncall to main(), the call checkbox(\"Check Me\", checked) will render a checkbox\nwhose checked state is determined by the parameter checked. In frames in which\nthe checkbox is not toggled by the user of the UI, the call will simply return\nthe value of the parameter checked. When the UI user toggles the checkbox, the\ncall will return (not checked), toggling the value of the checked parameter.\n\nIt is then up to the user to save this toggled state (in the checked variable\nin this case), and then feed that toggled state back into the call on\nsubsequent frames, therefore causing the checkbox to continue being rendered\nin the same state, until toggled again.\n\n### Programmers Manage UI State\n\nIn the example above, the IMUI programmer has to manage the checked state of\nthe checkbox. On any given frame, the framework internally does not know\nwhether that checkbox is currently checked; instead, the user has to maintain\nand provide that state to the framework. The framework is responsible for\ndrawing components and communicating UI events on those components back to the\nuser.\n\nThis philosophy of \"the user manages the UI state\" is prevalent in the IMUI\nspace. It has the significant advantage that users can structure, serialize,\nand persist their UI state however they want.\n\n## IMUI for the Web\n\nWe love IMUI's extremely terse and declarative syntax, and want to adapt IMUI\nto Web app development.\n\nRunning main() continuously, at a high frame rate, is essential to the IMUI\ndesign philosophy where programmers manage the UI state. Running the function\ncontinuously naturally \"syncs\" the UI to the current UI state. Running main()\ncontinuously is also a natural fit for in-game UIs. You just render your UI\ninside the game loop!\n\nBut running the application function at a high frame rate is impractical for\nweb applications. In a web context, we want to re-run main() only when it's\nlikely that it would render a changed UI.\n\nUltimately, we want to know if a dependent state variable changed. As long as\nthe state remains unchanged, there is no reason to re-run main(). We would\nlike to track reads and writes to state variables, and re-run main() only when\na previously read state variable was written.\n\nIntercepting reads and writes to variables of which the framework is unaware\nis impossible, short of a precise static analysis and source to source\ntranslation that instruments all the reads and writes.\n\nInstead, we will break with the IMUI philosophy where users manage all the\nstate. We will borrow ideas from Signals (also see S.js and Preact Signals) to\ndesign a managed state data structure that intercepts reads and writes and re-\nrenders the UI only when previously read state is updated.\n\nBut first, we look at how IMUI frameworks already manage component state under\nthe hood.\n\n## IMUI Already Manages Component State\n\nWhile IMUI state management philosophy is to offload UI state management to\nthe user, this isn't entirely the case. The user manages the \"high level\"\ncomponent state that logically makes sense for users to be concerned with.\nLike the checked state of a checkbox or the selected value of a radio group.\n\nThe framework then manages the rest of the component state, that would be\ncumbersome and nonsensical for users to have to manage.\n\nOne example of such internal state, in game context, may be ephemeral\nanimations. When you click a button, the button may become visually\nhighlighted using a short animation. If the app runs at 60 frames per second,\nthe animation will need to play out across many frames. To properly render the\ncurrent state of the animation on each frame, the framework needs to know\nwhether that button is in \"clicked animation\" state, and how much time has\nelapsed since the click. It does this by managing component state internally.\n\n### Unique Component IDs for State Management\n\nA core characteristic of IMUI frameworks is that they require a unique\ncomponent ID for each UI component, that is stable across all UI re-renders.\nThey may require programmers to pass in these IDs manually to each component\nconstructor, or they may disburden programmers from this chore by performing\nvarious tricks to infer most IDs automatically.\n\nThe reason IMUI frameworks need these IDs is precisely because they manage\ncomponent state under the hood. They maintain a mapping from component ID to\ninternal component state.\n\n## Adding Reactive State\n\nWe've established that an IMUI framework has to manage component state, and\nIMUI frameworks employ various techniques for assigning unique, stable IDs to\neach UI component, in order to manage that state.\n\nHyperdiv embraces these existing architectural concepts and repurposes them\nfor a new state component that is user-facing, reactive, and managed. The\nattributes of this state component (we call them props) work similarly to\nSignals.\n\nThis is what using state looks like:\n\n    \n    \n    import hyperdiv as hd def main(): state = hd.state(count=0) hd.text(state.count) if hd.button(\"Increment\").clicked: state.count += 1 hd.run(main)\n\nIgnoring for now how button.clicked works, the state component works like\nthis:\n\n  * hd.state(count=0) creates a state component with a unique component ID. Internally, the framework maintains state like {\"<component_id>\": {\"count\": 0}}.\n\n  * When state.count is read by the line of code hd.text(state.count), a read dependency is registered on (\"<component_id>\", \"count\").\n\n  * When state.count is mutated in response to the click, that read dependency is invalidated and main() is scheduled to re-run.\n\nThe framework remembers all the read dependencies registered in the previous\nrun of the app function. The framework then listens for mutations, and re-runs\nthe app function only when a mutation invalidates an existing read dependency.\n\n### Similarity to Signals\n\nHyperdiv reactive props work like signals in the sense that reading them\nregisters a read dependency on an enclosing function call, and writing them\nmay cause a re-run of a dependent function call, if that function call\npreviously read that prop. Signals support other features that do not apply to\nHyperdiv.\n\n### Private State\n\nNotice that this design enables UI functions to naturally define local,\nprivate state:\n\n    \n    \n    def counter(): state = hd.state(count=0) hd.text(state.count) if hd.button(\"Increment\").clicked: state.count += 1 def main(): counter() counter()\n\nWe define a counter component with private count state. Then we can add\nmultiple counters to the app, each with private, independent state. This\nstands in contrast to vanilla IMUI, where we may have to manage multiple\nglobal count variables, one per counter.\n\n## Making UI Components Reactive\n\nIn the design outlined above, state components start to look very similar to\nIMUI UI components like buttons and checkboxes: They are components with\nunique IDs, and the framework tracks a component's state internally based on\nits unique ID.\n\nBased on this insight, we make all component state reactive. Instead of the\nuser managing most UI component state, like the checked state of a checkbox,\nand passing that state in and out of calls to checkbox(), the framework\nmanages that UI state in built-in reactive props.\n\nSo checked becomes a built-in reactive prop of checkbox:\n\n    \n    \n    def main(): checkbox = hd.checkbox(\"Check Me\") if checkbox.checked: hd.text(\"It is checked.\") else: hd.text(\"It is not checked.\")\n\nWhen this app runs, a read dependency is registered on the checkbox's checked\nprop. When a user of the UI toggles the checkbox, the checked prop is mutated,\ninvalidating the dependency and causingmain() to re-run, which outputs an\nupdated UI.\n\n### How button.clicked Works\n\nProps like button.clicked are reactive props just like checkbox.checked. When\nan app executes code like if button.clicked:, a read dependency is registered\non that prop. When the button is clicked, clicked is mutated to True, the read\ndependency is invalidated, and main() re-runs.\n\n\"Event props\" like clicked are special in that they are automatically reset by\nthe framework, back to their default value (False in the case of clicked), at\nthe end of the run in which they were True.\n\n### Everything is Reactive State\n\nAt this point, all components, whether a UI component like checkbox or a\ncustom state component like state, work virtually identically. They are\n\"groups of reactive props\". The core difference is that UI components are\nrendered in the UI whereas state components are ignored for rendering.\n\nHyperdiv exposes a single base class, which handles the defining, reading, and\nwriting logic of reactive props, and all components, including state, derive\nfrom that base class.\n\n## Reactive Props Enable Caching\n\nSince we are tracking read dependencies and write invalidations on all props,\nwe can now add a @cached decorator that, in addition to caching the return\nvalue of a call, it also caches the Hyperdiv UI (virtual DOM) generated by\nthat call, as well as the read dependencies recorded during that call.\n\nWhen main() re-runs, calls to @cached-decorated functions will re-run only\nwhen one of the internal read dependencies of that call is invalidated.\nOtherwise, the cached virtual DOM and return value are reused.\n\n    \n    \n    @hd.cached def counter(): state = hd.state(count=0) hd.text(state.count) if hd.button(\"Increment\").clicked: state.count += 1 def main(): counter() counter()\n\nIn this example, when we click one of the buttons, only the corresponding call\nto counter() re-runs. The other call to counter() reuses its cached DOM from\nthe previous run.\n\n## Summary\n\nImmediate-Mode UI provides an attractive, terse syntax for expressing UIs\ndeclaratively. It promotes a linear workflow for building UIs quickly with\nminimal plumbing and boilerplate.\n\nTraditionally, UI state is managed by the user of the framework in data\nstructures that are not visible to the framework. Changes to UI state are\npicked up by running the application function at a high frame rate.\n\nTo adapt the Immediate-Mode paradigm to the Web, Hyperdiv extends state-\nmanagement concepts already present in IMUI frameworks with signals-like\nreactive state.\n\nHyperdiv departs from the traditional IMUI philosophy to offload UI state\nmanagement to the user, gaining on-demand rendering in exchange.\n\n## Try it out\n\nInstall Hyperdiv and open the documentation app locally:\n\n    \n    \n    > pip install hyperdiv > hyperdiv docs\n\nHyperdiv requires Python 3.9+ and has been tested on macOS and Linux.\n\nStar on GitHub\n\n", "frontpage": false}
