{"aid": "39998524", "title": "Run-Time Polymorphism in Swift", "url": "https://belkadan.com/blog/2024/04/Run-time-Polymorphism-in-Swift/", "domain": "belkadan.com", "votes": 1, "user": "goranmoomin", "posted_at": "2024-04-11 04:57:47", "comments": 0, "source_title": "Run-time Polymorphism in Swift", "source_text": "Run-time Polymorphism in Swift // -dealloc\n\n# Technical\n\n\u00ab Online Communication\n\nXZ Gon' Give It To Ya \u00bb\n\n\u00ab GitMounter\n\n\u00ab Default Arguments and Label-based Overloading\n\n## Run-time Polymorphism in Swift\n\nThis has come up several times on the forums over the years, but I\u2019ve never\nwritten it up in a standard place, so here it is: There are only three ways to\nget run-time polymorphism in Swift. Well, three and a half.\n\nWhat do I mean by run-time polymorphism? I mean a function/method call (or\nvariable or subscript access) that will (potentially) run different code each\ntime the call happens. This is by contrast with many, even most other function\ncalls: when you call Array\u2019s append, it\u2019s always the same method that gets\ncalled.\n\nSo, what are the three, sorry, three and a half ways to get this behavior?\n\n  * Calling a function value (closure)\n  * Calling a class member\n  * Calling a protocol requirement\n  * Manually testing the type of a value\n\n### Calling a function value\n\nThis one\u2019s kind of obvious. If you\u2019re calling a callback, it can be anything\nthat matches the function type, depending on where it\u2019s coming from.\n\n### Calling a class member\n\nA non-final method on a non-final class may be overridden in subclasses, so\ncalling a class method does dynamic dispatch based on the run-time type of\nself. This is the most familiar, object-oriented notion of \u201cpolymorphism\u201d, and\nit\u2019s usually not surprising to people.\n\nNote that \u201cclass method\u201d is kind of ambiguous: this rule applies to instance\nmethods and type-level methods (and to properties, subscripts, and required\ninitializers). In a class, however, static is equivalent to class plus final,\nso in that case there won\u2019t be any dynamic dispatch.\n\nThere\u2019s actually one more place where class members are dynamically\ndispatched, and that\u2019s the very specific case of convenience initializers. The\ncall to self.init within a convenience initializer is dynamically dispatched,\nwhich is why convenience initializers are only inherited if you provide all\nthe non-convenience initializers of your superclass. This is a pattern from\nObjective-C turned language feature in Swift, and yeah, maybe it\u2019s more\ncomplexity than we really needed.\n\n### Calling a protocol requirement\n\nThis one\u2019s also not too surprising; after all, the whole point of protocols is\nthat they provide a common API implemented by concrete types. What might be\nsurprising is that members added in extensions to the protocol do not get to\nparticipate in this behavior. If you think about it, though, supporting that\nwould mean that at run time the program would have to look at all the possible\nmethods a concrete type has and see if any of them match this extension\nmethod. If more than one matched, the runtime system would have to perform\noverload resolution. And what if that comes out ambiguous? So no, extension\nmethods are either chosen directly at compile time, or passed over directly at\ncompile time; whether they get called is entirely determined by static type\ninformation, not run-time polymorphism.\n\n### Manually testing the type of a value\n\nThis doesn\u2019t really count, but it\u2019s here because sometimes it really is the\nbest answer to a problem. Swift does not provide perfect parametricity; you\ncan attempt to downcast/convert to a more specific type whenever you want with\nis and as? expressions, or with is and as patterns:\n\n    \n    \n    if firstPet is Cat, let secondPet = secondPet as? Dog { /* ... */ }\n    \n    \n    switch thirdPet { case is Cat: /* ... */ case let thirdPet as Dog: /* ... */ default: break }\n\nWhether or not this is a good idea is partly a matter of tradeoffs and partly\nof taste, but Swift does allow it.\n\n### Aside: What about generics?\n\nGenerics are a powerful and flexible tool, but in general they don\u2019t result in\nany more run-time polymorphism than any types (formerly \u201cprotocol composition\ntypes\u201d). This often throws people who are used to C++ templates, where\noverload resolution is done on the concrete type that satisfies the generic\nconstraints rather than on the generic type. Swift didn\u2019t choose that option\nfor two main reasons: it makes it much harder to diagnose issues at compile\ntime, and it means that the entire body of the generic has to be visible to\ncallers (so they can substitute in the concrete type). This is good for\noptimization, but bad for library evolution. You can think of Swift\u2019s model as\n\u201cthe decision of which overload to call is made based on the knowledge where\nthe call is written, which in this case is inside a generic function with\ncertain constraints\u201d.\n\nI don\u2019t know of any other modern languages that have templates like C++, but\nthere\u2019s still a choice between monomorphization, i.e. generating a separate\ncopy of the code for every concrete type, and polymorphic generics, where a\nsingle copy of the code uses dynamic dispatch to work on many different\ntypes.^1 Different languages take different approaches to this:\n\nLanguage| Generics are...| Generic types are...| Overloads are resolved...  \n---|---|---|---  \nC++| monomorphized| expanded into concrete types| on the concrete types (hence\n\u201ctemplate\u201d)  \nRust| monomorphized| expanded into concrete types| based on constraints  \nSwift| polymorphic| expanded into concrete types (but sometimes indirected)|\nbased on constraints  \nJava| polymorphic| \u201cerased\u201d to their constraints| based on constraints  \nObjective\u2010C| polymorphic| \u201cerased\u201d to their constraints| what\u2019s an overload^2  \n  \nThere is now a way to get C++-like behavior in Swift (and Rust): macros. But\nSwift\u2019s macros are entirely syntactic and have to be invoked explicitly, so\nthey don\u2019t naturally lend themselves to C++ template-style usage, at least not\ntoday. So sometimes instead this is where the \u201c3.5\u201d solution comes into play:\na dynamic cast inside the body of a generic method acts as a form of\n\u201cspecialization\u201d, even though it does have a checking cost at run time.\n\n### Takeaways\n\nSo let me re-iterate: the three-and-a-half features listed at the top are the\nonly forms of run-time polymorphism in Swift. Now when someone asks \u201chow can I\nallow arbitrary different argument types to result in different behavior\u201d, you\nknow the answer: make a protocol. (Or piggyback on a base class, if they\u2019re\nalready classes in a hierarchy you own.) When someone asks \u201cwhy didn\u2019t this\nmethod call pick the more specialized overload\u201d, you know the answer: generics\naren\u2019t templates, overload resolution happens based on the generic constraints\nalone, and they may want to make a protocol. And when someone asks \u201chey, how\ndo I make my protocol extension methods overridable?\u201d, you know the answer:\nyou have to make another protocol (and possibly downcast to it from the\noriginal type).\n\n...Look, the tagline \u201cprotocol-oriented programming\u201d may be a bit of a\nbuzzword, but we weren\u2019t kidding! Protocols are your tool for run-time\npolymorphism, and polymorphism in general, that works on value types. Use\nthem!\n\n  1. Optimizations blur these distinctions. C++ or Rust code may generate many copies of the same function, but then optimize them back into one function if they have the same behavior at the machine code level, or at least outline the common parts of the function to save on code size. Like inlining, this is something that\u2019s often based on heuristics and other settings, and is still an area of active development (or at least was a few years ago). Conversely, while Swift formally uses a single definition for every version of a generic function, it sometimes specializes them for particular concrete types to increase performance at the cost of code size. \u21a9\ufe0e\n\n  2. I joke, but actually Objective-C does care about doing some type-checking on method calls for generics, to get the right calling convention. You just can\u2019t call a method that\u2019s declared to return float in one place and id in another, and so the compiler will complain if you try to call a method that\u2019s not in the parameter\u2019s constraints at all.\n\nI also snuck in Rust overloads. Rust does have overloading, even though it\npretends not to: separate traits can declare methods with the same name, and a\ncaller is required to disambiguate between them manually if both traits are\nvalid. \u21a9\ufe0e\n\nThis entry was posted on April 06, 2024 and is filed under Technical. Tags:\nSwift, Programming languages\n\nCopyright \u00a9 2007-2024 Jordan Rose -dealloc is powered by Jekyll/Shadowbox\n\n", "frontpage": false}
