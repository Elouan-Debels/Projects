{"aid": "39989181", "title": "Show HN: Catena \u2013 Simplify Express handlers with tRPC-like syntax", "url": "https://github.com/sonic-technology/catena", "domain": "github.com/sonic-technology", "votes": 3, "user": "eykrehbein", "posted_at": "2024-04-10 10:42:06", "comments": 0, "source_title": "GitHub - sonic-technology/catena: Build type-safe APIs with ease", "source_text": "GitHub - sonic-technology/catena: Build type-safe APIs with ease\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nsonic-technology / catena Public\n\n  * Notifications\n  * Fork 0\n  * Star 9\n\nBuild type-safe APIs with ease\n\n### License\n\nMIT license\n\n9 stars 0 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# sonic-technology/catena\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n2 Branches\n\n4 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\neykrehbeinMerge pull request #5 from sonic-\ntechnology/dependabot/npm_and_yarn/t...7267b09 \u00b7\n\n## History\n\n49 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| fix: pnpm git issue  \n  \n### .vscode\n\n|\n\n### .vscode\n\n| initial commit  \n  \n### docs/assets\n\n|\n\n### docs/assets\n\n| add demo  \n  \n### src\n\n|\n\n### src\n\n| adjust type to match zod type  \n  \n### tests\n\n|\n\n### tests\n\n| add test for transformer  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| github workflow for publishing  \n  \n### .npmignore\n\n|\n\n### .npmignore\n\n| update .npmignore to exclude src and examples  \n  \n### .prettierrc\n\n|\n\n### .prettierrc\n\n| initial commit  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| add LICENSE  \n  \n### README.md\n\n|\n\n### README.md\n\n| chore: adjust README  \n  \n### jest.config.js\n\n|\n\n### jest.config.js\n\n| initial commit  \n  \n### package.json\n\n|\n\n### package.json\n\n| chore: add repository to package.json  \n  \n### pnpm-lock.yaml\n\n|\n\n### pnpm-lock.yaml\n\n| build(deps-dev): bump typescript from 5.3.3 to 5.4.4  \n  \n### tsconfig.json\n\n|\n\n### tsconfig.json\n\n| initial commit  \n  \n## Repository files navigation\n\n#### A library for building type-safe Node.js APIs\n\nInstallation \u2022 Examples \u2022 Documentation\n\n# Build type-safe APIs\n\nCatena is an lightweight library for building end-to-end type-safe APIs on top\nof Express. It's inspired by tRPC but unlike tRPC, you can just plug it into\nyour existing Express codebase. The main goal is to have a unified chain of\nuseful steps to safely handle requests with a great DX and minimal overhead.\n\nA demo of type sharing between route handler (backend) and frontend, inspired\nby tRPC.\n\n# Installation\n\n  1. Install Catena and its peer dependencies\n\n    \n    \n    npm i @sonic-tech/catena zod express\n\n  2. Also make sure that you have Express' types installed, if you want to leverage the full type-safeness.\n\n    \n    \n    npm i -D @types/express\n\n# Documentation\n\n  * Examples\n  * Setting up Catena with Express\n  * Core Concepts\n\n    * Chaining\n\n      * Validators\n      * Middlewares\n      * Resolver\n      * Transformer\n    * Type-sharing across codebases\n    * File-based Routing\n\n# Examples\n\n## A simple handler\n\nThe first example is as simple as it gets. Looks like a normal express handler\nand also does the same.\n\n    \n    \n    // ... import { Handler } from '@sonic-tech/catena' const app = express() app.use(express.json()) app.get( '/', new Handler() .resolve((req, res) => { res.status(200).send('Hello World') }) // Make sure that `.express()` always is the last method in the handler chain. It converts the logical chain into an express handler. .express() )\n\n## Validating requests\n\nThere are many occasions where you want to validate parts of the incoming\ndata. Here's how Catena does it.\n\n    \n    \n    // ... import { Handler } from '@sonic-tech/catena' const app = express() app.use(express.json()); app.post( '/user/:uuid', new Handler(). .validate(\"params\", { uuid: z.string().uuid() }) .validate(\"body\", { username: z.string().optional(), age: z.number().min(13).optional(), email: z.string().email(), }) .resolve(async (req, res) => { // All 4 properties are strongly typed based on the zod schemas const { uuid } = req.params const { username, age, email } = req.body // ... res.status(200).send(\"User created!\") }) .express() )\n\n## Transformers\n\nIf you want to have a secure and unified way of returning data to the client,\nuse transformers. Transformers let you create and send JSON DTOs based on the\ndata that the resolver returned.\n\nThis is the recommended way of returning data to the client.\n\n    \n    \n    // ... import { Handler } from '@sonic-tech/catena' const app = express() app.use(express.json()); app.get( '/user/:uuid', new Handler(). .validate(\"params\", { uuid: z.string().uuid() }) .resolve(async (req, res) => { const userIncludingPassword = await UserService.getUser(req.uuid) return userIncludingPassword }) .transform((data) => { return { data: { uuid: data.uuid, email: data.email } } }) .express() )\n\n## Middlewares\n\nCatena extends middlewares by establishing a shared context that can be passed\nfrom one middleware to another and finally to the resolver. You can write\ninline middlewares or just pass in a function.\n\n    \n    \n    // ... import { Handler, HTTPError } from '@sonic-tech/catena' import { AnotherMiddleware } from \"...\" const app = express() app.use(express.json()); app.get( '/user/:uuid', new Handler(). .validate(\"params\", { uuid: z.string().uuid() }) .validate(\"headers\", { // key in header validations must always be lower-case! authorization: z.string() }) .middleware((req) => {j const requestingUser = await SecurityService.getAuthorizedUser(req.headers.authorization); if (!requestingUser) { // Throw errors when you want to stop further request processing while returning an error at the same time throw new HTTPError(400, 'This should fail') } return { requestingUser } }) .middleware(AnotherMiddleware) .resolve(async (req, res, context) => { // You can access the merged type-safe context of all middlewares in the resolver const { requestingUser } = context const userIncludingPassword = await UserService.getUser(req.uuid) return userIncludingPassword }) .transform((data) => { return { data: { uuid: data.uuid, email: data.email } } }) .express() )\n\n## Setting up Catena + Express\n\nCatena currently supports Express; work is underway to support Next.js.\n\nTo setup Catena with Express make sure to do the following:\n\n  * Install express and @types/express using yarn/npm/pnpm/bun\n  * Suffix all Catena handlers with .express() (!). This function will transform the Catena chain into an Express request handler. Without appending this method, you're going to get a type-error and the handler will not work.\n\nAlso, you have to use the express.json() (or body-parser) middleware in order\nfor the validators to work with JSON content.\n\n    \n    \n    const app = express() app.use(express.json())\n\n## Core Concepts\n\n## Chaining\n\nCatena features a handler that is assembled as a chain out of the following\nelements. Only the resolve element is required, all other elements are\noptional.\n\n  * validate: Chain zod-powered validators for body, params, query and headers that only allow requests that match the zod schema\n  * middleware: Middlewares can return values into a shared \"context\", which is type-safe and accessible to all following chain elements. To block further request processing, e.g. because the requesting entity is not authorized, throw HTTPError\n  * resolve: The resolver should be used to handle all business logic, like a normal express handler would do. It either returns data that is passed to the transformer or may use the res object to send a response without a transformer\n  * transform: The transformer can be used to generate a DTO that can be send as response body by just returning it\n\nThe elements in this chain are processed one after the other. So if a\nmiddleware is executed after a validator, you can be sure that the validation\nhas been passed. If there are multiple chained middlewares, you always access\nthe context of all previous middlewares in the following middlewares.\n\nAll Catena chain elements are bundled into one actual Express handler with the\n.express() method at the end of the chain. Internally, we are not calling\nExpress' next() until all chain elements have completed or there has been an\nuncaught error. If there is an uncaught error, that is not HTTPError, we are\ncalling next(err). You may then handle errors on router level or append\nanother middleware.\n\n## Validators\n\nValidators are virtual middlewares that validate the given request data using\nzod. You can create validators for body, params, query and headers. Objects\nvalidated by validators are type guarded for all following middlewares and the\nresolver.\n\n### Method Signature\n\n.validate(type: \"body\" | \"params\" | \"query\" | \"headers\", zodObject: object | z.object)\n\nThe second parameter can either be a z.object() or just a normal object that\ncontains keys with zod validations as values. So both of the following usages\nare valid:\n\n    \n    \n    new Handler().validate('body', { email: z.string().email(), }) // .resolve ...\n    \n    \n    new Handler().validate( 'body', z.object({ email: z.string().email(), }) // .resolve ... )\n\nUsing just an object is more readable, while using z.object has the advantage\nof being able to infer the validator type and use it e.g. in services as\nargument type. Example:\n\n    \n    \n    const bodyValidation = z.object({ email: z.string().email(), }) new Handler().validate('body', bodyValidation) //.resolve ... const myServiceMethod = (body: z.infer<typeof bodyValidation>) => { // ... }\n\n### Caveats\n\n  * For headers validations, always use lower-case only keys! Authorization: z.string() --> authorization: z.string(). The reason for this is that Express converts all headers to lower case to comply with the RFC for HTTP requests, which states that header keys are case-insensitive.\n\n## Middlewares\n\nMiddlewares are functions that you can connect prior to the resolver in order\nto add custom logic such as authorization, non-trivial validation, etc. before\nthe resolver is executed.\n\n### Middleware method signature\n\n    \n    \n    .middleware(req: RequestWithValidations, res: Response, next: NextFunction, context: MiddlewareContext)\n\n  * req extends the default express object with the type-safe inference made by the validators on body, params, query and headers.\n  * res is the default Express Response object\n  * next is the default Express NextFunction\n  * context is a simple object that is empty at the beginning of the first middleware in the chain. It can be filled with any values by the middlewares and passed to other middlewares and the resolver, see below\n\n### Catena Middlewares\n\nCatena exposes a more straightforward way to write middlewares, while also\nsupporting all existing middlewares.\n\n#### Context\n\nInstead of overwriting or extending some parts of the req object to pass along\ncontext, you can just return an object. This object will be merged with the\nexisting context object and will be accessible to all following middlewares\nand the resolver (type-safe, of course).\n\n    \n    \n    import { Handler, HTTPError } from '@sonic-tech/catena' new Handler() .validate('params', { uuid: z.string().uuid(), }) .middleware(async (req) => { const user = await UserService.getUser(req.params.uuid) // -> { email: \"...\", uuid: \"...\" } return { user, } }) .middleware(async (req, res, next, context) => { // email and uuid can be extracted from the context type-safely const { email, uuid } = context.user if (!email.endsWith('@mycompany.com')) { throw new HTTPError(403, 'Company not allowed') } const organization = await OrganizationService().getByUser(uuid) return { organization, } }) .resolve(async (req, res, context) => { /** * The resolver has access to both user and organization * since the context objects have been merged */ const { user, organization } = context // ... }) .express()\n\nA middleware does not need to return anything. If it returns void, the context\nobjects stays as is.\n\nSending something to the client using res.send causes the chain to stop, i.e.\nthe next chain element is not executed.\n\n#### Errors\n\nInstead of using res.send to send error messages, you can import HTTPError\nfrom Catena and use throw new HTTPError(statusCode, errorMessage) which will\nautomatically resolve the request using the given status code and a\nstandardized error message. An example can be seen in the code snippet of the\nlast section.\n\n### Existing Middlewares\n\nYou can also use any middleware that works with express out of the box using\nthe default (req, res, next) syntax.\n\n    \n    \n    import { MySecondMiddleware } from \"../middlewares\" const MyExistingMiddleware = (req, res, next) => { if(!req.body.continue) { res.status(400).send(\"Bad Request\") return } next() } new Handler() .middleware(MyExistingMiddleware) .middleware(MySecondMiddleware) .resolve(...) .transform(...) .express()\n\n## Resolver\n\nThe resolver may be used as the core handler of the request, just as you used\nthe handler function before.\n\n### Method Signature\n\n    \n    \n    .resolve((req: RequestWithValidations, res: Response, context: MiddlewareContext) => any | Promise<any>)\n\n  * The req is the default Express request object, except that req.body, req.params, req.query and req.headers are typed by the infered zod validations from the validators\n  * The res object is the default Express response object\n  * The context object is the merged Context you passed along the middlewares\n\n### Context\n\nAs with middlewares, you can access the merged context of all previous\nmiddlewares (= all middlewares) through the context object.\n\n### Return Values\n\nYou can use res to send responses directly to the client without a\ntransformer.\n\nHowever, it is recommended to return values instead. Those values are then\npassed to the Transformer instead of being sent to the client directly.\n\n    \n    \n    new Handler() .middleware(() => { return { user: { uuid: '...', }, } }) .resolve((req, res, context) => { const { user } = context const subscription = await UserService.getUserSubscription(user.uuid) // Just pass the data to the transformer instead of using res.send. return subscription }) .transform((data) => { // data has the type of \"subscription\" return { userSubscriptionUuid: data.uuid, } }) .express()\n\n## Transformer\n\nTransformers can be used to create sanitized data transfer objects based on\nthe resolved data. This enables your resolver to just handle the business\nlogic, independent of what single values should or should not be returned to\nthe client.\n\nFor example, the resolver might get a user object from the database for a\ngiven query. Of course you don't want to return the user's password to the\nclient. To keep things clean, just pass the user object from the resolver\n(which shouldn't have to care about sanitizing values) to the transformer,\nwhich then takes the given object and only returns values that are appropriate\nto be returned.\n\nExample\n\n    \n    \n    new Handler() .validate('params', { uuid: z.string().uuid(), }) .resolve(async (req) => { const { uuid } = req.params // This object contains confidential information, like a password const user = await UserService.getUser(uuid) return user }) .transform((data) => { return { uuid: data.uuid, email: data.email, // leave out the password, since we don't want to send it to the client } }) .express()\n\nYou may return any value. If you choose to return an object or array, they are\nsend with res.json(). All other return values are send with res.send().\n\nIf you want to use a different status code, set headers, cookie, etc. you can\nuse e.g. res.status(201) before the return statement. We'll use this res\nobject for sending the response internally\n\n## Type-sharing across codebases\n\nRequest and response types of API handlers can be inferred and exported. You\ncan use this to share your types e.g. with the frontend, like tRPC does.\n\nEach handler exposes a types interface that contains request and response\ntypes.\n\nThe request type contains the expected types for body, query, params and\nheaders.\n\nThe response type represents the type of the value that is returned by the\ntransformer.\n\n### Example\n\nBackend\n\n    \n    \n    const myRequestHandler = new Handler() .validate(\"body\", { email: z.string().email() }) .resolve(...) .transform((data) => { return { data: { uuid: data.uuid, email: data.email, age: data.age } } }) .express() app.get(\"/user\", myRequestHandler); export type GetUserTypes = typeof myRequestHandler.types;\n\nFrontend\n\n    \n    \n    // It's important to only import using `import type`. This way, no business logic will be leaked to the frontend but just the type import type { GetUserTypes } from 'backend/handler' /** * Body type inferred as * { * email: string * } */ const body: GetUserTypes['request']['body'] = { email: 'test@test.com', } const myRequestResponse = await fetch('/user', { body: JSON.stringify(body), }) /** * Type inferred as * { * data: { * uuid: string; * email: string; * age: number; * } */ const responseData: GetUserTypes['response'] = await myRequestResponse.json()\n\n## File-based Routing\n\nWe found express-file-routing to be a great addition to projects that use\nCatena, if you like file-based routing.\n\nAn example of Catena + file-based routing:\n\n    \n    \n    // /users/[uuid].ts export const POST = new Handler() .validate('params', { uuid: z.string().uuid(), }) .validate('body', { email: z.string().email().optional(), firstName: z.string().optional(), lastName: z.string().optional(), }) .resolve((req) => { const updatedUser = new UserService.updateUser(req.params.uuid) return updatedUser }) .transform((user) => { return { uuid: user.uuid, email: user.email, name: user.firstName + ' ' + user.lastName, } }) .express()\n\n## About\n\nBuild type-safe APIs with ease\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\nCustom properties\n\n### Stars\n\n9 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases 4\n\nv0.1.4 Latest\n\nMar 12, 2024\n\n\\+ 3 releases\n\n## Packages 0\n\nNo packages published\n\n## Contributors 3\n\n  * eykrehbein Eyk Rehbein\n  * Mucky Magnus Langanke\n  * dependabot[bot]\n\n## Languages\n\n  * TypeScript 98.7%\n  * JavaScript 1.3%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
