{"aid": "40053227", "title": "Failures, Mistakes, Confusion", "url": "https://blog.ignaskiela.eu/failures-mistakes-confusion.html", "domain": "ignaskiela.eu", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-16 15:25:48", "comments": 0, "source_title": "Failures, Mistakes, Confusion", "source_text": "Failures, Mistakes, Confusion\n\n# Failures, mistakes and confusion\n\nI feel like there's quite a bit of confusion online in discussions of\ndifferent \"error handling models\" in programming, and I think that it's\nprobably because basically every \"error handling model\" in programming\nlanguages I've seen conflates two (or more!) separate concepts into a single\nsystem.\n\n## Failures\n\nFailures happen when the system fails to perform some action, usually due to\nsome constraint. Constraints could be physical (limited memory size), security\n(authentication), business (quotas), etc. Failures (almost always) cannot be\nproven to never happen in some code. They are usually explicitly communicated.\nThey can often be worked around/fixed without human intervention. You usually\nhandle them by either trying to work around and/or fixing the source issue of\nthe failure, or communicating a failure yourself, depending on context and\nphilosophy (fail-fast, etc).\n\n## Mistakes\n\nMistakes are faults in the code that break invariants, both explicit and\nimplicit. Invariants are usually expressible with (some type of) logic. Large\nclasses of mistakes can be proven to never happen in some code. They may be\nexplicitly communicated when an invariant check fails, but sometimes it may\nresult in an immediate effect without communication. It's usually undesirable\nto work around mistakes in code, and the largely preferred solution is to stop\nexecution in a safe manner, stopping the propagation of the invariant\nbreakage.\n\n## Confusion\n\nBoth failures and mistakes are usually mashed together into errors - except in\nstatic analysis, where essentially only mistakes can show up. They are\npredominantly communicated via the same channels. And in fact, a lot of\ninvariant checking happens at the same time as checking for failures! EINVAL\nis the kernel saying \"hey, I think you have a mistake\" after it checked some\ninvariants before doing an operation, and those invariants have been broken.\nThe next step for the kernel after checking invariants would be trying to\ncheck some constraints to see if the operation can be performed, and if any of\nthe constraints are not satisfied that would indicate failure. Invariant\nchecking is done in the same place as checking for constraints. As such,\nmistakes detected in such way are communicated in the same way as failures.\nIncluding the ones you may want to handle, like a disk being filled up or the\nsystem having lost internet connection.\n\nMistakes and failures have very different properties in what they mean and how\nyou want to handle them, and yet they are treated as if it's a singular\nconcept of an error. I don't think they should live in a single system\n\n## Conclusion\n\nThere may be a benefit in separating these out more. But I don't have any\nsolutions, I just wanted to bring this up in hopes that others see this and\nstart thinking about it.\n\n", "frontpage": false}
