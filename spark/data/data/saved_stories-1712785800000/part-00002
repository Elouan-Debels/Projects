{"aid": "39992058", "title": "How I Write Tests in Go", "url": "https://blog.verygoodsoftwarenotvirus.ru/posts/testing-in-go/", "domain": "verygoodsoftwarenotvirus.ru", "votes": 6, "user": "badrequest", "posted_at": "2024-04-10 15:49:29", "comments": 0, "source_title": "How I write tests in Go", "source_text": "How I write tests in Go :: Very Good Software, Not Virus\n\nTerminal\n\n# How I write tests in Go\n\n2024-04-03 [Updated: 2024-04-03] :: verygoodsoftwarenotvirus :: 14 min read\n(2782 words)\n\n# How I write unit tests in Go\u2317\n\nOne of my favorite features of Go is that unlike many popular languages, it\ncomes with it\u2019s own testing framework, the testing package. Let\u2019s say we have\nthis trivial function in a file called numbers.go:\n\n    \n    \n    package numbers func addNumbers(numbers ...int) int { sum := 0 for _, number := range numbers { sum += number } return sum }\n\nThe idiomatic way to test this function is to create a second file called\nnumbers_test.go and test it using the aforementioned testing package:\n\n    \n    \n    package numbers import ( \"testing\" ) func Test_addNumbers(t *testing.T) { if addNumbers(3, 7) != 10 { t.FailNow() } }\n\nThen I can run go test and see the output of the test:\n\n    \n    \n    ok github.com/example/package/numbers\n\nAlternatively, if the test fails (i.e. if I expect the result to be 11\ninstead), I get an appropriate error report:\n\n    \n    \n    --- FAIL: Test_addNumbers (0.00s) FAIL FAIL github.com/example/package/numbers 0.255s FAIL\n\nThis works pretty well, overall. When I need to find the tests for a given\nfile, I can usually assume they\u2019re in its corresponding _test.go file. The\ntesting framework is built into the standard library, and does exactly what\nyou\u2019d expect with this code.\n\n### We have the technology\u2317\n\nThis isn\u2019t how I actually like to write Go unit tests, however. There are\ntechniques and libraries I use to make unit testing in Go more effective to\nwrite and understand when things go (heh) awry.\n\n### The test command\u2317\n\nYou can run go test in a given directory and see the output of your test, but\nthat leaves a lot of functionality on the table that can and will be useful.\nThe full command I typically use is:\n\ngo test -cover -shuffle=on -race -vet=all -failfast <$RELEVANT_PACKAGE(S)>\n\nHere\u2019s what each of these flags do:\n\n  * -cover instructs the test runner to determine coverage for a given package.\n  * -shuffle=on runs the tests in a random order, instead of in declared order.\n  * -race activates the data race detector.\n  * -vet=all \u201cruns go vet on the package and its test source files to identify significant problems. If go vet finds any problems, go test reports those and does not run the test binary.\u201d\n  * -failfast stops test execution when a given unit test fails. It allows tests executed in parallel (more on that in a bit) to finish.\n\n### Table-driven tests\u2317\n\nI\u2019m going to say something sort of controversial in the Go zeitgeist: I find\ntable tests very rarely useful. For something like our addNumbers function, I\nmight actually do it, because the inputs and outputs are simple. Here\u2019s what\nthat might look like:\n\n    \n    \n    package numbers import ( \"testing\" ) type addNumbersTestCase struct { inputs []int expectedOutput int } func Test_addNumbers_table(t *testing.T) { testCases := []addNumbersTestCase{ { inputs: []int{4, 4}, expectedOutput: 8, }, { inputs: []int{10, 0}, expectedOutput: 10, }, { inputs: []int{-1, 1}, expectedOutput: 0, }, } for _, testCase := range testCases { actual := addNumbers(testCase.inputs...) if testCase.expectedOutput != actual { t.FailNow() } } }\n\nThat said, it\u2019s pretty easy to end up in a situation where your table tests\nneed to be quite complicated and gnarly to get full coverage.\n\nGoland lets you generate tests for functions using a default template that\nattempts to adhere to the tradition of table-driven tests. Here\u2019s what the\ngenerated test function looks like for a method in a side project. This method\nfetches a webhook object from the database, and accepts 3 total parameters \u2014 a\ncontext, a webhook ID, and an accountID:\n\n    \n    \n    package whatever func TestQuerier_GetWebhook(t *testing.T) { type fields struct { tracer tracing.Tracer logger logging.Logger secretGenerator random.Generator oauth2ClientTokenEncDec encryption.EncryptorDecryptor generatedQuerier generated.Querier timeFunc func() time.Time config *dbconfig.Config db *sql.DB migrateOnce sync.Once } type args struct { ctx context.Context webhookID string accountID string } tests := []struct { name string fields fields args args want *types.Webhook wantErr assert.ErrorAssertionFunc }{ // TODO: Add test cases. } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { q := &Querier{ tracer: tt.fields.tracer, logger: tt.fields.logger, secretGenerator: tt.fields.secretGenerator, oauth2ClientTokenEncDec: tt.fields.oauth2ClientTokenEncDec, generatedQuerier: tt.fields.generatedQuerier, timeFunc: tt.fields.timeFunc, config: tt.fields.config, db: tt.fields.db, migrateOnce: tt.fields.migrateOnce, } got, err := q.GetWebhook(tt.args.ctx, tt.args.webhookID, tt.args.accountID) if !tt.wantErr(t, err, fmt.Sprintf(\"GetWebhook(%v, %v, %v)\", tt.args.ctx, tt.args.webhookID, tt.args.accountID)) { return } assert.Equalf(t, tt.want, got, \"GetWebhook(%v, %v, %v)\", tt.args.ctx, tt.args.webhookID, tt.args.accountID) }) } }\n\nI think this is kind of a mess, and it doesn\u2019t even include test cases yet.\nI\u2019d rather have the querier built by an only-available-to-tests constructor\nthat puts sensible defaults for all these values.\n\nThe point of this is not to dunk on Goland (I am a happily paying customer and\nhave been for many years), it\u2019s just to illustrate how even a non-trivial\nfunction can really blow up the readability of a table-driven test.\n\n### Parallel\u2317\n\nGo tests can be run in parallel, by declaring the test as parallel in the top\nlevel. This behavior is on by default, and can only be disabled by setting the\n-parallel=1 flag when invoking go test (which can be useful when debugging\nflaky tests).\n\nI\u2019m of the opinion that tests should be parallel unless they absolutely cannot\nbe, and even then, I\u2019d rather fix the flaw behind why they can\u2019t be run in\nparallel than force them to be run sequentially.\n\nRunning your tests in parallel generally allows you to suss out concurrency\nbugs earlier, even if you\u2019re not using the race detector (which you should),\nand will eventually lead to you developing concurrency-safe habits when\nwriting code in the first place. So generally, when I write a test, the very\nfirst line is the parallel declaration:\n\n    \n    \n    package numbers import ( \"testing\" ) func Test_addNumbers(t *testing.T) { t.Parallel() expected := 10 actual := addNumbers(3, 7) if expected != actual { t.FailNow() } }\n\n### Subtests\u2317\n\nSubtests are a feature of Go\u2019s testing library that allow you to have smaller\ntests for specific circumstances. These allow you to get some of the benefits\nof a behavior-driven testing style, without having to invoke an external\ndependency. I usually write subtests even when there\u2019s only one test case I\ncare about, because it incurs no real overhead to do so, and allows you to\neasily test a new case in the event the tested function gets more complex.\n\nWhen I write subtests, I usually name the top-level *testing.T object a\ncapitalized T, and use the conventional lower-cased t for subtests only. This\nway, the subtest logic always looks like an idiomatic Go test, and there\u2019s no\nconfusion of what variable is which or what shadows what. Calls to .Parallel()\nwill have to be made for both the big and little *T variables.\n\nHere\u2019s a demonstration that adapts our earlier example for the addNumbers\nfunction:\n\n    \n    \n    package numbers import ( \"testing\" ) func Test_addNumbers(T *testing.T) { T.Parallel() T.Run(\"standard\", func(t *testing.T) { t.Parallel() expected := 10 actual := addNumbers(3, 7) if expected != actual { t.FailNow() } }) }\n\nNow if I decide to add another test case, it\u2019s simply a matter of copying the\nsubtest block, changing the name, and then making the test match that\ndescription:\n\n    \n    \n    package numbers import ( \"testing\" ) func Test_addNumbers(T *testing.T) { T.Parallel() T.Run(\"standard\", func(t *testing.T) { t.Parallel() expected := 10 actual := addNumbers(3, 7) if expected != actual { t.FailNow() } }) T.Run(\"with many numbers\", func(t *testing.T) { t.Parallel() expected := 15 actual := addNumbers(1, 2, 3, 4, 5) if expected != actual { t.FailNow() } }) T.Run(\"with negative numbers\", func(t *testing.T) { t.Parallel() expected := 3 actual := addNumbers(4, -1) if expected != actual { t.FailNow() } }) }\n\nAdditionally, if there are test fixtures or constants that are relevant to all\nsubtests, they can live in the space between the big-T call to .Parallel() and\nthe first declared subtest.\n\n### Libraries\u2317\n\nWhile the standard library testing package is pretty great, there have been\nsome great contributions by the community to the ecosystem that make testing\nin Go even better.\n\n### Fake Values\u2317\n\nTypically, when I need to interact with an object in a test, I want to have\nunpredictable values to the extent possible for that object, so that I\u2019m\ndiscouraged from relying on those conventions when writing tests.\n\nSo for instance, if I need a *User object for a test, I want to have no idea\nwhat it\u2019s username might be, as opposed to a common static value that I might\ncopy/paste from place to place, which would make many tests fail if it was\ninadvertently changed.\n\nI like to use brianvoe/gofakeit for this. It comes with a ton of sensible\nfunctions with which to build fake instances of different types, and I\u2019ve\nnever had a problem with it. Here\u2019s what that fake user builder might look\nlike:\n\n    \n    \n    package whatever import ( \"github.com/example/project/internal/authorization\" \"github.com/example/project/internal/pkg/pointer\" \"github.com/example/project/pkg/types\" fake \"github.com/brianvoe/gofakeit/v7\" ) func buildFakeTime() time.Time { return fake.Date().Add(0).Truncate(time.Second).UTC() } func BuildFakeUser() *types.User { fakeDate := buildFakeTime() return &types.User{ ID: identifiers.New(), FirstName: fake.FirstName(), LastName: fake.LastName(), EmailAddress: fake.Email(), Username: fmt.Sprintf(\"%s_%d_%s\", fake.Username(), fake.Uint8(), fake.Username()), Birthday: pointer.To(buildFakeTime()), AccountStatus: string(types.UnverifiedHouseholdStatus), TwoFactorSecret: base32.StdEncoding.EncodeToString([]byte(fake.Password(false, true, true, false, false, 32))), TwoFactorSecretVerifiedAt: &fakeDate, ServiceRole: authorization.ServiceUserRole.String(), CreatedAt: buildFakeTime(), } }\n\n### Testify\u2317\n\nI\u2019m a huge fan of the (assert|require|mock) libraries in testify. In our\nexample test, using testify would look like:\n\n    \n    \n    package numbers import ( \"testing\" \"github.com/stretchr/testify/assert\" ) func Test_addNumbers(T *testing.T) { T.Parallel() T.Run(\"standard\", func(t *testing.T) { t.Parallel() expected := 10 actual := addNumbers(3, 7) assert.Equal(t, expected, actual) }) }\n\nI think assert.Equal is fairly obvious in its function for users who are new\nto a code base. testify is probably the only library I can think of that I\nwould wholeheartedly support being absorbed into the standard library.\n\nYou can use require instead if you want the test to stop in the event of a\nfailure. This is usually good for dependencies of a test, i.e. if I need to\ncreate a file and pass it to a function, I should probably require that no\nerrors happen when creating it:\n\n    \n    \n    package whatever import ( \"os\" \"testing\" \"github.com/stretchr/testify/require\" ) func TestSomeFunction(T *testing.T) { T.Parallel() T.Run(\"standard\", func(t *testing.T) { t.Parallel() f, err := os.Create(\"some_path.txt\") require.NoError(t, err) require.NotNil(t, f) }) }\n\nmock is also useful for defining mock implementations of structures. Say I\nhave the following interface:\n\n    \n    \n    package something type UserRetriever interface { GetUser(ctx context.Context, userID string) (*User, error) }\n\nImplementing a mock for this interface becomes a matter of:\n\n    \n    \n    package something import ( \"github.com/stretchr/testify/mock\" ) type mockUserRetriever struct { mock.Mock } func (m *mockUserRetriever) GetUser(ctx context.Context, userID string) (*User, error) { returnValues := m.Called(ctx, userID) return returnValues.Get(0).(*User), returnValues.Error(1) }\n\nUsing the above mock in a test looks like this:\n\n    \n    \n    package something import ( \"testing\" \"github.com/stretchr/testify/mock\" ) func TestUserRetrieval(T *testing.T) { T.Parallel() T.Run(\"standard\", func(t *testing.T) { t.Parallel() expected := &User{ID: \"something\"} mur := &mockUserRetriever{} mur.On(\"GetUser\", mock.Anything, expected.ID).Return(expected, nil) // pass our mock to whatever uses it and test it's functionality mock.AssertExpectationsForObjects(t, mur) }) }\n\nI won\u2019t lie, I\u2019m not deeply impressed with the way that mock.Mock determines\nwhich variables to return in what order, and when things go wrong (i.e. you\ncopy and paste something in the wrong order or have the wrong indices on your\nreturn values) it\u2019s VERY hard to suss out, but by and large, testify/mock does\nan incredible job of what it needs to do.\n\nYou can avoid having to put mock.Anything in an expectation call by writing a\ntype matcher. For context.Context, it would look like this:\n\n    \n    \n    mock.MatchedBy(func(context.Context) bool { return true })\n\nThere\u2019s also testify/suite, which I have used, but wouldn\u2019t recommend. It\u2019s\nuseful when you have a ton of common prerequisites for tests that need to be\nspun up ahead of time, but I still think it makes more sense to just make\nthose prerequisites the product of a common function, instead of writing non-\nstandard test code.\n\n### Testcontainers\u2317\n\nThis is a neat tool I\u2019ve only recently started using, but to great effect.\nIt\u2019s very common to have to write code that interfaces with a database, or a\nk/v store, or an in-memory cache, but before testcontainers, you either had to\nwrite a suite of integration tests that used that code to verify it did what\nyou wanted, or otherwise fly blind in production. With testcontainers, I can\nspin up ephemeral containers that run a given piece of software and have my\ncode interact with that to verify functionality.\n\nIn practice, it\u2019s not perfect. These tests generally run great on my machine,\nand in Github Actions, but you must remember that you\u2019re asking your computer\nto make a fake computer within itself, spin up a piece of software on that\nfake computer, and handle all the networking shenanigans that go along with\ninterfacing with it, so there\u2019s plenty of opportunity for mishaps and errors\nto occur.\n\nSometimes a testcontainer invocation will just fail, and the reason behind it\ncan be summarized up as: computers are hard. Since they can be a big more\nerror prone than standard tests, I don\u2019t typically write subtests for these.\nInstead, I tend to write one big function that uses a single instance of the\ncontainer to test a bunch of related functions.\n\nHere\u2019s an example of the test for that aforementioned webhook retrieval\nfunction:\n\n    \n    \n    package whatever import ( \"context\" \"database/sql\" \"fmt\" \"testing\" \"github.com/example/project/pkg/types\" \"github.com/example/project/pkg/types/converters\" \"github.com/example/project/pkg/types/fakes\" \"github.com/stretchr/testify/assert\" \"github.com/stretchr/testify/require\" \"gopkg.in/matryer/try.v1\" ) func buildDatabaseClientForTest(t *testing.T, ctx context.Context) (*Querier, *postgres.PostgresContainer) { t.Helper() dbUsername := fmt.Sprintf(\"%d\", hashStringToNumber(t.Name())) testcontainers.Logger = log.New(io.Discard, \"\", log.LstdFlags) var container *postgres.PostgresContainer err := try.Do(func(attempt int) (bool, error) { var containerErr error container, containerErr = postgres.RunContainer( ctx, testcontainers.WithImage(defaultImage), postgres.WithDatabase(splitReverseConcat(dbUsername)), postgres.WithUsername(dbUsername), postgres.WithPassword(reverseString(dbUsername)), testcontainers.WithWaitStrategyAndDeadline(2*time.Minute, wait.ForLog(\"database system is ready to accept connections\").WithOccurrence(2)), ) return attempt < 5, containerErr }) require.NoError(t, err) require.NotNil(t, container) connStr, err := container.ConnectionString(ctx, \"sslmode=disable\") require.NoError(t, err) dbc, err := ProvideDatabaseClient(ctx, logging.NewNoopLogger(), tracing.NewNoopTracerProvider(), &config.Config{ConnectionDetails: connStr, RunMigrations: true, OAuth2TokenEncryptionKey: \"blahblahblahblahblahblahblahblah\"}) require.NoError(t, err) require.NotNil(t, dbc) return dbc, container } func createWebhookForTest(t *testing.T, ctx context.Context, exampleWebhook *types.Webhook, dbc *Querier) *types.Webhook { t.Helper() // create if exampleWebhook == nil { exampleWebhook = fakes.BuildFakeWebhook() } dbInput := converters.ConvertWebhookToWebhookDatabaseCreationInput(exampleWebhook) created, err := dbc.CreateWebhook(ctx, dbInput) assert.NoError(t, err) require.NotNil(t, created) assert.Equal(t, exampleWebhook, created) webhook, err := dbc.GetWebhook(ctx, created.ID, created.BelongsToAccount) assert.NoError(t, err) assert.Equal(t, webhook, exampleWebhook) return created } func TestQuerier_Integration_Webhooks(t *testing.T) { ctx := context.Background() dbc, container := buildDatabaseClientForTest(t, ctx) databaseURI, err := container.ConnectionString(ctx) require.NoError(t, err) require.NotEmpty(t, databaseURI) defer func(t *testing.T) { t.Helper() assert.NoError(t, container.Terminate(ctx)) }(t) user := createUserForTest(t, ctx, nil, dbc) accountID, err := dbc.GetDefaultAccountIDForUser(ctx, user.ID) require.NoError(t, err) require.NotEmpty(t, accountID) exampleWebhook := fakes.BuildFakeWebhook() exampleWebhook.BelongsToAccount = accountID createdWebhooks := []*types.Webhook{} // create createdWebhooks = append(createdWebhooks, createWebhookForTest(t, ctx, exampleWebhook, dbc)) // other tests would go here // delete for _, webhook := range createdWebhooks { assert.NoError(t, dbc.ArchiveWebhook(ctx, webhook.ID, accountID)) var exists bool exists, err = dbc.WebhookExists(ctx, webhook.ID, accountID) assert.NoError(t, err) assert.False(t, exists) var y *types.Webhook y, err = dbc.GetWebhook(ctx, webhook.ID, accountID) assert.Nil(t, y) assert.Error(t, err) assert.ErrorIs(t, err, sql.ErrNoRows) } }\n\n(I acknowledge that this code is missing some function definitions, but it\u2019s\nmeant for you to get an idea, not copy/paste)\n\n### Failure Cases\u2317\n\nSome functions in the Go standard library return errors that you might surface\nto higher-level call sites, but in order to test that those errors are caught\nand returned, Here are some ways I manage to achieve failures for very\nspecific circumstances in Go.\n\n### JSON Encoding\u2317\n\nIt\u2019s a pretty common operation in Go code to take an instance of a given\nstruct and render it as JSON. This function is capable of returning an error\nin the event the source struct is unrepresentable, but it\u2019s actually pretty\nhard to make a struct unrepresentable in Go. You basically have to do it on\npurpose.\n\nThe way I achieve this is by using json.Number, a string alias meant to\nrepresent numbers, and giving it a non-numerical value. Here\u2019s what that looks\nlike:\n\n    \n    \n    type BreakableStruct struct { Thing json.Number } func TestRenderToJSON(T *testing.T) { T.Parallel() T.Run(\"with invalid structure\", func(t *testing.T) { t.Parallel() x := &BreakableStruct{Thing: \"stuff\"} actual, err := json.Marshal(x) assert.Nil(t, actual) assert.Error(t, err) }) }\n\n### URL Parsing\u2317\n\nParsing a URL in Go returns an error, but trying to force this error to occur\nwas very confusing to me. I had to dive into the actual test cases in the\nstandard library for net/url. Here are some inputs you might think return an\nerror from url.Parse, but actually don\u2019t:\n\n  * an empty string\n  * a URL with double dots in the path (i.e. https://google.com/../../var/data)\n  * just a scheme (i.e. https://)\n  * a URL with emojis in it (i.e. https://\ud83d\ude18.\ud83d\udd25)\n  * a URL with an invalid scheme (i.e. farts://)\n\nAll of these actually don\u2019t return an error. The only way I was able to force\nit to occur by using:\n\n    \n    \n    fmt.Sprintf(`%s://`, string(byte(127)))\n\nFor whatever reason, this causes url.Parse to fail.\n\n### Conclusion\u2317\n\nIn many other languages, you have to not only evaluate testing libraries, but\nalso write your tests in a style that complies with that library\u2019s\nexpectations. Gophers are blessed to have a thoroughly adequate solution out-\nof-the-box, and even further blessed to have an active ecosystem where folks\nare making in-depth testing a walk in the park.\n\n\u00a9 2024 Powered by Hugo :: Theme made by panr\n\n", "frontpage": true}
