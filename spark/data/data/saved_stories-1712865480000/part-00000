{"aid": "40002199", "title": "REST Explained", "url": "https://htmx.org/essays/rest-explained/", "domain": "htmx.org", "votes": 4, "user": "Kinrany", "posted_at": "2024-04-11 13:55:40", "comments": 0, "source_title": "</> htmx ~ REST - Explained For Beginners", "source_text": "</> htmx ~ REST - Explained For Beginners\n\n</> htmx\n\ndocs\n\nreference\n\nexamples\n\ntalk\n\nessays\n\n# REST - Explained For Beginners\n\nThere is no topic that generates more confusion in web development than the\nidea of Representational State Transfer, known as REST. This term comes from\nChapter 5 of Roy Fielding\u2019s PhD thesis at U.C. Irvine.\n\nIn this essay we will go through this Chapter and summarize the important\nconcepts for non-academic web developers. The thesis is dense and involves a\nlot of technical jargon that isn\u2019t relevant to people who aren\u2019t academics\ninterested in formal PhD thesis writing.\n\nBy the end of this essay you should have a better handle on REST, and the\nconcept of a Uniform Interface in particular.\n\n## #Overview\n\nThe first thing to understand about REST is that it is a description of the\noriginal web. Fielding describes REST as an \u201carchitectural style for\ndistributed hypermedia systems\u201d, which sounds fancy but just means the web we\nall know and love: clicking on hyperlinks, submitting forms, looking at\nimages, reading paragraphs and all that jazz.\n\nIt was NOT created as a description of a particular approach for JSON APIs,\nalthough that is the context that most people hear about REST today in.\nFielding was describing the early web and, in particular, how it was different\nfrom earlier client/server architectures.\n\n## #Section 5.1 Deriving Rest\n\nIn section 5.1, unfortunately for non-academics, Fielding adopts the technique\nof deriving REST from first principles. Here I will summarize each section and\nclarify and add context in the important ones.\n\n### #Client Server\n\nREST is, of course, a client-server architecture, since the web is a client\n(browser) server (http server) system.\n\n### #Stateless\n\nThe web, most developers know, is intended to be stateless. All requests\nshould encapsulate all information necessary to understand that request. For\nexample, there should not be a long running transaction implicitly associated\nwith a series of requests, as you might have with a SQL database session.\n\n### #Cache\n\nHTTP, you probably know, has a caching mechanism built into it. You don\u2019t need\nto know the details of this now, but may explore it later.\n\n### #Uniform Interface\n\nThis section, in my mind, is the crux of the REST architecture and,\nunfortunately, is very brief, so we will spend some time expanding on it,\nrather that just summarizing it. The chapter begins:\n\n> The central feature that distinguishes the REST architectural style from\n> other network-based styles is its emphasis on a uniform interface between\n> components\n\nTo clarify the discussion around exactly what the uniform interface is, let\u2019s\nconsider some simple HTML that I hope everyone reading this will understand:\n\n    \n    \n    <html <body> <section> <p> Name: Joe Blow </p> <p> Email: joe@blow.com </p> <p> <a href=\"/contacts/42/edit\">Edit</a> <a href=\"/contacts/42/email\">Email</a> <a href=\"/contacts/42/archive\">Archive</a> </p> </section> </body> </html>\n\nHere we have a basic bit of html, with some divs, a bit of information and\nthen some anchor tags to perform various operations on a contact. Nothing\nfancy. Again, for the discussion, imagine this content could be found at\nhttp://example.com/contacts/42.\n\nBack to the dissertation:\n\n> REST is defined by four interface constraints: identification of resources;\n> manipulation of resources through representations; self-descriptive\n> messages; and, hypermedia as the engine of application state.\n\nLet\u2019s go through each of these in turn.\n\n#### #Identification of Resources\n\nThe first aspect of Rest is the idea of resources that are found somewhere\nvia... well, Universal Resource Locators, or URLs. Note that the HTML contains\nadditional URLs for the actions that you can perform on this resource\n(contacts/1), following the conventional hierarchical arrangement of URL\npaths.\n\n#### #Manipulation of Resources Through Representations\n\nThis sounds fancy, but it just means that you can update and mutate the\nresource (that is, the contact) through various representations (that is HTML\npages) rather than having to issues, say, SQL, to modify it.\n\n#### #Self Descriptive Messages\n\nThis is a key concept of REST. Note that the browser, which is the client in\nthis client-server setup, knows nothing about contacts. And yet it is able to\nrender a \u201cContact UI\u201d simply by rendering the HTML returned by the server. The\nmessage itself is entirely self-describing, containing all information the\nclient needs about both the data and the possible operations on that data (in\nthe form of links.)\n\nNow, contrast this with a JSON representation of the same data:\n\n    \n    \n    { \"name\" : \"Joe Blow\", \"email\" : \"joe@example.com\" }\n\nObviously this is smaller, but a client working with this data must decide two\ncrucial things:\n\n  * How to render it\n  * What actions are available to mutate it\n\nThe first part is typically done with a client side template. The second is\ntypically done by reading the documentation for the API and encoding the\ninteractions with the server directly in the client.\n\nThis is the crux of the difference between REST-ful systems and traditional\nclient-server system: in the REST-ful system the client (i.e. the browser)\ndoesn\u2019t know anything about the resource, it just knows how to render a\nhypermedia. In the client-server system, knowledge about the resource is\nembedded in the client.\n\nThere are pros and cons to both approaches, but the REST-ful approach, in the\nform of the early web, proved to be extremely reliable and flexible. It hides\na tremendous amount of knowledge about the resources behind this uniform\ninterface of HTML, so the client doesn\u2019t have the opportunity to break in the\nway the thick-client does.\n\nNow, you may have noticed that, in the last decade, web development has\ntrended away from the REST-ful architecture and towards a more traditional\nclient-server setup, using JSON APIs. And you may have noticed a lot more\ndiscussion and issues around versioning APIs, providing more general query\nfunctionality and so on. This is not accidental: we are losing the flexibility\nof the REST-ful model as we turn the browser into a VM for hosting thick\nclient applications.\n\n#### #Hypermedia As The Engine of Application State (HATEOAS)\n\nThis last concept dovetails with the previous one: clients transition\napplication state by interacting with URLs found in the hypermedia itself (via\nforms and links). So, in the HTML example above, the ability to edit, email\nand archive the contact all encoded as anchors in the HTML. If one of those\nactions was not available, or a new one became available, it would come down\nin a new bit of HTML, after a page refresh.\n\nThis is in contrast with a thick client approach where, for example, a local\nstore may be sync\u2019d asynchronously with a back end and, thus, the HTML is not\nacting as the engine of application state, but rather as a (somewhat janky) UI\ndescription language.\n\nSomewhat hilariously, the Wikipedia article on HATEOAS uses JSON, which is not\na natural hypermedia. You can layer some REST-ful behavior on top of JSON if\nyou want, but it has rarely been useful in the real world, and HATEOAS is\nusually ignored in JSON APIs. This makes sense because JSON APIs are useful\nmainly for the traditional client-server architecture and aren\u2019t particularly\namenable to the REST-ful style.\n\n#### #Uniform Interface Summary\n\nThat\u2019s the crux of REST and really the crux of this essay. You can read on for\na bit more detail and analysis of Fieldings paper, but the core take away here\nis that there is a sharp distinction between a REST-ful hypermedia\narchitecture and traditional client-server architectures, and that distinction\nrevolves mainly around the concept of a uniform interface, and the self-\ndescribing nature of them in particular.\n\nAgain, don\u2019t get bogged down in the jargon here, just think about this HTML\nand what a miracle of flexibility and ingenuity it is:\n\n    \n    \n    <html> <body> <div> <div> Name: Joe Blow </div> <div> Email: joe@blow.com </div> <div> <a href=\"/contacts/42/edit\">Edit</a> <a href=\"/contacts/42/email\">Email</a> <a href=\"/contacts/42/archive\">Archive</a> </div> </div> </body> </html>\n\n### #Layered System\n\nYou don\u2019t need to know much about this, except that CDNs exist, and you should\nuse them.\n\n### #Code-On-Demand\n\nAgain, you don\u2019t need to know much about this, except that Javascript exists,\nand that it\u2019s the only part that\u2019s optional.\n\n## #Section 5.2 - REST Architectural Elements\n\nI won\u2019t drill in as deeply on this section as we did others because it gets\npretty technical and, frankly, is a bit boring and repetitive (as one might\nexpect from a dissertation.) The two big ideas in this section are Resources\nand Representations.\n\n## #Section 5.2.1 - Resources and Resource Identifiers\n\nFrom the paper:\n\n> The key abstraction of information in REST is a resource. Any information\n> that can be named can be a resource: a document or image, a temporal service\n> (e.g. \u201ctoday\u2019s weather in Los Angeles\u201d), a collection of other resources, a\n> non-virtual object (e.g. a person), and so on.\n\nPractically, a resource is anything that can be addressed by a URL. What\nhappens when you access a URL?\n\nWell, you get back a representation of that resource, in the form of an HTTP\nresponse that may contain HTML, directives and so forth.\n\n## #Section 5.2.1 - Representations\n\nI don\u2019t find a lot of practical use in this section. There is some stuff on\ncontrol data, media types and so forth, which are all worth learning about\neventually when needed, but aren\u2019t a commonly used aspect of web development.\n\nThe remaining sections 5.2 similarly do not offer much to the generalist.\n\n## #Section 5.3 - REST Architectural Views\n\nIn what is becoming a pattern, I again do not feel there is a lot of useful\nnew information for the average web developer in this section, with one big\nexception: it lays out the benefits of REST.\n\nFrom the paper:\n\n> REST\u2019s client-server separation of concerns simplifies component\n> implementation, reduces the complexity of connector semantics, improves the\n> effectiveness of performance tuning, and increases the scalability of pure\n> server components. Layered system constraints allow intermediaries\u2013proxies,\n> gateways, and firewalls\u2013to be introduced at various points in the\n> communication without changing the interfaces between components, thus\n> allowing them to assist in communication translation or improve performance\n> via large-scale, shared caching. REST enables intermediate processing by\n> constraining messages to be self-descriptive: interaction is stateless\n> between requests, standard methods and media types are used to indicate\n> semantics and exchange information, and responses explicitly indicate\n> cacheability.\n\nThis is all very true, and is why the web has been so successful and will\ncontinue to be successful.\n\n## #Sections 5.4 & 5.5 - Related Work & Summary\n\nThese brief sections are not relevant to non-academics interested in REST.\n\n## #Summary\n\nSo there you have it, a brief tour of Chapter 5 of Roy Fielding\u2019s disseration,\nwhich gave us the term REST. I have focused in on the areas that I think are\nmost important for web developers to understand and tried to convey how REST\ndescribes the original web model. The uniform interface concept is, in my\nopinion, the most important and interesting aspect of REST, and is useful for\nweb developers to understand as it is primarily responsible for the benefits\ndescribed above.\n\nFinally, I hope you can see how inappropriate REST is for describing most JSON\nAPIs in use today.\n\n</>\n\n## haiku\n\njavascript fatigue: longing for a hypertext already in hand\n\ndocs\n\nreference\n\nexamples\n\ntalk\n\nessays\n\n@htmx_org\n\n", "frontpage": false}
