{"aid": "40002854", "title": "Memoizing recursive functions via the fixed-point Y Combinator", "url": "https://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/", "domain": "might.net", "votes": 1, "user": "Tomte", "posted_at": "2024-04-11 14:54:04", "comments": 0, "source_title": "Memoizing recursive functions via the fixed-point Y combinator: Applying functional programming techniques to Javascript", "source_text": "Memoizing recursive functions via the fixed-point Y combinator: Applying\nfunctional programming techniques to Javascript\n\n# Fixed-point combinators in JavaScript: Memoizing recursive functions\n\n[article index] [email me] [@mattmight] [rss]\n\nIt comes as a surprise to many programmers that it is possible to express a\n\"recursive\" function like factorial without using recursion or iteration.\n\nThe technique involved is subtle but powerful: the recursive function is\ncomputed as the \"fixed point\" of a non-recursive function. To compute the\nfixed point, we can use the Y combinator, which is itself a non-recursive\nfunction that computes fixed points.\n\nThat this manages to work is truly remarkable.\n\n\\--Sussman and Steele on the Y Combinator\n\nAs a practical application of this theory, recursive functions expressed as\nfixed points allow the use of a memoizing fixed-point combinator. The\ncombinator approach to recursion makes it possible to cache the internal calls\nto a recursive function automatically.\n\nFor example, this caching turns the naive, exponential implementation of\nFibonacci into the optimized, linear-time version for free.\n\nRead below to see how to do this all of this in JavaScript, courtesy of its\nanonymous function construct.\n\nIf you like the article below, you might also enjoy:\n\n  * My recommended reading for programming languages.\n  * What every CS major should know.\n  * JavaScript: The Good Parts. Exactly that.\n  * JavaScript: The Definitive Guide. The reference on JavaScript.\n\n## Recursion as fixed points\n\nStudents of algebra are already familiar with recursion and fixed points.\n\nThey just don't realize it.\n\nConsider an equation like \"x = x^2 - 2.\" (Programmers might recognize this as\na recursive definition, in which x is being defined in terms of itself.)\n\nIf asked to solve for the value of x, a student might re-arrange the equation\nto use the quadratic formula. However, there is another way to express, and\neven find, the value(s) of x: fixed points.\n\nA fixed point of a function f is an input that is equal to its output; that is\nx is a fixed point of the function f if x = f(x). Some functions have no fixed\npoints; some have many. The notation Fix(f) denotes the set of fixed points of\na function f.\n\nDefine the function f such that f(v) = v^2 - 2. Then, observe that the\noriginal equation may now be re-written as \"x = f(x).\" In other words, the\nsolutions to the equation are the fixed points of the function f! That is,\nFix(f) = {-1,2}--a fact we can verify by seeing that\n\nf(-1) = (-1)^2 - 2 = 1 - 2 = -1,\n\nand:\n\nf(2) = (2)^2 - 2 = 4 - 2 = 2\n\nor by graphing y = x and y = f(x):\n\nThese are exactly the solutions to x = x^2 - 2 given by Wolfram Alpha.\n\nThe insight that powers the upcoming technique is the observation that any\ntime we have a recursive definition of the form \"x = f(x),\" the meaning of x\nis going to be defined in terms of fixed points.\n\nThe trick is to find a way to obtain fixed points when the equation has the\nform \"f = F(f),\" in which the value of f is not a number, but a function.\n\nThe Y combinator is that trick.\n\n## The Y combinator in theory\n\nIn his research on the \u03bb-calculus and combinatory logic, Haskell Curry\ndiscovered the \"paradoxical\" fixed-point combinator known as the Y combinator.\nThe Y combinator takes a functional as input, and it returns the (unique)\nfixed point of that functional as its output. A functional is a function that\ntakes a function for its input. Therefore, the fixed point of a functional is\ngoing to be a function.\n\nUsing the concepts of functionals and fixed points, we can eliminate explicit\nrecursion for a function through two steps:\n\n  1. Find a functional whose fixed point is the recursive function we seek.\n  2. Find the fixed point of a functional without recursion.\n\nA simple source transformation takes care of the first step. The Y combinator\ntakes care of the second.\n\n## Deriving the Y combinator\n\nThe \u03bb-calculus, the language in which the Y combinator is typically expressed,\nis a programming language which contains only anonymous functions, function\napplications and variable references. (Remarkably, this language is Turing-\ncomplete.) The notation \u03bbv.e stands for the function that maps the input v to\nthe output e. JavaScript supports anonymous functions:\n\n\u03bbv.e == function (v) { return e ; }\n\nSo, if we can find a way to express the Y combinator in the \u03bb-calculus, we can\nexpress it in JavaScript too.\n\nTo derive the Y combinator, start with the core property we seek. Namely, if\nwe give the Y combinator a functional F, then Y(F) needs to be a fixed point:\n\nY(F) = F(Y(F))\n\nWe could actually transliterate this definition into JavaScript as:\n\nfunction Y(F) { return F(Y(F)) ; }\n\nOf course, if we tried to use it, it would never work because the function Y\nimmediately calls itself, leading to infinite recursion.\n\nUsing a little \u03bb-calculus, however, we can wrap the call to Y in a \u03bb-term:\n\nY(F) = F(\u03bb x.(Y(F))(x))\n\nNow, when we invoke the function Y, it immediately calls the function F, and\npasses it \u03bb x.(Y(F))(x), which is equivalent to the fixed point.\n\nOr, in JavaScript:\n\nfunction Y(F) { return F(function (x) { return (Y(F))(x) ; } ) ; }\n\nThis function will actually find the fixed point of a functional, and we could\nuse it to eliminate recursion. Of course, as defined, the function Y calls\nitself recursively, so we haven't really eliminated recursion yet. We've just\nmoved it all into the function Y.\n\nUsing another construct called the U combinator, we can eliminate the\nrecursive call inside the Y combinator, which, with a couple more\ntransformations gets us to:\n\nY = (\u03bbh.\u03bbF.F(\u03bb x.((h(h))(F))(x))) (\u03bbh.\u03bbF.F(\u03bb x.((h(h))(F))(x)))\n\nNote that the right-hand-side makes no reference to Y.\n\n## The Y combinator in JavaScript\n\nAny untyped language which permits lexically scoped anonymous functions, such\nas JavaScript, can express the Y combinator without relying on recursion,\niteration or side effects. Even without understanding how the Y combinator\nworks, you still can see it in action and verify for yourself that no\nrecursion or iteration is used. The following example expresses the factorial\nfunction without using recursion:\n\n[result1]\n\nTake a close look at the definition of Y. It uses only three kinds of\nexpression: anonymous functions, variable reference and function application.\nEach anonymous function has the form function (argument) { return expression ;\n}. The Y combinator is a closed expression--it makes no explicit reference to\nan outside variable or to itself. Clearly, there is no recursion, iteration or\nmutation.\n\nThe Y combinator allows a concise transformation from a recursive function to\na non-recursive function. If we have a recursive function f:\n\n    \n    \n    function f (arg) { ... f ... }\n\nThis definition can be transformed into a non-recursive form:\n\n    \n    \n    var f = Y(function(g) { return (function (arg) { ... g ... }) ;}) ;\n\nIt is inspiring to see what you can achieve in just a few extra characters.\n\n## Exploiting the Y combinator\n\nThe Y combinator is a significant result in the theory of computation and the\ntheory of programming languages. It offers another way to think about\nnontrivial functions in terms of fixed points, rather than the standard\nparadigms of recursion and iteration.\n\nFor instance, suppose we define a recursive function using the functional-\nfixed-point paradigm: can we then create a fixed-point combinator that\nautomatically gives us better performance for the function? The answer is yes.\nWe can create a memoizing fixed-point combinator: a Y-like combinator that\ncaches the results of intermediate function calls.\n\nFor example, the naive way of defining Fibonacci using recursion makes two\nrecursive calls, leading to exponential time complexity:\n\n    \n    \n    function fib(n) { if (n == 0) return 0 ; if (n == 1) return 1 ; return fib(n-1) + fib(n-2) ; }\n\nWe could however, define Fibonacci using the Y combinator:\n\n    \n    \n    var fib = Y(function (g) { return (function (n) { if (n == 0) return 0 ; if (n == 1) return 1 ; return g(n-1) + g(n-2) ; }) ; }) ;\n\nThis formulation still has exponential complexity, but we can change it to\nlinear time just by changing the fixed-point combinator. The memoizing Y\ncombinator, Ymem, keeps a cache of computed results, and returns the pre-\ncomputed result if available:\n\n[result2]\n\nThere are a couple caveats with this particular Ymem:\n\n  1. Ymem only works on functions of one argument, but this could be remedied with Javascript's apply method and the use of a trie-like cache.\n  2. Ymem only works for indexable argument values like numbers and strings, but this can be circumvented by supplying a comparator on argument values, so that it can use a sorted tree for the cache.\n\nThe end result is that the 100th Fibonacci number is computed instantly,\nwhereas the naive version (or the version using the ordinary Y combinator)\nwould take well beyond the estimated lifetime of the universe.\n\n## External resources\n\n  * Benjamin Pierce's Types and Programming Languages is a great resource for the lambda calculus and programming language theory.\n  * Doug Crockford's site is a great reference on advanced JavaScript.\n  * A cool paper by Daniel Brown and William Cook on monads, mixins, inheritence and, yes, fixed points.\n\n## Related posts\n\n  * 26 languages in 25 days: Reflections on language design\n  * 26 languages in 25 days: Strategy, tactics, logistics\n  * Tree transformations: Desugaring Scheme\n  * Lexical analysis in Racket\n  * Grammar: The language of languages (BNF, EBNF, ABNF)\n  * What is static program analysis?\n  * Implementing Java as a CESK machine, in Java\n  * Writing an interpreter, CESK-style\n  * Order theory for computer scientists\n  * HOWTO: Translate math into code\n  * Writing CEK-style interpreters in Haskell\n  * Closure conversion: How to compile lambda\n  * How to compile with continuations\n  * Understand exceptions by implementing them\n  * A-Normalization: Why and How\n  * Compiling up to the \u03bb-calculus\n  * Parsing with derivatives (Yacc is dead: An update)\n  * By example: Continuation-passing style in JavaScript\n  * 7 lines of code, 3 minutes: Implement a programming language\n  * Architectures for interpreters\n  * First-class macros from meta-circular evaluators\n  * Programming with continuations by example\n  * Compiling Scheme to C\n  * Compiling to Java\n  * Church encodings in Scheme\n  * Non-termination without loops, iteration or recursion in Javascript\n  * Advanced programming languages\n  * Recommended books and papers for grad students\n\n[article index] [email me] [@mattmight] [rss]\n\nmatt.might.net is powered by linode | legal information\n\n", "frontpage": false}
