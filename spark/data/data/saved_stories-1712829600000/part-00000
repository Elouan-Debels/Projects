{"aid": "39998243", "title": "Fixing a Bug with C++'s >>= Operator", "url": "https://astrid.tech/2024/03/19/1/maybe-monad-cpp/", "domain": "astrid.tech", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-11 03:58:04", "comments": 0, "source_title": "Fixing a bug with C++'s >>= operator", "source_text": "Fixing a bug with C++'s >>= operator\n\n# astrid dot tech\n\n# Fixing a bug with C++'s >>= operator\n\nThis is very important and I don't know why it has been broken for so long\n\n2024-03-19 23:57\n\ncpp functional-programming haskell monads\n\nAs someone who has done a bit of functional programming, I have to say that\nC++ has really strange design choices, like being eagerly evaluated and\nallowing the user to cause all sorts of weird memory safety issues. But that\u2019s\nexcusable \u2013 not all languages can be as good as Haskell.\n\nHowever, there is one thing that cannot be excused \u2013 C++ has this weird bug\nwhere the >>= operator represents right-bitshift-and-assign, and not what it\nshould be, which is the monadic bind operator like in Haskell.\n\nWell, thanks to C++\u2019s amazing operator overload system, I was able to write\nsome code that fixes the problem!\n\nHere\u2019s some Haskell code:\n\n    \n    \n    module Main where main :: IO () main = let obj1 = Just 10 obj2 = Nothing :: Maybe Int action x = Just (x + 10) newthing1 = obj1 >>= action newthing2 = obj2 >>= action composeTwice = obj1 >>= action >>= action in do putStrLn \"Hello World!\" putStrLn $ show obj1 ++ \" becomes \" ++ show newthing1 putStrLn $ show obj2 ++ \" becomes \" ++ show newthing2 putStrLn $ \"Composed twice: \" ++ show composeTwice\n\nAnd here\u2019s the equivalent C++ code with my custom Maybe type:\n\n    \n    \n    int main() { Maybe<int> obj1 = Maybe<int>::Just(10); Maybe<int> obj2 = Maybe<int>::Nothing(); std::function<Maybe<int>(const int &)> action = ([](const int &a) { return Maybe<int>::Just(a + 10); }); Maybe<int> newthing1 = (obj1 >>= action); Maybe<int> newthing2 = (obj2 >>= action); Maybe<int> compose_twice = ((obj1 >>= action) >>= action); std::cout << \"Hello World!\\n\" << obj1 << \" becomes \" << newthing1 << \"\\n\" << obj2 << \" becomes \" << newthing2 << \"\\n\" << \"Composed twice: \" << compose_twice; }\n\nHere\u2019s the output:\n\n    \n    \n    Hello World! Just(10) becomes Just(20) Nothing becomes Nothing Composed twice: Just(30)\n\nThis kind of thing is extremely useful, and I would like C++ to fix this bug\nas soon as possible.\n\n## Full source\n\nThe full source of the mockup is available as a gist, but also mirrored here:\n\n    \n    \n    #include <functional> #include <iostream> #include <memory> #include <optional> #include <sstream> #include <string> template <class A> class Maybe { std::unique_ptr<A> contents; Maybe(std::unique_ptr<A> contents) : contents(std::move(contents)) {} Maybe() {} public: static Maybe<A> Just(A a) { return Maybe(std::make_unique<A>(a)); } static Maybe<A> Nothing() { return Maybe(); } bool is_just() const { return this->contents != nullptr; } const A &unwrap() const { if (this->contents) { return *this->contents; } throw \"failed to unwrap nothing\"; } template <class B> auto operator>>=(std::function<Maybe<B>(const A &)> f) { if (this->is_just()) { return f(this->unwrap()); } return Maybe<B>::Nothing(); } }; template <class A> std::ostream &operator<<(std::ostream &os, const Maybe<A> &obj) { if (obj.is_just()) { return os << \"Just(\" << obj.unwrap() << \")\"; } else { return os << \"Nothing\"; } } int main() { Maybe<int> obj1 = Maybe<int>::Just(10); Maybe<int> obj2 = Maybe<int>::Nothing(); std::function<Maybe<int>(const int &)> action = ([](const int &a) { return Maybe<int>::Just(a + 10); }); Maybe<int> newthing1 = (obj1 >>= action); Maybe<int> newthing2 = (obj2 >>= action); Maybe<int> compose_twice = ((obj1 >>= action) >>= action); std::cout << \"Hello World!\\n\" << obj1 << \" becomes \" << newthing1 << \"\\n\" << obj2 << \" becomes \" << newthing2 << \"\\n\" << \"Composed twice: \" << compose_twice; }\n\n## #undef SHITPOST\n\nOkay, you must be wondering how the hell this works. Well, the meat of the\ncode is here.\n\n    \n    \n    template <class B> auto operator>>=(std::function<Maybe<B>(const A &)> f) { if (this->is_just()) { return f(this->unwrap()); } return Maybe<B>::Nothing(); }\n\nLet\u2019s break this down.\n\n### Assignments are expressions\n\nAssignments in C++ are expressions. Even =. Usually, they return the newly\nassigned value. For example, if you write something like a = b = c that\nassigns b to the value of c, and then a to the value.\n\nHow do add-and-assign operators work?\n\n    \n    \n    #include <iostream> int main() { int a = 2; int b = 3; int c = 7; int d = a += b += c; std::cout << a << \" \" << b << \" \" << c << \" \" << d; }\n\nhas output 12 10 7 12. What\u2019s happening here is:\n\n  1. b += c makes c stay the same and b = b + c = 3 + 7 = 10\n  2. a += b makes b stay the same and a = a + b = 2 + 10 = 12\n  3. d = a makes d = a = 12.\n\nOther operate-and-assign operators have basically the same rules.\n\nNotice that it\u2019s right-associative (i.e. this is a += (b += c)) whereas\nHaskell\u2019s >>= is left-associative (as in, a >>= b >>= c is (a >>= b) >>= c).\nThat\u2019s why I have to write it like this:\n\n    \n    \n    Maybe<int> compose_twice = ((obj1 >>= action) >>= action);\n\n### auto return type\n\nI tried a type signature like this:\n\n    \n    \n    template <class B> Maybe<B> operator>>=(std::function<Maybe<B>(const A &)> f);\n\nThis will error at the very first time it\u2019s used, even if you explicitly\nspecify the return type like so:\n\n    \n    \n    Maybe<int> newthing1 = (obj1 >>= action);\n\nThis is because even though we did constrain B in the arguments, C++ seems too\nstupid to guess what the return will be.\n\n## C++23\n\nI know std::optional got a .and_then() method added to it that\u2019s basically\nthis but less cursed. I have not tried a C++23 compiler, but I suspect you\nmight be able to generalize to anything that has a .and_then() method,\nalthough I haven\u2019t tried that yet.\n\n## Webrings\n\n\u2190 xxiivv \u2192\n\n\u2190 \ud83c\udff3\ufe0f\ud83c\udf08 bucket webring \ud83c\udff3\ufe0f\ud83c\udf08 \u2192\n\n\u2190 (pending) \u2192\n\n\u00a9 2019-2024 Astrid Yu. Some rights reserved.\n\nastrid.tech v3 was generated by seams, the seamingly silly CMS. Seams, in\nturn, was made by Astrid Yu with a generous helping of tea and insomnia.\n\nSeams is licensed under AGPL-3.0-Only. The content of astrid.tech is licensed\nunder Creative Commons BY-SA 4.0.\n\n", "frontpage": false}
