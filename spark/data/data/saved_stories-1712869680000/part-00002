{"aid": "40002989", "title": "Architecture Of The FRISC 3 (SC32) CPU (1989)", "url": "https://users.ece.cmu.edu/~koopman/stack_computers/sec5_2.html", "domain": "cmu.edu", "votes": 1, "user": "peter_d_sherman", "posted_at": "2024-04-11 15:06:35", "comments": 0, "source_title": "Stack Computers: 5.2 ARCHITECTURE OF THE FRISC 3 (SC32)", "source_text": "Stack Computers: 5.2 ARCHITECTURE OF THE FRISC 3 (SC32)\n\nStack Computers: the new wave \u00a9 Copyright 1989, Philip Koopman, All Rights\nReserved.\n\nChapter 5. Architecture of 32-bit Systems\n\n## 5.2 ARCHITECTURE OF THE FRISC 3 (SC32)\n\n### 5.2.1 Introduction\n\nThe Johns Hopkins University/Applied Physics Laboratory (JHU/APL) FRISC 3 is a\nhardwired 32-bit processor optimized for executing the Forth programming\nlanguage. The name \"FRISC\" stands for \"Forth Reduced Instruction Set\nComputer.\" The \"3\" acknowledges two previous prototype stack processors. The\nfocus of the FRISC 3 is on single cycle execution of Forth primitives in a\nreal time control environment.\n\nJHU/APL developed the FRISC 3 in response to their need for a fast Forth\nlanguage processor for spaceborne control processing applications in\nsatellites and Space Shuttle experiments. The roots of the FRISC 3 project may\nbe traced back to the JHU/APL HUT project (see Appendix A), which was a bit-\nslice processor optimized for the Forth language.\n\nAfter the completion of the HUT processor, the design team at Johns Hopkins\ndesigned a prototype 4.0 micron silicon-on-sapphire 32-bit Forth processor\n(FRISC 1) and a 3 micron bulk CMOS version (FRISC 2), both of which were full-\ncustom designs. The latest version, FRISC 3, is the commercial quality\nprocessor that is an outgrowth of their earlier work.\n\nSilicon Composers has purchased commercial production rights to the FRISC 3,\nand has renamed the design the SC32. The description in this section applies\nto both the FRISC 3 and the SC32, although we shall call the design the FRISC\n3 throughout the remainder of the book.\n\nThe primary use of the FRISC 3 is for embedded real time control, especially\nin spacecraft (which is the focus of the JHU/APL group), but also for other\nindustrial and commercial applications.\n\n### 5.2.2 Block diagram\n\nFigure 5.1 is an architectural block diagram of the FRISC 3.\n\nFigure 5.1 -- FRISC 3 block diagram.\n\nThe Data Stack and Return Stack are implemented as identical hardware stacks.\nThey each consist of a stack pointer with special control logic feeding an\naddress to a 16 element by 32 bit stack memory arranged as a circular buffer.\nThe top four elements of both stacks are directly readable onto the Bbus. In\naddition, the topmost element of the Data Stack may be read onto the Tbus\n(Top-of-stack bus) and the topmost element of the Return Stack may be read\nonto the Abus (return Address bus). Both stack buffers are dual-ported, which\nallows two potentially different elements of the stacks to be read\nsimultaneously. Only one stack element may be written at a time.\n\nOne of the innovative features of the FRISC 3 is the use of stack management\nlogic associated with the stack pointers. This logic automatically moves stack\nitems between the 16-word on-chip stacks and a program memory stack spilling\narea to guarantee that the on-chip stack buffers never experience an overflow\nor underflow. This logic steals program memory cycles from the processor to\naccomplish this, avoiding the extra stack data pins on the chip in exchange\nfor a small performance degradation spread throughout program execution. The\ndesigners of the FRISC 3 call this feature a stack cache, because it caches\nthe top few stack elements for quick access on-chip. This cache is not like\nnormal data or instruction caches in that it does not employ an associative\nmemory lookup structure to allow access to data residing in scattered areas of\nmemory.\n\nThe ALU section of the FRISC 3 includes a standard ALU that is fed by latches\non the Bbus and the Tbus. These two ALU sources on separate busses allow the\ntopmost Data Stack element (via the Tbus) and any of the top four Data Stack\nelements (via the Bbus) to be operated on by an instruction since the Data\nStack is dual-ported. The Bbus can feed any non-stack bus source through the B\nside of the ALU as well.\n\nThe latches from the Bbus and Tbus that feed the ALU inputs are used to\ncapture data during the first half of a clock cycle. This allows the Bbus to\nbe used to write data from the ALU to other registers within the chip on the\nsecond half of the clock cycle. The shift block on the B input of the ALU is\nused to shift the B input left one bit for division, but can also pass data\nthrough unshifted. Similarly, the shift unit on the ALU output can shift data\nright one bit for multiplication, if desired, while feeding the Bbus.\n\nThe latch on the ALU output allows pointer-plus-offset addressing to access\nmemory. On the first clock cycle of a memory fetch or store, the ALU adds the\nliteral field value via the Tbus to the selected data stack word from the\nBbus. On the second cycle, the Bbus is used to transfer the selected \"bus\ndestination\" to or from memory.\n\nThe flag register (FL) is used to store one of 16 selectable condition codes\ngenerated by the ALU for use in conditional branches and multiple precision\narithmetic. The ZERO register is used to supply the constant value 0 to the\nBbus.\n\nFour User Registers are provided to store pointers into memory or other\nvalues. Two of these registers are reserved for use by the stack control logic\nto store the location of the top element of the program memory resident\nportions of the Data Stack and Return Stack.\n\nA Program Counter (PC) is used to supply the A-bus with program memory\naddresses for fetching instructions. The PC may also be routed via the ALU to\nthe Return Stack for subroutine calls. The Return stack may be used to drive\nthe Abus instead of the PC for subroutine returns. The Instruction Register\nmay be used to drive the Abus for instruction fetching, subroutine calls, and\nfor branching.\n\n### 5.2.3 Instruction set summary\n\nFigure 5.2 shows FRISC 3's four instruction formats: one for control flow, one\nfor memory loads and stores, one for ALU operations, and one for shift\noperations. The FRISC 3 uses unencoded instruction formats similar in spirit\nto those found on the NC4016, RTX 2000, and M17. All instruction formats use\nthe highest 3 bits of the instruction to specify the instruction type.\n\nFigure 5.2a -- FRISC 3 instruction format -- control flow.\n\nFigure 5.2a shows the control flow instruction format. The three control flow\ninstructions are subroutine call, unconditional branch, and conditional\nbranch. The conditional branch instruction is taken if the FL register was set\nto zero by the most recent instruction to set the FL register. The address\nfield contains a 29 bit absolute address. Unconditional branches may be used\nby the compiler to accomplish tail-end recursion elimination.\n\nFigure 5.2b -- FRISC 3 instruction format -- memory access.\n\nFigure 5.2b shows the memory access instruction format. Bits 0-15 contain an\nunsigned offset to be added to the address supplied by the bus source operand.\nThis is accomplished by latching the bus source and the offset field from the\ninstruction at the ALU inputs, performing an addition, and routing the\nresultant ALU output to the Abus for memory addressing.\n\nBits 16-19 specify control information for incrementing and decrementing the\nReturn Stack Pointer and/or Data Stack Pointer. Bits 20-23 specify the Bbus\nDestination. In this notation, \"TOS\" means Top of Data Stack, \"SOS\" means\nSecond on Data Stack, \"3OS\" means 3rd element of Data Stack, \"TOR\" means Top\nof Return Stack, etc. Bits 24-27 specify the Bus Source for the Bbus in a\nsimilar manner.\n\nBit 28 specifies whether the next instruction fetched will be addressed by the\ntop element of the Return Stack or the Program Counter. Using bit 28 to\nspecify the Return Stack as the instruction address is combined with a Return\nStack pop operation to accomplish a subroutine return in parallel with other\noperations.\n\nBits 29-31 specify the instruction type. For the memory access format\ninstructions, the four possible instructions are: load from memory, store to\nmemory, load address (low), and load address (high). The load and store\nfrom/to memory instructions use the bus source to supply an address, and the\nbus destination field to specify the data register destination or source. The\nload and store instructions are the only instructions that take two clock\ncycles, since they must access memory twice to accomplish both data movement\nand the next instruction fetch.\n\nThe two load address instructions simply load the computed memory address into\nthe destination register without accessing memory at all. This may also be\nthought of as an add-immediate instruction. The load address high instruction\nshifts the offset left 16 bits before performing the addition. The load\naddress instructions are also the means for loading literal values, since the\naddress register can be selected to the ZERO register. In this manner a load\naddress high followed by a load address low instruction can be used to\nsynthesize a full 32-bit literal.\n\nFigure 5.2c -- FRISC 3 instruction format -- ALU operations.\n\nFigure 5.2c shows the ALU instruction format. Bits 0-6 of this instruction\nformat specify the ALU operation to be performed. The A side of the ALU is\nconnected to the Tbus, while the B side is connected to the Bbus. Bit 7\nenables loading the FL Register with the condition code selected by bits 10-13\nof the instruction. These condition codes provide various combinations of a\nZero bit, Negative bit, Carry out bit, and oVerflow bit, as well as constant 0\nand 1. Bits 8-9 select the carry in to the ALU operation. Bit 14 selects\nwhether the actual ALU result or the contents of the FL register is driven\nonto the Bbus. Bit 15 is a 0, indicating that the instruction is an ALU\noperation.\n\nBits 16-28 are identical to the memory access instruction format shown in\nFigure 5.2b. Bits 29-31 specify the ALU/shift operation instruction type.\n\nFigure 5.2d -- FRISC 3 instruction format -- shift operations.\n\nFigure 5.2d shows the shift instruction format. Bit 0 of this instruction\nformat is unused. Bit 1 specifies whether the FL register input is taken from\nthe condition codes selected by bits 10-13 or the shift-out bit of the\nselected shift register. Bits 2-3 select special step operations for\nperforming multiplication and restoring division. Bit 4 selects whether the\nshift-right input bit comes from the FL register or the ALU condition code.\nBits 5-6 specify either a left or right shift operation. Bit 7 specifies\nwhether the FL Register is to be loaded with the shift output bit or the\ncondition code generated by bits 10-13 and bit 1. Bits 8-9 select the carry-in\nfor the ALU operation, while bit 14 determines whether the ALU output or the\nFL register is driven to the Bbus. Bit 15 is a 1, indicating that the\ninstruction is a shift operation.\n\nBits 16-28 are identical to the memory access instruction format shown in\nFigure 5.2b. Bits 29-31 specify the ALU/shift operation instruction type.\n\nAll instructions execute in one clock cycle, with the exception of the memory\nload and memory store instructions, which take two clock cycles. Each clock\ncycle is broken during execution into a source phase and a destination phase.\nDuring the source phase, the selected Bbus source and the Tbus value are read\ninto the ALU input latches. During the destination phase, the Bbus destination\nis written. Each instruction is fetched in parallel with the execution of the\nprevious instruction.\n\nSubroutine calls are accomplished in a single clock cycle. Subroutine returns\ntake no extra time to the extent that they can be combined with other\ninstructions.\n\n    \n    \n    0 >R 0< @ 0= AND 0> BRANCH 0BRANCH CALL 1 DROP 1+ DUP 1- EXIT 2* LITERAL 2+ NEGATE 2/ NOT 4+ OR + OVER -1 R> - R@ < S->D <> U< = U> > XOR\n\nTable 5.1(a) FRISC 3 Instruction Set Summary -- Forth Primitives. (see\nAppendix B for descriptions)\n\n    \n    \n    The FRISC 3 is capable of a very large number of compound Forth primitives. Space precludes listing all of them, so we shall give some illustrative examples. LIT + @ (address plus offset fetch) LIT + ! (address plus offset store) <variable> @ (fetch a variable) <variable> ! (store a variable) 2 PICK (copy the third element on the stack) 3 PICK (copy the fourth element on the stack) R> DROP R@ < SWAP DROP OVER OVER + LIT + DROP LIT OVER + DUP LIT + OVER - DROP DUP DUP + DROP OVER DUP AND OVER @ DUP XOR 2 PICK @ DUP 1+ 3 PICK @ OVER + OVER ! 2 PICK + 2 PICK ! 3 PICK + 3 PICK ! R@ + + >R R> + DUP >R DUP < DUP R> DROP DUP > R> DROP DUP The flexibility of the FRISC 3 also supports many operations not encompassed in the Forth language, such as stack manipulation words on the Return Stack (e.g. Return Stack SWAP).\n\nTable 5.1(b) FRISC 3 Instruction Set Summary -- Compound Forth Primitives.\n\nMost of the usual Forth primitives as well as manipulations of the top four\nstack elements on both the Data Stack and Return Stack are supported by the\nFRISC 3 instruction set. Table 5.1 shows a representative sample of FRISC 3\ninstructions.\n\n### 5.2.4 Architectural features\n\nLike all the other machines designs discussed so far, the FRISC 3 has a\nseparate memory address bus (the Abus) for fetching instructions in parallel\nwith other operations. In addition, the FRISC 3 does not have a dedicated top-\nof-stack register for the Data Stack, but instead uses a dual-ported stack\nmemory to allow arbitrary access to any of the top four stack elements. This\nprovides a more general capability than a pure stack machine and can speed up\nsome code sequences.\n\nThe stack control logic is a means to prevent catastrophic stack overflow and\nunderflow during program execution by \"dribbling\" elements onto and off of the\nstack to keep at least 4 elements on the stack at all times without\noverflowing. This demand-fed approach to stack buffer management is discussed\nin greater detail in Section 6.4.2.2. Each stack has 16 words used as a\ncircular buffer. The stack controllers perform stack data movement to and from\nmemory whenever there would be less than four or more than 12 elements in an\non-chip stack. The movement is performed one element at a time, since the\nstack pointers can only be incremented or decremented once per instruction.\nEach stack element transfer to or from memory consumes two clock cycles.\nChapter 6 discusses the cost of these extra cycles, which the FRISC 3\ndesigners claim is typically below 2% of overall program execution time for\ntheir machine.\n\n### 5.2.5 Implementation and featured application areas\n\nThe FRISC 3 is implemented on 2.0 micron CMOS technology with a silicon\ncompiler using 35,000 transistors. It is packaged in an 85 pin Pin Grid Array\n(PGA). The FRISC 3 runs at up to 10 MHz.\n\nThe FRISC 3 is designed for real time control applications, especially in the\narea of spaceborne systems. It is designed to execute Forth efficiently,\nalthough it should be reasonably efficient at running C or other conventional\nlanguages. C support is enhanced by the capability of using one of the User\nRegisters as a frame pointer and using the offset of the memory load and store\ninstructions to do frame pointer plus offset addressing.\n\nThe information in this section is based on the description of the FRISC 3 in\nHayes & Lee (1988). Information on previous versions of the FRISC architecture\nmay be found in Fraeman et al. (1986), Hayes (1986), and Hayes et al. (1987).\n\nNEXT SECTION\n\nPhil Koopman -- koopman@cmu.edu\n\n", "frontpage": false}
