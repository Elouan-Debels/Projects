{"aid": "40042845", "title": "Coherence and crate-level where-clauses in Rust. (2022)", "url": "https://smallcultfollowing.com/babysteps/blog/2022/04/17/coherence-and-crate-level-where-clauses/#coherence-and-crate-level-where-clauses", "domain": "smallcultfollowing.com", "votes": 1, "user": "fanf2", "posted_at": "2024-04-15 16:42:04", "comments": 0, "source_title": "baby steps", "source_text": "Coherence and crate-level where-clauses \u00b7 baby steps\n\n# Coherence and crate-level where-clauses\n\n17 April 2022\n\nRust has been wrestling with coherence more-or-less since we added methods;\nour current rule, the \u201corphan rule\u201d, is safe but overly strict. Roughly\nspeaking, the rule says that one can only implement foreign traits (that is,\ntraits defined by one of your dependencies) for local types (that is, types\nthat you define). The goal of this rule was to help foster the crates.io\necosystem \u2014 we wanted to ensure that you could grab any two crates and use\nthem together, without worrying that they might define incompatible impls that\ncan\u2019t be combined. The rule has served us well in that respect, but over time\nwe\u2019ve seen that it can also have a kind of chilling effect, unintentionally\nworking against successful composition of crates in the ecosystem. For this\nreason, I\u2019ve come to believe that we will have to weaken the orphan rule. The\npurpose of this post is to write out some preliminary exploration of ways that\nwe might do that.\n\n## So wait, how does the orphan rule protect composition?\n\nYou might be wondering how the orphan rule ensures you can compose crates from\ncrates.io. Well, imagine that there is a crate widget that defines a struct\nWidget:\n\n    \n    \n    // crate widget #[derive(PartialEq, Eq)] pub struct Widget { pub name: String, pub code: u32, }\n\nAs you can see, the crate has derived Eq, but neglected to derive Hash. Now, I\nam writing another crate, widget-factory that depends on widget. I\u2019d like to\nstore widgets in a hashset, but I can\u2019t, because they don\u2019t implement Hash!\nToday, if you want Widget to implement Hash, the only way is to open a PR\nagainst widget and wait for a new release.^1 But if we didn\u2019t have the orphan\nrule, we could just define Hash ourselves:\n\n    \n    \n    // Crate widget-factory impl Hash for Widget { fn hash(&self) { // PSA: Don\u2019t really define your hash functions like this omg. self.name.hash() ^ self.code.hash() } }\n\nNow we can define our WidgetFactory using HashSet<Widget>...\n\n    \n    \n    pub struct WidgetFactory { produced: HashSet<Widget>, } impl WidgetFactory { fn take_produced(&mut self) -> HashSet<Widget> { self.produced.take() } }\n\nOK, so far so good, but what happens if somebody else defines a widget-\ndelivery crate and they too wish to use a HashSet<Widget>? Well, they will\nalso define Hash for Widget, but of course they might do it differently \u2014\nmaybe even very badly:\n\n    \n    \n    // Crate widget-factory impl Hash for Widget { fn hash(&self) { // PSA: You REALLY shouldn\u2019t define your hash functions this way omg 0 } }\n\nNow the problem comes when I try to develop my widget-app crate that depends\non widget-delivery and widget-factory. I now have two different impls of Hash\nfor Widget, so which should the compiler use?\n\nThere are a bunch of answers we might give here, but most of them are bad:\n\n  * We could have each crate use its own impl, in theory: but that wouldn\u2019t work so well if the user tried to take a HashSet<Widget> from one crate and pass it to another crate.\n  * The compiler could pick one of the two impls arbitrarily, but how do we know which one to use? In this case, one of them would give very bad performance, but it\u2019s also possible that some code is designed to expect the exact hash algorithm it specified.\n\n    * This is even harder with associated types.\n  * Users could tell us which impl they want, which is maybe better, but it also means that the widget-delivery crates have to be prepared that any impl they are using might be switched to another one by some other crate later on. This makes it impossible for us to inline the hash function or do other optimizations except at the very last second.\n\nFaced with these options, we decided to just rule out orphan impls altogether.\nToo much hassle!\n\n## But the orphan rules make it hard to establish a standard\n\nThe orphan rules work well at ensuring that we can link two crates together,\nbut ironically they can also work to make actual interop much harder. Consider\nthe async runtime situation. Right now, there are a number of async runtimes,\nbut no convenient way to write code that works with any runtime. As a result,\npeople writing async libraries often wind up writing directly against one\nspecific runtime. The end result is that we cannot combine libraries that were\nwritten against different runtimes, or at least that doing so can result in\nsurprising failures.\n\nIt would be nice if we could implement some traits that allowed for greater\ninterop. But we don\u2019t quite know what those traits should look like (we also\nlack support for async fn in traits, but that\u2019s coming!), so it would be nice\nif we could introduce those traits in the crates.io ecosystem and iterate a\nbit there \u2014 this was indeed the original vision for the futures crate! But if\nwe do that, in practice, then the same crate that defines the trait must also\ndefine an implementation for every runtime. The problem is that the runtimes\nwon\u2019t want to depend on the futures crate, as it is still unstable; and the\nfutures crate doesn\u2019t want to have to depend on every runtime. So we\u2019re kind\nof stuck. And of course if the futures crate were to take a dependency on some\nspecific runtime, then that runtime couldn\u2019t later add futures as a\ndependency, since that would result in a cycle.\n\n## Distinguishing \u201cI need an impl\u201d from \u201cI prove an impl\u201d\n\nAt the end of the day, I think we\u2019re going to have to lift the orphan rule,\nand just accept that it may be possible to create crates that cannot be linked\ntogether because they contain overlapping impls. However, we can still give\npeople the tools to ensure that composition works smoothly.\n\nI would like to see us distinguish (at least) two cases:\n\n  * I need this type to implement this trait (which maybe it doesn\u2019t, yet).\n  * I am supplying an impl of a trait for a given type.\n\nThe idea would be that most crates can just declare that they need an impl\nwithout actually supplying a specific one. Any number of such crates can be\ncombined together without a problem (assuming that they don\u2019t put inconsistent\nconditions on associated types).\n\nThen, separately, one can have a crate that actually supplies an impl of a\nforeign trait for a foreign type. These impls can be isolated as much as\npossible. The hope is that only the final binary would be responsible for\nactually supplying the impl itself.\n\n## Where clauses are how we express \u201cI need an impl\u201d today\n\nIf you think about it, expressing \u201cI need an impl\u201d is something that we do all\nthe time, but we typically do it with generic types. For example, when I write\na function like so...\n\n    \n    \n    fn clone_list<T: Clone>(v: &[T]) { ... }\n\nI am saying \u201cI need a type T and I need it to implement Clone\u201d, but I\u2019m not\nbeing specific about what those types are.\n\nIn fact, it\u2019s also possible to use where-clauses to specify things about non-\ngeneric types...\n\n    \n    \n    fn example() where u32: Copy, { {\n\n...but the compiler today is a bit inconsistent about how it treats those. The\nplan is to move to a model where we \u201ctrust\u201d what the user wrote \u2014 e.g., if the\nuser wrote where String: Copy, then the function would treat the String type\nas if it were Copy, even if we can\u2019t find any Copy impl. It so happens that\nsuch a function could never be called, but that\u2019s no reason you can\u2019t define\nit^2.\n\n## Where clauses at the crate scope\n\nWhat if we could put where clauses at the crate scope? We could use that to\nexpress impls that we need to exist without actually providing those impls.\nFor example, the widget-factory crate from our earlier example might add a\nline like this into its lib.rs:\n\n    \n    \n    // Crate widget-factory where Widget: Hash;\n\nAs a result, people would not be able to use that crate unless they either (a)\nsupplied an impl of Hash for Widget or (b) repeated the where clause\nthemselves, propagating the request up to the crates that depend on them.\n(Same as with any other where-clause.)\n\nThe intent would be to do the latter, propagating the dependencies up to the\nroot crate, which could then either supply the impl itself or link in some\nother crate that does.\n\n## Allow crates to implement foreign traits for foreign impls\n\nThe next part of the idea would be to allow crates to implement foreign traits\nfor foreign impls. I think I would convert the orphan check into a \u201cdeny by\ndefault\u201d lint. The lint text would explain that these impls are not permitted\nbecause they may cause linker errors, but a crate could mark the impl with\n#[allow(orphan_impls]) to ignore that warning. Best practice would be to put\norphan impls into their own crate that others can use.\n\n## Another idea: permit duplicate impls (especially those generated via\nderive)\n\nJosh Triplett floated another interesting idea, which is that we could permit\nduplicate impls. One common example might be if the impl is defined via a\nderive (though we\u2019d have to extend derive to permit one to derive on a struct\ndefinition that is not local somehow).\n\n## Conflicting where clauses\n\nEven if you don\u2019t supply an actual impl, it\u2019s possible to create two crates\nthat can\u2019t be linked together if they contain contradictory where-clauses. For\nexample, perhaps widget-factory defines Widget as an iterator over strings...\n\n    \n    \n    // Widget-factory where Widget: Iterator<Item = String>;\n\n...whilst widget-lib wants Widget to be an iterator over UUIDs:\n\n    \n    \n    // Widget-lib where Widget: Iterator<Item = UUID>;\n\nAt the end of the day, at most one of these where-clauses can be satisfied,\nnot both, so the two crates would not interoperate. That seems inevitable and\nok.\n\n## Expressing target dependencies via where-clauses\n\nAnother idea that has been kicking around is the idea of expressing\nportability across target-architectures via traits and some kind of Platform\ntype. As an example, one could imagine having code that says where Platform:\nNativeSimd to mean \u201cthis code requires native SIMD support\u201d, or perhaps where\nPlatform: Windows to mean \u201cthis msut support various windows APIs. This is\njust a \u201ckernel\u201d of an idea, I have no idea what the real trait hierarchy would\nlook like, but it\u2019s quite appealing and seems to fit well with the idea of\ncrate-level where-clauses. Essentially the idea is to allow crates to\n\u201cconstrain the environment that they are used in\u201d in an explicit way.\n\n## Module-level generics\n\nIn truth, the idea of crate-level where clauses is kind of a special case of\nhaving module-level generics, which I would very much like. The idea would be\nto allow modules (like types, functions, etc) to declare generic parameters\nand where-clauses.^3 These would be nameable and usable from all code within\nthe module, and when you referenced an item from outside the module, you would\nhave to specify their value. This is very much like how a trait-level generic\ngets \u201cinherited\u201d by the methods in the trait.\n\nI have wanted this for a long time because I often have modules where all the\ncode is parameterized over some sort of \u201ccontext parameter\u201d. In the compiler,\nthat is the lifetime \u2019tcx, but very often it\u2019s some kind of generic type\n(e.g., Interner in salsa).\n\n## Conclusion\n\nI discussed a few things in this post:\n\n  * How coherence helps composability by ensuring that crates can be linked together, but harms composability by making it much harder to establish and use interoperability traits.\n  * How crate-level where-clauses can allow us to express \u201cI need someone to implement this trait\u201d without actually providing an impl, providing for the ability to link things together.\n  * A sketch of how crate-level where-clauses might be generalized to capture other kinds of constraints on the environment, such as conditions on the target platform, or to module-level generics, which could potentially be an ergonomic win.\n\nOverall, I feel pretty excited about this direction. I feel like more and more\nthings are becoming possible if we think about generalizing the trait system\nand making it more uniform. All of this, in my mind, builds on the work we\u2019ve\nbeen doing to create a more precise definition of the trait system in a-mir-\nformality and to build up a team with expertise in how it works (see the types\nteam RFC). I\u2019ll write more about those in upcoming posts though! =)\n\n  1. You could also create a newtype and making your hashmap key off the newtype, but that\u2019s more of a workaround, and doesn\u2019t always work out. \u21a9\ufe0e\n\n  2. It might be nice of us to give a warning. \u21a9\ufe0e\n\n  3. Fans of ML will recognize this as \u201capplicative functors\u201d. \u21a9\ufe0e\n\n", "frontpage": false}
