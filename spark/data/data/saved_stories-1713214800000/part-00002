{"aid": "40041437", "title": "Setup.py and Makefile: A just good enough build tool", "url": "https://tselai.com/setup-py-Makefile.html", "domain": "tselai.com", "votes": 3, "user": "fforflo", "posted_at": "2024-04-15 14:59:02", "comments": 0, "source_title": "setup.py + Makefile: A just good enough build tool", "source_text": "setup.py + Makefile: A just good enough build tool\n\nFlorents Tselai Think, Code, Read, Sleep, Repeat\n\n  * Blog\n  * Projects\n  * About\n\n# setup.py + Makefile: A just good enough build tool\n\n15 Apr 2024\n\nMuch of the discussion around the xz backdoor vulnerability has focused on the\ncomplexity of tools like autoconf. See this discussion pgsql-hackers: Security\nlessons from liblzma, for context.\n\nI don\u2019t have a specific proposal to save the world; instead, I\u2019ll try to\nsketch my idea of a just-good-enough-build tool and point to three of my\nfavorite examples.\n\nSemantics are indeed important, but I won\u2019t drown in them. As a build tool, I\ndefine a software tool that automates turning a reasonably complex codebase\ninto a single artifact suitable for distribution. This artifact can be a\nbinary executable, a shareable tarball, or a zip file ready to be uploaded to\npackage managers.\n\nWhat about the \u201cgood enough\u201d part? Here\u2019s where things get more complex. From\nmy perspective, a good enough build tool:\n\nIt should be readily available on most reasonable platforms. If I have to\nsearch for a different name to brew install it in my MacOS and a different\npackage to apt install in my CI pipelines, that\u2019s already too complex.\n\nIt should be readable and easy to navigate: nothing beats a Makefile on this.\nThe next best thing is the ci.yml file. That's the first thing I reverse-\nengineer to figure out how to build a package locally.\n\nIt should play nicely with CLI and environment variables to act both as flags\nand parameterizable defaults.\n\nIt should make it easy to call subprocesses from. Subprocesses are useful for\ngit operations (to extract the proper version for instances) or to call other\nbuild tools necessary by a submodule. For example, in many of the projects I\u2019m\ninvolved in submodules written in a language different from the main project.\nPython packages, for instance, that have C-written dependencies, which should\nbe built with autoconf. Bash scripts are the ideal option here, but they come\nwith their usual shortcomings and accidental complexity. They can call scripts\nthat seed the database with data for local development and testing.\n\nIt should be (almost) equally usable for 3 things: setting up a local\ndevelopment environment, running the CI pipeline, produce the build artifacts.\nIn previous decades, one could prioritize and pick, but today, especially in\nopen-source projects, the lines between the three are blurred.\n\nIts language should be powerful but expressive. Vanilla shell-fu is not an\noption either. I\u2019m sure Unix die-hards can do everything in a single sh script\nand they are indeed ideal for bootstrapping a project, but soon enough they\nturn too complex and hard to decipher. And they\u2019re notoriously hard to debug,\ntoo. Take this build script yb_build.sh to build Yugabyte. I\u2019ve used it and\ncan confirm it is battle-tested, but I don\u2019t think I can easily break it down\ninto pieces in less than 5 minutes.\n\nIt can act as a documentation repository of platform-specific tweaks and build\nknowledge.\n\nIf you think I\u2019ve over-fitted these properties to fit the initial title of the\npost, maybe you're right, but I can't help but think that whenever I find\nmyself bootstrapping a complex project I start by building step-by-step either\na Makefile or a bootstrap.sh/py that looks a lot like a setup.py\n\nBelow are some pieces of software that showcase what I'm looking for.\n\n## Redis Makefile\n\nAntirez (the creator of Redis) recently noted on Twitter:\n\n> Repeat with me: Unix is no longer the complex jungle it was 30 years ago,\n> and I no longer need a build system other than a Makefile with a few ifdefs\n> for the majority of system software projects. I thereby promise to try very\n> hard to keep things simple UNITL POSSIBLE.\n\nThe Redis Makefile itself is a testament to that: It's simple; it gets the job\ndone and has done so for many years.\n\n## LLamafile Makefile\n\nAnother Makefile-based popular software here, but I especially like how jart\nhas used a generic top-level Makefile that includes more specific Makefiles\nstored in the build directory, heavily relying on the fact that Makefiles rely\non text substitution and macros A deps.mk to handle dependencies and a\nconfig.mk for configuration, which can be overridden by environment variables,\nand a powerful rules.mk for the juicy stuff.\n\nAlso, note the download-cosmocc.sh script instead of requiring apt install.\nBandwidth nowadays is cheap, CPU time as well. Don't make me apt install\nsomething. Download it from the source in tmp/ and install it yourself. And\nfinally, do you need a checksum library? Just ship a sha256sum.c with it and\ncompile it.\n\n## EdgeDB setup.py\n\nThe setup.py script that EdgeDB uses is my favorite. It supercharges a usually\nPython-only approach to build something much more complex.\n\nIts logic is clear and written in Python. Subprocesses are called to extract\ngit info and even build Postgres from source (which itself relies on\nautoconf)! The fact that Python has a lot of syntactic sugar to deal with\nPaths beautifully helps a lot. Also, notice that it's clear how both cython-\nized and Rust extensions are built. And, of course, taps into an existing\npackage ecosystem like setuptools. So there you have it: a simple setup.py\nscript that builds a database (!) And builds components of it in at least 4\ndifferent languages. Isn't this beautiful and powerful?\n\n\u00a9 Copyright (and left) 2024 by Florents Tselai\n\n", "frontpage": false}
