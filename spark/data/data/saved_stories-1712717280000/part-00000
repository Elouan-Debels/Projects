{"aid": "39984059", "title": "NixOS/nixpkgs: There isn't a clear canonical way to refer to a specific package", "url": "https://github.com/NixOS/nixpkgs/issues/93327", "domain": "github.com/nixos", "votes": 3, "user": "todsacerdoti", "posted_at": "2024-04-09 20:46:29", "comments": 0, "source_title": "There isn't a clear canonical way to refer to a specific package version. \u00b7 Issue #93327 \u00b7 NixOS/nixpkgs", "source_text": "There isn't a clear canonical way to refer to a specific package version. \u00b7\nIssue #93327 \u00b7 NixOS/nixpkgs \u00b7 GitHub\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nNixOS / nixpkgs Public\n\n  * Notifications\n  * Fork 12.2k\n  * Star 15.5k\n\nJump to bottom\n\n# There isn't a clear canonical way to refer to a specific package version.\n#93327\n\nOpen\n\nthomastjeffery opened this issue Jul 17, 2020 \u00b7 75 comments\n\nOpen\n\n# There isn't a clear canonical way to refer to a specific package version.\n#93327\n\nthomastjeffery opened this issue Jul 17, 2020 \u00b7 75 comments\n\nLabels\n\n0.kind: question 6.topic: user experience\n\n## Comments\n\n###\n\nthomastjeffery commented Jul 17, 2020\n\n# Context\n\nThe overwhelming majority of packages in the Nix ecosystem did not come from\nthe Nix ecosystem. As such, the projects these packages are made to provide\ntend to use incompatible organization philosophies like version numbering.Even\nso, users expect Nix to provide multiple instances of packages that are\ndelineated by version number.\n\n## Nix Design\n\nIn Nix, a package is described in two places:\n\n  1. The derivation: Somewhere in nixpkgs/pkgs is a default.nix that describes where to get the source, how to build it, and what files to keep.\n  2. The global attribute path: The package name is defined in pkgs/top-level/all-packages.nix. The name evaluates a nix expression using the derivation defined in nixpkgs/pkgs/somewhere/package-name/default.nix.\n\nIt is assumed that a derivation will be built from the latest source\navailable. To update a package, the derivation is edited to build from a newer\nsource version, tested, and the changes to the derivation are added to a git\nPR to be merged with nixpkgs/master.It isn't uncommon for a derivation to\ndepend on a different version of a package than what is provided by its\ndefault.nix. For example, many C/C++ programs do not build with the latest\nGCC.When different versions of the same project are provided, they each need a\nunique derivation file and attribute path name.It is recommended in the manual\nthat extra package versions are created as separate derivations alongside the\ndefault derivation, and the version name is appended to the package name:\n\n> If there is only one version of a package, its Nix expression should be\n> named e2fsprogs/default.nix. If there are multiple versions, this should be\n> reflected in the filename, e.g. e2fsprogs/1.41.8.nix and\n> e2fsprogs/1.41.9.nix. The version in the filename should leave out\n> unnecessary detail.\n\n> All versions of a package must be included in all-packages.nix to make sure\n> that they evaluate correctly.\n\nFor example, there currently exist the attribute paths gcc6, gcc7, gcc8, gcc9,\nand gcc10 alongside gcc, which provides gcc 9.2.0.\n\n## Nix Usage\n\nWhen installing a package, a user will generally refer to its attribute path\nname, as defined in all-packages.nix.When a user updates their system with\nnixos-rebuild --upgrade [switch|boot] or nix-env -u [packagename|*], nix gets\nwhatever derivations are defined in the latest nixpkgs commit.\n\n> NOTE: This is made a little more complicated by channels. Just remember that\n> channels refer to git branch names.\n\n# Problem\n\nIt is fairly common for a user to want to use a different package version than\nthe default one provided in their nix channel. In order to use it, the user\nmust find it.There are three ways this can be accomplished:\n\n  1. If there is already a derivation provided by the user's channel, the user need only find its attribute path name. This has gotten easier with nix search, but isn't always reliable. Usually, packages follow the naming convention of appending the version to the package name, but this is not always the case.\n  2. If there is not a derivation provided in the user's channel, the user must find a hash that points to the desired derivation version, and use pinning to refer to the package by hash. The hash can be found using this third-party tool, and used as described here.\n  3. If there is not a derivation that provides the desired package version, the user much create their own. Suddenly, a user who just wanted to use a simple and elegant package manager needs to learn how to write a nix derivation, or at least how (and where) to modify an existing one and use that. This is usually done by checking out nixpkgs/master, and either altering the existing derivation (or a copy) to one that builds the desired package version. This method is described in the manual here.\n\nNone of these options is obvious, clear, canonical, and easy to use.Discussion\nhas been happening on this topic for about five years (off and on) here: #9682  \n---  \nThe text was updated successfully, but these errors were encountered:  \n  \nthomastjeffery mentioned this issue Jul 17, 2020\n\nNo way to install/use a specific package version? #9682\n\nClosed\n\nMember\n\n###\n\nvcunat commented Jul 17, 2020\n\nPerhaps it's just me, but I'm not sure where you aim at. I think the intended\ncanonical way will be Flakes, but it was linked in the other thread already,\nso perhaps I'm missing something you want? That is, apart from more\nstandardization of attribute naming, for the relatively uncommon cases where\nwe do keep multiple versions in nixpkgs.Generally, I believe that in practice\nthe main work is in maintenance of those versions \u2013 ensuring that the\ncombinations you'd like keep working together (up to exponential number),\nproducing binaries for those combinations (machine time & space), patching\nimportant (security) bugs, etc. I'd rather try pushing the community towards\nusing relatively few combinations of versions and configurations, as it just\nappears to make life easier (through sharing that work, basically).For\ninstance, what do you do after you find your desired version in some older\nnixpkgs commit? I believe typically you don't really want to just use the\nolder nixpkgs version. If that was OK, why would any distro bother with stable\nreleases? (And I omit the complication of having more of such dependencies.) I\nexpect you typically want something like forward-porting that version to\ncurrent nixpkgs stable branch (or master) \u2013 which might just work trivially or\nit might require further changes.  \n---  \n  \nMember\n\n###\n\nmarkuskowa commented Jul 17, 2020\n\nIs this maybe what you are looking for: https://matthewbauer.us/blog/all-the-\nversions.html  \n---  \n  \nMember\n\n###\n\nspinus commented Jul 17, 2020 \u2022\n\n> It is assumed that a derivation will be built from the latest source\n> available.\n\nwhere did you get this assumption from? is it your assumption? I didn't see\nthis assumption anywhere else.I think nix ecosystem would be solving different\nproblems than ones you express and desire. Let's look at nix website:\nReproducible Declarative Reliable Those are problems nix is trying to solve,\nnot to deliver as many packages in all of different versions. It's giving you\na tool to do it in a stable manner, but that's not the goal. How much work\nwould be to support so much software.  \n---  \n  \n###\n\njeff-hykin commented Jul 17, 2020\n\n@vcunat\n\n> I'm not sure where you aim at\n\n### Trivial Example\n\nI want to install Lua 5.0.x globally (assume I don't care about ANYTHING else)\n\n  1. How can I list every package/channel/derivation that contains Lua 5.0.x\n  2. What exact command do I run to install that version globally\n\n(Now repeat the process for Python 3.6.x and Ruby 2.5.x)\n\n### Problem\n\nIf your answer is \"well there's no straightforward way of doing that\" then\nthat is what this issue is about: we want a straightforward way of doing it\nbecause it is a frequent basic needIf there is a straightforward way, my\nunderstanding is that will be the end of this issue\n\n### Discussion\n\nI believe @thomastjeffery's post is long because he was diving into the\ndetails of how this process could potentially be made simple and the current\nstate of why it is difficult  \n---  \n  \nAuthor\n\n###\n\nthomastjeffery commented Jul 17, 2020\n\nAs far as I am concerned, until a solution does not need to be searched for by\nusers, this is an open issue.There needs to be a straightforward way for users\nto install different versions of packages.There needs to be a straightforward\nway to create derivations that depend on specific versions of packages.Right\nnow, there may be ways of doing those things, but those methods are not\nobvious or straightforward.As I stated in the original issue, I do not have\nenough expertise to lead this discussion. I have done my best to outline the\nproblem, and will be happy to answer any questions about it, and try to\nunderstand proposed solutions.  \n---  \n  \nMember\n\n###\n\nvcunat commented Jul 17, 2020\n\nMy point of view is that if there still are good use cases for Lua 5.0, Python\n3.6, etc. we should have them as attributes in the current nixpkgs repo. That\nway they will be comfortable to use, security problems will be easier to fix\non those packages, etc. (Say, we probably won't build all pythonPackages with\n3.6 on Hydra, but that's a tiny detail.) Those versions were typically removed\nbecause no known person used them.  \n---  \n  \nContributor\n\n###\n\n8573 commented Jul 18, 2020\n\n> I want to install Lua 5.0.x globally (assume I don't care about ANYTHING\n> else)\n\nI'm afraid I don't remember the prior art on this from when I used other\ndistros: How is this done with apt-get and other common tools for installing\nprograms globally?  \n---  \n  \n###\n\njeff-hykin commented Jul 19, 2020 \u2022\n\n> My point of view is that if there still are good use cases for Lua 5.0,\n> Python 3.6, etc. we should have them as attributes in the current nixpkgs\n> repo. That way they will be comfortable to use, security problems will be\n> easier to fix on those packages, etc. (Say, we probably won't build all\n> pythonPackages with 3.6 on Hydra, but that's a tiny detail.) Those versions\n> were typically removed because no known person used them.\n\nThat's good in theory, but just because someone/some group doesn't think it's\na good use case doesn't somehow change that I need a particular version. If\nI'm a security researcher studying vulnerabilities, or a someone working in a\ngovernment environment with versions that take decades to be approved, or any\nnumber of other cases: my \"good use case\" and your \"good use case\" are going\nto be different.If nix can't meet that need, then I'm just going to use\nsomething like brew, apt, or pacman that has a larger package base, and then\nI'll use luavm, rbenv, and asdf to manage versions on an individual basis like\nbefore.Maybe I'm missing something but what's even the point of having a\nfunctional packaging system when you can't reproduce the inputs? There's no\nuse in guaranting an output if you can't reproduce the inputs, which is the\nsame as any other package manager. They all supply \"good enough\" packages.  \n---  \n  \n###\n\njeff-hykin commented Jul 19, 2020 \u2022\n\n> > I want to install Lua 5.0.x globally (assume I don't care about ANYTHING\n> else)\n>\n> I'm afraid I don't remember the prior art on this from when I used other\n> distros: How is this done with apt-get and other common tools for installing\n> programs globally?\n\nIn the current state of things without nix, you have to get a version manager\nspecific to that binary: rbenv or rvm for Ruby, nvm for node, etc. Then use\nthose tools to install multiple versions of ruby/node/etc.\n\n#### Why not just do that?\n\n  1. It seems like that would be against the nix philosophy to install a version manager within nix (aka dynamic version mutation instead of functional versioning), since nix itself is supposed to manage versions functionally.\n  2. In that case, if I was going to do that, I just wouldn't use nix at all and I'd use a normal package manager. But even then its far from ideal having 10 different version managers, each of which are managing versions of language-specific-package-managers (e.g. pip) which manage versioning of packages.\n\n  \n---  \n  \nMember\n\n###\n\nvcunat commented Jul 19, 2020 \u2022\n\n> Maybe I'm missing something but what's even the point of having a functional\n> packaging system when you can't reproduce the inputs? [...]\n\nYou can. Just check out the historic nixpkgs commit you want and you will\nreproduce the build, including all the old dependencies, etc. I've done repo-\nwide git bisect over long history periods, multiple times, it's really nice.\n(Most tarballs should get mirrored on cache.nixos.org IIRC and old binary\nbuilds are there as well.) Note that typically those packages will depend on\nvulnerable OpenSSL, for example. If that's what you want... I expect you\nmainly need a tool that will find you a suitable nixpkgs revision (some of the\nlinked ones perhaps).  \n---  \n  \n###\n\njeff-hykin commented Jul 20, 2020 \u2022\n\n> Just check out the historic nixpkgs commit you want\n\nHow can I do that when I can't find the nixpkgs commit that has the version I\nneed??? (literally the title of this issue)  \n---  \n  \nMember\n\n###\n\nvcunat commented Jul 20, 2020\n\nAs I wrote you'd need some tool for that, e.g. this one (which I only know\nthanks to this GitHub issue).  \n---  \n  \n###\n\njeff-hykin commented Jul 20, 2020 \u2022\n\n> I expect you mainly need a tool\n\nI'm sorry we are still failing to communicate this: we expect nix to be that\ntool / incorporate that functionality. Only nix can create/enforce an official\nversioning standard, and until that happens no tool will have a canonical way\nsearch versions.\n\n> some tool for that, e.g. this one\n\nThe tool is a work-around and exists because a community member had the need\nso frequently, and the existing method fell so short, that they took the time\nto build and host an entire website as a make-shift solution which: doesn't\nsearch all packages, breaks on non-normal version methods, and breaks when\nversions are stored as derivations. Lazamar isn't the only one who took the\ntime to create their own workaround, Matthew Bauer wrote a command line one\nthats more convenient, but it misses more versions than lazamar's tool. Having\nthese tools as the pseudo-official solution really undermines the reliable\ndevelopment cycle I believe nix is trying to create.  \n---  \n  \n###\n\njeff-hykin commented Jul 20, 2020 \u2022\n\nI just don't understand how nix has the best command line installer I've ever\nseen, a one-liner complete with colors, transparent sudo usage, and explicit\nmention of all changes to my system. But then immediately falls on its face\nwhen I try to complete step 1: install my first package with a version that\nmatches the version needed for my pre-existing project. I shouldn't need to\nuse a community-member-made self-hosted website just to complete step 1 of\nusing a package manager to install a very popular version of a package.Its\nlike getting a car, but not the keys to the car, and then having to search the\ninternet for where to find the keys, and then having someone refer you to\ntheir friend that knows where to get lots (but not all) keys, and that friend\ncan probably get a key that's good-enough if you jiggle it to get it to fit in\nthe ignition. You could search through every possible key in the world\nyourself, or you could just decide to take the car to the shop and pay to have\nthem change the ignition, either way is less than ideal.  \n---  \n  \n###\n\njeff-hykin commented Jul 20, 2020 \u2022\n\n> Is this maybe what you are looking for: https://matthewbauer.us/blog/all-\n> the-versions.html\n\nThanks a lot for this @markuskowa, that is much closer to what I've been\nlooking for. Sadly it lists less versions than lazamar's but it's much easier\nto use. You might want to add the example to your comment so people don't need\nto read most/all of the blog post to get the answer. Maybe something like:To\nget versions for emacs run\n\n    \n    \n    nix eval \"(builtins.attrNames (import (builtins.fetchurl https://matthewbauer.us/generate-versions.nix) {}).emacs)\"\n\n(it will take awhile)To get versions for firefox run\n\n    \n    \n    nix eval \"(builtins.attrNames (import (builtins.fetchurl https://matthewbauer.us/generate-versions.nix) {}).firefox)\"\n\nTo install version 25.0.1 of firefox run\n\n    \n    \n    LC_ALL=C nix run \"(import (builtins.fetchurl https://matthewbauer.us/generate-versions.nix) {}).firefox.\\\"25.0.1\\\"\" -c firefox  \n  \n---  \n  \nMember\n\n###\n\nvcunat commented Jul 21, 2020 \u2022\n\n> Having these tools as the pseudo-official solution really undermines the\n> reliable development cycle I believe nix is trying to create.\n\nI believe that stuff discussed in this thread so far has never been meant\namong the main applications of NixPkgs, but I don't see that as a problem.\nDon't get me wrong, I'm (personally) not at all opposed to having some \"more\nofficial\" way of finding the versions you need.But the process starts the same\n\u2013 people from the community implement stuff and then it gets merged,\ndocumented, etc. For big changes it may be advisable to go through an RFC\nbeforehand (if you want to avoid working on something that gets refused in the\nend).  \n---  \n  \n###\n\njeff-hykin commented Jul 21, 2020 \u2022\n\n> But the process starts the same \u2013 people from the community implement stuff\n\nFair enough, thats a really good point \ud83d\udc4d\n\n> it may be advisable to go through an RFC\n\nThanks for the advice, I didn't know of nix's RFC system. I think this issue\nis hoping to create a community discussion to develop an actionable of a plan\nof how to best integrate versions with nix. Basically: listen to people's use-\ncases, hear from users who understand nix's feature set and goals, talk to\ndesign a system that is ideal both to use and to implement, then, if it\nrequires major changes to nix, go the route of an RFC and develop a pull\nrequest.  \n---  \n  \n###\n\njeff-hykin commented Jul 21, 2020 \u2022\n\n> so far has never been meant among the main applications of NixPkgs\n\nI think I am genuinely misunderstanding some aspect about nix. Maybe this\nthread isn't the place for this question: but what are the other main\napplications? I've read the Nix Package Manager Guide, but everything in there\nabout reproducibility seems to point to installing (and therefore finding)\nspecific versions. I mean the first title in chapter 1 is multiple versionsAny\nother multiple-simultaneous-version managers: asdf, kiex, gvm, rvm, rbenv,\npyenv, jenv, nvm, Renv, luavm, all have a list-available-versions as either\ntheir 1st or top-5 most-used commands. But nix has 5.3K stars, so there must\nbe something I'm not understanding if nix is missing something so vital  \n---  \n  \nMember\n\n###\n\nvcunat commented Jul 21, 2020\n\nOK, I'll try to keep explaining \ud83e\udd14Command that lists versions... has always\nbeen there:\n\n    \n    \n    $ nix-env -qa llvm | cat llvm-10.0.0 llvm-5.0.2 llvm-6.0.1 llvm-7.1.0 llvm-7.1.0 llvm-8.0.1 llvm-9.0.1\n\nbut in NixPkgs we choose to restrict the number of maintained versions (which\nhas been discussed at length in these threads), so there are few packages that\nhave multiple versions and having this many is very rare. That approach is\ntake by most distros, because QA is best that way. I understand that this\ncombination can seem confusing.But even that way the multi-versioning gets\nutilized a lot, e.g. for rollbacks. Perhaps it's worth noting that with Nix\nthe \"installed versions\" bring all transitive dependencies down to libc and\nthey can contain configuration (or whole OS), contrary to typical multi-\nversion management.So instead we focused this discussion on installing\nversions from other/\"historic\" NixPkgs commits, and there's no built-in tool\nto search in there... well I tried to explain I personally see limited use for\nthat. I think usually people choose the NixPkgs version they want (say, latest\nrelease-20.03) and not some particular package version (apart from cases like\nLLVM) \u2013 or alternatively they already had some package(s) and they keep them\n\"unupdated\" while replacing others with different versions. Also Flakes are\nnow being introduced as another way of \"managing versions\".  \n---  \n  \n###\n\njeff-hykin commented Jul 21, 2020 \u2022\n\nOkay, that was helpful and better explains #9682 (comment)In that case though,\nwhy would Nix opt to concurrently maintain multiple versions when historic\nversions can be depended upon? In other words, why do this (my current\nunderstanding of the packages):\n\n    \n    \n    current llvm-10.0.0 llvm-5.0.2 llvm-6.0.1 llvm-7.1.0 llvm-7.1.0 llvm-8.0.1 llvm-9.0.1 historic commit#a35lk6djfi3 llvm-5.0.2 llvm-6.0.1 llvm-7.1.0 llvm-7.1.0 llvm-8.0.1 llvm-9.0.1 historic commit#fjo350395 llvm-5.0.2 llvm-6.0.1 llvm-7.1.0 llvm-7.1.0 llvm-8.0.0\n\nInstead of doing this:\n\n    \n    \n    current llvm-10.0.0 historic commit#a35lk6djfi3 llvm-9.0.1 historic commit#a35lk6djfi3 llvm-9.0.0 historic commit#G98olk6djf llvm-8.0.1 historic commit#C35lk6djfi3 llvm-8.0.0 historic commit#B252335lk6 llvm-7.1.0 historic commit#Hfh593fjo35 llvm-7.0.0\n\nIf the answer has to do with this:\n\n> bring all transitive dependencies down to libc\n\nWhy can't current-packages depend on packages in historic commits?  \n---  \n  \nMember\n\n###\n\nvcunat commented Jul 21, 2020 \u2022\n\nThey could. Well, it's not as simple due to many \"packages\" being involved in\nthe dependency graph, but some variants of this are not difficult. If there's\na good use case for some old versions, we just bring them to current NixPkgs,\nbecause it's easier to manage. EDIT: well, Flakes will be a comfortable way,\ntoo, IIRC.  \n---  \n  \n###\n\njeff-hykin commented Jul 21, 2020 \u2022\n\n> because it's easier to manage\n\nis there a resource I could read to explain what makes it easier? Closest\nthing I have found is a video clip hereWithout detailed knowledge, it seems to\nme that it would be better to create a consistent flat system (that depends on\nhistory) rather than some kind of mixed system with an arbitrary \"good-enough\"\nuse case as a decision point. Why have a decision point instead of creating\ntooling that would make it easy to use any historic version, regardless of who\nthinks a version is good enough or not.  \n---  \n  \nMember\n\n###\n\nvcunat commented Jul 21, 2020\n\nThat way it's easier e.g. to fix serious (security) problems in the packages,\nincluding all their dependencies. Also, packages don't live in isolation \u2013 one\nNixPkgs commit is a set of packages that should work together well (for\nexample, the build farm runs VM tests on full systems). A different\ncombination (of historic versions) might work well or it might not, especially\nfor packages that are more tightly coupled to each other.  \n---  \n  \nAuthor\n\n###\n\nthomastjeffery commented Aug 5, 2020\n\nDon't forget that there are two timelines happening here:\n\n  1. The timeline for versions of a package.\n  2. The timeline for the derivation implementing a specific package version.\n\nSometimes, you want to change something in a derivation that implements an\nolder package version. For example, the source for llvm-8.0.1 might be moved\ntomorrow, which would break any new builds of your llvm-8.0.1 derivation.  \n---  \n  \n###\n\njeff-hykin commented Aug 6, 2020 \u2022\n\nI believe I have a relatively simple back-end solution; a database with\nmappings for every package e.g. (package version) => (commit hash). Every\ncommit to master would trigger an update to the database using a CI hook.This\nwould also optimize nix-env -qA since it's currently significantly slower than\ndoing a curl call to lazamars site. It should also partly address your\nrecently mentioned concerns @thomastjefferyI believe currently the channel(s)\nare being scanned for versions of a package, which is pretty inefficient.\nLazamar's tool is doing 5 week snapshots which is missing some versions.The\n\"database\" need not be an actual database, although it certainly could be. In\ntheory it could be a single JSON file although that would be impractical. To\nget around having one giant file, there could be a json file for each package,\nwith versions as the keys and commit hashes as values E.g.nameOfPackage.json\n(package version) => (commit hash)The data structure could also be made more\ncomplex to show which versions of the package were available on a stable\nchannel.Note the commit hash would not be the first (aka oldest) commit with\nthe version but instead the chronologically most-recent commit with the\nversion. This is intentional to address the issue @thomastjeffery mentioned\nwhere the source of the version changed, even though the version did not.I've\nbuilt similar versions of all the components needed to implement this, the\nonly thing slowing me down is learning nix, which I have sunk a considerable\namount of time into between reading the manual and trying to understand nix\n--help.\n\n### Examples for the following would be really helpful for making progress on\nthis\n\n  1. A command for searching for versions of a package within a specific commit\n  2. [completed] A command for listing all package names from specific commit\n  3. [completed/discovered] A command for installing a package derivation from a pinned commit\n  4. [completed/discovered] The code for a shell.nix that would install a specific deviation from a pinned package\n\nIf I can get those working then there will be a clear path towards an RFC  \n---  \n  \n###\n\nnixos-discourse commented Oct 9, 2020\n\nThis issue has been mentioned on NixOS Discourse. There might be relevant\ndetails there:https://discourse.nixos.org/t/re-using-nixpkgs-derivations-for-\ndifferent-package-versions/9236/2  \n---  \n  \n###\n\nvivook commented Oct 16, 2020\n\nI'm glad I found this thread and the one it came from. I just installed nix\nand have just uninstalled it. There are 2 reasons:1 - not possible to search\nfor which package contains a binary (e.g. where is sed?) 2 - not possible to\npin to arbitrary versions without jumping through the hoops described hereIt's\na shame. I thought this could be a good solution to building reproducible\ndeveloper environments like the web site says, but I guess not. It's beyond me\nwhy @jeff-hykin had to write so many posts to explain the simple concept of\npoint 2 above.Farewell nix \ud83d\udc4e  \n---  \n  \nContributor\n\n###\n\nrsynnest commented Oct 16, 2020 \u2022\n\n> 1 - not possible to search for which package contains a binary (e.g. where\n> is sed?)\n\n@vivook this is totally doable! You can install nix-index which provides the\nnix-locate command which does exactly what you need. I discovered this via the\nvery handy Nix to Debian phrasebook\n\n    \n    \n    curl -L https://nixos.org/nix/install | sh # reinstall nix :) nix-env -iA nixpkgs.nix-index # install nix-index nix-index # build the index, takes a while (~5 minutes) nix-locate --top-level --minimal --at-root --whole-name \"/bin/sed\" # RESULTS: # toybox.out # gnused_422.out # gnused.out # busybox.out\n\nAnother cool approach is comma, which transparently runs a nixpkgs binary\nwithout actually installing anything to the system. Great for trying stuff\nout. So in your case you would install comma then run , sed --helpYou can also\nsearch packages the traditional way with nix search. You may have to get\ncreative with such a short common name like \"sed\", but remember nix search\nalso searches package descriptions. nix search \" sed\" (note the leading space)\nworks great, returns 5 packages with the 2nd one being sed. Most things are\nmuch easier to find.  \n---  \n  \nContributor\n\n###\n\nrsynnest commented Oct 16, 2020\n\nBack to the topic of discussion, to me, this version history feature seems\nlike a worthwhile addition. Communities like Ruby, Python, etc. provide dozens\nof versions going back decades, despite the fact they are no longer\nmaintained, so why not Nix? The popularity of tools like nvm, pyenv, etc shows\nthere is a clear user demand, and I think Nix is uniquely capable of offering\na clean solution to this common user problem.@jeff-hykin 's proposal of a\ndatabase tracking versions seems like a good approach to an up-to-date\nmetadata service like this. This seems like it would be a good fit for\nintegrating into NixOS Search.Guix has some similar tooling setup for browsing\npast versions of packages and even comparing derivations across versions.\nPerhaps this upcoming RFC could borrow from there or reach out for tips?\nJudging by their README they are doing something very similar to what @jeff-\nhykin is proposing.  \n---  \n  \nstale bot removed the 2.status: stale\nhttps://github.com/NixOS/nixpkgs/blob/master/.github/STALE-BOT.md label Nov 9,\n2021\n\nmisog mentioned this issue Feb 19, 2022\n\nIdeas to make zap a package manager that did the one job srevinsaju/zap#66\n\nOpen\n\nContributor\n\n###\n\nyuuyins commented Apr 20, 2022 \u2022\n\nit's pretty obvious to me nix should have a simpler way for users to install a\nversion not in their nixpkgs handling all the needed logic in a transparent\nway, i.e. i just say pname-version, did not find it in active nixpkgs/input?\nautomagically try finding older definitions someway and do the logic\nsomeway... found derivation definition and not in the cache? nix says \"we\ndon't support pname-version you're on your own\" and builds it. and for those\nwho want more control to manually keep using overlays/overrides, different\ninput revisions for nixpkgs, etc.another thing is that nix just collides\nbinaries when there are different versions with same binary name. i think for\nthat nix should instead automatically append version to the binary name\n(better yet, keep the collided binary but symlink the binary to pname-version)\nso that it will be available to PATH. well appending version only would not\nsolve the issue, we would need the hash as well pname-version-hash, or part of\nthat hash. unison-lang.org might shred some light into this issue as well.  \n---  \n  \n###\n\nnixos-discourse commented Apr 25, 2022\n\nThis issue has been mentioned on NixOS Discourse. There might be relevant\ndetails there:https://discourse.nixos.org/t/nixpkgss-current-development-\nworkflow-is-not-sustainable/18741/62  \n---  \n  \n###\n\njeff-hykin commented Apr 25, 2022 \u2022\n\n> The root reason for me is; the maintainers seem indifferent to disscussions\n> around fixing foundational problems that totally undermine\n> reliability/stability/purity.\n\n> The issue with a particular package ? => just create an issue on the package\n> manager (nixpkg) repo and want to publish a tiny update to your package? =>\n> you need a PR against nixpkg directly\n\n> were just nails in the coffin below the flashing \"this is un-maintenable/un-\n> scaleable\" sign \ud83d\ude15\n\nI'm excited to announce these^ statements may no longer be true as of that\nconversation in the comment above Nixpkgs current development workflow is not\nsustainable.\n\n### Update for this Issue\n\nVersion search is a small piece of a larger issue: general package search-\nability. And I'm hopeful the discussion/proposal here will get some traction\nsince it paves the way for solving this problem and the maintainability\nproblem.I should mention that my old statement:\n\n> How can I possibly care about the new flakes system when there isn't even a\n> canonical name/version for packages?\n\nhas aged quite poorly. Now that I have much more experience and understand\nflakes, I can say the Nix overhaul I was talking about is (or can be) flakes.\nAnd core contributors have been working on that since before this issue was\nopened. Flakes are a standardization of package format, and this proposal is\ntrying get searchable fields added to the format.  \n---  \n  \ninfinisil mentioned this issue Jul 18, 2022\n\nInconsistent package versioning #295045\n\nOpen\n\nContributor\n\n###\n\nnxg commented Aug 21, 2022\n\nThis is something of a +1, but expressed as a (re?)statement of a use-case,\nwhich I haven't seen, in black and white, in this issue or its progenitor (but\nwhich I may very well have missed in the epic flow). This is related to @jeff-\nhykin 's point in a comment above.\n\n> Say I have a collection of nix-installed software that works for my project,\n> now, and I want to be able to reproduce that in future or tell someone else\n> how to. How do I do that? That \u2018tell someone else\u2019 could be me writing in a\n> publication \u2018download this published data from <URL>, then (install NixPkgs\n> and) install tools A, B and C using nix-shell my-magic-software-set.nix, and\n> you will see what I'm seeing and can reproduce my research\u2019. I want those\n> instructions to be good for at least ten years. How do I assemble the\n> contents of my-magic-software-set.nix?\n\nIf I have a working suite of software versions just now (but I know the\nprevious release had a bug and I'm worried the next one will have a\nregression), I can look at the $PATH to work out the hash of the derivation\nand then I can write that down somewhere, and later, if I'm understanding\nLazamar's site correctly, use that to retrieve that particular version, and\nall of the dependencies of that specific version. I might end up rebuilding\nthe world, but that's OK. That's all a bit DIY, though \u2013 I'd hope that NixPkgs\nwould make this a lot easier, and that it was documented somewhere other than\na github issue.This process is what I personally thought was NixPkgs USP, and\nthe fact that I couldn't find anything about it in the manual was puzzling me\ngreatly until I tried searching the manual with google, and stumbled across\nthe progenitor issue here. To be clear: I long believed that the above\nscenario was the point of NixPkgs.Note: despite the issue title, this isn't a\nquestion about versions, as such. One may agree with commenters above, that\n\u2018versions don't really mean anything\u2019, or with the less extreme position that\n\u2018at least they're useful as searchable metadata\u2019. I don't necessarily care\nwhat versions are in my magic-software-set, I just have to freeze them, for\nthe sake of my own sanity and that of my article's readers.The above assumes I\nget a hash by carefully storing it when I've got a working version (that's\nwhat notes/research-logs/record-keeping is for). It would be nice to be able\nto search (including searching versions-as-metadata) for what was the current\nversions when \u2018damn \u2013 I'm sure this was working six months ago \u2013 what version\nwas Nix-current then?\u2019 Lazamar's database can help here, but I find myself\nhere, trying to work out how to unearth a package which isn't one that they\ncover. And as others have said, one is surprised to have to rely on a third-\nparty site for this.Despite the length of this issue (and indeed of this\ncomment), I'm still convinced that I'm missing something obvious, and that\nsomeone is about to say that this particular use-case is already trivially\nsatisfied by X, Y and Z (where none of X, Y or Z are \u2018clone the entire git\nrepo\u2019). I'm sure that TFM is trying to tell me this, but it assumes I am more\ncomfortable with the Nix language than I am (it's clearly a great language,\nand I'm sure it'll be fun to learn at some point, but that might be a project\nfor another day).  \n---  \n  \nContributor\n\n###\n\n8573 commented Aug 21, 2022\n\n> > Say I have a collection of nix-installed software that works for my\n> project, now, and I want to be able to reproduce that in future or tell\n> someone else how to. How do I do that? That \u2018tell someone else\u2019 could be me\n> writing in a publication \u2018download this published data from <URL>, then\n> (install NixPkgs and) install tools A, B and C using nix-shell my-magic-\n> software-set.nix, and you will see what I'm seeing and can reproduce my\n> research\u2019. I want those instructions to be good for at least ten years.\n\nWhat about statically compiling the program and storing the executable? I\nimagine that could be cheaper in both effort and storage space than directly\nsolving this ticket's posited problem and needing to keep all the\n(transitive!) dependencies around somewhere (at least all the source code,\nwhich counts as dependencies in Nix). I think (or am I wrong?) that currently\nthe NixOS Foundation is bearing all the costs of storing built nixpkgs\npackages indefinitely, but I don't suppose that can continue for ever.  \n---  \n  \nContributor\n\n###\n\nnxg commented Aug 22, 2022\n\n> What about statically compiling the program and storing the executable?\n\nStatic compiles might indeed be a possibility in some cases, though in the\ncase of macOS, which relies heavily on dynamic libraries, I suspect building a\n\u2018static\u2019 executable could be a project in itself (though this isn't something\nI've investigated in depth).The problem is that that wouldn't deal with the\ncase of publishing a recipe (and that's literally publishing, in a journal\narticle): \u2018do X and you will be able to reproduce these results yourself.\u2019Re\nstorage: I wouldn't expect to be able to download packages of historical\nderivations, merely the link to the location of the source (third-party\nlocation), the patches and build recipe (in NixPkgs), and the transitive links\nto the dependencies (also NixPkgs). My understanding is that those patches and\nbuild recipe are what are hosted by NixPkgs, not the source. (But I'm\ncommenting in some ignorance here, since I'm aware that Nix would be a lovely\nrabbit-hole to explore, so I'm being cautious about how far I stray behind the\nfront desk.)Obviously, this depends on a third-party source location not\nchanging, and that can't be guaranteed. There's a different research-\nreproducibility rabbit-hole we could run down here, but if a build broke\nbecause the source had disappeared, then boo-hoo, but it's not NixPkgs fault.  \n---  \n  \n###\n\njeff-hykin commented Aug 27, 2022 \u2022\n\n> I'm still convinced that I'm missing something obvious, and that someone is\n> about to say that this particular use-case is already trivially satisfied by\n\n@nxgYou're not missing anything if you're aware of what's below.You can use\nnix-pinning to get old versions (all results on lazamars site show the code\nfor pinning). But, there is a risk. If package1 is from nixpkg commit1 and\npackage2 is from nixpkgs commit2, there is no guarantee they will work\ntogether. For standalone binarys that's fine, but for packages that interact\n(ex: package1=python3, package2=numpy) it can result is terrible\ndynamic/shared library issues. A lot of that isn't nixpkgs fault, it's just\nthe bad modern system design we have, like the recent breakage that glibc\ncaused. Additionally there is no guarantee that a package will behave the same\non a different system (linux/mac).If all the packages for a project are from\nthe same nixpkg commit, then it is very realistic to freeze all of them. If an\nexample would help, let me know and I'll provide the code. Create a shell.nix\nfile, use the mkShell tool within the nix language, load a pinned nixpkgs (as\na variable), then list all the packages in build inputs. Once that file is\nmade, it's as simple as running nix shell --pure in that directory for anyone\nto reproduce the project environment exactly (security flaws included).The\ndownsides are:\n\n  * system dependencies must be added manually, there is no equivalent to apt-get install\n  * package dependencies (pip install, npm install, gem install, go get, etc) not only can't be automated, but are actually much more difficult than system dependencies. Because node and an npm package interact, custom nix code is needed. Understanding nix lang becomes much more of a requirement, and even then it can be quite difficult to get things working (overlays and overrides).\n  * must use lazamars tools for finding older versions, and risk compatibility issues especially with package dependencies\n  * tools like git/npm still read from your $HOME and can cause \"well it works on my machine\" behaviors\n  * trying to add two binaries with the same name (like two versions of git) does not have an elegant solution, nixpkgs just goes with the last one mentioned in the shell.nix\n  * anything that needs open ssl certificates can have problems\n  * the default shell is bash and there's no way to change it\n\n  \n---  \n  \n###\n\njeff-hykin commented Aug 27, 2022 \u2022\n\nSome tools like niv have tried to alleviate some downsides. I haven't found\nany particularly comprehensive, understable or easy to use. I finished my own\nframework last year to reduce a lot of these problems, but I want to simplify\nthe API before doing a public release.  \n---  \n  \nContributor\n\n###\n\nnxg commented Aug 30, 2022\n\nMany thanks, @jeff-hykin \u2013 what I was missing was \u2018nix-pinning\u2019. Googling for\nthat, I found \u2018Towards reproducibility: pinning Nixpkgs\u2019, which I think I\npossibly should have been aware of already (is that list of guides new?).With\nthat, and with a bit of trial-and-error at https://status.nixos.org, I was\nable to find a channel which contained the specific tool version I needed.\nThat means that I also now understand what Lazamar's tool is doing (each Nix\n\u2018channel\u2019 is a git branch, and the tool identifies the first commit on each\nchannel/branch which has the searched-for tool version \u2013 yes?); I was clearly\nconfused about that before.I completely agree with you on the list of\nchallenges to actual reproducible software. Pinning lets NixPkgs provide step\none of a process, and I don't think NixPkgs need aim further up the ladder\nthan that. Even thinking of wrestling with Python package versioning within\nNixPkgs seems overambitious to me (venvs are everyone's friend!).As is often\nthe case after one has been cordially pointed to the right page of the FM, I\nfeel a little foolish at not having known the answer already. I don't remember\nseeing the current contents of learn before, with the list of guides\nprominently higher than the discussion of Nix pills: if that's always been\nthere, then now I do feel a bit dim; if that's newish, then excellent work\nwhoever reworked the page.Final reflections:\n\n  * This does match the use-case I described, and is just about as easy as it should be, once one knows that \u2018pinning\u2019 is the right term.\n  * I now see that this present issue is about something different: \u2018I'm fine with the channel I'm on, but I want a different version of specific package X\u2019. The above discussion makes more sense now than it did. It's always a little hard to work out, post-enlightenment, why one was confused, but in case it's useful...\n  * The notion of \u2018channel\u2019 is not, to me, as clear and obvious as the author of the relevant section of the manual thinks it is. That text describes a channel as \u2018a place that contains a set of Nix expressions and a manifest\u2019 \u2013 that's a definition in terms of the implementing technology. A definition that's more hand-waving, but possibly more accessible to the naive (eg, me) would be something like \u2018a channel is a set of package versions which are expected to work together; the most prominent example of a channel is the set of packages in a \u201crelease\u201d such as nixpkgs-21.09-darwin\u2019. Realising that would I believe have given me more traction with the NixPkgs docs at an earlier stage.\n\nThis issue is probably as much a documentation issue as a functionality one.\nThe challenge of writing documentation is always the challenge of trying to\nremember not understanding something. I hope that recording here the nature of\nmy ignorance, while that precious ignorance is fast-fading away, will help\nadvance the issue a little bit.  \n---  \n  \nContributor\n\n###\n\nyuuyins commented Aug 30, 2022\n\n> This issue is probably as much a documentation issue as a functionality one.\n> The challenge of writing documentation is always the challenge of trying to\n> remember not understanding something. I hope that recording here the nature\n> of my ignorance, while that precious ignorance is fast-fading away, will\n> help advance the issue a little bit.\n\n@nxg https://nixos.org/manual/nix/unstable/command-ref/new-\ncli/nix3-flake.html#flake-inputsbut it is missing using in outputs, like using\nmultiple nixpkgs through specialArgs  \n---  \n  \nMember\n\n###\n\nSuperSandro2000 commented Mar 19, 2023\n\n> There are three ways this can be accomplished:\n>\n>   1. If there is already a derivation provided by the user's channel, the\n> user need only find its attribute path name. This has gotten easier with nix\n> search, but isn't always reliable. Usually, packages follow the naming\n> convention of appending the version to the package name, but this is not\n> always the case.\n>\n\nThis is essentially fixed by search.nixos.org, nix search and a search through\nthe source code in worst case.\n\n>   2. If there is not a derivation provided in the user's channel, the user\n> must find a hash that points to the desired derivation version, and use\n> pinning to refer to the package by hash.\n>\n\nThis would result in mixing nixpkgs versions which generally works but can\nlead to major problems due to impureness in some parts of nixos like the\ngraphics driver or every program that uses LD_LIBRARY_PATH, so it generally\nshould be avoided whenever possible.\n\n> If nix can't meet that need, then I'm just going to use something like brew,\n> apt, or pacman that has a larger package base\n\nThat is wrong, depending on how you count packages, nixpkgs is biggest package\nrepository and closely behind is the AUR.\n\n> and then I'll use luavm, rbenv, and asdf to manage versions on an individual\n> basis like before.\n\nThose tools where created because all the classical package manager also did\nnot support every version of an ecosystem. For nix there are already some\ncommunity projects which try to do this for some ecosystems and that is place\nwhere I see those projects. Having them outside of nixpkgs allows them to\nrapidly make changes, point there focus on the specific ecosystem or even use\nfeatures which are not suitable for nixpkgs like IFD. Also fully automated\nimports of an entire ecosystem like pypi are possible which are not suited for\nnixpkgs.I read some comments in this thread and the only actionable things\nexcept the general well known documentation problem that I identified would\nrequire creating a RFC because they changes they require are beyond big.  \n---  \n  \n###\n\njeff-hykin commented Mar 19, 2023 \u2022\n\nAfter 3 years a lot has changed, but I've never stopped thinking about (or\nstopped running into) this problem. Literally as I'm writing this I'm waiting\non a nix-shell building python 3.7 using a nixpkgs commit from 2018. The\nLD_LIBRARY_PATH issue you mention @SuperSandro2000 is very present as well.\n\n> > If nix can't meet that need, then I'm just going to use something like\n> brew, apt, or pacman that has a larger package base\n\n> That is wrong, depending on how you count packages, nixpkgs is biggest\n> package repository and closely behind is the AUR.\n\nI didn't mean this as an attack but rather a statement of practicality; even\nright now I'm having to use apt-get and pyenv while I'm unable to get\npython3.7 working in nix-shell. Doesn't mean I'm not trying to get it working\nin nix, it just means I can't rely on it. \"Bigger\" is just the number of times\nI can brew install/apt-get/pacman something, but can't nix-install the same\nthing (like the arduino-ide on M1 or the moveit simulator for ROS). Maybe\nincluding pacman in the list was unfair as I don't use it all that often.\n\n> the only actionable things\n\nI do want to focus this issue on the actionable items instead of complaints.\n\n> would require creating a RFC because they changes they require are beyond\n> big\n\nI agree, there is no quick fix, even just making a full roadmap at this moment\nis impossible because there is so much to do. That said, actions can (and are)\nbeing taken, so here's what I've noticed and what I have been exploring.\n\n## Action Item 1: Solve the LD_LIBRARY_PATH (permanently)\n\nI have spent a lot of time learning about dynamic linking, glib, ldd, patchelf\netc specifically for this problem. I still have a lot left to learn, like\ngetting caught up with how nix-ld works, and if it can be used for this. Based\non what I do understand, it seems very much possible that the whole\nLD_LIBRARY_PATH problem is solvable by constantly updating the RPATH, rather\nthan having lib files that break whenever LD_LIBRARY_PATH is specified.\n\"Possible' doesn't mean without major complications. Instructions that would\nnormally say \"add X to your LD_LIBRARY_PATH\" will need to be converted into\nrunning a patching tool that changes the RPATH for things like .venv files,\nand if patching existing nixpkgs files, a tool will need to create new\nderivations with the modified RPATHS. Again, I still don't see anything that\nmakes it impossible and I've been exploring it with some hacked together tools\nsince I often have to mix and match nix commit versions to get packages I\nneed.I think mixing versions of nixpkgs is necessary to meet all the practical\nsituations of real-life projects, and this is a step towards making it\nfeasible for users who know nothing about dynamic libraries.If you think this\nis impossible (literally impossible not just impractical) I'd be happy to hear\nabout it @SuperSandro2000\n\n## Action Item 2: Solve \"a search through the source code in worst case\"\n\n> This is essentially fixed\n\nIt is not fixed.Great progress has been made, and I'll discuss actions in a\nmoment, but it is necessary to make it clear searching (not even searching for\na version) is still a major problem for nixpkgs. This one I've spent the most\ntime on, and have (what I think is) a good grasp on.\n\n### Action Item 2.1: Binary Name search\n\nThe smaller aspect of binary name search is one of the problems I believe has\nbeen effectively solved. For example, back in 2020 it was extremely difficult\nfor me to find a package for ls because there was no package named ls. At the\ntime I ended up installing lscolors as a makeshift solution because thats all\nI could find. Now, using search.nixos.org, searching for ls returns coreutils-\nfull as the first result which is what I would've wanted in the first place. A\nfantastic improvement.\n\n### Problem 2.2: Nested Attributes\n\nNow, lets search for another common package AVFoundation for MacOS. It is\nneeded quite frequently for building and does exist on nixpkgs with an exact\nattribute-name match.As a user I would probably conclude Nixpkgs just doesn't\nhave it, but lets try searching for it using Github anyways.None of the first\nseveral results give hints as to what to put for nix-env -iA. I'll leave it as\nan exercise for the reader to figure out the attribute path.Mechanical,\nelectrical, and civil engineers use apt-get all the time without ever knowing\nwhat \"grep\" is or how to use it, much less vim/git. Yet a common package on\nnix requires someone to understand advanced file grepping, cloning repos,\nand/or inner knowledge of how nix structures itself to come up with more\nclever searches that narrow down the results. I will consider this an issue\nworth solving as long as this remains the case.\n\n### Action Item 2.3: Uniformity\n\nPart of the problem with matching nested attributes (causing the problem\nabove) is the lack of uniformity across packages. There is a recent RFC for\nflattening Nixpkgs into a uniform structure, that is a major step in the right\ndirection for both maintainability and making it easier to search. That said,\nit doesn't address nested packages yet.Right now nixpkgs is still spagetti,\nuniform packages helps a lot but there's no clearly communicated difference\nbetween a package used by nobody and a package that is essential just for\nstdenv to exist, or a folder with a default.nix that isn't even a package.\nMore confusingly are the packages that are unnecessarily both core and non-\ncore because they're run multiple times using fixpoint recusion. Two months\nago I created nixpkgs-skeleton to try and slice through this confusion to help\nmyself and others understand what parts of nixpkgs were \"core\". Its a far cry\nfrom cleaning everything up but its a start.\n\n### Action Item 2.4: Indexing & Exploration\n\nTo create a searchable interface, there needs to be some way of exploring\nnixpkgs, and there's at least 2.\n\n  1. Through nix evaluation\n  2. Through static anaylsis\n\n### Action Item 2.4.1.1: Static Analysis: Tree Sitter\n\nLast month I finally made a static anaylsis breakthrough getting the nix-tree-\nsitter running (written by someone else) and using it to create a nix-bundler\nsystem (simlar to how javascript bundlers work). This is the basis for\nextracting information about nested package attributes, but has some common\nstatic analysis problems I'll mention in 2.4.1.3.\n\n### Action Item 2.4.1.2: Static Analysis: RNix\n\nOne week after that I found out about the rnix-parser which is a more\ncomprehensive parser written in rust. Its what is being used for automatic re-\nwrites for making the nixpkgs structure flat.\n\n### Action Item 2.4.1.3: Static Analysis: Problems\n\nThere's at least two problems that hurt static analysis significantly.\n\n  1. The with keyword (syntactic sugar) ruins static analysis. Its impossible to know the source of a variable inside mutliple with statements, and even inside only one with statement it is problematic. I would like to eventually propose deprecating with, similar to how Javascript deprecated their own with keyword for similar reasons. Actually it looks like someone has beat me to it.\n  2. Highly dynamic fields, such as packages that accept their version number as an argument, and then interpolate it into a string are difficult to analyze.\n\n### Action Item 2.4.2: Evaluation as Analysis\n\nThe try-to-evaluate functionality of nix is somewhat limited and difficult to\nuse. For example, back when I first started using nix-env queries to build a\nsearch index, there were certain packages on certain nixpkgs commits that fail\non darwin, causing the entire query to fail, meaning no data about any\npackages after that are returned. Instead there would need to be 80,000\nindividual queries just to make sure that failures of one package didn't make\nit impossible to get information about other packages.More recently I've\nattempted to write an expression for recursively exploring packages, to drill\ndown into those attributes. However there is a similar issue, packages fail to\nevaluate, some failures cannot be caught, so I had make a fork and edit out\nall the cases that would throw uncatchable errors. Having a mode for exploring\nnixpkgs that allows for everything to be caught would be quite helpful.Another\naspect is that because of the lazy evaluation try-eval often needs to be\ncombined with deepSeq which often doesn't work for getting around the problem.\nAs I learned recently, there is a makeshift work around specifically for\nderivations recurseForDerivations which I'll be checking out next time I'm\nworking on this task.Evaluation is more comprehensive since it accounts for\ndynamic attribtues, but this can also cause problems when evaulating packages\nfor non-supported systems. For example, trying to get the version number of a\ncuda package on a non-cuda machine.I worked a bit on a propsal for flakes to\nhave a meta or static tag that was evaluatable on every machine. But later\nsettled that the flake.lock format would be better suited for storing\nindexable data.\n\n## Action Item 3: Version Publications\n\nThose things above are mostly just working on package discovery, even without\nversions, but for versions, compatibility checks etc, final action is working\non a system of simulaniously distributed and centralized packages based of\nthis. Where packages can be published and added to a registry independent of\nwhether or not they are integrated into nixpkgs. This will require a server\nwith authentication listening for publish commands, as well as its own search\nsystem. I can't say I'm close, but I have been writing code for this for a\ncouple years now.In terms of actionable steps, getting flakes nailed down will\nbe extremely helpful for this case. Both with the flake-lock being great\nequivlent to something similar to a package.json, and with the inputs more\neasily allowing pulling in code from sources other than nixpkgs.\n\n## TLDR\n\nThere aren't many messages, exciting demos/changes, but a lot of actions have\nbeen done and are worth doing towards solving this issue. I might complain a\nlot, but its because I want nixpkgs to be all it can be instead of what it is.  \n---  \n  \nMember\n\n###\n\nSuperSandro2000 commented Mar 31, 2023\n\n> ### Action Item 2.1: Binary Name search\n>\n> The smaller aspect of binary name search is one of the problems I believe\n> has been effectively solved. For example, back in 2020 it was extremely\n> difficult for me to find a package for ls because there was no package named\n> ls. At the time I ended up installing lscolors as a makeshift solution\n> because thats all I could find. Now, using search.nixos.org, searching for\n> ls returns coreutils-full as the first result which is what I would've\n> wanted in the first place. A fantastic improvement.\n\nThat's probably pretty easy to fix when we have replaced command-not-found\nwith nikx-locate, someone would just need to write some converter to elastic\nand expose i on the website.\n\n> Now, lets search for another common package AVFoundation for MacOS. It is\n> needed quite frequently for building and does exist on nixpkgs with an exact\n> attribute-name match.\n\nThere is probably a recurseInto somewhere missing or we are not evaluating\nthose parts on linux, so those things are missed. Not fully sure.Don't really\nhave something to say on the other things right now.  \n---  \n  \n###\n\nnixos-discourse commented Apr 29, 2023\n\nThis issue has been mentioned on NixOS Discourse. There might be relevant\ndetails there:https://discourse.nixos.org/t/best-practice-for-pinning-version-\nof-individual-packages/6194/7  \n---  \n  \n###\n\ndudicoco commented Jul 20, 2023\n\ndevbox solves this problem by letting you specify package versions within a\njson file, it's a great nix wrapper for mere mortals.  \n---  \n  \n###\n\njeff-hykin commented Jul 23, 2023 \u2022\n\nSo I think there's still a problem worth solving here, but it's not really a\nproblem with devbox as much as it is that this issue thread is an upstream\nissue for devbox.I've been working on/using a devbox-like tool (\"virkshop\" the\nvirtual workshop). I want to provide similar features like versions but both\nmyself and devbox can't AFAIK because:\n\n  1. It's not possible to programatically find/list all available versions (please correct me if devbox has invented their own static-analysis or dynamic-analysis tool that solves this; that kind of solution would close this whole issue thread)\n  2. Even when you find a package, pinning the nixpkgs version (which devbox does let you do) will cause stuff like the LD_LIBRARY_PATH problem that SuperSandro2000 brought up a few comments ago.\n\nAll that said; I would still highly recommend trying out devbox in the\nmeantime! Once this issue is fixed devbox should simply work better than ever\nbefore. I didn't know about it till it was mentioned here (thank you\n@dudicoco), and I'm pretty excited to try it out and see if it can fully\nreplace the tool I've been working on.  \n---  \n  \n###\n\ndudicoco commented Jul 24, 2023\n\n> So there's still a problem, but it's not really with devbox moreso this\n> issue thread is an upstream issue for devbox.I've been working on/using a\n> devbox-like tool (\"virkshop\" the virtual workshop). I want to provide\n> similar features like versions but both myself and devbox can't because:\n>\n>   1. It's not possible to programatically find/list all available versions\n> (please correct me if devbox has invented their own static-analysis or\n> dynamic-analysis tool that solves this; that kind of solution would close\n> this whole issue thread)\n>   2. Even when you find a package, pinning the nixpkgs version (which devbox\n> does let you do) will cause stuff like the LD_LIBRARY_PATH problem that\n> SuperSandro2000 brought up a few comments ago.\n>\nAll that said; I would still highly recommend trying out devbox in the\nmeantime! Once this issue is fixed devbox should simply work better than ever\nbefore. I didn't know about it till it was mentioned here (thank you\n@dudicoco), and I'm pretty excited to try it out and see if it can fully\nreplace the tool I've been working on.\n\n@jeff-hykin devbox does support searching for available package versions\nwithin its CLI:\nhttps://www.jetpack.io/devbox/docs/cli_reference/devbox_search/  \n---  \n  \n###\n\njeff-hykin commented Jul 24, 2023 \u2022\n\n## Answer Update: How to find and install a specific version\n\nNote: Devbox is not designed for this, but it is the most exhaustive solution\nat the moment. Devbox is a framework, it's not really designed to work \"with\nnix\", it moreso uses nix under the hood. This tutorial is only how to use it\nto find/install nix packages versions.\n\n    \n    \n    # install devbox curl -fsSL https://get.jetpack.io/devbox | bash # can also use nix: nix-env -iA nixpkgs.devbox # exhaustive search devbox search nodejs --show-all # nodejs (20.3.1, 20.2.0, 20.0.0, 19.9.0, 19.8.1, 19.8.0, 19.7.0, 19.6.1, 19.6.0, 19.5.0, 19.4.0, 19.2.0, 19.1.0, 19.0.1, 19.0.0, 18.16.1, 18.16.0, 18.15.0, 18.14.2, 18.14.1, 18.14.0, 18.13.0, 18.12.1, 18.12.0, 18.10.0, 18.9.1, 18.9.0, 18.8.0, 18.7.0, 18.6.0, 18.5.0, 18.4.0, 18.3.0, 18.2.0, 18.1.0, 18.0.0, 17.9.0, 17.8.0, 17.7.2, 17.5.0, 17.4.0, 17.3.1, 17.3.0, 17.2.0, 17.1.0, 17.0.1, 16.20.1, 16.20.0, 16.19.1, 16.19.0, 16.18.1, 16.18.0, 16.17.1, 16.17.0, 16.16.0, 16.15.1, 16.15.0, 16.14.2, 16.14.0, 16.13.2, 16.13.1, 16.13.0, 16.12.0, 16.10.0, 16.9.1, 16.9.0, 16.8.0, 16.7.0, 16.6.2, 16.6.1, 16.6.0, 16.5.0, 16.4.2, 16.4.1, 16.4.0, 16.3.0, 16.2.0, 16.1.0, 16.0.0, 15.14.0, 15.13.0, 15.12.0, 15.11.0, 15.10.0, 15.9.0, 15.8.0, 15.7.0, 15.6.0, 15.5.1, 15.5.0, 15.4.0, 15.3.0, 15.2.1, 15.2.0, 15.1.0, 15.0.1, 14.21.3, 14.21.2, 14.21.1, 14.21.0, 14.20.1, 14.20.0, 14.19.3, 14.19.2, 14.19.1, 14.19.0, 14.18.3, 14.18.2, 14.18.1, 14.18.0, 14.17.6, 14.17.5, 14.17.4, 14.17.3, 14.17.2, 14.17.1, 14.17.0, 14.16.1, 14.16.0, 14.15.5, 14.15.4, 14.15.3, 14.15.1, 14.15.0, 14.14.0, 14.9.0, 14.8.0, 14.7.0, 14.6.0, 14.5.0, 14.4.0, 13.14.0, 12.22.12, 12.22.11, 12.22.10, 12.22.9, 12.22.8, 12.22.7, 12.22.6, 12.22.5, 12.22.4, 12.22.3, 12.22.2, 12.22.1, 12.22.0, 12.21.0, 12.20.2, 12.20.1, 12.20.0, 12.19.1, 12.19.0, 12.18.4, 12.18.3, 12.18.2, 12.18.1, 12.18.0, 10.24.1, 10.24.0, 10.23.3, 10.23.2, 10.23.1) # nodejs-slim (20.3.1, 20.2.0, 20.0.0, 19.9.0, 19.8.1, 19.8.0, 19.7.0, 19.6.1, 19.6.0, 19.5.0, 19.4.0, 19.2.0, 19.1.0, 19.0.1, 19.0.0, 18.16.1, 18.16.0, 18.15.0, 18.14.2, 18.14.1, 18.14.0, 18.13.0, 18.12.1, 18.12.0, 18.10.0, 18.9.1, 18.9.0, 18.8.0, 18.7.0, 18.6.0, 18.5.0, 18.4.0, 18.3.0, 18.2.0, 18.1.0, 18.0.0, 17.9.0, 17.8.0, 17.7.2, 17.5.0, 17.4.0, 17.3.1, 17.3.0, 17.2.0, 17.1.0, 17.0.1, 16.20.1, 16.20.0, 16.19.1, 16.19.0, 16.18.1, 16.18.0, 16.17.1, 16.17.0, 16.16.0, 16.15.1, 16.15.0, 16.14.2, 16.14.0, 16.13.2, 16.13.1, 16.13.0, 16.12.0, 16.10.0, 16.9.1, 16.9.0, 16.8.0, 16.7.0, 16.6.2, 16.6.1, 16.6.0, 16.5.0, 16.4.2, 16.4.1, 16.4.0, 16.3.0, 16.2.0, 16.1.0, 16.0.0, 15.14.0, 15.13.0, 15.12.0, 15.11.0, 15.10.0, 15.9.0, 15.8.0, 15.7.0, 15.6.0, 15.5.1, 15.5.0, 15.4.0, 15.3.0, 15.2.1, 15.2.0, 15.1.0, 15.0.1, 14.21.3, 14.21.2, 14.21.1, 14.21.0, 14.20.1, 14.20.0, 14.19.3, 14.19.2, 14.19.1, 14.19.0, 14.18.3, 14.18.2, 14.18.1, 14.18.0, 14.17.6, 14.17.5, 14.17.4, 14.17.3, 14.17.2, 14.17.1, 14.17.0, 14.16.1, 14.16.0, 14.15.5, 14.15.4, 14.15.3, 14.15.1, 14.15.0, 14.14.0, 14.9.0, 14.8.0, 14.7.0, 14.6.0, 14.5.0, 14.4.0, 13.14.0, 12.22.12, 12.22.11, 12.22.10, 12.22.9, 12.22.8, 12.22.7, 12.22.6, 12.22.5, 12.22.4, 12.22.3, 12.22.2, 12.22.1, 12.22.0, 12.21.0, 12.20.2, 12.20.1, 12.20.0, 12.19.1, 12.19.0, 12.18.4, 12.18.3, 12.18.2, 12.18.1, 12.18.0, 10.24.1, 10.24.0, 10.23.3, 10.23.2, 10.23.1) # nodejs_latest (20.0.0, 19.9.0, 19.8.1, 19.8.0, 19.7.0, 19.6.1, 19.6.0, 19.5.0, 19.4.0, 19.2.0, 19.1.0, 19.0.1, 19.0.0, 18.10.0, 18.9.1, 18.9.0, 18.8.0, 18.7.0, 18.6.0, 18.5.0, 18.4.0, 18.3.0, 18.2.0, 18.1.0, 18.0.0, 16.14.2, 16.14.0, 16.13.2, 16.13.1, 16.13.0, 16.12.0, 16.10.0, 16.9.1, 16.9.0, 16.8.0, 16.7.0, 16.6.2, 16.6.1, 16.6.0, 16.5.0, 16.4.2, 16.4.1, 16.4.0, 16.3.0, 16.2.0, 16.1.0, 16.0.0, 15.14.0, 15.13.0, 15.12.0, 15.11.0, 15.10.0, 15.9.0, 15.8.0, 15.7.0, 15.6.0, 15.5.1, 15.5.0, 15.4.0, 15.3.0, 15.2.1, 15.2.0, 15.1.0, 15.0.1, 14.9.0, 14.8.0, 14.7.0, 14.6.0, 14.5.0, 14.4.0) # nodejs-slim_latest (20.0.0, 19.9.0, 19.8.1, 19.8.0, 19.7.0, 19.6.1, 19.6.0, 19.5.0, 19.4.0, 19.2.0, 19.1.0, 19.0.1, 19.0.0, 18.10.0, 18.9.1, 18.9.0, 18.8.0, 18.7.0, 18.6.0, 18.5.0, 18.4.0, 18.3.0, 18.2.0, 18.1.0, 18.0.0, 16.14.2, 16.14.0, 16.13.2, 16.13.1, 16.13.0, 16.12.0, 16.10.0, 16.9.1, 16.9.0, 16.8.0, 16.7.0, 16.6.2, 16.6.1, 16.6.0, 16.5.0, 16.4.2, 16.4.1, 16.4.0, 16.3.0, 16.2.0, 16.1.0, 16.0.0, 15.14.0, 15.13.0, 15.12.0, 15.11.0, 15.10.0, 15.9.0, 15.8.0, 15.7.0, 15.6.0, 15.5.1, 15.5.0, 15.4.0, 15.3.0, 15.2.1, 15.2.0, 15.1.0, 15.0.1, 14.9.0, 14.8.0, 14.7.0, 14.6.0, 14.5.0, 14.4.0) # nodejs-16_x-openssl_1_1 (16.19.0, 16.18.1, 16.18.0, 16.17.1, 16.17.0) # for your whole system devbox global add nodejs@19.9.0 devbox global install # for your specific project/folder devbox init devbox add nodejs@19.9.0 devbox shell # mimicing nix-shell\n\nTo get the nixpkg hash of the package (so it can be installed without devbox,\nor used in a shell.nix) you'll have to open up your devbox.lock\n\n  * If global installing, check cat $XDG_DATA_HOME/devbox/global/default/devbox.lock and/or cat ~/.local/share/devbox/global/default/devbox.lock\n  * if local then it will just be in the local ./devbox.lock\n\n#### Caveats / Notes:\n\n  1. \"Search api lacks x86-darwin info\" is in a comment and I imagine there are many other such caveats because of this issue (packages don't have a consistent way of listing their versions within nixpkgs)\n  2. Says \"experimental\" on the Devbox site (at least at the moment, July 24th 2023)\n  3. The LD_LIBRARY_PATH problem mentioned a few comments above is still going to be present\n\nThanks again for the update @dudicoco. I'll have to spend more time reading\ntheir source code to figure out how they're doing it (it is still pretty tough\nfor me to imagine they perfectly/ideally solved version search). But this is\ndefinitely the best most-comprehensive version search for nixpkgs I've seen,\nso they've got to be doing something right!  \n---  \n  \n###\n\njeff-hykin commented Aug 26, 2023 \u2022\n\n### Update: The Version-Search Results are now Updated Daily! (In sync with\nnixpkgs unstable)\n\nFrom the guys at devbox: https://www.nixhub.io/ (Which is also powers their\nCLI search in the comment above). As of today; as soon as a version is\navailable in nixpkgs unstable; within 24 hours it'll show up on those search\ntools.Note: There are still search caveats, like Mac M1, but this is still a\nhuge amount of progress on this issue and all the credit goes to the devbox\nteam. They also have a great article here talking about how they canoncialize\nnames and versions since Nixpkgs still doesn't try to.I met with 3 devbox\nengineers last month and we've been working together to 1. spearhead getting\nall the missing versions cataloged and 2. get all the code to be open source.\nSome nice incremental achievement is finished a script that can fully\nexhaustively brute force search all attributes (which AFAIK not even hydra or\nnix-env is capable of). The script/approach is too slow for daily updates, but\nit will help us figure out why nix-env misses packages. If we can figure that\nout and fix it, then we will have an entirely clear path for indexing every\nversion that's ever existed on nixpkgs in a efficient way, even super old\nnicpkgs. From there it'll be a matter of building the final bits of\ninfrastructure, open sourcing it, and getting it to be part of the normal nix-\nsystem/nix-search.Update (Nov 2023): The devbox guys still haven't open\nsourced the indexing tool which is sad, but I haven't pinged them about\nit.LD_PATH is still a problem, but honestly that problem belongs in a\ndifferent issue.  \n---  \n  \nMember\n\n###\n\nSuperSandro2000 commented Aug 27, 2023\n\nWe now all know about devbox but could we not turn this thread into an ad for\nit? That would be nice.  \n---  \n  \n###\n\njeff-hykin commented Nov 12, 2023 \u2022\n\n@SuperSandro2000 I agree and I see why it comes off that way.There were no\ncomplaints when I posted a tutorial for Lazamar's website, probably because\ntheir website is designed to work with nix, and its only job is version\nsearch. (Clearly Lazamar had no ulterior motive)I do not have a single project\nthat uses devbox; I have never indented to advertise anything other than a how\nto find/install specific versions of nix packages. The devbox tutorial had a\nlot of detail because (unfortunately) Devbox is a bulky framework, and\ndevbox's version search isn't designed to work with nix. Getting a nixpkgs\ncommit hash out of Devbox is an extreme pain compared to Lazamar's site. It\ntook me quite a while to find how to get the nixpkgs hash, so I wanted to make\na tutorial for the people who cared about that.I agree that^ difference is\nworth clarifying so I added a disclaimer at the top, and tried to make the\nnix-without-devbox usage more prominent. Let me know if you think it can be\nbetter @SuperSandro2000I'll also do another answer summary to show all the\noptions.  \n---  \n  \n###\n\njeff-hykin commented Nov 12, 2023\n\n# TLDR; How to find and install a specific version\n\n  1. Search for a version here https://history.nix-packages.com/ (the successor to Lazamar's website; RikudoeSage's site!) and start at Step 1 of this tutorial\n  2. If the version isn't on there, then try finding it using devbox tutorial here.\n\n  \n---  \n  \nContributor\n\n###\n\nRikudouSage commented Nov 12, 2023\n\nI'd just add that the instructions are there for each version if you click\ninto the version's detail.  \n---  \n  \nFliegendeWurst added 0.kind: question 6.topic: user experience labels Nov 12,\n2023\n\nMember\n\n###\n\nbryango commented Nov 13, 2023\n\nI think I have found a \"native\" solution to the problem of installing old\nversions (at least for my own use case). In summary, to install an old package\nwith nix,\n\n  * locate a cached old version of the package on hydra: https://hydra.nixos.org\n  * install the cached closure via nix profile install or builtins.fetchClosure\n\nA detailed write-up is here:\nhttps://github.com/bryango/cheznix/blob/master/doc/cached-versions.md  \n---  \n  \nSign up for free to join this conversation on GitHub. Already have an account?\nSign in to comment\n\nLabels\n\n0.kind: question 6.topic: user experience\n\n25 participants\n\nand others\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": true}
