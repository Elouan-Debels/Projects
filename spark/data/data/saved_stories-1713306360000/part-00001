{"aid": "40053977", "title": "Calling OCaml from C", "url": "https://transactional.blog/blog/2024-calling-ocaml-from-c", "domain": "transactional.blog", "votes": 1, "user": "eatonphil", "posted_at": "2024-04-16 16:24:40", "comments": 0, "source_title": "Calling OCaml from C", "source_text": "Calling OCaml from C\n\n\u2191 Blog \u2191 S3-Compatible Cloud Storage Costs \u21a6\n\n# Calling OCaml from C\n\nPosted 2024-04-15\n\nMaking an OCaml library usable from C.\n\n  * Basics\n  * Garbage Collection\n  * Option\n\n## Basics\n\nThe official docs on this subject is Interfacing C with OCaml, which is a\nuseful read, though it focuses more on making C callable from OCaml. It\u2019s also\nmissing some collective guidance on how to interact with OCaml values from C\nand not offend the garbage collector when the C function isn\u2019t being called by\nOCaml. So, these are my rough notes on how to get all the pieces to fit\ntogether. This is subtweeting the ongoing Building BerkeleyDB series, as my\npersonal BerkeleyDB re-implementation is in OCaml.\n\nI\u2019m going to assume a minimal directory structure, which looks like:\n\n    \n    \n    project/ \u251c\u2500\u2500 bin \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 main.ml \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u251c\u2500\u2500 ocaml_library.ml \u251c\u2500\u2500 project.opam\n\nIn this, you have some library ocaml_library, and the goal is to expose some\nmethods it defines to C while still allowing the rest of your OCaml\nmain/tests/etc. modules to work. We\u2019ll accomplish this by adding a new folder\nfor the bindings:\n\nbindings/\n\n    \n    \n    \u251c\u2500\u2500 bindings \u251c\u2500\u2500 capi.ml \u251c\u2500\u2500 cstub.c \u2514\u2500\u2500 dune\n\nThis new dune file should contain the below:^[1] [1]: This was mostly copied\nfrom an example on an OCaml forums post.\n\ndune\n\n    \n    \n    (executable (name capi) (1) (libraries ocaml_library) (2) (foreign_stubs (language c) (names cstub)) (3) (flags :standard -linkall) (modes (native shared_object))) (install (4) (section lib) (files (capi.so as capi-1.0.0.so))) (5)\n\n1| capi here means dune expects a capi.ml file by that exact name.  \n---|---  \n2| Or whatever your library module name is which defines the public API you\nwish to export to C. Only code (transitively) included in the specified\nmodules here will be included in the generated .so file.  \n3| cstubs here means dune expects a cstubs.c file by that exact name.  \n4| The install section is skippable, and means you\u2019ll need a .opam and/or\ndune-project file as well.  \n5| The major point of having this is that install lets you rename the .so,\notherwise its name will be your module name + .so.  \n  \ncapi.ml is where you\u2019ll leverage the Callback library to register the\nfunctions that you wish to make accessible to C. .capi.ml\n\n    \n    \n    let () = Callback.register \"ocaml_library_func1\" Ocaml_library.func1 (1) let () = let func2_as_string str = (2) str |> Bigstring.of_string |> Ocaml_library.func2 |> Bigstring.to_string in Callback.register \"ocaml_library_func2\" func2_as_string\n\n1| Associate each function you wish to expose with a unique string.  \n---|---  \n2| Accessing and manipulating primitive types is easier than OCaml types, so\nif there\u2019s easy opportunities to turn types into int/string/etc., then it\u2019s\nsometimes worth the small wrapper function to do so  \n  \ncstubs.c is where you\u2019ll implement the C half that knows how to invoke the\nregistered OCaml functions.\n\nThe first part we\u2019ll need to ensure is that the OCaml runtime is initialized.\nIf there\u2019s no clean singular entrypoint, then perform a (thread-safe)\ninitialization check within each function exposed.\n\ncstubs.c\n\n    \n    \n    #include <caml/alloc.h> #include <caml/mlvalues.h> #include <caml/callback.h> void __caml_init() { // Or pthread_once if you need it threadsafe. static int once = 0; if (once == 0) { // Fake an argv by prentending we're an executable `./ocaml_startup`. char* argv[] = {\"ocaml_startup\", NULL}; // Initialize the OCaml runtime caml_startup(argv); once = 1; } }\n\nNow, we can expose C functions which invoke their OCaml equivalent:\n\nLet\u2019s assume Ocaml_library.func1 was implemented with type () -> ().\n\ncstubs.c\n\n    \n    \n    void ocaml_library_func1() { // Ensure the OCaml runtime is initialized before we invoke anything. __caml_init(); // Fetch the function we registered via Callback. static const value* _Ocaml_library_func1 = NULL; if (_Ocaml_library_func1 == NULL) _Ocaml_library_func1 = caml_named_value(\"Ocaml_library_func1\"); (1) // Invoke the function, supplying () as the argument. caml_callback_exn(*_Ocaml_library_func1, Val_unit); (2) }\n\n1| The unique string for the function.  \n---|---  \n2| caml_callback_exn is the cornerstone of this post, as it\u2019s the way to\ninvoke an OCaml function from C.  \n  \nYou should now be able to run dune build or dune install, and see your capi.so\nfile generated! nm -D capi.so will let you double check that\nocaml_library_func1 is an exported symbol.\n\n## Garbage Collection\n\nIn our minimal example, we\u2019ve ignored all interactions with the garbage\ncollector. This is fine, as the returned () from func1 is immediately garbage\nanyway, so it\u2019s fine for it to be GC\u2019d at any point. Let\u2019s assume our exposed\nwrapper of Ocaml_library.func2 is of type string -> string, and thus something\nless trivially safe for garbage collection. This also means we also get to go\ninto a minor digression on string handling!\n\nFor allocating a string, there\u2019s two options:\n\n  * Null-terminated: value caml_copy_string (char const *)\n\n  * Known-size: value caml_alloc_initialized_string (mlsize_t len, const char *)\n\nAnd for extracting data out of a string, mlsize_t caml_string_length (value)\nreturns the length of the string, and String_val(value) is a macro which\nreturns the pointer to the beginning of the string.\n\nTo prevent accidents, it\u2019s also nice to assert on the tag type of returned\nvalues when possible, so that it\u2019s obvious if the types don\u2019t line up across\nOCaml and C. For strings, that looks like assert(Tag_val(val) == String_tag).\n\nAnd now, the garbage collection safe pattern:\n\ncstubs.c\n\n    \n    \n    char* ocaml_library_func2(char* str_in) { __caml_init(); CAMLparam0(); (1) static const value* _Ocaml_library_func2 = NULL; if (_Ocaml_library_func2 == NULL) _Ocaml_library_func2 = caml_named_value(\"ocaml_library_func2\"); value ocaml_str_in = caml_copy_string(str_in); CAMLlocal1(result); (2) result = caml_callback2_exn(*_Ocaml_library_func2, ocaml_str_in); assert(Tag_val(result) == String_tag); size_t result_len = caml_string_length(result); char* str_out = malloc(result_len); memcpy(str_out, String_val(result), result_len); CAMLreturnT(char*, str_out); (3) }\n\n1| Start all functions with CAMLparam0(). The 0 is that it takes 0 arguments.\nThe arguments would be any value arguments given by the OCaml runtime. This is\nmostly meant for C functions called from OCaml, which isn\u2019t what we\u2019re doing,\nso it\u2019ll always be 0.  \n---|---  \n2| Use CAMLlocal*() to create locals which are GC-safe. CAMLlocal1(result); is\nequivalent to value result;, but GC-safe. The number can range from 1 through\n5.  \n3| Use CAMLreturnT instead of return. First argument is your return type,\nsecond is the return expression. Most other example code shows\nCAMLreturn(val), which is equivalent to CAMLreturnT(value, val). Except we\naren\u2019t a C function being called from OCaml, so we probably never want to\nreturn a value.  \n  \nThis idiom provides a way to ensure that values returned from OCaml stay alive\nduring the local scope of the function. To allow them to stay alive past the\nend of the function scope, then they need to be registered as a GC root with\nthe OCaml runtime. There\u2019s two ways of registering GC roots offered:\ncaml_register_global_root(value*) and\ncaml_register_generational_global_root(value*). The difference is in how often\nthe pointed-to value will be mutated. If nearly never, then use the latter\ngenerational variant. If the pointed-to value is expected to change, then use\nthe former not-generational variant. Both forms of GC roots are un-registered\nvia caml_remove_global_root(value*).\n\nIn both cases, the expected usage is to register the GC root immediately after\na valid value has been written to the location, and one must not call any\nother OCaml runtime or allocation function in between. As an example, we have\na function which allocates a non-trivial OCaml object, and associated\nfunctions to get information about it:\n\ncapi.ml\n\n    \n    \n    (* Our non-trivial object. *) type t = { s : string } let () = let make_t_obj () = { s = \"hello\" } in Callback.register_exn \"make_t_obj\" make_t_obj let () = let t_get_s obj = obj.s in Callback.register_exn \"t_get_s\" t_get_s\n\nWe\u2019d then expose this in C as something like:\n\ncstubs.c\n\n    \n    \n    typedef void* ocaml_obj_t; (1) ocaml_obj_t make_t_obj() { __caml_init(); CAMLparam0(); static const value* _ocaml_make_t_obj = NULL; if (_ocaml_make_t_obj == NULL) _ocaml_make_t_obj = caml_named_value(\"make_t_obj\"); CAMLlocal1(result); result = caml_callback2_exn(*_ocaml_make_t_obj, Val_unit); ocaml_obj_t *ocs = malloc(sizeof(ocaml_obj_t)); *((value*)ocs) = result; caml_register_generational_global_root((value*)ocs); (2) CAMLreturnT(ocaml_obj_t*, ocs); } char* ocaml_obj_t_get_s(ocaml_obj_t* obj) { CAMLparam0(); (3) static const value* _ocaml_t_get_s = NULL; if (_ocaml_t_get_s == NULL) _ocaml_t_get_s = caml_named_value(\"t_get_s\"); CAMLlocal1(result); result = caml_callback2_exn(*_ocaml_t_get_s, *((value*)obj)); assert(Tag_val(result) == String_tag); size_t result_len = caml_string_length(result); char* str_out = malloc(result_len); memcpy(str_out, String_val(result), result_len); CAMLreturnT(char*, str_out); } void free_ocaml_obj_t(ocaml_obj_t* obj) { caml_remove_global_root(obj); (4) free(ocs); }\n\n1| Expose the ocaml object under some opaque type. We\u2019ll cast it back to\nvalue* when needed, but this prevent anything else from knowing it\u2019s an OCaml\nvalue.  \n---|---  \n2| We know our ocaml_obj_t is something written to only once, so the\ngenerational variant is appropriate here.  \n3| obj is already a GC root, so there\u2019s no need to CAMLparam1(obj). Also, note\nthat one wouldn\u2019t call this function without already having called\nmake_t_obj(), so there\u2019s no need to repeat the __caml_init() check.  \n4| Remove the GC root as part of the normal C flow of destroying and freeing\nthe object.  \n  \n## Option\n\nOCaml records and sum types are relatively opaque from C, but unexpectedly,\noption is trivial to manipulate from C.\n\ncapi.ml\n\n    \n    \n    let () = let maybe_integer () = Some(1) in Callback.register_exn \"maybe_integer\" maybe_integer\n\nAnd rather than having to also register is_none and get_int_from_some\nfunctions to invoke, one can just directly manipulate the int option type from\nC:\n\ncstubs.c\n\n    \n    \n    typedef _optional_integer_t { bool present; int value; } optional_integer_t; optional_integer_t ocaml_maybe_integer() { __caml_init(); CAMLparam0(); static const value* _ocaml_maybe_integer = NULL; if (_ocaml_maybe_integer == NULL) _ocaml_maybe_integer = caml_named_value(\"maybe_integer\"); CAMLlocal1(result); result = caml_callback2_exn(*_ocaml_maybe_integer, Val_unit); optional_integer_t ret_value; if (Is_none(result)) { (1) ret_value.present = false; } else { ret_value.present = true; value some = Some_val(result); (2) ret_value.value = Int_val(some); (3) } CAMLreturnT(optional_integer_t, ret_value); }\n\n1| Is_none(v) is a macro which is the same as Option.is_none.  \n---|---  \n2| Some_val(v) is a macro which is the same as Option.get.  \n3| And the unwrapped value can be treated as normal, which in this case, is\ninterpret it as an integer.  \n  \n\u2191 Blog \u2191 S3-Compatible Cloud Storage Costs \u21a6\n\nSee discussion of this page on Reddit, HN, and lobsters.\n\n", "frontpage": false}
