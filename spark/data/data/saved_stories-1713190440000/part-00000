{"aid": "40038013", "title": "Short Tale of Intel Mac to Apple Silicon Mac Migration", "url": "https://badgerbadgerbadgerbadger.dev/posts/misc/2024-03-13-intel-to-apple-silicon/", "domain": "badgerbadgerbadgerbadger.dev", "votes": 2, "user": "badgerbbbadger", "posted_at": "2024-04-15 08:12:16", "comments": 0, "source_title": "Short Tale of Intel -> Apple Silicon Migration", "source_text": "Short Tale of Intel -> Apple Silicon Migration \u2013 Badger Badger Badger Badger\n\n# Badger Badger Badger Badger\n\nLinkedIn Twitter\n\n# Short Tale of Intel -> Apple Silicon Migration\n\n2024-03-13\n\n> Note: I will be using the terms amd64, x86_64, and Intel interchangeably in\n> this post. They all refer to the same architecture. Similarly arm64 and\n> Apple Silicon are used interchangeably.\n\nI recently got handed a new MacBook at work. It\u2019s a MacBook Pro with an M3\nchip and my first encounter with Apple Silicon. I have been hearing many good\nthings about Apple Silicon and having experienced it for myself for the past\nday I must say that my old Intel MacBook can\u2019t compare. I know that comparing\nmy 2020 Intel MacBook, which has been used and abused for 4 years, to a brand\nnew, out-of-the-box 2023 M3 Mac is not an Apples to Apples comparision. So I\nwill take the word of tech reviewers through the years as well as my own\nbiased experience (I no longer have to wait several seconds for a compilation\nstep) and say that Apple Silicon is a game changer.\n\nThe point of this post is not to talk up Apple\u2019s chips but to talk about the\nchallenges I faced getting up and running after moving my stuff from an Intel\nMac to an Arm Mac.\n\n## Migration Assistant\n\nWhile not specific to the Intel -> Arm transfer, I was reminded once again\nthat I should probably be running Migration Assistant over a cable instead of\nWiFi. It took all night and the way the numbers kept going up instead of down,\nsometimes, gave me a ton of anxiety. The next time I do this I have to remind\nmyself that taking 5 extra minutes to get that cable out and connected will\nsave me hours later.\n\n## It Does Not Come with Rosetta\n\nI\u2019m not entirely sure if this is always the case or if it ended up being the\ncase because I performed a Migration, but Rosetta was not already installed on\nmy system. Instead, any time I tried to run a process that was Intel based, I\ngot a pop-up that asked me if I want to install Rosetta.\n\nI put it off for as long as I could. I wanted to have everything running as\nnatively Apple Silicon as I could possibly manage. I finally did cave when I\ndiscovered a few tools did not have an Arm counterpart, but I think I managed\nto reinstall a lot of things before I hit that stage.\n\n## You Can See What\u2019s Running on Rosetta\n\nIf you open the Activity Monitor, you can check which apps are running on\nRosetta. In the CPU tab, look at the Kind column. It will either say Intel or\nApple.\n\nI managed to discover several things running on Rosetta and then went and\nfound Apple Silicon versions of them. For example, I have some bash scripts\nthat open tunnels to my company\u2019s internal network. For managing these\nmultiple tunnels the script uses tmux. I discovered in Activity Monitor that I\nhad several bash processes running as Kind Intel. I suspected tmux spawned\nthese processes, so I did a quick check:\n\n    \n    \n    \u279c which tmux /usr/local/bin/tmux \u279c file /usr/local/bin/tmux /usr/local/bin/tmux: Mach-O 64-bit executable x86_64\n\nIt looks like tmux is still an x86 executable.\n\n    \n    \n    \u279c which bash /bin/bash \u279c file /bin/bash /bin/bash: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit executable x86_64] [arm64e:Mach-O 64-bit executable arm64e] /bin/bash (for architecture x86_64): Mach-O 64-bit executable x86_64 /bin/bash (for architecture arm64e): Mach-O 64-bit executable arm64e\n\nbash on the other hand, is a universal binary, an app format that encapsulates\nmultiple architectures and acts as one of the bridges between Intel and Arm\nMacs.\n\nBut since these bash processes were spawned by an x86_64 tmux, it was the\nx86_64 version that got spawned. Once I replaced tmux with the arm version,\nthe bash processes also spawned with their arm counterparts. So far so makes\nsense!\n\n## A Scriptological Journey\n\n> Warning: This section ended up being longer than anticipated and is filled\n> with arcane unix tools and commands. It was also the most fun section to\n> write!\n\nI wanted to find other binaries that were still x86_64 and see if we could\nclean them up. So I went into the /usr/local/bin/ directory and ran the\nfollowing command:\n\n    \n    \n    \u279c find -L . -type f -exec file {} + | grep 'x86_64' | grep -v 'arm64'\n\nBreaking it down:\n\n  * find -L . -type f searches in the current directory and subdirectory, limited to items that are files. The -L option follows symbolic links as well.\n  * -exec file {} + executes the file command on each file.\n  * grep 'x86_64' finds us instances of x86_64 appearing in the output (the output for x86_64 binaries is Mach-O 64-bit executable x86_64).\n  * grep -v 'arm64' excludes instances where there is a universal binary (like bash, as mentioned before), which has both x86_64 and arm variants available in one package.\n\nThat last grep is to explicitly ensure that if I have a universal binary with\nboth x86_64 and arm64 architectures, we keep that universal binary.\n\n> Side Note: The + modifier is an interesting one. It instructs find to\n> accumulate the found files and execute the command passed to exec (in this\n> case file) command on them in a single invocation. So while without + each\n> of the found files would have file executed against them one by one, with +\n> the files are passed to the command in one go.\n\nThe result of running this command:\n\n    \n    \n    ./vagrant-go (for architecture x86_64): Mach-O 64-bit executable x86_64 ./dummy: Mach-O 64-bit executable x86_64 ./taste: Mach-O 64-bit executable x86_64 ./python3.10-intel64: Mach-O universal binary with 1 architecture: [x86_64:Mach-O 64-bit executable x86_64] ./python3.10-intel64 (for architecture x86_64): Mach-O 64-bit executable x86_64\n\nIf you look closely, you\u2019ll notice that the command is not quite completely\ngiving us the result we want. For ./python3.10-intel64 (which is a universal\nbinary with only 1 architecture) we are getting two lines of output. And for\n./vagrant-go (which we can deduce to be a universal binary with both\narchitectures), we are getting the x86_64 line of output when we actually want\nnone at all. Recall that the ultimate goal is to delete the Intel-only\nbinaries, for which we want a clean list of files.\n\nawk to the rescue!\n\nFor universal binaries with two architectures, file gives us the following.\n\n    \n    \n    \u279c file vagrant-go vagrant-go: Mach-O universal binary with 2 architectures: [arm64:Mach-O 64-bit executable arm64] [x86_64] vagrant-go (for architecture arm64): Mach-O 64-bit executable arm64 vagrant-go (for architecture x86_64): Mach-O 64-bit executable x86_64\n\nThe first line tells us that this is a universal binary with 2 architectures\nand the next two lines give more details on those architectures, one line\nbeing for each architecture.\n\nWe can\u2019t treat this as a line-by-line problem, anymore. We need to process the\nwhole 3-line block. We need to recognize that we\u2019re processing a\n2-architecture universal binary and then figure out a way to exclude the whole\nblock.\n\n    \n    \n    \u279c find -L . -type f -exec file {} + | \\ awk '/Mach-O universal binary with 2 architectures/ && /arm64/ && /x86_64/ { getline; getline; next } { print }' | \\ grep 'x86_64' | \\ grep -v 'arm64'\n\nWe\u2019ve added an awk invocation after listing our files via find (and file) and\nbefore we start grepping them. Breaking down the command:\n\n  * awk is our invocation of the awk tool.\n  * /Mach-O universal binary with 2 architectures/ && /arm64/ && /x86_64/ is the pattern that matches the first line output by file.\n  * { getline; getline; next } is the action block that executes on the lines matched by our pattern. We call getline twice to skip over the two architecture lines. next stops processing the current line since we don\u2019t want to do anything with the architecture lines.\n  * { print } the default action block to apply to anything that does not match our pattern. It lets them pass through and be printed.\n\nSo to put it all together, our awk invocation looks for lines that indicate a\nuniversal binary with two architectures and skips over the architecture lines,\nessentially ignoring the whole block.\n\nThe result of this invocation is:\n\n    \n    \n    ./dummy: Mach-O 64-bit executable x86_64 ./taste: Mach-O 64-bit executable x86_64 ./python3.10-intel64: Mach-O universal binary with 1 architecture: [x86_64:Mach-O 64-bit executable x86_64] ./python3.10-intel64 (for architecture x86_64): Mach-O 64-bit executable x86_64\n\nNow we no longer get ./vagrant-go as part of our results, but\n./python3.10-intel64 still appears twice. This is easily remedied by tacking\non another grep -v \"universal binary\" to the end of our commands.\n\n    \n    \n    \u279c find -L . -type f -exec file {} + | \\ awk '/Mach-O universal binary with 2 architectures/ && /arm64/ && /x86_64/ { getline; getline; next } { print }' | \\ grep 'x86_64' | \\ grep -v 'arm64' | \\ grep -v 'universal binary' ./dummy: Mach-O 64-bit executable x86_64 ./taste: Mach-O 64-bit executable x86_64 ./python3.10-intel64 (for architecture x86_64): Mach-O 64-bit executable x86_64\n\nAt this point our command chain is getting a bit too long. For the sake of\nsanity I will put it all in a file called find86_64.sh.\n\n> Side Note: If you\u2019re wondering what dummy is, let me show you the trick to\n> creating a dummy Mach-O x86_64 executable file for testing purposes.\n>  \n>  \n>     \u279c printf\n> '\\xcf\\xfa\\xed\\xfe\\x07\\x00\\x00\\x01\\x03\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n> > dummy\n>\n> This file won\u2019t execute, but running file on it gives us\n>  \n>  \n>     dummy: Mach-O 64-bit executable x86_64\n>\n> Which is good enough for testing.\n\nThe next step is to extract just the name of the file. We can leave in the\nleading ./ since ls (which we will run next) will accept that just fine.\n\nawk to the rescue again!\n\n    \n    \n    \u279c find86_64.sh | awk -F':| ' '{print $1}' ./dummy ./taste ./python3.10-intel64\n\nBreaking it down:\n\n  * awk -F':| uses either : or space as a field separator to split the line into multiple fields.\n  * {print $1} prints the first field, which, in our case, is the file name.\n\nOur updated script now looks like this.\n\n    \n    \n    #!/bin/sh find -L . -type f -exec file {} + | \\ awk '/Mach-O universal binary with 2 architectures/ && /arm64/ && /x86_64/ { getline; getline; next } { print }' | \\ grep 'x86_64' | \\ grep -v 'arm64' | \\ grep -v 'universal binary' | \\ awk -F':| ' '{print $1}'\n\nPipe that through xargs ls -l.\n\n    \n    \n    \u279c find86_64.sh | xargs ls -l -rw-r--r-- 1 shak admin 48 9 Mar 12:47 ./dummy lrwxr-xr-x 1 shak admin 81 9 Mar 12:57 ./python3.10-intel64 -> ../../../Library/Frameworks/Python.framework/Versions/3.10/bin/python3.10-intel64 -rw-r--r-- 1 shak admin 48 8 Mar 23:50 ./taste\n\nNote that we have a mix of regular files and symlinks (the l at the beginning\nof the permission string indicates a symlink, which we can also see by the\narrow pointing from ./python3.10-intel64 to what it is linked to). This is not\nunexpected. Package managers and installation scripts often write their\nbinaries to a location of choice and make them reachable for execution by\nsymlinking from places like /usr/local/bin/.\n\n> Side Note: If we were to pipe anything into ls by invoking | ls -l, it would ignore the piped input and run ls -l in the working directory, which is clearly not the behavior we want. This is because ls does not accept input piped into it. xargs converts the piped in input to arguments for ls to consume.\n\nIf we were to pipe the output of find86_64.sh directly into xargs rm, we would\nremove the files stored in /usr/local/bin. Which works well for the binaries\nthat are stored in this directory but for the ones that are symlinked, we will\nonly have their symlinks removed and not the underlying files.\n\nAfter a bit of research I found the readlink command which can be used to find\nthe target of a symbolic link.\n\n    \n    \n    \u279c readlink ./python3.10-intel64 ../../../Library/Frameworks/Python.framework/Versions/3.10/bin/python3.10-intel64 \u279c echo $? 0\n\nOn regular files it outputs nothing and exits with a 1.\n\n    \n    \n    \u279c readlink ./dummy \u279c echo $? 1\n\nWith this knowledge in mind, we can extend our script to read each line and do\nsomething different based on whether it\u2019s a symlink or a regular file.\n\n    \n    \n    #! /bin/bash find -L . -type f -exec file {} + | \\ awk '/Mach-O universal binary with 2 architectures/ && /arm64/ && /x86_64/ { getline; getline; next } { print }' | \\ grep 'x86_64' | \\ grep -v 'arm64' | \\ grep -v 'universal binary' | \\ awk -F':| ' '{print $1}' | \\ while read -r file; do if [ -L \"$file\" ]; then target=$(readlink \"$file\") echo \"$file is a symlink targeting $target\" else echo \"$file is a regular file\" fi done\n\nBreaking it down:\n\n  * while read -r file reads each line, the -r prevents any backslashes from being processed as escape sequences, preserving the original content of the line.\n  * if [ -L \"$file\" ] checks if the file is a symlink\n\nAnd the rest is just echos. You can imagine how this could be replaced with a\nbunch of rms to clean up our unwanted binaries. Disinclined to take\nresponsibility for shenanigans apart from my own, I will leave that final bit\nof scripting to the reader.\n\n## Easier Than I Imagined\n\nI talked to a colleague who got his Apple Silicon Mac more than three years\nago when these things were fresh out of the oven. His tales of trial and\ntribulations made me grateful that I am making the move now when so many\nprojects have adopted Apple Silicon and have arm versions released. I code\nprimarily in Golang, and it was almost trivial to clean up my old Golang\nversions and install Apple Silicon compatible ones.\n\n## Wrapping it Up\n\nI started a draft for this post when I began my migration journey. I imagined\nI would have to go through a lot more trouble than I actually ended up going\nthrough. Almost every app had an Apple Silicon version that was a simple\ndownload+replace operation and the story held true for nearly everything I\nneeded to install via brew. I was up and running in a matter of hours.\n\nHaving said that, the scripting journey was a lot of fun. I had to dust off\nsome old Unix tools and learn a few new ones. I also got to play with some of\nthe more arcane features of these tools. I hope you had as much fun reading\nabout it as I did writing about it.\n\nI thank everyone who have been experimenting with Apple Silicon these last few\nyears. They walked with hobbling steps, so people like me could run.\n\nTags: #apple #shell-scripting\n\nM \u2193 Markdown\n\nCommento\n\n## More posts like this\n\n## Alerting on Process Completion\n\n2024-04-04 | #home-assistant #shell-scripting #webhooks\n\nMost of my technical endeavours have something to do with enabling me to work\nas little as possible for as much reward as possible. And yet, paradoxically,\nin a pursuit of doing less I often end up doing more. I have this idea that in\nthe long term this will eventually lead me to doing much less. I\u2019m not sure if\nthat\u2019s true, but it\u2019s a nice thought and keeps me going.\n\nContinue reading\n\n2024 \u00a9 Shaun Das - Creative Commons Attribution 4.0 International License.\n\nFicurinia theme for Hugo by Gabriele Musco. Licensed under GNU AGPLv3.\n\n", "frontpage": false}
