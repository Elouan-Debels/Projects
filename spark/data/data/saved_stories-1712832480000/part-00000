{"aid": "39998474", "title": "When and how C++ variables are initialized?", "url": "https://www.sandordargo.com/blog/2024/04/10/initializations-part-1", "domain": "sandordargo.com", "votes": 1, "user": "jandeboevrie", "posted_at": "2024-04-11 04:46:21", "comments": 0, "source_title": "When and how variables are initialized? - Part 1", "source_text": "When and how variables are initialized? - Part 1 | Sandor Dargo's Blog\n\nSandor Dargo's Blog\n\nOn C++, software development and books\n\n  * HOME\n  * CATEGORIES\n  * TAGS\n  * ARCHIVES\n  * BOOKS\n  * SPEAKING\n  * DAILY C++\n  * HI...\n\nBlog 2024 04 10 When and how variables are initialized? - Part 1\n\nPost\n\nCancel\n\n# When and how variables are initialized? - Part 1\n\nSandor Dargo 1 day ago2024-04-10T00:00:00+02:00\n\n5 min\n\nRecently, I shared a story with you about a bug, about a manifestation of\nundefined behaviour a compiler upgrade uncovered. There we briefly looked into\nwhy a member was left uninitialized, but the topic of initialization deserves\na deeper look.\n\nLet\u2019s look first at C++ Reference. It matters where you check, but you might\neven find 8 different types of initialization.\n\nI had a bit of a hard time understanding how all of them relate to each other.\nSo I decided to go over each of them and just see if they mention/reference\nothers. Here is what I found:\n\n  * Default-initialization: zero-initialization\n  * Zero-initialization: value-initialization, non-local initialization, constant-initialization\n  * Value-initialization: aggregate-initialization, list-initialization, default-initialization, zero-initialization, copy-initialization\n  * Aggregate-initialization: list-initialization, copy-initialization, direct-initialization\n  * List-initialization: direct-list-initialization, copy-list-initialization, aggregate-initialization, copy-initialization, direct-initialization\n  * Direct-initialization: list-initialization, aggregate-initialization, value-initialization, copy-initialization\n  * Copy-initialization: list-initialization, aggregate-initialization, direct-initialization\n  * Constant-initialization: default-initialization\n  * Reference initialization: list-initialization, copy-initialization, direct-initialization\n\nThat\u2019s plenty of connections. How can we categorize initializations? How can\nwe start learning them?\n\nI had two ideas in mind, a top-down and a bottom-up approach. The top-down in\nthis case would mean that we start with those that reference others and as we\nneed more details, we get deeper. With the bottom-up approach, we\u2019d start with\nthe details and once we understand them, we use them to build up higher-level\nconcepts.\n\nThe problem is that the above list is full of cycles, only reference-\ninitialization is not referenced by others.\n\nSo let\u2019s use another approach, which is based on C++ reference\u2019s.\n\n## 3 initialization syntaxes\n\nC++ reference lists 4 distinct syntaxes to perform initialization, but two\nforms use the same rules, the same list-initialization-syntax.\n\nThe first listed syntax involves an = and an expression right after. That is\nthe copy-initialization syntax and will invoke copy-initialization of the\nobject on the left of the equation sign operator. E.g. T obj = foo();\n\nThe second syntax still involves braces. It doesn\u2019t matter whether those\nbraces follow an =, the syntax is called the list-initialization syntax and\nthey will invoke the rules of list initialization. The pair of braces can be\neither empty, contain an initializer list or a designated initializer list.\nE.g. T obj = {.foo = 42, .bar = 13}\n\nThere is another syntax where the variable name is followed by a pair of\nparentheses (()) with an initializer-list in between. This syntax is called\ndirect-initialization syntax and therefore the object will be direct-\ninitialized. E.g. T obj(\"foo\", bar)\n\nIn this article, we are going to cover the first one from that list, copy-\ninitialization and during the next weeks, we\u2019ll cover the rest.\n\n## Copy-initialization\n\nPreviously, we saw that copy-initialization is invoked by the copy-\ninitialization syntax such as T obj = foo(). But copy initialization will also\nhappen when you pass an argument by value to a function or when you return a\nvariable by value from a function. Let\u2019s not forget about throwing or catching\nan exception by value also uses copy-initialization! And we\u2019ll also see copy-\ninitialization later, as part of aggregate initialization.\n\nLet\u2019s see the effects of copy-initialization.\n\n    \n    \n    1 2 3 4 5 6 7 8\n\n|\n\n    \n    \n    class MyClass { /* */ }; MyClass foo() { return MyClass(); } // ... MyClass mc = foo();  \n  \n---|---  \n  \nIn the above snippet, mc is copy-initialized from the return value of foo().\nSince C++17 copy elision is guaranteed, so only one MyClass object is\ninstantiated, there are no temporary objects created.\n\n    \n    \n    1 2 3 4 5\n\n|\n\n    \n    \n    class MyClass { /* */ }; // ... MyClass mc; MyClass mc2 = mc;  \n  \n---|---  \n  \nThis is also a copy-initialization and it would still be called a copy\ninitialization if mc was moved (MyClass mc2 = std::move(mc)). In these cases,\nthe copy and move constructors are invoked. Otherwise, when there are the same\ntypes on both sides or on the left side there is a derived type of the type to\nbe initialized, the compiler would examine all the non-explicit constructors\nof the type on the left to find the best match by overload resolution and call\nit.\n\nIf the types are not the same on both sides, the left side is also not a\nderived type of the left side and at least one side is not a class type then\nthe compiler will consider user-defined conversion sequences.\n\n> A user-defined conversion consists of zero or one non-explicit single-\n> argument converting constructor or non-explicit conversion function call.\n\nThe above definition means that explicit constructors are not considered user-\ndefined conversions. Let\u2019s expand our MyClass to see the above in action.\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\n|\n\n    \n    \n    #include <string> class MyClass { public: MyClass() = default; explicit MyClass (const std::string& s): m_s(s){} private: std::string m_s; }; int main() { // MyClass mc = \"not OK\"; using namespace std::string_literals;; // MyClass mc2 = \"also not OK\"s; MyClass mc = MyClass(\"OK\"); // just to keep the copy-initialization syntax, but normally you simply call MyClass mc(\"OK\"); }  \n  \n---|---  \n  \nWe can see that we must explicitly invoke an explicit constructor, otherwise,\nit\u2019s not considered even if it wouldn\u2019t require a conversion from const char*\nto std::string. On the other hand, when we invoke the constructor, an implicit\nconversion is performed for the parameter.\n\nIf there are non-class types on both sides, the compiler will consider\nstandard conversions if necessary.\n\n    \n    \n    1 2\n\n|\n\n    \n    \n    int num = true; // OK num is 1 const float val = num; // OK val is 1.0  \n  \n---|---  \n  \n## Conclusion\n\nLast week, piggybacking a bug caused by undefined behaviour, we discussed why\nknowing about the different types of initializations in C++ is important. This\nweek, we started a discovery of the different types and syntaxes of\ninitialization and we discovered the details of copy-initialization.\n\nNext week, we\u2019ll continue with list- and direct-initialization. Stay tuned.\n\n## Connect deeper\n\nIf you liked this article, please\n\n  * hit on the like button,\n  * subscribe to my newsletter\n  * and let\u2019s connect on Twitter!\n\ndev\n\ncpp fundamental initialization copyinitialization\n\nThis post is licensed under CC BY 4.0 by the author.\n\nShare\n\nRecent Update\n\n  * Upgrading the compiler: undefined behaviour uncovered\n  * C++23: Encoding related changes\n  * Multiple destructors with C++ concepts\n  * How to write your own C++ concepts? Part II.\n  * C++23 likes to move it!\n\nTrending Tags\n\ncpp books watercooler career tutorial stl algorithms cpp23 management\nphilosophy\n\nContents\n\n### Further Reading\n\n8 days ago2024-04-03T00:00:00+02:00\n\n### Upgrading the compiler: undefined behaviour uncovered\n\nNot so long time ago, I already mentioned the differences between the\ndifferent kinds of initializations in my article, Struct Initialization. In\nthe coming weeks, I\u2019m going to revisit the topic. ...\n\nOct 25, 20222022-10-26T00:00:00+02:00\n\n### The evolution of statements with initializers in C++\n\nIn the coming two articles, we\u2019ll see how C++ evolved in terms of writing\ndifferent statements that include initializers. Simple? Boring? I don\u2019t think\nso, it just shows how far we got in C++ and i...\n\nNov 1, 20222022-11-02T00:00:00+01:00\n\n### The evolution of statements with initializers in C++ - part 2\n\nIn these two articles, we see how C++ evolved in terms of writing different\nstatements that include initializers. Simple? Boring? I don\u2019t think so, it\njust shows how far we got in C++ and in progra...\n\nUpgrading the compiler: undefined behaviour uncovered\n\n-\n\nComments powered by Disqus.\n\n\u00a9 2024 Sandor Dargo. Some rights reserved.\n\nPowered by Jekyll with Chirpy theme.\n\n#### Trending Tags\n\ncpp books watercooler career tutorial stl algorithms cpp23 management\nphilosophy\n\n", "frontpage": false}
