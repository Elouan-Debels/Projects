{"aid": "40039020", "title": "Python is Actually Portable (2022)", "url": "https://ahgamut.github.io/2021/07/13/ape-python/", "domain": "ahgamut.github.io", "votes": 21, "user": "thunderbong", "posted_at": "2024-04-15 11:17:44", "comments": 0, "source_title": "Python is Actually Portable | Blog Needs a Name", "source_text": "Python is Actually Portable | Blog Needs a Name\n\nSkip to main\n\nBlog Needs a Name\n\n  * Home\n  * About\n\n## Python is Actually Portable\n\nUpdate (2022-07-27) : This post describes a proof-of-concept Python executable\n(2.7.18 and 3.6.14) built on Cosmopolitan Libc, which allows it to run on six\ndifferent operating systems (Linux, Mac, Windows, NetBSD, FreeBSD, OpenBSD).\nIt\u2019s been more than a year since I put this together, and now Python3.6 and\nits test suite are part of the Cosmopolitan Libc monorepo. There\u2019s been a LOT\nof work done to improve python.com over vanilla Python3.6 \u2013 a custom\nsys.meta_path entry for faster loading, size reductions of the unicodedata, a\ncosmo module for Cosmopolitan-specific goodies, a revamp of Python\u2019s build and\ntesting system, a superb REPL experience, backports from Python 3.7, and a lot\nmore! So some of the details in this blog post are likely out of date. Check\nout the history of APE Python here, build it via the Cosmopolitan monorepo, or\ndownload python.com from here. I\u2019m also trying to port the newer versions of\nPython and some well-known Python packages like numpy. Join the discussion\nabout Python and Cosmopolitan Libc in the redbean Discord server:\nhttps://discord.gg/rGQja6kS\n\nBack in February, I put together Lua 5.4 using Cosmopolitan Libc as a quick\nproof-of-concept, and that led to Lua 5.4 being vendored as part of the\nCosmopolitan repository on Github, along with many other interesting\ndevelopments. It\u2019s pretty exciting to try and compile well-known C projects\nusing Cosmopolitan; the portability reward is great motivation, and I get to\nobserve the design, coding style, and build system of high-quality codebases.\n\nHowever, my initial plan with Cosmopolitan was not to compile Lua, it was to\ncompile Python. Since February, I\u2019ve been trying to understand how\nCosmopolitan works, reading the repo code and submitting PRs occasionally, and\nfinally I have an actually portable version of Python 2.7.18 (and 3.6.14^1) \u2013\nyou can build it from the repository here. It\u2019s not solid as Lua 5.4 because\nit currently passes only a third of the regression tests, but most of the\nparts are there. For example, here\u2019s a GIF showing a simple Flask webapp\nrunning via the python.com APE.\n\nIt\u2019s quite slow, but it works(tested on Debian Linux and Windows 10^2), and\nthere\u2019s a lot of room for improvement. This post describes the kinds of\nchanges I made to get Python to work.\n\n## Getting Python to compile\n\nPython 2.7.18 is built via the configure idiom: the tarball provides a\nconfigure shell script which runs the necessary compatibility tests for the\nhost system/compiler. which then creates the Makefile for the actual build,\nand fills pyconfig.h with the necessary #defines related to the features\navailable in the host system.\n\nI added dummy headers like for Lua, and wrote a superconfigure script which\ncalled configure with the flags for the Cosmopolitan amalgamation, like below:\n\n    \n    \n    ./configure --disable-shared \\ --without-threads --disable-ipv6 \\ CFLAGS=\"$COSMO_CFLAGS\" \\ LDFLAGS=\"$COSMO_LDFLAGS\" \\ LIBS=\"cosmopolitan.a\" make -j4\n\nThis started the build, but almost every source file had complaints about\nfunctions being re-declared. For example, the Makefile assumed that sinh was\nnot available, and wrongly had #define HAVE_SINH 0, which caused it to use\nPython\u2019s backup implementation.\n\nIt turns out that the CFLAGS provided for the cosmopolitan amalgamation\nclashed with AC_CHECK_FUNC, which is what configure scripts use to check if\nthe host provides a particular function. At the time, the simplest fix was to\nedit the AC_CHECK_FUNC part of configure script to make it play well, and it\njust worked^3.\n\nAfter that, fixing the remaining errors was mostly straightforward: add a few\n#defines or #undefs to avoid missing functions, ensure the Makefile performed\nthe linking correctly, find-and-replace for name clashes^4, and so on.\n\n## Running the base interpreter\n\nI tried running the python.com APE within the build directory, and it worked\nwithout a hitch. But when I moved the executable somewhere, the interpreter\nwould start up and then exit with a failure unable to import site: Python\nchecks for site.py in sys.path at startup, which sets up the import context\nfor the rest of the standard library (stuff like which OS the APE is on for\nos.py). Running python.com -S fixed the issue^5, and later I added a few\nrelative folder paths to sys.path so that Python could search there at\nstartup.\n\nOne annoying issue I faced with the python.com REPL on Linux was I had to\npress Return twice when I wanted to enter an empty line to the REPL. By\nrunning python.com -u I found out this this was related to input buffering and\nsetvbuf: the interpreter was following Cosmopolitan\u2019s choice of buffering IO,\nso I added a couple of lines to use unbuffered input by default.\n\nWhen I tried python.com -S on Windows, the interpreter would start, but then\nevery line I entered at the REPL would cause a syntax error. I thought this\nwas also related to setvbuf, but this was because Windows cmd.exe sends CRLF\non pressing Return, and the interpreter expects only LF, so the CR was read as\nincorrect syntax. It was straightforward to change the parser logic.\n\n## Adding standard library modules\n\nWhen the Makefile finishes building python, it immediately tries to call a\nsetup.py to build C extensions for the standard library. This was pretty\nstupid: setup.py tries to build and link a bunch of shared objects to the\ninterpreter even though I\u2019ve specified a static build (--disable-shared). I\nfound out it was doing this after I saw a successful build on the screen,\nfollowed a deluge of (unable to link/no dlopen/Rdynamic specified but also\nstatic) errors.\n\nThere is a nice way to compile C extensions into Python statically: via\nModules/Setup. This file follows a simple syntax to specify extensions and\ntheir requirements, so that you can compile extensions before setup.py is\ncalled.\n\n    \n    \n    *static* # <name of extension> <source files in Modules folder> <includes> <links> -DSOME_FLAG math mathmodule.c _math.c # -lm array arraymodule.c\n\nCalling make after changing Modules/Setup rebuilds the Makefile with the\nnecessary recipes for the specified extensions. You can read about\nModules/Setup here. One nasty aspect of this is if the syntax in Modules/Setup\nis wrong, the Makefile will be wrong, so you can\u2019t run make even after you\u2019ve\nfixed the error.\n\nI was able to compile a lot of modules into APE using Modules/Setup: basic\nmodules like cPickle, zlib etc., modules that required external libraries like\n_sqlite, _bz2, readline, _ctypes^6 etc., and even external packages that\ndepend on simple C extensions, like greenlet. It all boils down to writing the\ncorrect recipe in Modules/Setup, ensuring the necessary static libraries are\navailable, and checking that the glue code around the imports works\ncorrectly^7.\n\nThe final annoyance with the stdlib python files was that I had to copy the\nfolder containing them alongside python.com, but this got solved because\nCosmopolitan allows the APE to be used as a valid ZIP file. I just zipped up\nLib/ into the APE, added python.com itself as an entry in sys.path, and\nPython\u2019s own zipimport package handled the rest.\n\n## Using pip and external packages\n\nAfter compiling most of the standard library packages, I still couldn\u2019t get\nensurepip to work, because it relied on threads, and the standard threading\nmodule in Python would just raise an ImportError if it could not find the\n_thread C extension. The fix was present within the stdlib: there is a module\ncalled _dummy_thread, which spoofs _thread so that threading doesn\u2019t\ncomplain^8. After this, I was able to run ensurepip to install pip and\nsetuptools in Lib/site-packages.\n\nHowever, running python.com -m pip install doesn\u2019t work because the Python APE\ndoe not currently have SSL support. I tried providing http://pypi.org/simple\nas the index URL but pip was adamant in not letting me get my way.\n\nI didn\u2019t want to figure out how to add SSL support to the APE (I expect it\nshould be possible^9), so I just cheated and downloaded the packages manually.\nThe arrangement to add packages works like this:\n\n    \n    \n    mkdir -p Lib/site-packages # specify python version to pip if necessary /usr/bin/python2 -m pip download flask -t . # wheels are just ZIPs, use unzip if pip complains ./python.com -m pip install flask*.whl -t ./Lib/site-packages zip -qr ./python.com ./Lib/site-packages/ rm -rf ./*.whl ./Lib/site-packages/ ./python.com -m flask --version\n\nOf course, you would have recompile the APE if you wanted to add any C\nextensions.\n\n## Closing Notes\n\nIt is really convenient to have the same application work on\nLinux/Windows/MacOS, but the techniques I have seen/used all have tradeoffs:\neither for the developer in terms of design, testing, and safety/consistency,\nor for the user in terms on application size and performance.\n\nCosmopolitan Libc does come with some tradeoffs as well (static compilation, C\ncodebases, no multithreading (Update 2022-07-27:, no multithreading yet, the\npthreads API takes a while to fill)), but I think it is amazing that I can\nsend a python.com executable of a few megabytes as a zip file to someone, have\nthem run it without worrying about the OS, and provide them a simple webapp\nwith a backend that works even without an internet connection.\n\nThis successful python.com experiment unlocks many interesting directions:\n\n  * Is it possible to tune the performance of the python.com APE? I don\u2019t expect it to get anywhere close to redbean, but some speed improvements would be nice because Python web frameworks are established and easy to use.\n\n  * Is there room for a custom build system to produce a single-file size-optimized python.com APE webapp? We saw that it is possible to add C extensions, and even regular packages into the executable via zip. If there is a dependency resolver that accounts for stdlib imports, which then produces a Modules/Setup or some similar build script to compile extensions and add only the necessary libraries, that would be awesome^10. (2022-07-27: now the Cosmopolitan monorepo builds python.com via a Makefile, checks import dependencies at link-time, runs the Python test suite, and adds all files to the APE internal ZIP store ready-to-use).\n\n  * Regarding python packages with C extensions, the build process for adding them to the APE is rather unwieldy (2022-07-27 adding C extensions to the APE is much more elegant now because of the Cosmopolitan monorepo, see this) because of all the manual changes involved. Is there a way to automatically patch the imports, or better yet, compile Python C extensions as shared libraries with Cosmopolitan?\n\n  * I\u2019ve managed to compile Lua, QuickJS, and now Python2.7 and Python3.6. Are there web-friendly languages that would benefit more from a Cosmopolitan build? Maybe PHP, or Ruby, or even Go if the details work out? Remains to be seen.\n\n  1. Did you click on this before reading the remainder of the post because you were wondering about Python 3? I know Python 2.7 reached EOL last year, but the Python 2.7 codebase was easier to read, change, and debug, so I was able to get a better idea of where I had to make changes. I put together a Python 3.6.14 APE (build it from the repo here), and it took much less time and experimentation because I knew exactly where to look. \u21a9\ufe0e\n\n  2. I originally uploaded this post like twelve hours, in the excitement of seeing a Flask webapp work on the APE. Unfortunately, I forgot to test on Windows before putting the post out, and Windows, true to its nature caused several annoyances which together took a couple of hours to sort out. However, I think it ought to work now. \u21a9\ufe0e\n\n  3. I originally tried the complicated solution of writing a new configure script from scratch, but I got lost in the docs for autoconf, and resorted to the simpler fix of just editing the shell script. This issue only happened because I used dummy headers with the amalgamation; if you have the Cosmopolitan repo nearby, you can use -isystem cosmopolitan/libc/isystem instead of -I dummy_headers -include cosmopolitan.h, which would avoid confusing configure. \u21a9\ufe0e\n\n  4. I remembered this a few days back: if a name in your C file clashes with a header name somewhere, you can do something like:\n    \n        #ifdef name #define name __name #undef name\n\nand avoid the name clash instead of doing a find-and-replace. \u21a9\ufe0e\n\n  5. Over the course of getting the APE to work, my muscle memory is to call python -BESsuv, which avoids a bunch of normal startup stuff and adds stderr information about imports. This is super useful when building python, but one time I was running a local script and couldn\u2019t figure out why it was failing before I saw that I had typed python -BESsuv script.py every single time. \u21a9\ufe0e\n\n  6. I was pleasantly surprised to find out that _sqlite and _bz2 could be compiled, because I didn\u2019t expect SQLite or libbz2 would be easy to compile from source with Cosmopolitan. SQLite is now vendored in the Cosmopolitan repo.\n\nOn the other hand, I wanted readline because I like to have the (press-Up-\narrow-for-previously-typed-line) in the REPL, but I didn\u2019t know how terminfo\nworked. _ctypes was also a disappointment because I had to compile libffi from\nsource, and then I saw most of _ctypes\u2019 use comes from having dlopen. \u21a9\ufe0e\n\n  7. for example, greenlet contains a C extension called _greenlet which it refers to by doing things like the following in __init__.py:\n    \n        from ._greenlet import foo from greenlet._greenlet import bar\n\nnow __init__.py expects _greenlet.so to be present in the same directory, but\nthat is not possible because the extension is compiled into the interpreter\nstatically. So I had to manually change this to use from _greenlet without the\ndot. This also means I have to change the extension name in the PyModuleDef\npart of the C source code: it\u2019s not greenlet._greenlet anymore, it\u2019s just\n_greenlet. \u21a9\ufe0e\n\n  8. This works because most libraries use only the high-level threading API to handle their threads. A notable counter-example is Django: I tried getting Django to work before figuring out how _greenlet could be compiled, but Django imports the low-level _thread API to handle things. \u21a9\ufe0e\n\n  9. It is possible to have SSL support: you just have to build OpenSSL with Cosmopolitan Libc. I was able to build libssl.a, link it with python.com via Modules/Setup, and pip worked. However, I have not tested it with the OpenSSL test suite. \u21a9\ufe0e\n\n  10. The Cosmopolitan repo builds python.com using PYOBJ.COM, a minimal Python executable that creates .pyc files and symbols for the linker to resolve dependencies. \u21a9\ufe0e\n\nCopyright \u00a9 2023 Gautham Venkatasubramanian\n\n", "frontpage": true}
