{"aid": "40037178", "title": "Make it easy for me to review your code", "url": "https://gaurangtandon.com/blog/easy-code-review", "domain": "gaurangtandon.com", "votes": 4, "user": "gaurang_tandon", "posted_at": "2024-04-15 04:51:47", "comments": 0, "source_title": "Make it easy for me to review your code", "source_text": "Make it easy for me to review your code | Gaurang Tandon\n\nGaurang Tandon\n\n# Make it easy for me to review your code\n\nApr 15, 2024\n\nAlmost every software engineer - irrespective of their tech stack - writes\ncode collaboratively via Git. They submit their fixes or features as\nchangesets. One of their colleagues then reviews the changeset and approves or\nrejects it. This reviewer must approve your changeset before it can be merged\nand deployed.\n\nThe reviewer\u2019s job is tiring and thankless. They have to:\n\n  1. understand the context of your change, such as the issue at hand\n  2. review your design to ensure that no other design is more feasible\n  3. review the actual code to ensure it is a high-quality implementation\n  4. test the implementation to ensure it actually works\n\nIn this blog, I present specific and actionable suggestions, so you can make\nit easy for any reviewer to review your changeset. The mantra is to reduce the\ndiff and make it understandable. All of the following suggestions directly\nimplement this mantra.\n\n## Reduce the diff\n\ntl;dr: Reviewing 5 separate changesets is easier than one giant bundled\nchangeset because smaller, focused changes are easier to understand, test, and\nvalidate. It reduces cognitive load, improves visibility into changes, and\nallows for more targeted feedback and testing.\n\n### Do not make unrelated code changes\n\nIt is easy to accidentally bundle code formatting or code refactoring changes\nin your primary changeset. Note that any formatting or refactoring change\nshould always be in its own separate changeset. Your primary changeset that\nimplements a bugfix should never also be renaming multiple variables or\nchanging indentations.\n\nAs a rule of thumb: you can separate changesets by their effect on the\napplication\u2019s function. Any code refactor or formatting will likely be a non-\nfunctional changeset. Any bugfix or feature is likely a functional changeset.\nYou should keep these changesets separate.\n\nIn practice, this separation makes the reviewer\u2019s task easy: I know this\nchangeset is only for code formatting, so any functional change is probably a\nmistake, and I should flag it.\n\n### Focus each changeset on one specific issue\n\nWhen working on one bugfix, it is easy to find more bugs on the same feature.\nThe natural tendency is to bundle their bugfixes together in the changeset.\nAfter all, all the bugs are related to the same feature, and you fixed them\naround roughly the same time.\n\nPractically, when all the bugfixes are bundled in one changeset, most code\nreview tools (like in GitLab/GitHub) will present one large diff for all\nbugfixes together. This makes it difficult for the reviewer to understand\nwhich part of the diff corresponds to which bugfix.\n\nYou should put each bugfix in its own dedicated changeset, as this gives the\nreviewer (and you) the ability to reason about each bugfix independently.\n\nAs a rule of thumb, write a simple one-sentence summary of your changeset, and\nif the changeset does more than just the summary, it should be split up.\n\n### Split large changesets into multiple sequential parts\n\nChangesets that implement large features, such as a new user walkthrough, are\nvery difficult to review. That is because often these changesets implement the\ncore feature and also re-organize a lot of the related code. For example: they\nextract helper functions from existing code.\n\nIt usually makes sense to split out these reorganization changes into a\ndedicated changeset. This makes the reviewer\u2019s task easy, because 1. this is a\nnon-functional changeset, and 2. it reduces the size of the primary changeset\n(which would now be just the core feature).\n\nThe rule of thumb I follow is: I first write the feature changeset fully. Once\nit is done, then I extract the non-functional changes into a separate\nchangeset and send that first.\n\n## Make the changeset understandable\n\ntl;dr: Reviewing understandable changesets avoids needless asynchronous back-\nand-forth, and saves everyone time.\n\n### Explain confusing changes\n\nYou should always explain any change that is not immediately obvious. This\nsaves the reviewer time from having to ask you a question, and you from having\nto respond to it. In asynchronous/remote teams, this saves everyone time.\n\nAs a rule of thumb, if I feel any part is confusing, I always explain it ahead\nof time, because the reviewer is likely to find it confusing too.\n\n### Explain alternative solutions for the same issue\n\nThe reviewer is also a subject matter expert just like you. They\u2019re likely to\nthink of other solutions to the same issue. If you have also thought about\nthem, you should make that clear in the changeset. Specifically: which other\nsolutions did you implement, and why did they fall short of the proposed\nsolution?\n\nWithout your explanation, the reviewer will just be confused: Why didn\u2019t we\nimplement solution X which appears much simpler?\n\n### Add tests\n\nTests help the reviewer understand how a given bug manifests in practice.\nTests also give the reviewer confidence that your implementation does fix that\nbug. Finally, tests clarify your thought process, because they describe all\nthe instances that you consider relevant to the bug. This allows the reviewer\nto suggest any new instance which should also be tested in this changeset.\n\n## Conclusion\n\nI hope you found the blog post useful. Feel free to reach out to me to\ncontinue the discussion.\n\n## Gaurang Tandon\n\n  * Gaurang Tandon\n  * gaurangtandonone at gmail dot com\n\n  * gaurangtandon\n  * alltimecoder\n\nI write about tech stuff.\n\n", "frontpage": false}
