{"aid": "39983046", "title": "Design is not recoverable from implementation", "url": "https://ericnormand.substack.com/p/design-is-not-recoverable-from-implementation", "domain": "ericnormand.substack.com", "votes": 2, "user": "todsacerdoti", "posted_at": "2024-04-09 19:10:43", "comments": 0, "source_title": "Design is not recoverable from implementation", "source_text": "Design is not recoverable from implementation\n\n# Eric Normand's Newsletter\n\nShare this post\n\n#### Design is not recoverable from implementation\n\nericnormand.substack.com\n\n#### Discover more from Eric Normand's Newsletter\n\nSoftware design, functional programming, and software engineering practices\n\nOver 5,000 subscribers\n\nContinue reading\n\nSign in\n\n# Design is not recoverable from implementation\n\n### Continuous improvement is the only way\n\nEric Normand\n\nApr 09, 2024\n\n3\n\nShare this post\n\n#### Design is not recoverable from implementation\n\nericnormand.substack.com\n\nShare\n\nHere is some news before I dive into the essay:\n\nI've published a \"readable\" draft of Chapter 3: Operation Lens. By readable, I\nmean it is worth your time without implying perfection. Operation Lens is\nwhere the rubber meets the road. The data lens may have seemed simple and\nuninteresting. However, the operation lens delves deep into the separation\nbetween specification and implementation. This concept separates the juniors\nfrom the seniors\u2014getting it to work vs designing it. If you were skeptical of\nthe previous chapters for being too basic, I'd love to hear your thoughts on\nthe new one.\n\nAnd now for the essay:\n\n#\n\nDesign is not recoverable from implementation\n\nOne glance at line 50 in the 100-line function told me we couldn't refactor\nit. The design was lost, and the only way to recover it was to reconstruct it\nfrom other sources like the git commits log, the tests, and programmers'\nmemories.\n\nThis was during a recent episode of Apropos. We analyzed a lengthy function\nwith plenty of duplication, making mental notes of what we might refactor to\nreflect the design better. Then, we hit a conditional that did not follow the\npattern. It seemed to come out of nowhere.\n\nThe behavior was apparent: If the error type was a particular constant,\nrethrow the exception. It was a special case that had some meaning to the\nprogrammer. But, the design was unclear. Why was that type special for this\nparticular try/catch block? What code might set that error type and why? We\nhad more questions than answers.\n\nThis phenomenon of lost design could be a law of code, similar to the law of\nincreasing entropy: Without energetic intervention, the implementation tends\nto diverge from the design. Given enough time, the codebase will not resemble\nthe mental structures a programmer uses to understand it. And just like you\ncan't reverse the shattering of a teacup, you can't recover the lost design.\n\n> In the long run every program becomes rococo\u2014then rubble. - Alan Perlis\n\nA corollary to this law is that you should put your design into the code while\nit's still fresh in your mind. What concepts are you using to think through\nhow the software should work? These mental concepts are the design. Try to get\nthat into the code before you forget it because it will only worsen over time.\nYour memory fades. As more people touch that code to fix bugs and add\nfeatures, the further it will drift from the design.\n\nAnother corollary is that you should write your design first and implement it\nsecond. If you can\u2019t go from implementation to design but can go from design\nto implementation, it\u2019s obvious which order to write them in. The practical\nproblem is that you don\u2019t know the design until you implement it at least\nonce. Implementation gives us so much information. The process is iterative.\n\nA stronger version of the law states that a single implementation always\ncorresponds to multiple designs. No matter how fresh the code is, it is\nalready impossible to decide between the designs. The best you can do is to\nmake your code eliminate as many designs as possible, especially the more\nlikely but incorrect ones.\n\nIf this is a law, why are we so opposed to \"over-designing\" or \"over-\nabstracting.\" Instead of building the design into the code, we write the code\nto be simple and work. We avoid indirection. There's wisdom to that, but why?\n\nThe root cause is that we've learned lousy design. To many, design means\nlooking for ways to apply cookie-cutter patterns\u2014the more, the better! To\nothers, it means anticipating changes and defensively adding indirection, just\nin case some things change. After we learn bad design, we learn to stop\ndesigning, and then (maybe) we learn good design.\n\nAnticipating changes is not design. Design is the higher level understanding\nof how we decompose the system into interacting parts. We cannot keep the\nentire system in our heads. We must subdivide it hierarchically to have any\nchance of understanding it. We break the whole thing into a manageable number\nof parts. If those parts are too big, we break them up. And so we proceed\nrecursively until we're at a manageable level. How you decompose is the art of\ndesign. That's all I'll say here.\n\n> Everything should be built top-down, except the first time. - Alan Perlis\n\nThis law is one of the reasons I am skeptical of refactoring. Yes, refactoring\nis good. However, good refactoring is about recovering the design. Proponents\nassume you can find it either in the code or the tests. But the assumption\ndoesn't hold. Sometimes, you have to impose a new design because you can't\nrecover it, and that new design requires different behavior. So, by\ndefinition, you can't use refactoring.\n\nFinally, I want to explore whether you should encode a bad design. Or, put\nanother way, is it better to have undesigned code that works or poorly\ndesigned code that works? Since it's impossible to have a perfect design, we\nmust allow bad design by induction.\n\nThe extreme of bad design is needlessly convoluted to the extent that it hides\nthe underlying behavior. We might encode the design in the code, but it is\nless legible than no design. Moreover, people who wrote the bad design think\nit's good. Telling people they can only encode good design into the codebase\ndoesn't help.\n\nThe only solution I know is to have them write the design separately from the\nimplementation. That way, it might become apparent how complicated it is and\nseek to simplify it. But that's not assured. Some people consider complication\na sign of sophistication. Maybe not everyone can have good taste.\n\nIn the end, design is an aesthetic skill since every decision is\ninterconnected and full of tradeoffs. We need good taste to make good designs,\nand we develop taste through experience and experimentation. Building software\nis iterative. So this is the only path forward: The programmers must\ncontinuously improve their design skills, they must use that skill to improve\nthe design, and they must improve the code to reflect that design better.\n\n### Subscribe to Eric Normand's Newsletter\n\nLaunched 5 months ago\n\nSoftware design, functional programming, and software engineering practices\n\n3 Likes\n\n3\n\nShare this post\n\n#### Design is not recoverable from implementation\n\nericnormand.substack.com\n\nShare\n\nComments\n\n[EN 480] Restarting my newsletter\n\nThis is my first issue in a whole year\n\nNov 6, 2023 \u2022\n\nEric Normand\n\n30\n\nShare this post\n\n#### [EN 480] Restarting my newsletter\n\nericnormand.substack.com\n\n10\n\nComplexity begets complexity\n\nNov 13, 2023 \u2022\n\nEric Normand\n\n24\n\nShare this post\n\n#### Complexity begets complexity\n\nericnormand.substack.com\n\n2\n\nThe most underrated book in software engineering management\n\nIdea Flow by Janelle Arty Starr\n\nDec 11, 2023 \u2022\n\nEric Normand\n\n19\n\nShare this post\n\n#### The most underrated book in software engineering management\n\nericnormand.substack.com\n\nReady for more?\n\n\u00a9 2024 Eric Normand\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great writing\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
