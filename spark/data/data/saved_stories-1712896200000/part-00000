{"aid": "40007472", "title": "The 'Story of Mel' Explained", "url": "https://jamesseibel.com/the-story-of-mel/", "domain": "jamesseibel.com", "votes": 1, "user": "ColinWright", "posted_at": "2024-04-11 22:27:48", "comments": 0, "source_title": "The \u2018Story of Mel\u2019 Explained", "source_text": "The \u2018Story of Mel\u2019 Explained | James Seibel\n\n# The 'Story of Mel' Explained\n\nWednesday. April 08, 2015\n\nThe Story of Mel is a story about a \u2018Real Programmer\u2019 that came out in the\nearly 1980\u2032s on Usenet. As described on its Wikipedia page:\n\n> The Story of Mel is an archetypical piece of computer programming folklore.\n> Its subject, Mel Kaye, is the canonical Real Programmer.\n\nThis is a very popular piece of programming lore, which is often reposted.\nMany people have read this story without fully understanding it, which is a\nshame, because it really gives you a taste for what it took to be an elite\nprogrammer in the early days of computing (late 1950\u2032s / early 1960\u2032s).\n\nWhat follows is the complete story, with the technical bits explained as\nneeded. If I make a mistake or you think something should be improved, please\ncomment below.\n\n## The Story of Mel\n\n    \n    \n    A recent article devoted to the macho side of programming made the bald and unvarnished statement: Real Programmers write in FORTRAN. Maybe they do now, in this decadent era of Lite beer, hand calculators, and \u201cuser-friendly\u201d software but back in the Good Old Days, when the term \u201csoftware\u201d sounded funny and Real Computers were made out of drums and vacuum tubes, Real Programmers wrote in machine code. Not FORTRAN. Not RATFOR. Not, even, assembly language. Machine Code. Raw, unadorned, inscrutable hexadecimal numbers. Directly.\n\nMachine code is binary (1\u2032s and 0\u2032s). Hexadecimal is a representation of Base\n16 (0-9, A-F), so it is easy to represent 4 binary numbers in one hexadecimal\ncharacter. Writing \u2018A\u2019 rather than 1010 is easier for humans to read. So Mel\nis a machine programmer, who wrote his binary in hexadecimal format. He didn\u2019t\nuse any fancy assembly language, (Add, Sub, etc.) to make coding easier- he\nwrote in binary code directly.\n\n    \n    \n    Lest a whole new generation of programmers grow up in ignorance of this glorious past, I feel duty-bound to describe, as best I can through the generation gap, how a Real Programmer wrote code. I\u2019ll call him Mel, because that was his name. I first met Mel when I went to work for Royal McBee Computer Corp., a now-defunct subsidiary of the typewriter company. The firm manufactured the LGP-30, a small, cheap (by the standards of the day) drum-memory computer, and had just started to manufacture the RPC-4000, a much-improved, bigger, better, faster \u2014 drum-memory computer. Cores cost too much, and weren\u2019t here to stay, anyway. (That\u2019s why you haven\u2019t heard of the company, or the computer.)\n\nCore Memory was a form of random access memory that used magnetic fields to\nstore information. It was hand-manufactured by skilled factory workers, which\nmade it expensive. Eventually it came down in cost, from $1 per bit to 1 cent\nper bit, but during Mel\u2019s time it was quite expensive. Therefore, the\nengineers at Royal McBee, trying to target the lower-end of the computer\nmarket (an LGP-30 would cost about $400,000 in 2015 \u2013 however, quite cheap for\ncomputers in the 1950\u2032s!) decided to use Drum Memory which is simpler to\nmanufacturer and therefore cheaper. Drum Memory is much slower than Core\nMemory, which made the new RPC-4000 still seem less-than-ideal to a programmer\ndespite improvements in other areas of the machine.\n\n    \n    \n    I had been hired to write a FORTRAN compiler for this new marvel and Mel was my guide to its wonders. Mel didn\u2019t approve of compilers. \u201cIf a program can\u2019t rewrite its own code\u201d, he asked, \u201cwhat good is it?\u201d\n\nAs will be explained later, Mel used a variety of tricks that exploited quirks\nof the processor and drum memory that allowed him to squeeze every bit of\npower from the machine. These tricks were so specific to the LGP-30\u2032s\nprocessor that no compiler could automatically generate machine code that was\nas fast and optimized as Mel\u2019s. Therefore, Mel didn\u2019t like compilers, because\nhe\u2019s a Real Programmer, who wants the most power possible.\n\nAbout a \u201cprogram rewriting its own code\u201c, by modifying the region of memory\nthat contained the program instructions, Mel could (very, very carefully) have\nthe program modify its own instructions while it was running, effectively\nchanging its own source code. Modern high-level languages like Python and\nJavaScript allow creating new code dynamically, but not mutating existing\ncode. Compilers will not generate self-modifying code, as it\u2019s too dangerous\nand not likely to be performant. However, a Real Programmer like Mel would\nfind this an attractive feature when programming.\n\n    \n    \n    Mel had written, in hexadecimal, the most popular computer program the company owned. It ran on the LGP-30 and played blackjack with potential customers at computer shows. Its effect was always dramatic. The LGP-30 booth was packed at every show, and the IBM salesmen stood around talking to each other. Whether or not this actually sold computers was a question we never discussed.\n\nThis is mind blowing that something so complex and excellent was written\ndirectly in machine code, especially to the author who was fluent in high\nlevel languages (FORTRAN).\n\n    \n    \n    Mel\u2019s job was to re-write the blackjack program for the RPC-4000. (Port? What does that mean?)\n\nTypically porting a program to another OS or processor architecture means\ntargeting the new OS / architecture and recompiling the source code. However,\nwhen you program directly in machine code (like Mel), you need to completely\nrewrite the entire program if the new processor has a different set of\ninstructions it supports (which is expensive and time consuming). This is one\nreason why high level programming languages were created \u2013 portability \u2013 so\nthat the same source code can run on different operating systems and\nprocessors.\n\n    \n    \n    The new computer had a one-plus-one addressing scheme, in which each machine instruction, in addition to the operation code and the address of the needed operand, had a second address that indicated where, on the revolving drum, the next instruction was located. In modern parlance, every single instruction was followed by a GO TO! Put *that* in Pascal\u2019s pipe and smoke it.\n\nMachine language is a series of 1\u2032s and 0\u2032s. In a hypothetical 16 bit\ninstruction scheme, the first 4 bits could be the operation code (allowing 16\nmaximum operations), the next 4 bits the storage register, the next 4 bits an\noperand register, and the next 4 bits another operand register. Therefore, if\n0001 is the opcode for \u2018Add\u2019, and we want to store the result of adding\nregister 1 and 2 into register 3, a potential binary instruction could be 0001\n0011 0001 0010 (in decimal: 1 3 1 2).\n\nIn the RPC-4000 computer, the instruction of the next address was determined\nby an operand inside the current instruction. Normally, a program is loaded\ninto memory sequentially. The first instruction is at address 0, the next at\n1, the next at 2, and so on, and the program counter (which keeps track of the\ncurrent instruction) increments each time an instruction is executed (unless a\n\u2018jump\u2019 causes the counter to change to something else).\n\nHowever, because of the nature of drum memory, it isn\u2019t performant to have the\nprogram counter increment sequentially between commands. Understanding this\nrequires a brief digression into drum memory. It is critical that you\nunderstand this in order to understand the rest of The Story of Mel.\n\nDrum Memory looks like it sounds \u2013 a rotating cylinder that is covered in a\nmagnetic material that can be be switched between two different states (1 and\n0) using electricity. State is modified using read-write \u2018heads\u2019 that are\nlocated along the drum. The drum rotates at a fixed rate, while the heads\ndon\u2019t move, so a head must wait for the drum to rotate into a specific\nposition in order to read or write a certain address.\n\nFor instance, imagine a hypothetical drum with 4 \u2018tracks\u2019. Each track has its\nown read-write \u2018head\u2019. Each track contains 256 bits, for 1024 bits total. If\nyou want to read the bit at address 900, the drum will send a response once\nbit 124 (remember, each track has 256 bits, so bit 900 is the 124th bit of the\n4th track) rotated beneath the 4th head.\n\nA side effect of this is drastically inconsistent memory response times. In\nmodern semi-conductor based memory, access speed is typically the same no\nmatter which RAM bank the data is in. In Drum Memory, the response time is\nextremely quick if the requested address is just after the current location of\nthe head, or extremely slow if the head just missed it.\n\n    \n    \n    Mel loved the RPC-4000 because he could optimize his code: that is, locate instructions on the drum so that just as one finished its job, the next would be just arriving at the \u201cread head\u201d and available for immediate execution. There was a program to do that job, an \u201coptimizing assembler\u201d, but Mel refused to use it. \u201cYou never know where it\u2019s going to put things\u201d, he explained, \u201cso you\u2019d have to use separate constants\u201d. It was a long time before I understood that remark. Since Mel knew the numerical value of every operation code, and assigned his own drum addresses, every instruction he wrote could also be considered a numerical constant. He could pick up an earlier \u201cadd\u201d instruction, say, and multiply by it, if it had the right numeric value. His code was not easy for someone else to modify.\n\nContinuing our discussion about the drum\u2019s read-write heads, it becomes clear\nthat merely having each instruction sequentially written to the drum would be\ninefficient. This is because by the time an instruction is executed, the head\nwould no longer be over the very next instruction. This is because the clock\nrate (instructions executed per second) of the processor and the drum memory\nare not perfectly synchronized (which is desirable, because you don\u2019t want to\nbottleneck either the processor or the drum by forcing them to operate at an\nexactly synchronized rate).\n\nTherefore, an \u2018optimizing assembler\u2019 was written that would take assembly code\nand arrange the instructions in memory locations that lined up with the drum\nrotation.\n\nThis would allow the programmer to write their code in sequential order,\nwithout worrying about the next-instruction operand:\n\n    \n    \n    Add R1, R2, R3, GOTO 2 Subtract R4, R2, R1, GOTO 3 Multiply R1, R2, GOTO 4 ...\n\nAnd the optimizing assembler would take the same code, and rearrange the\ninstructions in an order that was optimized for the drum memory, automatically\nchanging the next-instruction address operand. Our optimized code would now\nlook like:\n\n    \n    \n    1. Add R1, R2, R3, GOTO 112 2. ... 55. Multiply R1, R2, GOTO 398 56. ... 112. Subtract R4, R2, R1, GOTO 55 113. ...\n\nObviously, having to program your commands completely out of order using\nGOTO\u2019s on each line to jump to a new instruction would be unbelievably\ndifficult. So an optimizing assembler would do this automatically, taking the\nburden off of the programmer, and output reasonably efficient machine code.\nThe next instruction would be reasonably close to the current location of the\ntrack head, minimizing seek time.\n\nMel never used the optimizing assembler, because Mel is a Real Programmer. He\nfound a trick that was beyond the capabilities of the optimizing assembler\nthat gave him more computation power, and because the optimizing assembler\ncould not give him the same power, he hated using it.\n\nThe \u201cconstants\u201d Mel used require some explanation.\n\nAs described before, a 16 bit processor would have instructions that looked\nlike this:\n\n1001 0101 1010 1111\n\nIf a hypothetical instruction set used the first 4 bits for the opcode, then\nyou have 16 potential opcodes (2 ^ 4 = 16). Let\u2019s say that the final 4 bits of\nthe instruction were the address of the next instruction (the GOTO statements\nin the assembly code). Obviously, this is an example, because this system\nwould allow only 16 instructions per program. If you had a command that looked\nlike this:\n\nAnd R1, R2, GOTO 5\n\nThe machine code could look like this:\n\n0001 0001 0010 0101\n\nWhich evaluates to 4389 in decimal !!!\n\nTherefore, using extremely careful ordering of the instructions, and by\nanalyzing the existing locations of instructions, Mel could look at all of his\ninstructions and treat them simultaneously as numerical constants.\n\nIf he needed to multiply a value, he could examine the location of each track\nhead during the current instruction, see if any instruction had a \u2018constant\u2019\nvalue that could be used, or even wait briefly for the drum to rotate a tad\nfurther, to give him a range of potential constants.\n\nMel saw his entire program as a living, intricate machine. The program\u2019s\nsource code was malleable \u2013 as the program executed, the instructions of the\nprogram could rewrite themselves. So looking at Mel\u2019s source code didn\u2019t show\nyou the whole thing. When executing the program, the instructions themselves\nwould change, so instruction 927 could start as an Add, and then switch to a\nMultiply.\n\n    \n    \n    I compared Mel\u2019s hand-optimized programs with the same code massaged by the optimizing assembler program, and Mel\u2019s always ran faster. That was because the \u201ctop-down\u201d method of program design hadn\u2019t been invented yet, and Mel wouldn\u2019t have used it anyway. He wrote the innermost parts of his program loops first, so they would get first choice of the optimum address locations on the drum. The optimizing assembler wasn\u2019t smart enough to do it that way.\n\nRather than writing his programs by architecting a high-level design and then\nbuilding out each piece, as is typically done today, Mel would first implement\nthe loops he needed, and assign them the most efficient locations on the drum\nfor maximum speed. So the code that ran most often (loops) would be guaranteed\nto run as fast as possible.\n\n    \n    \n    Mel never wrote time-delay loops, either, even when the balky Flexowriter required a delay between output characters to work right. He just located instructions on the drum so each successive one was just past the read head when it was needed; the drum had to execute another complete revolution to find the next instruction. He coined an unforgettable term for this procedure. Although \u201coptimum\u201d is an absolute term, like \u201cunique\u201d, it became common verbal practice to make it relative: \u201cnot quite optimum\u201d or \u201cless optimum\u201d or \u201cnot very optimum\u201d. Mel called the maximum time-delay locations the \u201cmost pessimum\u201d.\n\nTime delay loops were needed to ensure that when using a Flexowriter as\noutput, the computer didn\u2019t send commands too fast for it to handle. Time\ndelay loops are bad in a computer that doesn\u2019t have an operating system. If\nyou write a program that uses a sleep() command in Python or Java, the\noperating system can swap your program out of the processor and execute other\nprograms until you have finished sleeping.\n\nHowever, in the LGP-30 there was no operating system, just a single program\nexecuting. So while your program slept, the computer was doing nothing useful.\n\nSo rather than write wasteful time delay loops, Mel would pick the worst\npossible location for the next instruction, which would delay the maximum\namount of time, without needing to write a do-nothing loop.\n\n    \n    \n    After he finished the blackjack program and got it to run (\u201cEven the initializer is optimized\u201d, he said proudly), he got a Change Request from the sales department. The program used an elegant (optimized) random number generator to shuffle the \u201ccards\u201d and deal from the \u201cdeck\u201d, and some of the salesmen felt it was too fair, since sometimes the customers lost. They wanted Mel to modify the program so, at the setting of a sense switch on the console, they could change the odds and let the customer win. Mel balked. He felt this was patently dishonest, which it was, and that it impinged on his personal integrity as a programmer, which it did, so he refused to do it. The Head Salesman talked to Mel, as did the Big Boss and, at the boss\u2019s urging, a few Fellow Programmers. Mel finally gave in and wrote the code, but he got the test backwards, and, when the sense switch was turned on, the program would cheat, winning every time. Mel was delighted with this, claiming his subconscious was uncontrollably ethical, and adamantly refused to fix it. After Mel had left the company for greener pa$ture$, the Big Boss asked me to look at the code and see if I could find the test and reverse it. Somewhat reluctantly, I agreed to look. Tracking Mel\u2019s code was a real adventure. I have often felt that programming is an art form, whose real value can only be appreciated by another versed in the same arcane art; there are lovely gems and brilliant coups hidden from human view and admiration, sometimes forever, by the very nature of the process. You can learn a lot about an individual just by reading through his code, even in hexadecimal. Mel was, I think, an unsung genius. Perhaps my greatest shock came when I found an innocent loop that had no test in it. No test. None. Common sense said it had to be a closed loop, where the program would circle, forever, endlessly. Program control passed right through it, however, and safely out the other side. It took me two weeks to figure it out.\n\nEvery non-infinite loop has a condition that eventually exits the loop. Even\nif you have an infinite loop, you can still break out of it. However, the loop\nMel wrote had no test or condition that allowed exiting. Yet, somehow, it\nstill exited the loop cleanly...\n\n    \n    \n    The RPC-4000 computer had a really modern facility called an index register. It allowed the programmer to write a program loop that used an indexed instruction inside; each time through, the number in the index register was added to the address of that instruction, so it would refer to the next datum in a series. He had only to increment the index register each time through. Mel never used it.\n\nAn index register is used to efficiently iterate through an array of data, by\nincrementing it for each element and then adding the current register value to\nthe base address of the array.\n\n    \n    \n    Instead, he would pull the instruction into a machine register, add one to its address, and store it back. He would then execute the modified instruction right from the register. The loop was written so this additional execution time was taken into account \u2014 just as this instruction finished, the next one was right under the drum\u2019s read head, ready to go. But the loop had no test in it.\n\nThis is a clever trick to increase speed without using the index register.\nRather than incrementing the index register, he would increment the\ninstruction itself (modifying the source code of the program), store it back,\nand execute it. The additional overhead of modifying the instruction and\nstoring it back was just enough time for the drum to rotate into position to\nexecute the next instruction, without an additional clock cycle to manipulate\nthe index register.\n\n    \n    \n    The vital clue came when I noticed the index register bit, the bit that lay between the address and the operation code in the instruction word, was turned on \u2014 yet Mel never used the index register, leaving it zero all the time. When the light went on it nearly blinded me.\n\nIn order to use the index register, there was an \u2018index register bit\u2019 which\nwas located between the instruction address and opcode of an instruction. Mel\nwould turn it on, which is perplexing, because Mel never used the index\nregister...\n\n    \n    \n    He had located the data he was working on near the top of memory \u2014 the largest locations the instructions could address \u2014 so, after the last datum was handled, incrementing the instruction address would make it overflow. The carry would add one to the operation code, changing it to the next one in the instruction set: a jump instruction. Sure enough, the next program instruction was in address location zero, and the program went happily on its way.\n\nOperation codes (opcodes) tell the processor which operation to execute for\ngiven operands. The opcode Mel used was 1 less than the opcode for JUMP, which\n\u2018jumps\u2019 to another instruction rather than executing the next one\nsequentially.\n\nWhen the final element in the array was accessed, at the very top of memory,\nsetting the index register to 1 caused an overflow. The overflow carried over\nto the opcode, which would be incremented, thus changing the operation to a\nJUMP because the current opcode was 1 less than JUMP. The JUMP would cause the\nprogram to execute the instruction at location 0, the very bottom of memory,\nwhich is indeed where Mel placed the next instruction.\n\nTo summarize, Mel enabled the index register bit (despite not using the index\nregister) to cause an integer overflow, and because the instruction was at the\nvery top of memory, it had the side-effect of also incrementing the\ninstruction\u2019s opcode, modifying the instruction to change into a JUMP command,\nin order to exit an infinite loop.\n\nThis is a totally insane optimization, which is why it took the author weeks\nto understand it. Clearly, Mel knew the inner workings of drum memory and the\nprocessor so well that he amassed a collection of tricks to squeeze maximum\nperformance from the computer. He would use all of them in his programs, which\nwould always beat the compiler and optimizing assembler. Mel was a Real\nProgrammer.\n\n    \n    \n    I haven\u2019t kept in touch with Mel, so I don\u2019t know if he ever gave in to the flood of change that has washed over programming techniques since those long-gone days. I like to think he didn\u2019t. In any event, I was impressed enough that I quit looking for the offending test, telling the Big Boss I couldn\u2019t find it. He didn\u2019t seem surprised. When I left the company, the blackjack program would still cheat if you turned on the right sense switch, and I think that\u2019s how it should be. I didn\u2019t feel comfortable hacking up the code of a Real Programmer.\n\n## Addendum\n\nFor those of you who made it this far, congratulations. I hope you have\nlearned something about the fine art of computer programming, and what it took\nto be an elite programmer of ancient computers.\n\nHacker News and other Internet communities routinely argue over what languages\nconstitute \u2018real programming\u2019. PHP and JavaScript seem to be the current\nwhipping boys, while C/C++ are what the True Programmers use.\n\nThe bottom line is, the argument is irrelevant. None of us are Real\nProgrammers. We are abstracted away so far from what is really happening in\nthe metal, that arguing about languages is a pointless endeavor.\n\nI suggest being content that modern technology doesn\u2019t require us to hack up\nmachine code in order to keep our software running :-)\n\nJames Seibel \u00a9 2024\n\n", "frontpage": false}
