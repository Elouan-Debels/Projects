{"aid": "40004974", "title": "LPDDR5 Tutorial: Deep dive into its physical structure", "url": "https://www.systemverilog.io/design/lpddr5-tutorial-physical-structure/", "domain": "systemverilog.io", "votes": 3, "user": "vikramskr", "posted_at": "2024-04-11 18:00:03", "comments": 0, "source_title": "LPDDR5 Tutorial - Deep dive into its physical structure - systemverilog.io", "source_text": "LPDDR5 Tutorial - Deep dive into its physical structure - systemverilog.io\n\nSkip to content\n\nLATEST ON SVIO -- LPDDR5 Tutorial: Deep dive into its physical structure\n\n# LPDDR5 Tutorial: Deep dive into its physical structure\u00b6\n\n## Introduction\u00b6\n\nIn this article, we'll take a detailed look at the physical structure of\nLPDDR5 memory, starting from the basics and working our way up. By the end,\nyou'll have a clear understanding of key terms related to LPDDR5 memory,\nincluding:\n\n  1. LPDDR5 IOs: Command Bus (CA), Data Bus (DQ/DQS), ChipSelect (CS), Clock (CK)\n  2. Bank and Bank Group Architecture\n  3. Ranks and Page Size\n  4. LPDDR5 Memory Channels\n  5. Interpretation of x16/x32/x64 widths\n\nWe'll begin with a single DRAM memory cell and gradually explore how it forms\na complete Memory Package soldered onto a PCB.\n\nFigure 0: Memory cell to memory package\n\n## The LPDDR5 Memory Die\u00b6\n\n### A Single Memory Cell\u00b6\n\nAt the lowest level, a bit is essentially a capacitor that holds the charge\nand a transistor acting as a switch. Since the capacitor discharges over time,\nthe information eventually fades unless the capacitor is periodically\nREFRESHed. This is where the D in DRAM comes from - it refers to Dynamic as\nopposed to the Static in SRAM.\n\nFigure 1: Memory Cell\n\n### Bank, Rows and Columns\u00b6\n\nWhen you zoom out one level, you will notice Memory Cells arranged in a grid\nof Rows and Columns.\n\nOne such grid of memory cells is called a Bank. A Bank also has a structure\ncalled Sense Amps. During a READ operation, a Row is first ACTIVATED and\nloaded into the Sense Amps. The Column address is then used to read out the\nappropriate column bits.\n\nIn LPDDR5,\n\n  * Each Row of a Bank holds 1KB (8192 bits) of data\n  * This 1KB in each row is arranged into 64 Columns of 128b each. [64 x 128b = 8192b]\n  * So, with each READ/WRITE access a Row Address and a Column address is specified and the bank returns 128b of data. This number is important, we'll revisit it once again in the next section.\n\nFigure 2: Memory Array\n\n### LPDDR5 Bank Architecture\u00b6\n\nZooming out another level, each LPDDR5 Die has 32 of these Bank tile. These 32\ntiles can be arranged in 3 different configurations.\n\n  1. Bank Group Mode\n\n     * Also known as BG Mode. Here the 32 Bank tiles are organized into 2 sets of 4 Bank Groups with 4 Banks each. [2x4x4 = 32].\n     * In Figure 3 below, notice the BG0,1,2,3 along Y-axis and Bank0,1,2,3 along X.\n     * During a READ/WRITE operation, the supplied bank address activates 2 banks and a total of 256b is accessed (Remember, each Row and Col address access 128b within a bank).\n  2. 16 Bank Mode\n\n     * In this mode the 32 Bank tiles are organized into 2 sets of 16 Banks [2 x 16 = 32].\n     * The difference between this mode and the Bank Group Mode is that, the timing parameters to access the banks are different between the two modes. As you will see later, the 16 Bank Mode can only operate at speeds below 3200 Mbps whereas BG Mode operates at speeds greater than 3200 Mbps.\n  3. 8 Bank Mode\n\n     * Here the 32 Bank tiles are organized into 4 sets of 8 Banks [4 x 8 = 32]. So, during a READ/WRITE operation, the supplied bank address activates 4 banks and a total of 512b is accessed.\n\nFigure 3: LPDDR5 Bank Architecture\n\n#### Why are there 3 Bank Modes and not just one? \ud83e\udd14\u00b6\n\nLPDDR5 offers multiple Bank Modes to accomodate different speeds of operation\n(such as 3200Mbps, 5400Mbps, 6400 Mbps, etc.) and different data access widths\n(256b and 512b). Bank Mode selection is done during initialization by setting\na parameter in Mode Register MR3 (The default setting is 16B Mode).\n\nSo, which among the 3 configurations you choose depends on 2 factors\n\n  1. Speed Grade - What speed is the memory is operating at?\n  2. Native Burst Length - How many bits of data do you want to read/write with each operation?\n\nLet us look at these in detail.\n\n#### Speed Grade\u00b6\n\n  * Bank Group Mode can only be used if the memory is operating > 3200Mb/s\n  * 16 Bank Mode can only be used if the memory is operating <= 3200Mb/s\n  * 8 Bank Mode can be accessed at all speeds\n\n#### Native Burst Length\u00b6\n\n  * In 16 Bank Mode and Bank Group Mode, a Read operation activates 2 Banks in parallel and accesses 256b of data (Remember each Bank returns 128b). In LPDDR5, the Data Bus is 16 bits wide (DQ[15:0]). So the 256b of data is then streamed out in a burst of 16 chunks, with each chunk being 16b (16x16 = 256). This is also called BL16 or Burst Length 16.\n  * In 8 Bank Mode, as you see in Figure 3, each READ/WRITE operation activates 4 banks and a total of 512b of data is fetched. This data is then streamed out in a burst of 32 beats with each beat holding 16b of data (32x16 = 512). This is called Burst Length 32.\n\nExample: If your system is designed to operate at 6400Mb/s (the highest speed\nLPDDR5 supports), and you require data access at 256b granularity, then you\nwould choose the Bank Group Mode.\n\nNote\n\nYou can do BL32 in Bank Group mode too, but its a bit more complex and does\nsome interleaving of data. You are better off just using 8B Mode if you want a\nBurst Length of 32.\n\n### Page Size\u00b6\n\nPage Size is the number of bits loaded into the Sense Amps when a row is\nactivated.\n\n  * In 16 Bank Mode and Bank Group Mode the Page Size is 2KB\n  * In 8B Mode Page Size is 4KB\n\n#### How did we arrive at these numbers?\u00b6\n\nIn Figure 2 we saw that each Row in a bank holds 1KB of data (arranged as 64\ncolumns of 128b); and, from Figure 3 in 16 Bank and Bank Group Modes two banks\nare activated simultaneously to fetch total of 256b. So, from the memory die's\npoint of view, 2 banks are activated and total page size is 2x1KB = 2KB.\n\nFollowing from that, in case of 8 bank mode one access activates 4 banks hence\npage size is 4KB.\n\n### Density\u00b6\n\nSo far we have discussed the physical structure of a LPDDR5 memory die, but\nwhat is the capacity of a memory die, how many bits can it hold?\n\nThe LPDDR5 memory die is manufactured in specific capacities, from 2Gb to\n32Gb, as specified in the JEDEC Specification. The main difference between a\ndie with 2Gb capacity and that with 32Gb is the number of rows in each bank.\nThe table below shows the number of address bits for a memory operating in BG\nmode.\n\nMemory Density| 2Gb| 8Gb| 16Gb| 32Gb  \n---|---|---|---|---  \nNumber of Rows| 8192| 32,768| 65,536| 131,072  \nNumber of Cols| 64| 64| 64| 64  \nRow Address Bits| R0-R12| R0-R14| R0-R15| R0-R16  \nCol Address Bits| C0-C5| C0-C5| C0-C5| C0-C5  \nBank Address Bits| BA0-BA1| BA0-BA1| BA0-BA1| BA0-BA1  \nBG Address Bits| BG0-BG1| BA0-BA1| BA0-BA1| BA0-BA1  \nPage Size| 2KB| 2KB| 2KB| 2KB  \nArray Pre-Fetch| 256b| 256b| 256b| 256b  \n  \n... Table 1: x16 DQ Mode Addressing\n\n    \n    \n    Arriving at the total density of a 2Gb die: 4 (BG) x 4 (Banks) x 8192 (rows) x 64 (cols) x 256b (each col) = 2,147,483,648 = 2Gb\n\n### Putting it all together\u00b6\n\nAnalogy Time\n\n> A DRAM chip is equivalent to a building full of file cabinets\n>\n> Bank Group Identifies the floor number\n>\n> Bank Address Identifies the file cabinet within that floor where the file\n> you need is located\n>\n> Row Address Identifies which drawer in the cabinet the file is located.\n> Reading data into the Sense Amplifiers is equivalent to opening/pulling out\n> the file drawer.\n>\n> Col Address Identifies the file number within this drawer. When you want to\n> read another row, you have to put this file back in the drawer and close it\n> before opening the next drawer. This is equivalent to PRECHARGE-ing.\n\n### x8 DQ Mode\u00b6\n\nThe LPDDR5 interface has 16 DQ (data) pins. So, by default the memory comes up\nin what is called x16 DQ mode.\n\nBut, you can disable 8 of the DQ pins and put the memory in x8 DQ mode. In\nthis mode only one Bank is activated during a read or write access (instead of\n2). In return, what you get is a deeper memory, i.e., each Bank appears to\nhave twice the number of Rows compared to x16 mode. (We cut the access width\nin half so, as you would expect, the depth doubled.)\n\nFigure 4: x8 DQ Mode\n\nMemory Density| 2Gb| 8Gb| 16Gb| 32Gb  \n---|---|---|---|---  \nNumber of Rows| 16,384| 65,536| 131,072| 262,144  \nNumber of Cols| 64| 64| 64| 64  \nRow Address Bits| R0-R13| R0-R15| R0-R16| R0-R17  \nCol Address Bits| C0-C5| C0-C5| C0-C5| C0-C5  \nBank Address Bits| BA0-BA1| BA0-BA1| BA0-BA1| BA0-BA1  \nBG Address Bits| BG0-BG1| BA0-BA1| BA0-BA1| BA0-BA1  \nPage Size| 1KB| 1KB| 1KB| 1KB  \nArray Pre-Fetch| 128b| 128b| 128b| 128b  \n  \n... Table 2: x8 DQ Mode Addressing\n\nin the above table notice how, when compared to Table 1, the Array Pre-Fetch\nand Page Size halved and Number of Rows doubled.\n\nx16 vs x8 mode is set in mode register MR8.\n\n## LPDDR5 Memory Channel\u00b6\n\nAnother common term you will hear in the context of LPDDR5 is \"Number of\nChannels\". In the simplest terms, a memory channel is what a LPDDR5 controller\ninteracts with. This interface between a memory controller and a memory\nchannel has the following IOs.\n\nPin| Width| Type| Description  \n---|---|---|---  \nRESET_n| 1| Input| Reset pin  \nCK_t, CK_c| 1| Input| Differential clock  \nCS[1:0]| 2| Input| Chip Select. Think of this as the enable/valid pin. The\nrest of the command bus is valid only when this is high.  \nCA[6:0]| 7| Input| Address bus. This is used to select which\nBankGroup,Bank,Row,Col to access.  \nDQ[15:0]| 16| InOut| Bidirectional data bus  \nWCK[1:0]_t, WCK[1:0]_c| 2| Input| Differential clocks used for WRITE data\ncapture and READ data output  \nDMI[1:0]| 2| InOut| Data mask inversion. This IO has several functions such as\nDataMask (DM), DataBusInversion (DBI), or Link ECC based on the mode register\nsetting.  \nRDQS[1:0]_t, RDQS[1:0]_c| 1| RDQS_t: Inout, RDQS_c: Output| Read Data Strobe  \n  \n... Table 3: LPDDR5 IOs\n\n### Ranks, Width cascading and depth cascading\u00b6\n\nA channel can be composed of one or more LPDDR5 memory dies. In the following\nfigure I've shown how multiple 2Gb memory die can be configured to increase\nthe total memory capacity available in a channel.\n\n  1. 2Gb Channel Capacity: This is simple. Just a single 2Gb memory die connected to the LPDDR5 IOs.\n  2. 4Gb Channel Capacity: Here, we have 2 x 2Gb dies that are \"Depth Cascaded\", otherwise called 2-Rank configuration. Die-A is accessed by setting ChipSelect0 (CS0 pin) and Die-B is selected using CS1 pin. But, both dies share the same Address and Data Bus since only one of the ChipSelect pins are active at a time.\n  3. 8Gb Channel Capacity: Here we have 4 x 2Gb dies. Similar to 4Gb capacity, there are 2-Ranks. But within each rank we have 2-dies that are \"Width Cascaded\", i.e., each of the dies are configured in x8 width mode.\n\nFigure 5: LPDDR5 Channel\n\n## LPDDR5 Memory Package\u00b6\n\nFigure 6: x64 4-Channel LPDDR5 Package\n\nZoom out one final time and now we have the entire LPDDR5 Memory Device\nPackage. This is what you can purchase from a vendor like Micron or Samsung.\n\nTypically, a memory package holds multiple channels. This allows memory\nmanufacturers to create memory devices with varying Width and Capacity to\naccommodate various applications.\n\nTypical width and capacities in a vendor's parts catalog are:\n\n  * Capacity: 4GB, 8GB, 16GB, etc\n  * Width: x16 (1-Channel), x32 (2-Channels), x64 (4-Channels). Each channel is independently accessible and have their own set of CA and DQ pins.\n\n## The SoC-LPDDR5 Interface\u00b6\n\nNow that we understand what a LPDDR5 memory looks like, I'll end this article\nwith a discussion on how does a Processor or SoC READ/WRITE to the memory?\n\nIn order to communicate with a LPDDR5 memory, an SoC, ASIC, FPGA or Processor\nrequires a Controller and a PHY. Together, these 3 entities - The Controller,\nThe PHY and The LPDDR5 Memory Device form the LPDDR5 memory sub-system.\n\nFigure 7: LPDDR5 Memory Sub-System\n\n### LPDDR5 Interface\u00b6\n\nAs discussed earlier, the following table describes the interface between the\nPHY and one LPDDR5 memory channel. These IOs are physical traces through the\nPCB.\n\nPin| Width| Type| Description  \n---|---|---|---  \nRESET_n| 1| Input| Reset pin  \nCK_t, CK_c| 1| Input| Differential clock  \nCS| 1| Input| Chip Select. Think of this as the enable/valid pin. The rest of\nthe command bus is valid only when this is high.  \nCA[6:0]| 7| Input| Address bus. This is used to select which\nBankGroup,Bank,Row,Col to access.  \nDQ[15:0]| 16| InOut| Bidirectional data bus  \nWCK[1:0]_t, WCK[1:0]_c| 2| Input| Differential clocks used for WRITE data\ncapture and READ data output  \nDMI[1:0]| 2| InOut| Data mask inversion. This IO has several functions such as\nDataMask (DM), DataBusInversion (DBI), or Link ECC based on the mode register\nsetting.  \nRDQS[1:0]_t, RDQS[1:0]_c| 1| RDQS_t: Inout, RDQS_c: Output| Read Data Strobe  \n  \n### DFI Interface\u00b6\n\nYou can think of the controller as the logical layer. A large state machine\nwhich ensures the LPDDR5 protocol is strictly followed when performing a read,\nwrite or refresh operation. The PHY, on the other hand, is the Physical layer.\nIt has all the analog parts required to guarantee the reliable launch and\ncapture of the clock, address and data signals to and from the memory.\n\nReferring to Figure 7 above, the PHY and Controller talk to each other through\na well-defined standard interface called the DFI interface. The PHY can\ncommunicate to the Controller via this interface whether it is in the\ninitialization phase, calibration phase, or ready to execute a READ/WRITE.\n\n### Controller Interface\u00b6\n\nAccessing a DDR memory is a delicate dance. For example, to WRITE data into\nthe memory, multiple commands need to be issued to the memory to activate the\nright bank, rows and columns, and a precise time-interval later (called the\nWrite-Latency) the data has to be launched. In between all this, the memory\nneeds to be REFRESHed at a fixed period so that you don't lose any data.\n\nThe controller abstracts all of the above complications and presents a simple\ninterface, like AXI, through which you can issue a Write or a Read.\n\nApart from providing a simple interface to access the memory, the controller\nalso has several smart features (such as address re-ordering) to help the\nSoC/Processor maximize the memory bandwidth. This is important because the\nmemory is almost always the bottle neck when it comes to performance of your\nLaptop, Phone or a complex ASIC like the TPUs.\n\n## Conclusion\u00b6\n\nThat brings us to the end. In a nutshell, this is what was discussed in this\narticle:\n\n  * What exactly is a LPDDR5 memory device made up of.\n  * What the interfaces to the memory look like.\n  * How does a Processor or SoC communicate with the memory.\n\n## References\u00b6\n\n  * JEDEC JESD-209 LPDDR5 Protocol Specification\n  * Micron Datasheets\n\n## Questions or Comments\u00b6\n\nPlease use this link for any discussions, questions or comments.\n\nIf you found this content useful then please consider supporting this site! \ud83e\udef6\n\nBack to top\n\nCopyright \u00a9 2015-2024 Subramani Ganesh\n\nMade with Material for MkDocs\n\n", "frontpage": false}
