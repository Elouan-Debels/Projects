{"aid": "39982974", "title": "Innovative Firmware Update Method to Microcontrollers During Runtime", "url": "https://www.mdpi.com/2079-9292/13/7/1328", "domain": "mdpi.com", "votes": 1, "user": "PaulHoule", "posted_at": "2024-04-09 19:05:29", "comments": 0, "source_title": "Innovative Firmware Update Method to Microcontrollers during Runtime", "source_text": "Electronics | Free Full-Text | Innovative Firmware Update Method to Microcontrollers during Runtime\n\n  * Consent\n  * Details\n  * [#IABV2SETTINGS#]\n  * About\n\n## This website uses cookies\n\nWe use cookies to personalise content and ads, to provide social media\nfeatures and to analyse our traffic. We also share information about your use\nof our site with our social media, advertising and analytics partners who may\ncombine it with other information that you\u2019ve provided to them or that they\u2019ve\ncollected from your use of their services.\n\nShow details\n\n  * Necessary cookies help make a website usable by enabling basic functions like page navigation and access to secure areas of the website. The website cannot function properly without these cookies.\n\n    * Cookiebot\n\n1\n\nLearn more about this provider\n\n1.gifUsed to count the number of sessions to the website, necessary for\noptimizing CMP product delivery.\n\nExpiry: SessionType: Pixel\n\n    * Crazyegg\n\n2\n\nLearn more about this provider\n\n_ce.cchStores the user's cookie consent state for the current domain\n\nExpiry: SessionType: HTTP\n\nce_successful_csp_checkDetects whether user behaviour tracking should be\nactive on the website.\n\nExpiry: PersistentType: HTML\n\n    * Google\n\n1\n\nLearn more about this provider\n\ntest_cookieUsed to check if the user's browser supports cookies.\n\nExpiry: 1 dayType: HTTP\n\n    * LinkedIn\n\n2\n\nLearn more about this provider\n\nli_gcStores the user's cookie consent state for the current domain\n\nExpiry: 180 daysType: HTTP\n\nbscookieThis cookie is used to identify the visitor through an application.\nThis allows the visitor to login to a website through their LinkedIn\napplication for example.\n\nExpiry: 1 yearType: HTTP\n\n    * commenting.mdpi.com\n\n2\n\nSESS#Preserves users states across page requests.\n\nExpiry: SessionType: HTTP\n\nXSRF-TOKENEnsures visitor browsing-security by preventing cross-site request\nforgery. This cookie is essential for the security of the website and visitor.\n\nExpiry: SessionType: HTTP\n\n    * commenting.mdpi.com consent.cookiebot.com\n\n2\n\nCookieConsent [x2]Stores the user's cookie consent state for the current\ndomain\n\nExpiry: 1 yearType: HTTP\n\n    * matomo.mdpi.com\n\n1\n\n_pk_testcookie_domainThis cookie determines whether the browser accepts\ncookies.\n\nExpiry: 1 dayType: HTTP\n\n    * mdpi.com\n\n3\n\n__cfruidThis cookie is a part of the services provided by Cloudflare -\nIncluding load-balancing, deliverance of website content and serving DNS\nconnection for website operators.\n\nExpiry: SessionType: HTTP\n\ncf_clearanceThis cookie is used to distinguish between humans and bots.\n\nExpiry: 1 yearType: HTTP\n\nMDPIPHPSESSIDPending\n\nExpiry: SessionType: HTTP\n\n    * mdpi.com mdpi.org mdpi-res.com sciprofiles.com\n\n4\n\n__cf_bm [x4]This cookie is used to distinguish between humans and bots. This\nis beneficial for the website, in order to make valid reports on the use of\ntheir website.\n\nExpiry: 1 dayType: HTTP\n\n    * www.jisc.ac.uk\n\n2\n\nAWSALBRegisters which server-cluster is serving the visitor. This is used in\ncontext with load balancing, in order to optimize user experience.\n\nExpiry: 7 daysType: HTTP\n\nAWSALBCORSRegisters which server-cluster is serving the visitor. This is used\nin context with load balancing, in order to optimize user experience.\n\nExpiry: 7 daysType: HTTP\n\n    * www.mdpi.com\n\n7\n\ncf_chl_1This cookie is a part of the services provided by Cloudflare -\nIncluding load-balancing, deliverance of website content and serving DNS\nconnection for website operators.\n\nExpiry: 1 dayType: HTTP\n\niconify0Used by the website's content management system (CMS) to determine how\nthe website's menu-tabs should be displayed.\n\nExpiry: PersistentType: HTML\n\niconify1This cookie is set to ensure proper product displays on the website.\n\nExpiry: PersistentType: HTML\n\niconify2Used by the website's content management system (CMS) to determine how\nthe website's menu-tabs should be displayed.\n\nExpiry: PersistentType: HTML\n\niconify3Determines the device used to access the website. This allows the\nwebsite to be formatted accordingly.\n\nExpiry: PersistentType: HTML\n\niconify-countUsed by the website's content management system (CMS) to\ndetermine how the website's menu-tabs should be displayed.\n\nExpiry: PersistentType: HTML\n\niconify-versionUsed by the website's content management system (CMS) to\ndetermine how the website's menu-tabs should be displayed.\n\nExpiry: PersistentType: HTML\n\n  * Preference cookies enable a website to remember information that changes the way the website behaves or looks, like your preferred language or the region that you are in.\n\n    * LinkedIn\n\n1\n\nLearn more about this provider\n\nlidcRegisters which server-cluster is serving the visitor. This is used in\ncontext with load balancing, in order to optimize user experience.\n\nExpiry: 1 dayType: HTTP\n\n    * www.mdpi.com\n\n2\n\nmdpi_layout_typeThis cookie is used to store user setting of using fixed\ndesktop layout instead of the default responsive layout\n\nExpiry: 1 yearType: HTTP\n\nsettingsThis cookie is used to determine the preferred language of the visitor\nand sets the language accordingly on the website, if possible.\n\nExpiry: PersistentType: HTML\n\n  * Statistic cookies help website owners to understand how visitors interact with websites by collecting and reporting information anonymously.\n\n    * Crazyegg\n\n8\n\nLearn more about this provider\n\n_ce.clock_dataCollects data on the user\u2019s navigation and behavior on the\nwebsite. This is used to compile statistical reports and heatmaps for the\nwebsite owner.\n\nExpiry: 1 dayType: HTTP\n\n_ce.clock_eventCollects data on the user\u2019s navigation and behavior on the\nwebsite. This is used to compile statistical reports and heatmaps for the\nwebsite owner.\n\nExpiry: 1 dayType: HTTP\n\n_ce.gtldHolds which URL should be presented to the visitor when visiting the\nsite.\n\nExpiry: SessionType: HTTP\n\n_ce.sCollects data on the user\u2019s navigation and behavior on the website. This\nis used to compile statistical reports and heatmaps for the website owner.\n\nExpiry: 1 yearType: HTTP\n\ncebsTracks the individual sessions on the website, allowing the website to\ncompile statistical data from multiple visits. This data can also be used to\ncreate leads for marketing purposes.\n\nExpiry: SessionType: HTTP\n\ncebsp_Collects data on the user\u2019s navigation and behavior on the website. This\nis used to compile statistical reports and heatmaps for the website owner.\n\nExpiry: SessionType: HTTP\n\nce_fvdCollects data on the user\u2019s navigation and behavior on the website. This\nis used to compile statistical reports and heatmaps for the website owner.\n\nExpiry: PersistentType: HTML\n\ncetabidSets a unique ID for the session. This allows the website to obtain\ndata on visitor behaviour for statistical purposes.\n\nExpiry: SessionType: HTML\n\n    * Google\n\n5\n\nLearn more about this provider\n\ncollectUsed to send data to Google Analytics about the visitor's device and\nbehavior. Tracks the visitor across devices and marketing channels.\n\nExpiry: SessionType: Pixel\n\n_gaRegisters a unique ID that is used to generate statistical data on how the\nvisitor uses the website.\n\nExpiry: 2 yearsType: HTTP\n\n_ga_#Used by Google Analytics to collect data on the number of times a user\nhas visited the website as well as dates for the first and most recent visit.\n\nExpiry: 2 yearsType: HTTP\n\n_gatUsed by Google Analytics to throttle request rate\n\nExpiry: 1 dayType: HTTP\n\n_gidRegisters a unique ID that is used to generate statistical data on how the\nvisitor uses the website.\n\nExpiry: 1 dayType: HTTP\n\n    * Hotjar\n\n5\n\nLearn more about this provider\n\nhjActiveViewportIdsThis cookie contains an ID string on the current session.\nThis contains non-personal information on what subpages the visitor enters \u2013\nthis information is used to optimize the visitor's experience.\n\nExpiry: PersistentType: HTML\n\nhjViewportIdSaves the user's screen size in order to adjust the size of images\non the website.\n\nExpiry: SessionType: HTML\n\n_hjSession_#Collects statistics on the visitor's visits to the website, such\nas the number of visits, average time spent on the website and what pages have\nbeen read.\n\nExpiry: 1 dayType: HTTP\n\n_hjSessionUser_#Collects statistics on the visitor's visits to the website,\nsuch as the number of visits, average time spent on the website and what pages\nhave been read.\n\nExpiry: 1 yearType: HTTP\n\n_hjTLDTestRegisters statistical data on users' behaviour on the website. Used\nfor internal analytics by the website operator.\n\nExpiry: SessionType: HTTP\n\n    * LinkedIn\n\n1\n\nLearn more about this provider\n\nAnalyticsSyncHistoryUsed in connection with data-synchronization with third-\nparty analysis service.\n\nExpiry: 30 daysType: HTTP\n\n    * Twitter Inc.\n\n1\n\nLearn more about this provider\n\npersonalization_idThis cookie is set by Twitter - The cookie allows the\nvisitor to share content from the website onto their Twitter profile.\n\nExpiry: 400 daysType: HTTP\n\n    * matomo.mdpi.com\n\n2\n\n_pk_id#Collects statistics on the user's visits to the website, such as the\nnumber of visits, average time spent on the website and what pages have been\nread.\n\nExpiry: 1 yearType: HTTP\n\n_pk_ses#Used by Piwik Analytics Platform to track page requests from the\nvisitor during the session.\n\nExpiry: 1 dayType: HTTP\n\n    * www.mdpi.com\n\n1\n\nsentryReplaySessionRegisters data on visitors' website-behaviour. This is used\nfor internal analysis and website optimization.\n\nExpiry: SessionType: HTML\n\n  * Marketing cookies are used to track visitors across websites. The intention is to display ads that are relevant and engaging for the individual user and thereby more valuable for publishers and third party advertisers.\n\n    * Meta Platforms, Inc.\n\n3\n\nLearn more about this provider\n\nlastExternalReferrerDetects how the user reached the website by registering\ntheir last URL-address.\n\nExpiry: PersistentType: HTML\n\nlastExternalReferrerTimeDetects how the user reached the website by\nregistering their last URL-address.\n\nExpiry: PersistentType: HTML\n\n_fbpUsed by Facebook to deliver a series of advertisement products such as\nreal time bidding from third party advertisers.\n\nExpiry: 3 monthsType: HTTP\n\n    * Google\n\n2\n\nLearn more about this provider\n\npagead/1p-user-list/#Tracks if the user has shown interest in specific\nproducts or events across multiple websites and detects how the user navigates\nbetween sites. This is used for measurement of advertisement efforts and\nfacilitates payment of referral-fees between websites.\n\nExpiry: SessionType: Pixel\n\ntdRegisters statistical data on users' behaviour on the website. Used for\ninternal analytics by the website operator.\n\nExpiry: SessionType: Pixel\n\n    * LinkedIn\n\n4\n\nLearn more about this provider\n\nbcookieUsed by the social networking service, LinkedIn, for tracking the use\nof embedded services.\n\nExpiry: 1 yearType: HTTP\n\nli_sugrCollects data on user behaviour and interaction in order to optimize\nthe website and make advertisement on the website more relevant.\n\nExpiry: 3 monthsType: HTTP\n\nUserMatchHistoryEnsures visitor browsing-security by preventing cross-site\nrequest forgery. This cookie is essential for the security of the website and\nvisitor.\n\nExpiry: 30 daysType: HTTP\n\nli_adsIdCollects data on user behaviour and interaction in order to optimize\nthe website and make advertisement on the website more relevant.\n\nExpiry: PersistentType: HTML\n\n    * Twitter Inc.\n\n3\n\nLearn more about this provider\n\ni/adsct [x2]The cookie is used by Twitter.com in order to determine the number\nof visitors accessing the website through Twitter advertisement content.\n\nExpiry: SessionType: Pixel\n\nmuc_adsCollects data on user behaviour and interaction in order to optimize\nthe website and make advertisement on the website more relevant.\n\nExpiry: 400 daysType: HTTP\n\n    * YouTube\n\n22\n\nLearn more about this provider\n\n#-#Pending\n\nExpiry: SessionType: HTML\n\niU5q-!O9@$Registers a unique ID to keep statistics of what videos from YouTube\nthe user has seen.\n\nExpiry: SessionType: HTML\n\nLAST_RESULT_ENTRY_KEYUsed to track user\u2019s interaction with embedded content.\n\nExpiry: SessionType: HTTP\n\nLogsDatabaseV2:V#||LogsRequestsStorePending\n\nExpiry: PersistentType: IDB\n\nnextIdUsed to track user\u2019s interaction with embedded content.\n\nExpiry: SessionType: HTTP\n\nremote_sidNecessary for the implementation and functionality of YouTube video-\ncontent on the website.\n\nExpiry: SessionType: HTTP\n\nrequestsUsed to track user\u2019s interaction with embedded content.\n\nExpiry: SessionType: HTTP\n\nServiceWorkerLogsDatabase#SWHealthLogNecessary for the implementation and\nfunctionality of YouTube video-content on the website.\n\nExpiry: PersistentType: IDB\n\nTESTCOOKIESENABLEDUsed to track user\u2019s interaction with embedded content.\n\nExpiry: 1 dayType: HTTP\n\nVISITOR_INFO1_LIVETries to estimate the users' bandwidth on pages with\nintegrated YouTube videos.\n\nExpiry: 180 daysType: HTTP\n\nVISITOR_PRIVACY_METADATAStores the user's cookie consent state for the current\ndomain\n\nExpiry: 180 daysType: HTTP\n\nYSCRegisters a unique ID to keep statistics of what videos from YouTube the\nuser has seen.\n\nExpiry: SessionType: HTTP\n\nyt.innertube::nextIdRegisters a unique ID to keep statistics of what videos\nfrom YouTube the user has seen.\n\nExpiry: PersistentType: HTML\n\nytidb::LAST_RESULT_ENTRY_KEYStores the user's video player preferences using\nembedded YouTube video\n\nExpiry: PersistentType: HTML\n\nYtIdbMeta#databasesUsed to track user\u2019s interaction with embedded content.\n\nExpiry: PersistentType: IDB\n\nyt-remote-cast-availableStores the user's video player preferences using\nembedded YouTube video\n\nExpiry: SessionType: HTML\n\nyt-remote-cast-installedStores the user's video player preferences using\nembedded YouTube video\n\nExpiry: SessionType: HTML\n\nyt-remote-connected-devicesStores the user's video player preferences using\nembedded YouTube video\n\nExpiry: PersistentType: HTML\n\nyt-remote-device-idStores the user's video player preferences using embedded\nYouTube video\n\nExpiry: PersistentType: HTML\n\nyt-remote-fast-check-periodStores the user's video player preferences using\nembedded YouTube video\n\nExpiry: SessionType: HTML\n\nyt-remote-session-appStores the user's video player preferences using embedded\nYouTube video\n\nExpiry: SessionType: HTML\n\nyt-remote-session-nameStores the user's video player preferences using\nembedded YouTube video\n\nExpiry: SessionType: HTML\n\n    * cdn.pbgrd.com\n\n2\n\npagead/gen_204Collects data on visitor behaviour from multiple websites, in\norder to present more relevant advertisement - This also allows the website to\nlimit the number of times that they are shown the same advertisement.\n\nExpiry: SessionType: Pixel\n\ncsiCollects data on visitors' preferences and behaviour on the website - This\ninformation is used make content and advertisement more relevant to the\nspecific visitor.\n\nExpiry: SessionType: Pixel\n\n    * pub.mdpi-res.com\n\n1\n\nOAIDRegisters a unique ID that identifies a returning user's device. The ID is\nused for targeted ads.\n\nExpiry: 1 yearType: HTTP\n\n  * Unclassified cookies are cookies that we are in the process of classifying, together with the providers of individual cookies.\n\n    * Crazyegg\n\n1\n\nLearn more about this provider\n\n_ce.irvPending\n\nExpiry: SessionType: HTTP\n\n    * matomo.mdpi.com\n\n1\n\n_pk_hsr.0.01efPending\n\nExpiry: 1 dayType: HTTP\n\n    * www.mdpi.com\n\n3\n\nhypothesis.testKeyPending\n\nExpiry: PersistentType: HTML\n\nmdpi_layout_type_v2Pending\n\nExpiry: 1 yearType: HTTP\n\nsettings_cachedPending\n\nExpiry: SessionType: HTTP\n\nCross-domain consent[#BULK_CONSENT_DOMAINS_COUNT#] [#BULK_CONSENT_TITLE#]\n\nList of domains your consent applies to: [#BULK_CONSENT_DOMAINS#]\n\nCookie declaration last updated on 3/25/24 by Cookiebot\n\n## [#IABV2_TITLE#]\n\n[#IABV2_BODY_INTRO#]\n\n[#IABV2_BODY_LEGITIMATE_INTEREST_INTRO#]\n\n[#IABV2_BODY_PREFERENCE_INTRO#]\n\n[#IABV2_BODY_PURPOSES_INTRO#]\n\n[#IABV2_BODY_PURPOSES#]\n\n[#IABV2_BODY_FEATURES_INTRO#]\n\n[#IABV2_BODY_FEATURES#]\n\n[#IABV2_BODY_PARTNERS_INTRO#]\n\n[#IABV2_BODY_PARTNERS#]\n\nCookies are small text files that can be used by websites to make a user's\nexperience more efficient.\n\nThe law states that we can store cookies on your device if they are strictly\nnecessary for the operation of this site. For all other types of cookies we\nneed your permission.\n\nThis site uses different types of cookies. Some cookies are placed by third\nparty services that appear on our pages.\n\nYou can at any time change or withdraw your consent from the Cookie\nDeclaration on our website.\n\nLearn more about who we are, how you can contact us and how we process\npersonal data in our Privacy Policy.\n\nPlease state your consent ID and date when you contact us regarding your\nconsent.\n\nPowered by Cookiebot by Usercentrics\n\nNext Article in Journal\n\nGreen Information Systems\u2014A Bibliometric Analysis of the Literature from 2000\nto 2023\n\nPrevious Article in Journal\n\nTransfer Learning Method from Parameter Scene to Physical Scene Based on Self-\nGame Theory\n\nPrevious Article in Special Issue\n\nTime-Allocation Adaptive Data Rate: An Innovative Time-Managed Algorithm for\nEnhanced Long-Range Wide-Area Network Performance\n\n## Journals\n\nActive Journals Find a Journal Proceedings Series\n\n## Topics\n\n## Information\n\nFor Authors For Reviewers For Editors For Librarians For Publishers For\nSocieties For Conference Organizers\n\nOpen Access Policy Institutional Open Access Program Special Issues Guidelines\nEditorial Process Research and Publication Ethics Article Processing Charges\nAwards Testimonials\n\n## Author Services\n\n## Initiatives\n\nSciforum MDPI Books Preprints.org Scilit SciProfiles Encyclopedia JAMS\nProceedings Series\n\n## About\n\nOverview Contact Careers News Press Blog\n\nSign In / Sign Up\n\n## Notice\n\nclear\n\n## Notice\n\nYou are accessing a machine-readable page. In order to be human-readable,\nplease install an RSS reader.\n\nContinue Cancel\n\nclear\n\nAll articles published by MDPI are made immediately available worldwide under\nan open access license. No special permission is required to reuse all or part\nof the article published by MDPI, including figures and tables. For articles\npublished under an open access Creative Common CC BY license, any part of the\narticle may be reused without permission provided that the original article is\nclearly cited. For more information, please refer to\nhttps://www.mdpi.com/openaccess.\n\nFeature papers represent the most advanced research with significant potential\nfor high impact in the field. A Feature Paper should be a substantial original\nArticle that involves several techniques or approaches, provides an outlook\nfor future research directions and describes possible research applications.\n\nFeature papers are submitted upon individual invitation or recommendation by\nthe scientific editors and must receive positive feedback from the reviewers.\n\nEditor\u2019s Choice articles are based on recommendations by the scientific\neditors of MDPI journals from around the world. Editors select a small number\nof articles recently published in the journal that they believe will be\nparticularly interesting to readers, or important in the respective research\narea. The aim is to provide a snapshot of some of the most exciting work\npublished in the various research areas of the journal.\n\nOriginal Submission Date Received: .\n\n  * Journals\n\n    *       * Active Journals\n      * Find a Journal\n      * Proceedings Series\n\n  * Topics\n  * Information\n\n    *       * For Authors\n      * For Reviewers\n      * For Editors\n      * For Librarians\n      * For Publishers\n      * For Societies\n      * For Conference Organizers\n\n      * Open Access Policy\n      * Institutional Open Access Program\n      * Special Issues Guidelines\n      * Editorial Process\n      * Research and Publication Ethics\n      * Article Processing Charges\n      * Awards\n      * Testimonials\n\n  * Author Services\n  * Initiatives\n\n    *       * Sciforum\n      * MDPI Books\n      * Preprints.org\n      * Scilit\n      * SciProfiles\n      * Encyclopedia\n      * JAMS\n      * Proceedings Series\n\n  * About\n\n    *       * Overview\n      * Contact\n      * Careers\n      * News\n      * Press\n      * Blog\n\nSign In / Sign Up Submit\n\nJournals\n\nElectronics\n\nVolume 13\n\nIssue 7\n\n10.3390/electronics13071328\n\nSubmit to this Journal Review for this Journal Propose a Special Issue\n\n\u25ba \u25bc Article Menu\n\n## Article Menu\n\n  * Academic Editors\n\nEleftherios Anastasiadis\n\nDionisis Kandris\n\n  * Subscribe SciFeed\n  * Recommended Articles\n  * Related Info Link\n\n    * Google Scholar\n\n  * More by Authors Links\n\n    * on DOAJ\n\n      * Neves, B. Pinto\n      * Santos, V. D. N.\n      * Valente, A.\n\n    * on Google Scholar\n\n      * Neves, B. Pinto\n      * Santos, V. D. N.\n      * Valente, A.\n\n    * on PubMed\n\n      * Neves, B. Pinto\n      * Santos, V. D. N.\n      * Valente, A.\n\n/ajax/scifeed/subscribe\n\nArticle Views 793\n\n  * Table of Contents\n\n    * Abstract\n    * Introduction\n    * Related Work\n    * Method Development\n    * Results\n    * Conclusions\n    * Author Contributions\n    * Funding\n    * Data Availability Statement\n    * Conflicts of Interest\n    * References\n\nAltmetric share Share announcement Help format_quote Cite question_answer\nDiscuss in SciProfiles thumb_up\n\n...\n\nEndorse textsms\n\n...\n\nComment\n\n## Need Help?\n\n### Support\n\nFind support for a specific problem in the support section of our website.\n\nGet Support\n\n### Feedback\n\nPlease let us know what you think of our products and services.\n\nGive Feedback\n\n### Information\n\nVisit our dedicated information section to learn more about MDPI.\n\nGet Information\n\nclear\n\n## JSmol Viewer\n\nclear\n\nfirst_page\n\nDownload PDF\n\nsettings\n\nOrder Article Reprints\n\nFont Type:\n\nArial Georgia Verdana\n\nFont Size:\n\nAa Aa Aa\n\nLine Spacing:\n\nColumn Width:\n\nBackground:\n\nOpen AccessFeature PaperArticle\n\n# Innovative Firmware Update Method to Microcontrollers during Runtime\n\nby Bernardino Pinto Neves\n\nBernardino Pinto Neves\n\nSciProfiles Scilit Preprints.org Google Scholar\n\n^ 1^, Victor D. N. Santos\n\nVictor D. N. Santos\n\nSciProfiles Scilit Preprints.org Google Scholar\n\n^ 2,3^ and Ant\u00f3nio Valente\n\nAnt\u00f3nio Valente\n\nSciProfiles Scilit Preprints.org Google Scholar\n\n^ 1,4,*^\n\n^1\n\nEngineering Department, School of Sciences and Technology, University of Tr\u00e1s-\nos-Montes and Alto Douro (UTAD), Quinta de Prados, 5000-801 Vila Real,\nPortugal\n\n^2\n\nPolytechnic Institute of Coimbra, Coimbra Institute of Engineering, Rua Pedro\nNunes-Quinta da Nora, 3030-199 Coimbra, Portugal\n\n^3\n\nINESC Coimbra, DEEC, Polo II, 3030-290 Coimbra, Portugal\n\n^4\n\nINESC Technology and Science, 4200-465 Porto, Portugal\n\n^*\n\nAuthor to whom correspondence should be addressed.\n\nElectronics 2024, 13(7), 1328; https://doi.org/10.3390/electronics13071328\n\nSubmission received: 23 February 2024 / Revised: 25 March 2024 / Accepted: 28\nMarch 2024 / Published: 1 April 2024\n\n(This article belongs to the Special Issue Advanced Wireless Sensor Networks:\nApplications, Challenges and Research Trends)\n\nDownload keyboard_arrow_down\n\nDownload PDF Download PDF with Cover Download XML Download Epub\n\nBrowse Figures\n\nReview Reports Versions Notes\n\nArticle Views\n\nCitations -\n\n## Abstract\n\nThis article presents a new firmware update paradigm for optimising the\nprocedure in microcontrollers. The aim is to allow updating during program\nexecution, without interruptions or restarts, replacing only specific code\nsegments. The proposed method uses static and absolute addresses to locate and\nisolate the code segment to be updated. The work focuses on Microchip\u2019s\nPIC18F27K42 microcontroller and includes an example of updating functionality\nwithout affecting ongoing applications. This approach is ideal for band\nlimited channels, reducing the amount of data transmitted during the update\nprocess. It also allows incremental changes to the program code, preserving\nnetwork capacity, and reduces the costs associated with data transfer,\nespecially in firmware update scenarios using cellular networks. This ability\nto update the normal operation of the device, avoiding service interruption\nand minimising downtime, is of remarkable value.\n\nKeywords:\n\nfirmware update; partial update; runtime; internet of things; microcontrollers\n\nGraphical Abstract\n\n## 1\\. Introduction\n\nIn electronic devices that incorporate microcontrollers, it is common to\nimplement firmware update mechanisms to correct errors and make new services\navailable after the product has been launched. Firmware updates often involve\nrisks related with downtime, failure of the update itself, and costs\nassociated with communications to support those updates. The article aims to\naddress these limitations by presenting an innovative firmware update method\nthat minimises or eliminates downtime and optimises the data to be updated.\nDespite the importance of this topic, there is little research into efficient\nfirmware update methods that minimise or eliminate downtime. There are devices\nfor which interruption of operation is critical, for example, the digital\ncontrol of the power supply of a data centre (or other critical system) in a\nnon-redundant configuration. In this scenario, firmware updates on the power\nsupply unit can lead to temporary service interruptions [1]. Kilpel\u00e4inen [2]\npresents an innovative method for dynamic firmware updates, addressing updates\nwithout the need to reboot the device and modify the program code during\nexecution. With regard to the efficient use of the communications channel, the\nliterature refers to methods for optimising the data transmission to be\nupdated. Bogdan [3] focuses on optimising data transmission in firmware update\nprocesses, detailing the concept of delta transmission and its combination\nwith data compression. That work is based on the use of opcodes instead of\naddresses, offering an innovative perspective to efficiently transmit the\nupdates. The system inactivity time present in the aforementioned methods,\nwhich assume a reboot after the update, led to the proposal of an innovative\nfirmware update method based on block updates, with the aim of replacing\nspecific code segments the program\u2019s memory, which is done during runtime and\nwithout the need for a reboot. The originality of this study lies in the\ninnovative approach of updating firmware by blocks, enabling an efficient and\nsecure implementation while minimising negative impacts on system operations.\nThis new method is expected to significantly reduce downtime and the use of\ncommunication channels. A circuit with a PIC18F27K42 microcontroller [4] was\ndeveloped to validate the method. The firmware that comprises the applications\nand the update process was initially uploaded to that circuit using a RS232\nserial channel and a serial terminal. The article is organised in sections.\nSection 2 describes several similar related studies. Section 3 gives a\ndetailed description of the implemented block oriented firmware update method\nand the assumptions that allow the method to be successfully replicated. The\ncommunications protocol used to perform the update file transfer is also\ndescribed as well the update process. In Section 4, the results obtained are\ndescribed. Section 5 presents the main conclusions derived from the findings\nof this study.\n\n## 2\\. Related Work\n\nSeveral notable studies were analysed related to the firmware updates\nmanagement, optimisation of the update files transmission, and improving the\nprocess of writing to the microcontroller\u2019s program memory. In the field of\nfirmware update management, Mahfoudhi [5] describes an over-the-air firmware\nupdate management model for NB-IoT networks as the number of end devices\nincreases significantly, seeking improvements in flexibility, installation\ntime, efficiency, and cost reduction. In a similar context, Frisch [6]\nproposes a set of models and rules for the firmware update process based on\nsecure distribution and automatic installation mechanisms. Kachman [7]\naddresses energy efficiency and its impact on firmware update processes as\nwell as explores the evolution of this method based on delta transmission. In\nthe area of optimising the transmission of update files, several significant\nstudies stand out. Wee [8] presents a methodology for transmitting update\nfiles that is based on the differences between the new and old firmware, with\nthe aim of optimising the firmware update process. Moreover, a high speed\ncompression and decompression algorithm to significantly speed up the update\ntime is described. Ji [9] refers to a study that focuses on the incremental\nfirmware update method by modules. This method is based on assigning memory\nzones to each module and introducing the concept of static allocation of\nfunctions and relevant security considerations. This innovative approach\nimproves the efficiency and security of firmware updates. Regarding the\noptimising of the writing process of to the microcontroller\u2019s program memory,\nseveral studies have made significant contributions. Jisu Kwon [10] presents a\nmethod of updating the microcontroller\u2019s program memory based on updating by\nfunctional blocks. This makes possible a partial update of the program memory\ninstead of completely rewriting it, avoiding downtime during the update\nprocess. Xia [11] presents the concept of function addressing by means of a\nmodule orientated programming model. In this model, the code is organised\naround modes and modules for a generic dispatching procedure. Xia also\nintroduces the concept of multimode application management, grouping together\napplications with similar behaviour and analysing performance evaluation\ntechniques and metrics. Dhakal [12] presents an architecture based on delta\nupdates and incremental mode for large scale IoT systems and refers to the\nability to verify firmware integrity, highlighting the advantages of delta\nupdates and identifying scenarios in which this method may not be efficient.\nSun [13] reveals the limits of conventional firmware update methods and\nproposes a method that uses partial updates, optimising the lifetime of\nprogram memory. This method is based on partitioning the program memory into\nseveral sections, updating only the relevant section, and classifying each\npartition as a component. The study addresses security mechanisms, such as\nencryption, signing, and validation before and after the update, as well as\nsolutions for the static allocation of functions in scenarios where the\nfunction addresses are different between the two firmware versions; in\naddition, the update method is based on packets that include the functions or\nmodules to be updated, and the study presents a statistical analysis of update\ntimes as a function of the transmission channel. Kwon [14] proposes\npartitioning the firmware into functional blocks, introducing the concept of a\nfunction map. The method aims to update only the functional blocks with\ndifferences, reducing the use of program memory, energy consumption, and\nupdate time. This involves sending a functional block, where the updating\napplication checks for differences and updates only what is necessary, then\nupdating the function map to reflect the new state. Baldassari [15] explores\ndelta firmware updates in scenarios with bandwidth constraints by updating\nonly small memory files of the firmware. The study details the delta update\nprocess, which requires one application to build the delta file and another to\nrebuild the new firmware from the received deltas. Although this approach\noffers the advantage of updating the firmware with small memory files, it also\nhas disadvantages, such as greater complexity compared to traditional methods,\na higher probability of failure, and the need to keep a copy of the original\nversion of the firmware in the microcontroller. In addition, it requires\nsubstantial resources on the microcontroller side, including memory and\nprocessing to handle delta updates and corrections.\n\n## 3\\. Method Development\n\nThe underlying idea of the proposed new method consists of the Non Volatile\nMemory (NVM) controller usage to directly update parts of the existent program\ncode. The NVM controller is a hardware resource present in the majority of\nmicrocontrollers that is responsible for the management of non-volatile\nmemory\u2014also known as flash memory\u2014the type of memory that retains data even\nwhen the microcontroller is turned off. The above mentioned NVM controller\nacts over the available flash memory blocks allowing one to read, write, and\nerase the existing data in memory. The use of this NVM controller allow us to\nupdate the existent firmware during runtime in the same way we can read and\nwrite NVM user data without compromising the operation of the applications.\nConsequently, an update task application is added that aims to receive the\ndata blocks associated with the code of a particular application and update\nthem in the flash program memory, as illustrated in Figure 1.\n\nFigure 1. Runtime firmware updates method.\n\nThe non-volatile memory of a microcontroller is usually segmented or organised\ninto several sectors, most of them devoted to the program memory. The program\nmemory can be configured with different partitions, sizes, and write\nprotection attributes. These partitions can be configured to implement the\nboot area, the application area, and the user memory data. In this paper, a\nPIC18F27K42 microcontroller is used as a testbed platform to validate the\nproposed techniques. This microcontroller has a non-volatile memory control\nmechanism that uses an internal timer and voltage generator to perform writing\noperations. Reading program memory is executed byte by byte. The writing\nprocess is, however, more complex, as it requires the operation to be\nperformed on a row of bytes. The content of this row must be previously erased\nor available for writing if it is its first use. The writing operation also\nrequires that a write unlock sequence be activated [4]. Writing or erasing\nprogram memory will halt the microcontroller central processing unit CPU,\nmaking it impossible to execute instructions from the memory row that is being\nerased, as the microcontroller CPU is blocked until the process is completed\n[4]. For the above mentioned PIC18F27K42, the measured erasing and writing\nprocedures take 10 ms per row. Table 1 illustrates the size and number of rows\n[4].\n\nTable 1. Size and number of rows, PIC18F27K42.\n\nThe program memory read operation does not modify data; therefore, it is very\nsimple to carry out, simply defining the memory area to be accessed. To\ncomplete this operation, we need to previously select the program flash memory\nand set the address to be read using the TBLPTR register, then read the\ncontents of that position. Note that the reading is performed byte to byte,\nbut each program memory position has a size of two bytes; therefore, it is\nnecessary to increment the pointer of the reading table TBLRD for each byte\nread. The result is in the register TABLAT: the first byte corresponds to the\nless significant byte and the second to the most significant byte of the\nspecified memory position content [4]. To read the contents of a particular\nprogram memory address, the following sequence of operations must be\ncompleted, as illustrated in the flowchart of Figure 2.\n\nFigure 2. Reading the contents of program memory PIC18F27K42.\n\nThe write operation follows the same principle as the read operation, but\noperates over rows instead of bytes. The write operation is performed on an\nentire row, but it is implemented byte by byte [4]. As a recommended practice,\nin a write operation in which only part of the row is changed, it is suggested\nthat the row be read and stored in volatile memory RAM before being erased.\nThe copied row is then updated with the portion of the data that differs from\nthe original version. Finally, the NVM row should be deleted and rewritten\nwith the updated version. For the writing process to be successful, we must\nfirst make sure that the row is available for writing; in other words, the row\nis formatted. Thereafter, it is necessary to define the NVM area to be used\nfor writing, where through the TBLPTR register we define the address we want\nto write; as with reading, the writing is also done byte by byte, and, in the\nwriting process, the least significant byte is copied to the register TABLAT\nfollowed by the increment of the writing table TBLWR. That process is repeated\nfor the most significant byte. After copying the row, the next step involves\nactivating the NVMCON1bits.WREN write permission bit as well as selecting the\nNVMCON1bits.FREE write bit command, followed by sending the write unblock\nsequence to the NVM. The actual write is initiated by activating the\nNVMCON1bits.WR bit [4]; see the flowchart in Figure 3.\n\nFigure 3. Writing process to program memory PIC18F27K42.\n\nTo erase a row of non-volatile memory, a specific NVM controller command is\nused devoted for that purpose. The FREE bit of the NVMCON1 register, if\nenabled, indicates that on the next enable the WR bit of the same register\nwill erase the row specified by the address contained in the TBLPTR register.\nMoreover, it is necessary to previously unlock a specific range of rows to\naccommodate the program code and thereafter complete the erase procedure [4],\nas depicted in the flowchart in Figure 4.\n\nFigure 4. Erasing a row of program memory PIC18F27K42.\n\nThe NVM memory locking mechanism prevents unintended self-write programming or\nerasing. Thus, to promote memory integrity, any write and erase operation\nperformed by the NVM controller must be preceded by an unlocking process. This\nprocess must be executed sequentially and without interruptions. If the\nsequence, for some reason, is interrupted, the writing or erasing process is\ncancelled [4]. To implement this method successfully, two non-mandatory but\nhighly recommended requirements must be met to facilitate its implementation.\nThe first one concerns the static and absolute allocation of the functions.\nTypically, a compiler, in order to optimise the space of the memory of the\nprogram, leans all the code to minimise the used memory space, making it more\ndifficult to identify the location of the block of code that will need to be\nupdated. By allocating the function\u2019s code in a static and absolute way, an\nabsolute reference of the location of each function of program is set,\nfacilitating the identification of the code block in an Intel Hex file (see\nFigure 5).\n\nFigure 5. Example of memory allocation with and without static and absolute\nallocation.\n\nThe usage of static and absolute function allocation also improves the code\norganisation. Without static and absolute allocation, even small changes in\nsource code can result in a hex file completely reformulated by the compiler.\nThe usage of static and absolute allocation avoids major changes. Now, small\ncode changes in specific functions will only affect the associated allocated\nmemory areas, as illustrated in Figure 6.\n\nFigure 6. Result of the hexadecimal file with the change of only one line of\ncode.\n\nStatic and absolute allocation of functions requires well designed system\narchitecture and a complete knowledge of the program\u2019s memory map in order to\navoid overlaps between the functions or applications code blocks. In order to\nprevent an accidental overlap of two or more functions, the compiler warns us\nby displaying a message with the functions that are at stake, promoting the\nnecessary changes in the memory map. The following error message was generated\nby the compiler under the above mentioned conditions [16].\n\nerror: (596)\n\nsegment \u201c_Reset_CNT_TMR_text\u201d (19574-195A3)\n\noverlaps segment \u201c_TMR0_Interrupt_Handling_text\u201d (194F6-1958F)\n\nThe second requirement concerns the size allocated to each function, which\nmust be an integer multiple of row size; in the considered microcontroller,\nthat size is equal to 128 bytes [4]. An example of a program memory map is\ndepicted in Figure 7.\n\nFigure 7. Example of program memory map.\n\nThe following step, after the program memory map definition, comprises setting\nthe function\u2019s indexes addresses in the above mentioned range. To allocate a\nfunction in a static and absolute way, one simply needs to add before the\nfunction name the method __at(address); from here, the compiler will place\nthat function in that specific address, as illustrated in the following\nfunction prototype.\n\nvoid __at(APP_1_Start_Address) App_1(void)\n\nTo validate this method, a testbed was developed comprising a circuit board\nwith the microcontroller, two push buttons, and an ICSP header (depicted in\nFigure 8).\n\nFigure 8. Layout of the circuit implemented to validate the method.\n\nThe firmware project comprises three applications: two similar applications\nassociated to different hardware resources, in this case push buttons, and In\nApplication Programming (IAP) that performs an update of the firmware by means\nof a runtime self programming process. The first application prints in the\nserial port the message \u201cButton 1 has been pressed\u201d when button 1 is pressed.\nSimilarly, the second application prints the message \u201cButton 2 has been\npressed\u201d in the serial port when button 2 is pressed. These messages are\ndefined and saved in the microcontroller flash memory. Figure 9 illustrates\nthe flowchart of the implemented program.\n\nFigure 9. Implemented system and applications used to validate the proposed\nmethod.\n\nAfter executing a firmware upgrade operation, it is intended to update the\nmessage printed by the first application from \u201cButton 1 has been pressed\u201d to\n\u201cThis string has been changed by update at run time\u201d, whenever the hardware\nbutton 1 is pressed (see Figure 10).\n\nFigure 10. Proposed amendment for App_1.\n\nFrom the analysis of the compiled program code, it can be seen where each\nfunction of the first application is allocated in the program memory (see\nFigure 11 and example of program memory map in Figure 7).\n\nFigure 11. Sample code and location of functions in program flash memory.\n\nAdditionally, it is also possible to identify and locate application 1 in the\nhexadecimal file generated from the compiler (see Figure 12).\n\nFigure 12. Location of functions in program memory in the hexadecimal file.\n\nFrom the analysis of the modified program hexadecimal file, it can be\nconcluded that only a well defined area of the program memory was changed; all\nthe remaining program memory stays intact. Figure 13 presents the original and\nupgraded code versions of the aforementioned application 1, demonstrating the\ncode blocks that have been removed on the original version and the ones that\nhave been inserted on the modified one.\n\nFigure 13. Changed program memory area viewed from hexadecimal file.\n\nUsing the static and absolute function allocation allows one to control and\nmanipulate the entire program memory, making the updating task easier and\nkeeping the firmware update circumscribed to a well defined block of program\nmemory between addresses 0x00001280 and 0x000012B0. The update process\nconsists of receiving a hexadecimal file in the Intel Hex File format [17]\nover the serial channel. However, as only one block of the program\u2019s memory is\nto be updated and the hexadecimal file is not formatted to send a single block\nbut the entire file, some changes need to be made so that the update process\napplication can interpret the file correctly. Those changes include the\naddition of a start file, followed by the most significant word of the address\nand the end of file, as illustrated in Figure 14.\n\nFigure 14. Update file in Intel Hex File format, adapted to the application.\n\nThe Intel Hex File format is one of the formats used to update\nmicrocontrollers\u2019 firmware, but there are also other possible formats, such as\nthe binary .bin file. The Intel Hex File format is characterized by the lines\nbeing in hexadecimal format; all the lines start with the character \u2018:\u2019\nfollowed by the data field length, start address, data type, the associated\ndata (for each specific data type), and, finally, the error control checksum\nmechanism [17].\n\nFigure 13 depicts the hexadecimal file obtained from the compiled modified\ncode, which is sent to the microcontroller according to the aforementioned\nIntel Hex File format described in Figure 15 and Table 2. As explained\npreviously, with the inclusion of all the fields, the file sent to the\nmicrocontroller is the one presented in Figure 14. The update file results\nfrom the extraction of a block of program memory of the hexadecimal file with\nthe updated code; the file is started with a start file named Update, followed\nby the most significant word of the address, the data to update, and, finally,\nthe end of file indicator. The update process application is responsible for\nthe file receiving and processing. The initial state of the update process app\nwaits for the reception of a start file, \u201cUpdate\u201d string, to proceed to the\ndata acquisition state. In this state, the process waits until it receives a\ncomplete record and verifies its integrity using the checksum mechanism. If\nthe line is valid, the process thereafter extracts the address, the type, and\nthe data contained in the line. Depending on the type of data, the process\nreacts accordingly. For Extended Linear Address type, the MSW of the address\nis defined; if the type is \u201cData_Record\u201d, it updates the LSW of the address\nand copies the data to a process buffer; finally, if the type is End of file,\nthe process proceeds to the next stage, updating the program memory block.\nFirst, it copies the area of the program memory block to be updated to\nvolatile memory RAM for final verification purposes of the update integrity;\nin the next operation, it erases the memory block to be updated, followed by\nupdating with the data received by the update file; finally, a verification is\nperformed between the data in the update file received and the data stored in\nthe updated memory block. The update process application can be seen in the\nflowchart in Figure 16.\n\nFigure 15. Intel Hex File record format [17].\n\nFigure 16. Updating process application state diagram.\n\nTable 2. Line fields structure, Intel Hex File format [17].\n\nIf the process was completed successfully, it reports \u201cUpdate success\u201d;\notherwise, it reports \u201cUpdate failure\u201d through the serial channel. Figure 17\nillustrates the update file transfer protocol implemented between the host and\nthe device microcontroller.\n\nFigure 17. Implemented update file transfer protocol.\n\n## 4\\. Results\n\nThis section presents the results obtained by the proposed novel firmware\nupdate method during runtime. This method was validated using the previously\npresented example program and testbed. First, an Intel hex file was sent to\nthe PIC18F27K42 microcontroller using an RS232 terminal to change program\nmemory, updating the message that occurs when the push button is activated.\nThe update process application receives and verifies the integrity of the\nIntel hex file, producing the desired modification in one particular block of\nthe flash memory (see Figure 18). The updated applications now operate\naccordingly with the performed changes. The application assigned to button, 1\ninstead of printing the message \u201cButton 1 has been pressed\u201d on the serial\nport, starts to print a different message: \u201cThis string has been changed by\nupdate at run time\u201d. It is also possible to verify through the terminal log\ntime that the update completion time took around 63 ms, which is the expected\nvalue for an update with a size of 128 bytes. The 63 ms corresponds to about\n52 ms spent in the transmission (about 200 bytes at a rate of 38.4 kbps), 10\nms in the block update [4], and about 1 ms in the update process. One of the\nmain contributions of this study is the significant reduction in downtime\nduring the update process as well as the elimination of the need for rebooting\nthe end device after the update. Moreover, this method aims to overcome some\nlimitations associated with the delta firmware update method described in\n[3,12,15], namely, the requirement to reconstruct the firmware from the\ndeltas, leading to resource savings and process simplification.\n\nFigure 18. Microcontroller update during runtime.\n\n## 5\\. Conclusions\n\nIn this paper, a new firmware update method for microcontrollers is presented,\nimplemented, and validated. This new method differs from existing ones because\nit allows for updating only specific code lines, blocks, or functions instead\nof replacing the entire program during runtime. This method is suited to band\nlimited channels that take into account the attained reduction on the amount\nof data transmitted. The proposed update procedure offers additional\nadvantages, such as a reduced downtime, less than 10 ms, and good\nrecoverability in a failure scenario.\n\nThe planned method also presents some limitations; the update process was\ndesigned to update only up to eight rows (1024 bytes\u2019 maximum), so it is\ntherefore impossible to update the entire program memory at once.\n\nThis firmware update method is also incompatible with operating systems and/or\nintermediate hardware abstraction layers; it requires full control over all\nfunctionalities. Moreover, under a power failure event, the success of the\nupdate process is not guaranteed. Thus, it is advisable to include a\nsupercapacitor-based backup power circuit to maintain module power and the\nupgrade process integrity.\n\nThis method was successfully and easily replicated on several\nmicrocontrollers, such as the MSP430, STM8, STM32, ATtiny, ATmega, SAMD21, and\nPIC32. This observation emphasises the feasibility and applicability of the\nmethod on a broad set of microcontrollers, thus increasing the scope of its\npotential usefulness. Future advances on the proposed method must consider the\ninclusion of radio transmission, using LoRaWAN or available cellular networks,\nto send the update file to remote sensor end-devices. An automated process to\nmanage the partitioning of program memory and assign to each specific function\nan area of appropriated size based on its likelihood of being updated will\nalso be investigated in the future. In conclusion, this article leaves an open\ndoor to a new generation of firmware updates for microcontrollers.\n\n## Author Contributions\n\nConceptualization, A.V.; Formal analysis, V.D.N.S.; Investigation, B.P.N.;\nMethodology, B.P.N., V.D.N.S. and A.V.; Resources, V.D.N.S.; Writing\u2014original\ndraft, B.P.N.; Writing\u2014review and editing, V.D.N.S. and A.V. All authors have\nread and agreed to the published version of the manuscript.\n\n## Funding\n\nThis work was financed by National Funds through the Portuguese funding\nagency, FCT\u2014Funda\u00e7\u00e3o para a Ci\u00eancia e a Tecnologia, within project\nLA/P/0063/2020. DOI\n10.54499/LA/P/0063/2020|https://doi.org/10.54499/LA/P/0063/2020. This work was\nsupported by the Portuguese Foundation for Science and Technology under the\nproject grant UIDB/00308/2020 with the DOI\n10.54499/UIDB/00308/2020|https://doi.org/10.54499/UIDB/00308/2020.\n\n## Data Availability Statement\n\nData are contained within the article.\n\n## Conflicts of Interest\n\nThe authors declare no conflict of interest.\n\n## References\n\n  1. Dumais, A.; Schlunder, H. AN2601\u2014Online Firmware Updates in Timing-Critical Applications; Microchip Technology Inc.: Chandler, AZ, USA, 2018; Available online: https://ww1.microchip.com/downloads/en/Appnotes/Live%20Update%20Application%20Note.pdf (accessed on 27 March 2024).\n  2. Kilpel\u00e4inen, H. Dynamic Firmware Updating of an Embedded System. Bachelor\u2019s Thesis, Information and Communications Technology, Metropolia University of Applied Sciences, Metropolia, Finland, 2023. [Google Scholar]\n  3. Bogdan, D.; Bogdan, R.; Popa, M. Delta flashing of an ECU in the automotive industry. In Proceedings of the IEEE 11th International Symposium on Applied Computational Intelligence and Informatics (SACI), Timisoara, Romania, 12\u201314 May 2016. [Google Scholar] [CrossRef]\n  4. Low-Power High-Performance Microcontrollers with XLP Technology; PIC18(L)F26/27/45/46/47/55/56/57K42, Datasheet; Microchip Technology Inc.: Chandler, AZ, USA, 2021; Available online: https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/PIC18%28L%29F26-27-45-46-47-55-56-57K42-Data-Sheet-40001919G.pdf (accessed on 27 March 2024).\n  5. Mahfoudhi, F.; Sultania, A.K.; Famaey, J. Over-the-air firmware updates for constrained Nb-IOT devices. Sensors 2022, 22, 7572. [Google Scholar] [CrossRef] [PubMed]\n  6. Frisch, D.; Rei\u00dfmann, S.; Pape, C. An Over the Air Update Mechanism for ESP8266 Microcontrollers. 2017. Available online: https://www.researchgate.net/publication/320335879 (accessed on 27 March 2024).\n  7. Kachman, O.; Balaz, M. Optimized differencing algorithm for firmware updates of low-power devices. In Proceedings of the IEEE 19th International Symposium on Design and Diagnostics of Electronic Circuits & Systems (DDECS), Kosice, Slovakia, 20\u201322 April 2016. [Google Scholar] [CrossRef]\n  8. Wee, Y.; Kim, T. A new code compression method for FOTA. IEEE Trans. Consum. Electron. 2010, 56, 2350\u20132354. [Google Scholar] [CrossRef]\n  9. Ji, Z.; Xiangyu, Z.; Yong, P. Implementation and research of bootloader for automobile ECU remote incremental update. In Proceedings of the AASRI International Conference on Industrial Electronics and Applications, London, UK, 27\u201328 June 2015. [Google Scholar] [CrossRef]\n  10. Kwon, J. Available online: https://ai-soc.github.io/m_jskwon.html (accessed on 10 January 2024).\n  11. Xia, M.; Chi, K.; Wang, X.; Cheng, Z. Mode-oriented hybrid programming of sensor network nodes for supporting rapid and Flexible Utility Assembly. Comput. Netw. 2019, 158, 77\u201397. [Google Scholar] [CrossRef]\n  12. Dhakal, S.; Jaafar, F.; Zavarsky, P. Private Blockchain Network for IOT device firmware integrity verification and update. In Proceedings of the IEEE 19th International Symposium on High Assurance Systems Engineering (HASE), Hangzhou, China, 3\u20135 January 2019. [Google Scholar] [CrossRef]\n  13. Sun, S. Design and Implementation of Partial Firmware Upgrade. Master\u2019s Thesis, School of Electrical Engineering and Computer Science, KTH Royal Institute of Technology, Stockholm, Sweden, 2019. [Google Scholar]\n  14. Kwon, J.; Cho, J.; Park, D. Function block-based robust firmware update technique for additional flash-area/energy-consumption overhead reduction. In Proceedings of the International Symposium on Intelligent Signal Processing and Communication Systems (ISPACS), Taipei, Taiwan, 3\u20136 December 2019. [Google Scholar] [CrossRef]\n  15. Baldassari, F. Saving Bandwidth with Delta Firmware Updates. Interrupt. 2022. Available online: https://interrupt.memfault.com/blog/ota-delta-updates (accessed on 10 January 2024).\n  16. MPLAB XC8 C Compiler. MPLAB\u00ae XC8 C Compiler User\u2019s Guide for PIC\u00ae MCU; Microchip Technology Inc.: Chandler, AZ, USA, 2020; Available online: https://ww1.microchip.com/downloads/en/devicedoc/50002053g.pdf (accessed on 27 March 2024).\n  17. Bootloader Generator User\u2019s Guide; DS400001779B; Microchip Technology Inc.: Chandler, AZ, USA, 2020; Available online: https://ww1.microchip.com/downloads/en/DeviceDoc/40001779B.pdf (accessed on 27 March 2024).\n\nFigure 1. Runtime firmware updates method.\n\nFigure 2. Reading the contents of program memory PIC18F27K42.\n\nFigure 3. Writing process to program memory PIC18F27K42.\n\nFigure 4. Erasing a row of program memory PIC18F27K42.\n\nFigure 5. Example of memory allocation with and without static and absolute\nallocation.\n\nFigure 6. Result of the hexadecimal file with the change of only one line of\ncode.\n\nFigure 7. Example of program memory map.\n\nFigure 8. Layout of the circuit implemented to validate the method.\n\nFigure 9. Implemented system and applications used to validate the proposed\nmethod.\n\nFigure 10. Proposed amendment for App_1.\n\nFigure 11. Sample code and location of functions in program flash memory.\n\nFigure 12. Location of functions in program memory in the hexadecimal file.\n\nFigure 13. Changed program memory area viewed from hexadecimal file.\n\nFigure 14. Update file in Intel Hex File format, adapted to the application.\n\nFigure 15. Intel Hex File record format [17].\n\nFigure 16. Updating process application state diagram.\n\nFigure 17. Implemented update file transfer protocol.\n\nFigure 18. Microcontroller update during runtime.\n\nTable 1. Size and number of rows, PIC18F27K42.\n\nDescription| Value| Units  \n---|---|---  \nErase Row Size| 64| Word  \nLength Row| 128| Byte  \nUser Rows| 1024| Byte  \n  \nTable 2. Line fields structure, Intel Hex File format [17].\n\nField| Designation  \n---|---  \nStart frame| Record start character  \nLength| Two ASCII digits to specify the record data field size  \nAddress| Four ASCII digits to define the starting address of this data record.  \nType| Data type:0\u2014Data record;1\u2014End of file record;2\u2014Extended segment address\nrecord;4\u2014Extended linear address record.  \nData| Data bytes.  \nChecksum| Two ASCII digits representing the checksum calculated as 2s\ncomplement of all preceding bytes in data record except the colon.  \n  \nDisclaimer/Publisher\u2019s Note: The statements, opinions and data contained in\nall publications are solely those of the individual author(s) and\ncontributor(s) and not of MDPI and/or the editor(s). MDPI and/or the editor(s)\ndisclaim responsibility for any injury to people or property resulting from\nany ideas, methods, instructions or products referred to in the content.  \n---  \n\u00a9 2024 by the authors. Licensee MDPI, Basel, Switzerland. This article is an\nopen access article distributed under the terms and conditions of the Creative\nCommons Attribution (CC BY) license\n(https://creativecommons.org/licenses/by/4.0/).\n\n## Share and Cite\n\nMDPI and ACS Style\n\nNeves, B.P.; Santos, V.D.N.; Valente, A. Innovative Firmware Update Method to\nMicrocontrollers during Runtime. Electronics 2024, 13, 1328.\nhttps://doi.org/10.3390/electronics13071328\n\nAMA Style\n\nNeves BP, Santos VDN, Valente A. Innovative Firmware Update Method to\nMicrocontrollers during Runtime. Electronics. 2024; 13(7):1328.\nhttps://doi.org/10.3390/electronics13071328\n\nChicago/Turabian Style\n\nNeves, Bernardino Pinto, Victor D. N. Santos, and Ant\u00f3nio Valente. 2024.\n\"Innovative Firmware Update Method to Microcontrollers during Runtime\"\nElectronics 13, no. 7: 1328. https://doi.org/10.3390/electronics13071328\n\nNote that from the first issue of 2016, this journal uses article numbers\ninstead of page numbers. See further details here.\n\n## Article Metrics\n\nYes\n\n### Citations\n\nNo citations were found for this article, but you may check on Google Scholar\n\nNo\n\n### Article Access Statistics\n\nFor more information on the journal statistics, click here.\n\nMultiple requests from the same IP address are counted as one view.\n\nZoom | Orient | As Lines | As Sticks | As Cartoon | As Surface | Previous Scene | Next Scene\n\n## Cite\n\nExport citation file: BibTeX | EndNote | RIS\n\nMDPI and ACS Style\n\nNeves, B.P.; Santos, V.D.N.; Valente, A. Innovative Firmware Update Method to\nMicrocontrollers during Runtime. Electronics 2024, 13, 1328.\nhttps://doi.org/10.3390/electronics13071328\n\nAMA Style\n\nNeves BP, Santos VDN, Valente A. Innovative Firmware Update Method to\nMicrocontrollers during Runtime. Electronics. 2024; 13(7):1328.\nhttps://doi.org/10.3390/electronics13071328\n\nChicago/Turabian Style\n\nNeves, Bernardino Pinto, Victor D. N. Santos, and Ant\u00f3nio Valente. 2024.\n\"Innovative Firmware Update Method to Microcontrollers during Runtime\"\nElectronics 13, no. 7: 1328. https://doi.org/10.3390/electronics13071328\n\nNote that from the first issue of 2016, this journal uses article numbers\ninstead of page numbers. See further details here.\n\nclear\n\nElectronics, EISSN 2079-9292, Published by MDPI\n\nRSS Content Alert\n\n### Further Information\n\nArticle Processing Charges Pay an Invoice Open Access Policy Contact MDPI Jobs\nat MDPI\n\n### Guidelines\n\nFor Authors For Reviewers For Editors For Librarians For Publishers For\nSocieties For Conference Organizers\n\n### MDPI Initiatives\n\nSciforum MDPI Books Preprints.org Scilit SciProfiles Encyclopedia JAMS\nProceedings Series\n\n### Follow MDPI\n\nLinkedIn Facebook Twitter\n\n\u00a9 1996-2024 MDPI (Basel, Switzerland) unless otherwise stated\n\nDisclaimer\n\nDisclaimer/Publisher\u2019s Note: The statements, opinions and data contained in\nall publications are solely those of the individual author(s) and\ncontributor(s) and not of MDPI and/or the editor(s). MDPI and/or the editor(s)\ndisclaim responsibility for any injury to people or property resulting from\nany ideas, methods, instructions or products referred to in the content.\n\nTerms and Conditions Privacy Policy\n\nWe use cookies on our website to ensure you get the best experience. Read more\nabout our cookies here.\n\nAccept\n\n## Share Link\n\nCopy\n\nclear\n\n## Share\n\nclear\n\nBack to TopTop\n\n", "frontpage": false}
