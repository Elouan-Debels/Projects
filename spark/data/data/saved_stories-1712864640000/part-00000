{"aid": "40002050", "title": "Okhsv and Okhsl: two new color spaces for color picking. (2021)", "url": "https://bottosson.github.io/posts/colorpicker/", "domain": "bottosson.github.io", "votes": 1, "user": "fanf2", "posted_at": "2024-04-11 13:42:04", "comments": 0, "source_title": "Two new color spaces for color picking - Okhsv and Okhsl", "source_text": "Two new color spaces for color picking - Okhsv and Okhsl\n\n#\n\nOkhsv and Okhsl\n\n#### Two new color spaces for color picking\n\n> This post has an accompanying interactive comparison of color pickers.\n>\n> I would recommend checking out the interactive demo first, then return if\n> you are interested in the background and technical details.\n\nPicking colors is a common operation in many applications and over the years\ncolor pickers have become fairly standardized. Ubiquitous today are color\npickers based on HSL and HSV. They are simple transformations of RGB values to\nalternative coordinates chosen to better correlate with perceptual qualities.\n\nHere are two common variants of color pickers built on HSL and HSV:\n\nA HSV color picker.\n\nA HSL color picker.\n\nDespite color picking playing a big role in a lot of applications, the design\nof color pickers isn\u2019t a particularly well researched topic. While some\nvariation exist in the widgets themselves, the choice of HSL or HSV is mostly\ntaken for granted, with only a few exceptions.\n\nIs their dominance well deserved or would it be possible to create better\nalternatives? I at least think that this question deserves to be explored and\nthat color picker design should be an active research topic. With this post I\nhope to contribute to the exploration of what a better color picker could and\nshould be, and hopefully inspire others to do the same!\n\nThe main focus here will be on the choice of color space, rather than the\ndesign of the UI widget used for navigating the color space.\n\n> This rest of this post is organized as follow:\n>\n>   * A brief history of color picking\n>   * What are meaningful properties of color spaces for color picking?\n>   * What options exist already and how do they perform?\n>   * Introducing two new color spaces: Okhsl and Okhsv\n>   * Ideas for future work\n>\n\n## Color picking before computers\n\nMunsell Color System. Photo by Hannes Grobe, license CC BY-SA 4.0\n\nExample of NCS color picker. Screenshot from NCS Navigator in the Colourpin\napp.\n\nCategorizing, describing and picking colors is an old problem and predates\ncomputers by many centuries. Over the years countless artists and scientists\nhave worked to understand how humans perceive colors and used that knowledge\nto try and create practical systems for describing colors. Many different\ncolor ordering systems have been created over the years based on mixing\nproperties of paints, light or on perceptual qualities.\n\nDuring the 20th century two important color systems emerged. The Munsell Color\nSystem and the Natural Color System (NCS). Both of them are based on human\nperception and were derived using experiments, but with different approaches.\nThe two systems are used in many practical applications today still.\n\nIn the Munsell color system, colors are described with three parameters,\ndesigned to match the perceived appearance of colors: Hue, Chroma and Value.\nThe parameters are designed to be independent and each have a uniform scale.\nThis results in a color solid with an irregular shape. Modern color spaces and\nmodels, such as CIELAB, Cam16 and my own Oklab, are very similar in their\nconstruction.\n\nThe Natural Color System takes a different approach, and is designed to make\nit easy to describe colors, rather than to match perceptual qualities. It does\nthis by describing colors by their similarity to six primary colors: white,\nblack, yellow, red, green and blue. The yellow, red, green and blue colors are\nused to determine the hue. The final color is described by a color triangle\nwith the corners white, black and the most saturated color of the given hue. A\nposition in the triangle is described with the parameters whiteness,\nblackness, chromaticness. Any two of those parameters are sufficient, since\nthey sum to one.\n\nFor more information about historical color systems, this is a great resource:\ncolorsystem.com.\n\n## What makes a good color picker?\n\nBefore diving into how color pickers have evolved in the digital era, let\u2019s\nlook a bit further at what considerations can be relevant when designing a\ncolor space for color picking. This part assumes familiarity with color\nappearance concepts such as lightness, chroma, saturation and hue.\n\nIn this post the focus will be on what is today the most common case, picking\ncolors in the sRGB gamut. Wide gamut and HDR displays are becoming more common\nand will be increasingly important, so wide gamut and HDR color picking is\ndefinitely a topic for further research and development, but it will not be\nconsidered here.\n\nHere\u2019s an attempt at capturing useful properties for color spaces designed for\npicking colors:\n\n  * Orthogonal Lightness - Hue/Chroma/Saturation can be altered, while keeping perceived Lightness constant\n  * Orthogonal Chroma - Lightness/Hue can be altered, while keeping perceived Chroma constant\n  * Orthogonal Saturation - Lightness/Hue can be altered, while keeping perceived Saturation constant\n  * Orthogonal Hue - Lightness/Chroma/Saturation can be altered, while keeping perceived Hue constant\n  * Simple Geometrical Shape - Fit the target gamut into a cylinder or other simple shape, so that parameters can be altered independently without resulting in colors outside the target gamut. Could also be a swept triangle like NCS, since it is simple to map back and forth to a cylinder.\n  * Max Chroma at edge - Make it easy to find the strongest color of a given hue, by placing the strongest color on edge of the color volume.\n  * Varies Smoothly - Vary smoothly with each parameter. No discontinuous or abrupt changes.\n  * Varies Evenly - The perceived magnitude of the change in color caused by changing a parameter should be uniform for all values of the parameter.\n\nNote: These properties are in conflict, so designing a color space for color\npicking is a about finding which tradeoffs to make. In particular, independent\ncontrol of hue, lightness and chroma can not be achieved in a color space that\nalso maps sRGB to a simple geometrical shape.\n\n## Color spaces for color picking\n\nBy far the most used color spaces today for color picking are HSL and HSV, two\nrepresentations introduced in the classic 1978 paper \u201cColor Spaces for\nComputer Graphics\u201d. HSL and HSV designed to roughly correlate with perceptual\ncolor properties while being very simple and cheap to compute.\n\nWorth noting is that HSL and HSV are not quite color spaces on their own, they\nare transformations from a source RGB color space. For each set of RGB\nprimaries and transfer functions, the transformation to HSL and HSV produces\nunique color spaces. Today HSL and HSV are most commonly used together with\nthe sRGB color space, so that is what we will look at here and we will here\nuse HSL and HSV to refer to HSL and HSV for the sRGB color space.\n\nAlso useful to note is that HSL and HSV are not continuously differentiable,\nso that limits their use with numerical optimization and machine learning.\n\n### HSV\n\nHSV describes colors with three parameters:\n\n  * \"Hue\" - Roughly corresponds to perceived hue, but it has quite severe distortions.\n  * \"Saturation\" - Roughly corresponds to saturation relative to maximum possible saturation in sRGB of the same hue.\n  * \"Value\" - A bit hard to define. Can be seen as how much to mix the color with black, with 100% being no black and 0% completely black. \u201cValue\u201d is sometimes also referred to as Brightness.\n\nHSV is quite similar to the Natural Color System in its structure and it\u2019s\npossible to transform it to have parameters more similar to NCS, then referred\nto as hue, whiteness and blackness (HWB). After that transformation the\nlargest difference compared with NCS are:\n\n  * NCS is derived based on research into the appearance of colors and does a good job at matching human perception\n  * HWB/HSV has a simple construction, not taking research into color appearance into account and is not matching perception closely. Hue is the most problematic.\n  * NCS has a gamut designed to contain pigments realizable in paint/print\n  * HWB/HSV has a gamut based on the RGB color space it is constructed from (most commonly sRGB)\n\nExample of hue distortion for deep blue colors. Notice the purple shift as\nsaturation decreases.\n\n### HSL\n\nHSV describes colors with three parameters:\n\n  * \"Hue\" - Identical to \u201chue\u201d in HSV, with the same issues.\n  * \"Saturation\" - Roughly the chroma of the color relative to the most colorful color with the same \u201clightness\u201d and \u201chue\u201d. Confusingly referred to as saturation, which it is not comparable to. In the original paper it was referred to as \u201crelative chroma\u201d, which is more accurate. Not the same as \u201csaturation\u201d in HSV.\n  * \"Lightness\" - Some correlation with the perception of lightness, with 0% corresponding to black and 100% to white. Does not match the perception of lightness well at all for saturated colors. Referred to as \u201cIntensity\u201d in the original paper.\n\nExample of hue distortion for deep blue colors.\n\nExample of colors HSL considers to have the same lightness.\n\n### HSLuv\n\nHSLuv is a recent development to tackle some of the shortcomings of HSL. It is\nbased on CIELChuv, a cylindrical form of 1976 CIE color space CIELUV. CIELChuv\nis constructed so that for a given hue, all colors of that hue can be\nconstructed by additive blending of white and a saturated color of that hue\n(and in general, additive blending of light forms straight lines in CIELuv).\n\nHSLuv describes colors with three parameters:\n\n  * \"Hue\" - Same as hue in CIELChuv. Does not match the perception of hue fully due to the Abney effect: the perception of hue does not correspond to additive blending.\n  * \"Saturation\" - Based on chroma as defined in CIELChuv, but rescaled to be relative to the most saturated sRGB color of the same \u201clightness\u201d and \u201chue\u201d.\n  * \"Lightness\" - Same as lightness in CIELChuv. Does a good job at matching perceived lightness.\n\nTwo drawback with HSLuv are:\n\n  * Does not match perception of hue. This is particularly obvious for deep blue and purple colors.\n  * The way \u201cSaturation\u201d is defined, it does not vary smoothly due to the uneven shape of the sRGB gamut. E.g. by keeping \u201cSaturation\u201d constant and changing hue, the perceived chroma can change drastically and abruptly.\n\nExample of hue distortion for blue colors. The distortion in HSLuv is\ndifferent from that in sRGB and is caused by the Abney effect.\n\nExample of constant lightness in HSLuv, with low \u201csaturation\u201d close to the\ncenter of the circle and maximum \u201csaturation\u201d at the edge. Notice how the blue\nand red hues are much more saturated than surrounding colors.\n\nSlice of colors with constant \u201csaturation\u201d in HSLuv. The scaling to match the\nuneven shape of the sRGB gamut makes the perceived chroma vary unevenly.\n\n### Color spaces modelling color appearance\n\nWhile there is a limited amount of research done regarding color picking, a\nlot of work has been done to create color models that are able to predict\ncolor appearance. These continue in the tradition of the Munsell color model\ndiscussed above, but use more modern color science and mathematical models to\nbetter model the appearance of color. One of the most famous of these is\nCIELab, but there are today several new models that perform better.\n\nComparing all the color models is beyond the scope of this post, the important\nconclusion here is that these models can model the perception of Lightness,\nHue and Chroma much better than all the previously discussed options. For a\nbrief overview of some of the more recent models, see my previous post \u201cA\nperceptual color space for image processing\u201d. Since then another color model\nhas also appeared: ZCAM. For a much deeper overview of modern color science\nand different attempts at modeling color appearance, I recommend the book\n\u201cColor Appearance Models\u201d by Mark D. Fairchild.\n\nThe main drawback of using these models directly for color picking is that the\nsRGB gamut has a quite irregular shape in these color spaces. As a result,\nchanging one parameter, such as hue, can easily create a color outside the\ntarget gamut, making them quite tedious to use. Several color pickers have\nbeen made using either CIELab or more modern lab-like color spaces. From what\nI can tell they have only seen limited use compared with the more common HSV\nand HSL color pickers however.\n\nI would think that the reason that they haven\u2019t caught on is that their\ndrawbacks outweigh their benefits: using a space with parameters that don\u2019t\nmatch the our perception of hue, lightness and chroma is easier than using one\nwith an irregular shape. That is certainly my personal experience.\n\nFor the more advanced models an additional complication is that they have\nseveral parameters meant to be adjusted based on the viewing conditions. When\nused for color picking they seem to mostly be set to match some kind of\naverage viewing conditions though.\n\nHere are a couple of examples of the irregular shape of the sRGB gamut in a\nperceptual color space:\n\nA slice of the gamut with a constant blue hue.\n\nA slice of the gamut with a constant yellow hue.\n\nIt is unfortunately also common to see CIELab based color pickers showing\ncolors outside the target gamut and often they are mapped back by simply\nclamping individual RGB components. This creates severe distortions in hue,\nlightness and chroma, in would would otherwise be a fairly uniform color\nspace.\n\n### Summary\n\nThese are the color spaces I am aware of that are relevant, but please reach\nout if you are aware of any more color spaces useful for color picking.\n\nTo summarize, here is a table of the different color spaces discussed and how\nthey match the different desirable properties. This is definitely a bit\nsubjective, but will hopefully give a decent overview.\n\nHSV| HSL| HSLuv| Lab-like*| NCS  \n---|---|---|---|---  \nOrthogonal Lightness| no| no| yes| yes| no  \nOrthogonal Chroma| no| no| no| yes| partial  \nOrthogonal Saturation| partial| no| no| no**| no  \nOrthogonal Hue| partial| partial| partial| yes| yes  \nSimple Geometrical Shape| yes| yes| yes| no| no***  \nMax Chroma at Edge| yes| no| no| yes| no  \nVaries Smoothly| yes| yes| no| yes| yes  \nVaries Evenly| no| no| no| yes| partial  \n  \n> *) This of course depends on which Lab-like color space. This is the best\n> possible an appearance modelling color space could achieve. **) If\n> desirable, saturation can be used instead of Chroma, and then this would be\n> a yes and \u201cOrthogonal Chroma\u201d a no. ***) NCS has a simple geometrical shape,\n> but it does not match the sRGB gamut.\n\n## Finding a better tradeoff\n\nOne of the main advantages of HSL and HSV over the different Lab color spaces\nis that they map the sRGB gamut to a cylinder. This makes them easy to use\nsince all parameters can be changed independently, without the risk of\ncreating colors outside of the target gamut.\n\nThe main drawback on the other hand is that their properties don\u2019t match human\nperception particularly well. Reconciling these conflicting goals perfectly\nisn\u2019t possible, but given that HSV and HSL don\u2019t use anything derived from\nexperiments relating to human perception, creating something that makes a\nbetter tradeoff does not seem unreasonable.\n\nWe will attempt to do just that by creating new color spaces similar to HSL\nand HSV but that better match perception. This will be done by leveraging the\nOklab color space. Using Oklab here over more advanced models such as CAM16 is\nuseful because working out the math becomes a lot simpler. It also means that\nit won\u2019t be a full color model able to adapt to different viewing conditions,\nbut that is probably also desirable here since it is more practical.\n\nFor consistency with the naming of Oklab, these new color spaces will be\ncalled Okhsl and Okhsv. The parameters will also be referred to as h, s and l\nand h, s and v respectively. Those names are a bit confusing but I think\nmaking the new spaces easy to adopt for someone used to HSL and HSV is more\nimportant than trying to establish new names.\n\n## Intermission - a new lightness estimate for Oklab\n\nOne design decision with Oklab is to use a design that is scale independent.\nThat is, Oklab has no concept of reference white, unlike CIELab for example.\nIn many cases this is an advantage, since it makes dealing with larger dynamic\nranges easier.\n\nHowever, in the context of a color picker with well defined dynamic range and\na clear reference white luminance it reduces Oklab\u2019s ability to predict\nlightness. Therefore, an additional lightness estimate is needed to better\nhandle these cases. With a reference white luminance of Y=1, the new lightness\nestimate Lr is defined as:\n\nk1=0.206,k2=0.03,k3=1+k21+k1\n\nLr=2k3L\u2212k1+\u221a(k3L\u2212k1)2+4k2k3L\n\nWith the inversion:\n\nL=k3(Lr+k2)Lr(Lr+k1)\n\nThis new lightness estimate closely matches the lightness estimate of CIELab\noverall and is nearly equal at 50% lightness (Y for CIELab L is 0.18406, and\nLr 0.18419) which is useful for compatibility. Worth noting is that it is not\npossible to have a lightness scale that is perfectly uniform independent of\nviewing conditions and background color. This new lightness function is\nhowever a better tradeoff for cases with a well defined reference white.\n\nFrom top to bottom: CIELab L, Oklab Lr, Oklab L.\n\n## Introducing two new color spaces: Okhsv and Okhsl\n\nWith this new lightness estimate, we are ready to look into the construction\nof Okhsv and Okhsl. Here is a rough overview of the general idea behind Okhsv\nand Okhsl and their construction. Some details are glossed over here, for all\nthe details check out the source code below.\n\n### Okhsv\n\nTo derive Okhsv, we will start with OkLCh, use its estimate for hue, h, as is\nand introduce s and v parameters that are calculated based on lightness, Lr,\nand chroma, C. To keep the triangular shape when using Lr we also scale C by\nLr/L.\n\nHere is the sRGB gamut plotted for set of hues, with Lr on the y-axis and\nCLr/L on the x-axis:\n\nTo create a HSV-like color space, we want to find a mapping so that the cusp\nof the triangle is in s=1 and v=1. We also want to change the triangle shape\ninto a square, by stretching the lower part of the triangle.\n\nTo find the cusp we can use the same method as in my previous post about sRGB\ngamut clipping.\n\nIf we perform this remapping we get the following result:\n\nRemaining now is a small curve at the top, that we also have to remove. This\nis done by scaling v to compensate. This step makes the space less uniform\nperceptually, but is needed to fit the sRGB gamut to a cylinder exactly. The\nchange is quite small however. This gives the following result:\n\nAs an additional step we adjust saturation to be more uniform for low\nsaturation colors. This makes it easier to compare saturation values for\ndifferent colors, when saturation is low. The effect of this is subtle.\n\nThis gives us a new model with a simple geometrical shape and a hue parameter\nthat closely matches perception. Overall the space will be very familiar to\nsomeone who is used to HSV, but with improved perceptual uniformity.\n\n#### Okhwb\n\nIf desired, Okhsv can also be converted to a HWB (hue, whiteness and\nblackness) form.\n\nw=(1\u2212s)v\n\nb=1\u2212v\n\nWith the inverse:\n\ns=1\u22121\u2212bw\n\nv=1\u2212b\n\n### Okhsl\n\nTo derive Okhsl we also start with OkLCh. Lr and h are kept as is, with Lr\nreferred to as l instead for consistency.\n\nFor s we want to somehow remap C so that the sRGB gamut nicely fits into a\ncylinder.\n\nThe simplest way to do this is to simply scale it by the maximum chroma inside\nthe sRGB gamut for a given value of l and h, Cmax(h,l), which is what HSLuv\ndoes. As we have seen with HSLuv though, the unevenness of the shape of the\ngamut will affect the interior of the entire space resulting in an uneven\nscale for the s component.\n\nInstead it would be good if we could find a way to keep the unevenness local\nto colors close to the edge of the gamut, leaving the interior less affected.\nThis is the key idea behind Okhsl.\n\nOne way to solve this would be to solve it as a boundary value problem,\nfinding C=f(h,s,l), with a boundary condition that C=Cmax(h,l) and some set of\ndifferential equation that keeps the interior smooth. This approach could\ndefinitely give a good result and would be interesting to explore, but is\nlikely to only have a numerical solution, which would make it hard to use\npractically to construct a color space.\n\nInstead Okhsl uses a fairly ad-hoc approach to create a smoothly varying\ninterior, since that makes it efficient to run and easy to invert.\n\nInstead of scaling s by a single value for C, the max possible value in the\ngamut, three different values are used, one for low values of s, C0, one for\nmidrange values of s, Cmid and one for large values, Cmax. These are\nconstructed the following way:\n\n  * C0(l) is constructed to be independent of hue, this way creating continuity for colors close to the s=0 axis.\n  * Cmid(h,l) is constructed to be closer in shape to Cmax, but still much smoother and has been constructed using an optimization process. See the source code for more details and the exact computation.\n  * Cmax(h,l) is the maximum possible value for C in the sRGB gamut for the given values of l and h\n\nTo get an understanding of C0, Cmid and Cmax, here are a few hue slices where\nC is computed C=sC0, C=sCmid and C=sCmax respectively.\n\nC0\n\nCmid\n\nCmax\n\nTo create the full Okhsl model, the values are interpolated so that:\n\n  * At s=0: \u2202s\u2202C=C0, C=0\n  * At s=0.8: C=Cmid\n  * At s=1.0: C=Cmax\n\nThis gives the final Okhsl model:\n\nAltogether this gives a model with a simple geometrical shape that has\nparameters for lightness and hue that closely match perception. The model is\nquite different from regular HSL, in order to achieve a better lightness\nestimate. I believe Okhsl delivers a better overall compromise, and keeps many\nof the benefits of Lab-like color spaces, without the complexity of an\nirregular shape.\n\nHere are a few examples of slices Okhsl, with constant lightness and\nsaturation:\n\nExample of constant \u201clightness\u201d in Okhsl.\n\nSlice of colors with constant \u201csaturation\u201d in Okhsl. While not matching\nperceived chroma fully it is smoothly varying.\n\nFor 100% \u2018saturation\u2019 the variation in perceived chroma is larger, due to the\nshape of the sRGB gamut.\n\n### Summary\n\nFor completeness, here is a table of how Okhsv and Okhsl match the desired\nproperties from earlier. Again, this is definitely a bit subjective. A better\nway to judge the performance is to just try the results yourself.\n\nOkhsv| Okhsl  \n---|---  \nOrthogonal Lightness| no| yes  \nOrthogonal Chroma| no| no  \nOrthogonal Saturation| partial| no  \nOrthogonal Hue| yes| yes  \nSimple Geometrical Shape| yes| yes  \nMax Chroma at Edge| yes| no  \nVaries Smoothly| yes| yes  \nVaries Evenly| no| no  \n  \n## Ideas for future work\n\nOkhsv and Okhsl are my attempts at making better color pickers for the sRGB\ngamut. I would love to see more experimentation overall with color picker\ndesign and in the next few years, color pickers for wide gamut and HDR will be\nmore and more important and need a lot of research. They both offer their own\nnew challenges.\n\nWide gamut is challenging since we are seeing an increased variety of\ndifferent gamuts. At least for a while, target color spaces will be much more\nvaried and applications for authoring colors will have to either settle for\ncommon subset or have to deal with this complexity. This of course will have a\nbig impact on what color pickers look like and how they behave.\n\nOne interesting avenue to pursue would be to more automatically create color\nspaces like Okhsv and Okhsl for a given color gamut. This would likely need to\nuse a bit of a different approach, maybe using lookup tables and numerical\nsolutions in order to not need as much handcrafted logic.\n\nHDR also has the issue of not being quite standardized, but an added\ncomplexity is the increased dynamic range and variation is absolute\nbrightness. In the past color pickers have been able to mostly ignore how the\neye adapts to different luminance levels, but this does not work as well with\nHDR. So far the approaches I\u2019ve seen are to use regular SDR color pickers, but\nwith and added exposure/intensity control. Is this the best approach or are\nthere new ways we should be working with HDR color pickers?\n\nAn additional thing to explore is what spacing of hues would be the best.\nOkhsl and Okhsv simply inherit their spacing from Oklab. A different option\ncould be to do a remapping similar to NCS, which would make the parameter vary\nless evenly, but could make it easier to use by mapping the different axes to\nmore familiar colors.\n\n## Source Code\n\nHere is the Source Code for conversion between sRGB, HSL and HSV. This code\ndepends on the code from my previous post sRGB gamut clipping, which is not\nincluded here. You can find the source for both posts combined here as a C++\nheader.\n\nThe interactive comparison of color pickers also has an implementation of this\nin JavaScript. The source is available here.\n\n### License\n\nAll the source code on this page is provided under the MIT license:\n\n    \n    \n    Copyright (c) 2021 Bj\u00f6rn Ottosson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n### Common code\n\n    \n    \n    struct HSV { float h; float s; float v; }; struct HSL { float h; float s; float l; }; struct LC { float L; float C; };\n    \n    // Alternative representation of (L_cusp, C_cusp) // Encoded so S = C_cusp/L_cusp and T = C_cusp/(1-L_cusp) // The maximum value for C in the triangle is then found as fmin(S*L, T*(1-L)), for a given L struct ST { float S; float T; };\n    \n    // toe function for L_r float toe(float x) { constexpr float k_1 = 0.206f; constexpr float k_2 = 0.03f; constexpr float k_3 = (1.f + k_1) / (1.f + k_2); return 0.5f * (k_3 * x - k_1 + sqrtf((k_3 * x - k_1) * (k_3 * x - k_1) + 4 * k_2 * k_3 * x)); }\n    \n    // inverse toe function for L_r float toe_inv(float x) { constexpr float k_1 = 0.206f; constexpr float k_2 = 0.03f; constexpr float k_3 = (1.f + k_1) / (1.f + k_2); return (x * x + k_1 * x) / (k_3 * (x + k_2)); }\n    \n    ST to_ST(LC cusp) { float L = cusp.L; float C = cusp.C; return { C / L, C / (1 - L) }; }\n\n### HSV\n\nThis code converts between sRGB (not linear) and Okhsv.\n\n    \n    \n    struct HSV { float h; float s; float v; }; RGB okhsv_to_srgb(HSV hsv) { float h = hsv.h; float s = hsv.s; float v = hsv.v;\n    \n    float a_ = cosf(2.f * pi * h); float b_ = sinf(2.f * pi * h);\n    \n    LC cusp = find_cusp(a_, b_); ST ST_max = to_ST(cusp); float S_max = ST_max.S; float T_max = ST_max.T; float S_0 = 0.5f; float k = 1 - S_0 / S_max;\n    \n    // first we compute L and V as if the gamut is a perfect triangle:\n    \n    // L, C when v==1: float L_v = 1 - s * S_0 / (S_0 + T_max - T_max * k * s); float C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);\n    \n    float L = v * L_v; float C = v * C_v;\n    \n    // then we compensate for both toe and the curved top part of the triangle: float L_vt = toe_inv(L_v); float C_vt = C_v * L_vt / L_v;\n    \n    float L_new = toe_inv(L); C = C * L_new / L; L = L_new;\n    \n    RGB rgb_scale = oklab_to_linear_srgb({ L_vt, a_ * C_vt, b_ * C_vt }); float scale_L = cbrtf(1.f / fmax(fmax(rgb_scale.r, rgb_scale.g), fmax(rgb_scale.b, 0.f)));\n    \n    L = L * scale_L; C = C * scale_L;\n    \n    RGB rgb = oklab_to_linear_srgb({ L, C * a_, C * b_ }); return { srgb_transfer_function(rgb.r), srgb_transfer_function(rgb.g), srgb_transfer_function(rgb.b), }; }\n    \n    HSV srgb_to_okhsv(RGB rgb) { Lab lab = linear_srgb_to_oklab({ srgb_transfer_function_inv(rgb.r), srgb_transfer_function_inv(rgb.g), srgb_transfer_function_inv(rgb.b) });\n    \n    float C = sqrtf(lab.a * lab.a + lab.b * lab.b); float a_ = lab.a / C; float b_ = lab.b / C;\n    \n    float L = lab.L; float h = 0.5f + 0.5f * atan2f(-lab.b, -lab.a) / pi;\n    \n    LC cusp = find_cusp(a_, b_); ST ST_max = to_ST(cusp); float S_max = ST_max.S; float T_max = ST_max.T; float S_0 = 0.5f; float k = 1 - S_0 / S_max;\n    \n    // first we find L_v, C_v, L_vt and C_vt\n    \n    float t = T_max / (C + L * T_max); float L_v = t * L; float C_v = t * C;\n    \n    float L_vt = toe_inv(L_v); float C_vt = C_v * L_vt / L_v;\n    \n    // we can then use these to invert the step that compensates for the toe and the curved top part of the triangle: RGB rgb_scale = oklab_to_linear_srgb({ L_vt, a_ * C_vt, b_ * C_vt }); float scale_L = cbrtf(1.f / fmax(fmax(rgb_scale.r, rgb_scale.g), fmax(rgb_scale.b, 0.f)));\n    \n    L = L / scale_L; C = C / scale_L;\n    \n    C = C * toe(L) / L; L = toe(L);\n    \n    // we can now compute v and s:\n    \n    float v = L / L_v; float s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);\n    \n    return { h, s, v }; }\n\n### HSL\n\nThis code converts between sRGB (not linear) and Okhsl.\n\n    \n    \n    struct HSL { float h; float s; float l; };\n    \n    // Returns a smooth approximation of the location of the cusp // This polynomial was created by an optimization process // It has been designed so that S_mid < S_max and T_mid < T_max ST get_ST_mid(float a_, float b_) { float S = 0.11516993f + 1.f / ( +7.44778970f + 4.15901240f * b_ + a_ * (-2.19557347f + 1.75198401f * b_ + a_ * (-2.13704948f - 10.02301043f * b_ + a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_ ))) );\n    \n    float T = 0.11239642f + 1.f / ( +1.61320320f - 0.68124379f * b_ + a_ * (+0.40370612f + 0.90148123f * b_ + a_ * (-0.27087943f + 0.61223990f * b_ + a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_ ))) );\n    \n    return { S, T }; }\n    \n    struct Cs { float C_0; float C_mid; float C_max; }; Cs get_Cs(float L, float a_, float b_) { LC cusp = find_cusp(a_, b_);\n    \n    float C_max = find_gamut_intersection(a_, b_, L, 1, L, cusp); ST ST_max = to_ST(cusp);\n    \n    // Scale factor to compensate for the curved part of gamut shape: float k = C_max / fmin((L * ST_max.S), (1 - L) * ST_max.T);\n    \n    float C_mid; { ST ST_mid = get_ST_mid(a_, b_);\n    \n    // Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma. float C_a = L * ST_mid.S; float C_b = (1.f - L) * ST_mid.T; C_mid = 0.9f * k * sqrtf(sqrtf(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b)))); }\n    \n    float C_0; { // for C_0, the shape is independent of hue, so ST are constant. Values picked to roughly be the average values of ST. float C_a = L * 0.4f; float C_b = (1.f - L) * 0.8f;\n    \n    // Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma. C_0 = sqrtf(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b))); }\n    \n    return { C_0, C_mid, C_max }; }\n    \n    RGB okhsl_to_srgb(HSL hsl) { float h = hsl.h; float s = hsl.s; float l = hsl.l;\n    \n    if (l == 1.0f) { return { 1.f, 1.f, 1.f }; }\n    \n    else if (l == 0.f) { return { 0.f, 0.f, 0.f }; }\n    \n    float a_ = cosf(2.f * pi * h); float b_ = sinf(2.f * pi * h); float L = toe_inv(l);\n    \n    Cs cs = get_Cs(L, a_, b_); float C_0 = cs.C_0; float C_mid = cs.C_mid; float C_max = cs.C_max;\n    \n    // Interpolate the three values for C so that: // At s=0: dC/ds = C_0, C=0 // At s=0.8: C=C_mid // At s=1.0: C=C_max\n    \n    float mid = 0.8f; float mid_inv = 1.25f;\n    \n    float C, t, k_0, k_1, k_2;\n    \n    if (s < mid) { t = mid_inv * s;\n    \n    k_1 = mid * C_0; k_2 = (1.f - k_1 / C_mid);\n    \n    C = t * k_1 / (1.f - k_2 * t); } else { t = (s - mid)/ (1 - mid);\n    \n    k_0 = C_mid; k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0; k_2 = (1.f - (k_1) / (C_max - C_mid));\n    \n    C = k_0 + t * k_1 / (1.f - k_2 * t); }\n    \n    RGB rgb = oklab_to_linear_srgb({ L, C * a_, C * b_ }); return { srgb_transfer_function(rgb.r), srgb_transfer_function(rgb.g), srgb_transfer_function(rgb.b), }; }\n    \n    HSL srgb_to_okhsl(RGB rgb) { Lab lab = linear_srgb_to_oklab({ srgb_transfer_function_inv(rgb.r), srgb_transfer_function_inv(rgb.g), srgb_transfer_function_inv(rgb.b) });\n    \n    float C = sqrtf(lab.a * lab.a + lab.b * lab.b); float a_ = lab.a / C; float b_ = lab.b / C;\n    \n    float L = lab.L; float h = 0.5f + 0.5f * atan2f(-lab.b, -lab.a) / pi;\n    \n    Cs cs = get_Cs(L, a_, b_); float C_0 = cs.C_0; float C_mid = cs.C_mid; float C_max = cs.C_max;\n    \n    // Inverse of the interpolation in okhsl_to_srgb:\n    \n    float mid = 0.8f; float mid_inv = 1.25f;\n    \n    float s; if (C < C_mid) { float k_1 = mid * C_0; float k_2 = (1.f - k_1 / C_mid);\n    \n    float t = C / (k_1 + k_2 * C); s = t * mid; } else { float k_0 = C_mid; float k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0; float k_2 = (1.f - (k_1) / (C_max - C_mid));\n    \n    float t = (C - k_0) / (k_1 + k_2 * (C - k_0)); s = mid + (1.f - mid) * t; }\n    \n    float l = toe(L); return { h, s, l }; }\n\nIf you liked this article, it would be great if you considered sharing it:\n\nFor discussions and feedback, ping me on Twitter.\n\nPublished 08 Sep 2021\n\n", "frontpage": false}
