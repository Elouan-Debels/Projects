{"aid": "39983745", "title": "InSpectre Gadget: Inspecting the Residual Attack Surface of Cross-Privilege Spe", "url": "https://www.vusec.net/projects/native-bhi/", "domain": "vusec.net", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-09 20:14:29", "comments": 0, "source_title": "InSpectre Gadget", "source_text": "InSpectre Gadget - vusec\n\n# vusec\n\nSearch\n\n# InSpectre Gadget\n\nInspecting the Residual Attack Surface of Cross-privilege Spectre v2\n\n## TL;DR\n\nWe present InSpectre Gadget, an in-depth Spectre gadget inspector that uses\nsymbolic execution to accurately reason about exploitability of usable\ngadgets. Our tool performs generic constraint analysis and models knowledge of\nadvanced exploitation techniques to accurately reason over gadget\nexploitability in an automated way.\n\nWe show that our tool can not only uncover new (unconventionally) exploitable\ngadgets in the Linux kernel, but that those gadgets are sufficient to bypass\nall deployed Intel mitigations. As a demonstration, we present the first\nnative Spectre-v2 exploit against the Linux kernel on last-generation Intel\nCPUs, based on the recent BHI variant and able to leak arbitrary kernel memory\nat 3.5 kB/sec.\n\nHere\u2019s a demo of our exploit leaking /etc/shadow:\n\n## Native BHI (CVE-2024-2201)\n\nBut wait, wasn\u2019t BHI fixed? Let\u2019s delve deeper.\n\nIn our prior work, we demonstrated that Spectre-V2 attacks were still possible\nin the kernel through Branch History Injection (BHI), and used eBPF to craft a\nSpectre disclosure gadget (or simply Spectre gadget for simplicity). In\nresponse, vendors suggested disabling unprivileged eBPF. This mitigation left\nus with a dangling question: \u201cIs finding \u2018native\u2019 Spectre gadgets for BHI,\ni.e., not implanted through eBPF, feasible?\u201d\n\nTo address this question, we developed InSpectre Gadget. With this tool, we\ncan analyze Spectre gadgets and reason about their (advanced) exploitability.\nOur efforts led to the discovery of 1,511 Spectre gadgets and 2,105 so-called\n\u201cdispatch gadgets\u201d. The latter are very useful for an attacker, as they can be\nused to chain gadgets and direct speculation towards a Spectre gadget.\n\nAs the number of gadgets we found point to a nontrivial attack surface,\nvendors are now recommending to mitigate Native BHI by enabling hardware\nmitigations and, for older CPUs, software mitigations.\n\nFrom the many gadgets we discovered, we selected one and crafted an end-to-end\nNative (eBPF=off) BHI exploit. The video above showcases this exploit in\naction.\n\n## FineIBT Bypass\n\nBuilding upon CET-IBT, FineIBT introduces fine-grained control-flow integrity\n(CFI). Our research shows that, while FineIBT does shorten the speculation\nwindow, it falls short of completely closing it. The situation becomes even\nmore problematic when we start a contention workload on the sibling core: the\nspeculation window size increases and an attacker can now fit hundreds of\nSpectre gadgets discovered by InSpectre Gadget.\n\nTo demonstrate the issue, we created a FineIBT Bypass PoC based on Native BHI:\n\n## InSpectre Gadget\n\nWhenever there is a chain of loads that can be executed in a speculative\nwindow, we might be able to leak memory through a side channel. However, not\nall double loads are created equal. In particular, finding viable gadgets for\nSpectre-V2 in a codebase like the Linux Kernel requires a scalable approach.\n\nTo find Spectre-V2 gadgets we used a new angr-based gadget analyzer, which we\ncall InSpectre Gadget. We open-sourced the source code, documentation, and a\ndatabase of gadgets for the Linux Kernel, version 6.6-rc4 (see below). This\ntool finds potential Spectre gadgets and classifies them based on properties\nlike where can we leak from, where can we place our reload buffer, etc.\n\nThe main idea behind InSpectre Gadget is to start from a list of speculation\nentry points, e.g., all the indirect call targets in the kernel, run an\nanalyzer that performs an in-depth scan of the speculation window, including\nattacker-controlled values, constraints and ranges, and finally pass the\nresults to a reasoner that is aware of advanced exploitation techniques.\n\nInSpectre Gadget overview\n\n### Tool Internals\n\nThe analyzer initially marks registers and stack locations as symbolic, then\nuses symbolic execution to explore each speculation window for a limited\n(configurable) amount of basic blocks through symbolic execution, recording\nall symbolic memory operations (attacker-controlled loads) and symbolic jumps\n(potential dispatch gadgets), together with branch conditions and other\nconstraints. Later, the symbolic expression of potential transmissions is\ninspected to extract the base (e.g., position of the reload buffer for\nFlush+Reload) and the secret being transmitted, and a fast range analysis is\nperformed. Finally, a database of all potential transmissions found is\noutputted.\n\nThe next step is to run the reasoner. Instead of looking statically for\npatterns that resemble a \u201cperfect\u201d gadget (i.e, attacker-controlled load +\nmasking + shifting + second dependent load), we take into account different\nside-channels and a multitude of exploitation techniques that have shown how\n\u201cimperfect\u201d gadgets can still be exploited (Retbleed, Spec Probing, Leaky\nAddress Mask). This strategy relaxes the common preconditions of standard\ngadgets, while still avoiding the common overapproximations that would\notherwise report many unexploitable gadgets. Moreover, it provides the analyst\nwith insights into exploitability characteristics, such as the exploitation\ntechniques required, the constraints to be met, the values that can be leaked,\netc.\n\nHere\u2019s an example of the output of the scanner (annotated assembly) and a\nshort demo of the workflow:\n\nAnnotated assembly file generated by InSpectre Gadget. Right to the assembly\ninstructions, we output the annotations attached to the source and destination\noperands (source \u2192 destination). The annotations include the origin of the\nvalue, which is either the instruction pointer of the source load or a\nregister (e.g., @rdi). As we generate for each detected gadget an annotated\nassembly file, we do not print annotations that are irrelevant to the gadget\nflow and we replace all secret annotations with an attacker annotation that\nare, for this specific gadget, not used as a secret but as an attacker-\ncontrolled value. In the case of a branch instruction, we show the branch\ncondition to hold instead. As shown by the annotations, the attacker-\ncontrolled value rdi is used in the first load 1, followed by a series of\nloads whose controllability is tracked 2. The encountered branch condition is\nrecorded 3. Subsequently, the secret value is loaded from an attacker-\ncontrolled value 4 and transmitted using an attacker-controlled value as the\nbase 5. We output key details after the assembly code, including the symbolic\nexpression and the range\u2014i.e., (min, max, stride)\u2014for each transmission\ncomponent 6, insights about the transmitted secret bits 7, details about which\nregisters an attacker should control to exploit the gadget 8 as well as the\nconstraints and branches encountered 9.Demo of the gadget-analysis workflow\nwith InSpectre Gadget (Click on it to expand)\n\n## More details\n\nInSpectre Gadget paper (PDF) is accepted for publication at the 33rd USENIX\nSecurity Symposium 2024. Checkout the paper, code and documentation:\n\n  * InSpectre Gadget tool, gadget analysis results, and exploit code\n  * InSpectre Gadget documentation\n\ngenerated by\n\n  * Group by\n\n    * Year\n    * Author\n    * Type\n    * Keyword\n    * Downloads\n  *     * Expand/Collapse All\n    * Download BibTeX\n    * RSS Feed\n\nExcellent! Next you can create a new website with this list, or embed it in an\nexisting web page by copying & pasting any of the following snippets.\n\nJavaScript (easiest)\n\n<script\nsrc=\"https://bibbase.org/show?bib=https%3A%2F%2Fdownload.vusec.net%2Fpapers%2Fzotero.php%3FitemKey%3D7H5YPGLQ%26full%3D%26format%3Dbibtex%26sort%3Ddate%26limit%3D1000&theme=default&jsonp=1&owner=none&filter=&jsonp=1\"></script>\n\nPHP\n\n<?php $contents =\nfile_get_contents(\"https://bibbase.org/show?bib=https%3A%2F%2Fdownload.vusec.net%2Fpapers%2Fzotero.php%3FitemKey%3D7H5YPGLQ%26full%3D%26format%3Dbibtex%26sort%3Ddate%26limit%3D1000&theme=default&jsonp=1&owner=none&filter=\");\nprint_r($contents); ?>\n\niFrame (not recommended)\n\n<iframe\nsrc=\"https://bibbase.org/show?bib=https%3A%2F%2Fdownload.vusec.net%2Fpapers%2Fzotero.php%3FitemKey%3D7H5YPGLQ%26full%3D%26format%3Dbibtex%26sort%3Ddate%26limit%3D1000&theme=default&jsonp=1&owner=none&filter=\"></iframe>\n\nFor more details see the documention.\n\nThis is a preview! To use this list on your own web site or create a new web\nsite from it, create a free account. The file will be added and you will be\nable to edit it in the File Manager. We will show you instructions once you've\ncreated your account.\n\nTo the site owner:\n\nAction required! Mendeley is changing its API. In order to keep using Mendeley\nwith BibBase past April 14th, you need to:\n\n  1. renew the authorization for BibBase on Mendeley, and\n  2. update the BibBase URL in your page the same way you did when you initially set up this page.\n\nFix it now\n\n2024 (1)\n\nInSpectre Gadget: Inspecting the Residual Attack Surface of Cross-privilege\nSpectre v2. Wiebing, S.; de Faveri Tron, A.; Bos, H.; and Giuffrida, C. In\nUSENIX Security, August 2024. Paper Web Code link bibtex\n\n    \n    \n    @inproceedings{wiebing_inspectre_2024, title = {{InSpectre} {Gadget}: {Inspecting} the {Residual} {Attack} {Surface} of {Cross}-privilege {Spectre} v2}, url = {Paper=https://download.vusec.net/papers/inspectre_sec24.pdf Web=https://vusec.net/projects/native-bhi Code=https://github.com/vusec/inspectre-gadget}, booktitle = {{USENIX} {Security}}, author = {Wiebing, Sander and de Faveri Tron, Alvise and Bos, Herbert and Giuffrida, Cristiano}, month = aug, year = {2024}, keywords = {class\\_sidechannels, proj\\_allocamelus, proj\\_intersect, proj\\_rescale, type\\_ae, type\\_conf, type\\_cve\\_assigned, type\\_paper, type\\_tier1, type\\_top}, }\n\n## FAQ\n\n### How does Native BHI differ from BHI?\n\nThe original BHI attack was demonstrated by using eBPF. As a response,\nunprivileged eBPF was disabled and the BHI attack demonstrated in the paper\nwas mitigated. We now show that BHI is possible without eBPF, thus Native BHI.\n\n### Which systems are affected by Native BHI?\n\nShort answer: All Intel systems that were affected by BHI are also affected by\nNative BHI.\n\n### How can I protect my system?\n\nPlease refer to the security advisory:\nhttps://www.intel.com/content/www/us/en/developer/articles/technical/software-\nsecurity-guidance/technical-documentation/branch-history-injection.html\n\n## Acknowledgements\n\nWe would like to thank the anonymous reviewers for their feedback. This work\nwas supported by Intel Corporation through the \u201cAllocamelus\u201d project, by the\nDutch Research Council (NWO) through project \u201cINTERSECT\u201d, and by the European\nUnion\u2019s Horizon Europe programme under grant agreement No. 101120962\n(\u201cRescale\u201d).\n\n## Systems and Network Security Group at VU Amsterdam\n\n## Recent Tweets\n\nRecent Tweets\n\n## Recent Posts\n\nThe header\n\nNative BHI Exploit: Leaking the /etc/shadow file A demo of the Native BHI\nattack leaking the root password hash on a 13th Gen Intel Core with Linux\nkernel 6.6-rc4 (Ubuntu). For more information on this attack, see the info\npage: https://vusec.ne...\n\nYouTube | 3 hours ago\n\nFineIBT Bypass PoC | Native BHI A demo of the FineIBT Bypass PoC, based on the Native BHI attack, on a 13th Gen Intel Core with Linux kernel 6.6-rc4 (Ubuntu). For more information on this attack, see the info page: https://vusec...\n\nYouTube | 3 hours ago\n\neinstein Practical Data-Only Attack Generation\n\nGitHub | March 20, 2024\n\nsafefetch-ae No description\n\nGitHub | March 14, 2024\n\nghostrace No description\n\nGitHub | March 6, 2024\n\n# Archives\n\n# Categories\n\nProudly powered by WordPress\n\nAnnotated assembly file generated by InSpectre Gadget. Right to the assembly\ninstructions, we output the annotations attached to the source and destination\noperands (source \u2192 destination). The annotations include the origin of the\nvalue, which is either the instruction pointer of the source load or a\nregister (e.g., @rdi). As we generate for each detected gadget an annotated\nassembly file, we do not print annotations that are irrelevant to the gadget\nflow and we replace all secret annotations with an attacker annotation that\nare, for this specific gadget, not used as a secret but as an attacker-\ncontrolled value. In the case of a branch instruction, we show the branch\ncondition to hold instead. As shown by the annotations, the attacker-\ncontrolled value rdi is used in the first load 1, followed by a series of\nloads whose controllability is tracked 2. The encountered branch condition is\nrecorded 3. Subsequently, the secret value is loaded from an attacker-\ncontrolled value 4 and transmitted using an attacker-controlled value as the\nbase 5. We output key details after the assembly code, including the symbolic\nexpression and the range\u2014i.e., (min, max, stride)\u2014for each transmission\ncomponent 6, insights about the transmitted secret bits 7, details about which\nregisters an attacker should control to exploit the gadget 8 as well as the\nconstraints and branches encountered 9.\n\nAnnotated assembly file generated by InSpectre Gadget. Right to the assembly\ninstructions, we output the annotations attached to the source and destination\noperands (source \u2192 destination). The annotations include the origin of the\nvalue, which is either the instruction pointer of the source load or a\nregister (e.g., @rdi). As we generate for each detected gadget an annotated\nassembly file, we do not print annotations that are irrelevant to the gadget\nflow and we replace all secret annotations with an attacker annotation that\nare, for this specific gadget, not used as a secret but as an attacker-\ncontrolled value. In the case of a branch instruction, we show the branch\ncondition to hold instead. As shown by the annotations, the attacker-\ncontrolled value rdi is used in the first load 1, followed by a series of\nloads whose controllability is tracked 2. The encountered branch condition is\nrecorded 3. Subsequently, the secret value is loaded from an attacker-\ncontrolled value 4 and transmitted using an attacker-controlled value as the\nbase 5. We output key details after the assembly code, including the symbolic\nexpression and the range\u2014i.e., (min, max, stride)\u2014for each transmission\ncomponent 6, insights about the transmitted secret bits 7, details about which\nregisters an attacker should control to exploit the gadget 8 as well as the\nconstraints and branches encountered 9.\n\nDemo of the gadget-analysis workflow with InSpectre Gadget (Click on it to\nexpand)\n\nDemo of the gadget-analysis workflow with InSpectre Gadget (Click on it to\nexpand)\n\n", "frontpage": false}
