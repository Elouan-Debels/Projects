{"aid": "39980845", "title": "Building a CLI from scratch with TypeScript and oclif", "url": "https://www.joshcanhelp.com/oclif/", "domain": "joshcanhelp.com", "votes": 2, "user": "joshcanhelp", "posted_at": "2024-04-09 16:02:55", "comments": 0, "source_title": "Building a CLI from scratch with TypeScript and oclif", "source_text": "Building a CLI from scratch with TypeScript and oclif - Josh Can Help\n\nHome \u203a Posts \u203a Apr 08, 2024\n\n# Building a CLI from scratch with TypeScript and oclif\n\nI'm currently working on a pair of CLIs, one I've written about here and one\nI'll announce soon. I just love a good text-based interface so a lot of the\ntools I build for myself and built at work take on that form. I'm certainly no\nexpert in this realm (yet) but I enjoy figuring out sane defaults for options,\nclear flag names, and helpful error messages. Despite that, I am also still\npretty fun at parties.\n\nIn an attempt to save myself some pain and suffering while building the\nbudgeting CLI last year, I looked into existing JavaScript CLI frameworks that\nare out there and decided to try out oclif. It looked like it had the right\nfeatures and mostly got out of your way but, after playing with it for a few\nhours, I just could not get it to do much of anything so I scrapped it and\nwent with the built-in Node utility for parsing arguments, util.parseArgs().\nYou can see how I'm using that here.\n\nFlash forward a year or so and I'm back in the same position with a new\nproject. Currently I'm just compiling files and executing them directly with\nnode ./dist/command.js. This new CLI will have a much bigger footprint of\ncommands and options so the flag and argument parsing is only a part of the\njob to be done. The oclif package popped into my head again so I took a look\nand saw that there had been 2 major releases since I last tried it out with a\nnumber of features that I'm likely to use: plugins, hooks, and releases. It\nlooked like I would be able to integrate it in the project without completely\nrearchitecting how everything works, which was a big plus. I don't like being\ntrapped in a framework, if I can avoid it.\n\nI dove in and got it running right away but was not quite sure exactly what\nwas going on. The getting started tutorial is about a half-page long, counting\nthe introduction, and doesn't do much to help to understand what I was doing.\nYou generate a complete CLI project and are left without much to go on after\nthat besides just reading through the code. The guides and API reference docs\nare solid but only if you know exactly what you're looking for. I spent about\nan hour reading the docs and ended up with a bit better sense of what's going\non but I had to piece it together myself.\n\nI believe a getting started tutorial should start at zero and work through the\nbasics, building upon understanding as it goes. As a part of getting this\nworking in my budgeting CLI, I walked through the foundational pieces that\nneed to be added, contributed a command that adds these pieces without all the\nrest of the template boilerplate, and wrote the tutorial below in the process.\nHopefully these pieces will help if you decide to write a CLI!\n\nThis tutorial assumes that you:\n\n  * Have Node and npm installed on your system\n  * Are or will be using TypeScript (TS going forward) to build the CLI\n\nThe oclif CLI has two options to create the files you need:\n\n  * The generate command that creates a new npm project from scratch in a new directory\n  * The init command that adds the basic configuration to an existing project\n\nThe generate command is the easiest way to get to a completely working CLI but\nit leaves you with a lot of boilerplate that you might not need and a number\nof unanswered questions about what comes next.\n\nWe're going to start this tutorial with an empty directory and work our way to\na functional CLI step-by-step, starting with the init command. We'll rely on\nlinks to the documentation to expand on what's here and, by the end, you\nshould have a clear path forward for your own CLI project.\n\nFirst, we need a new directory and a package.json file, which we'll get by\ninitializing npm and installing TS:\n\n    \n    \n    $ mkdir new-oclif-cli $ cd new-oclif-cli $ npm init # ... answer all prompts, defaults are fine for this tutorial\n    \n    $ npm install typescript\n\nWe're going to do the absolute bare minimum of setup to get TS compiling since\nthat's not the focus of this tutorial. If you're just getting started with TS,\nthe TypeScript Tooling in 5 minutes is a great place to start. For now, we\njust want to make sure that TS is compiling our files in the right place.\n\nStarting where we left off, make a TS file that outputs to the console:\n\n    \n    \n    $ mkdir src $ echo 'console.log(\"Hi!\");' >> src/index.ts\n\nAdd a basic tsconfig.json file in root of your project with configuration for\nthe source files and output directory:\n\n    \n    \n    // tsconfig.json { \"include\": [ \"src/**/*\" ], \"compilerOptions\": { \"outDir\": \"./dist\", \"module\": \"nodenext\" } }\n\nInvoke the TS package we installed in this project to compile this new file to\na dist directory in our project and make sure it can be executed:\n\n    \n    \n    $ npm exec tsc $ node ./dist/index.js Hi!\n\nIf you're having trouble getting to this point, please refer to the TS\ndocumentation. If not, then congratulations, you have a CLI built in TS!\n\nWe're going to use npx to invoke the oclif CLI, which will add the necessary\nnpm module, bin files, and configuration:\n\n    \n    \n    npx oclif init\n\nThis command will ask a few questions:\n\n  1. First, you'll be asked for what directory to use to install. Accept the default value to install in the current working directory.\n  2. Next, you'll be asked for the command name that will be exported for your project. This becomes important when you're publishing your project but, for the purpose of this exercise, you can accept the default.\n  3. Next, you'll be asked about your module type. The Node documentation has a thorough explanation of modules that's a great start if you're not sure which one to use. While this decision is important for your overall project, it doesn't matter much for this tutorial so pick the one you're most comfortable with and continue.\n  4. The next step will happen automatically, since we already installed a package using npm. The init command auto-detects what package manager you're using based on the name of the lock file. The command saw the package-lock.json file and used npm to install the @oclif/core package in the background.\n\nIf everything completed successfully, you should see a message like \"Created\nCLI new-oclif-cli\" and no errors in the console. You should also have:\n\n  * Four new files in a new ./bin folder\n  * An oclif object in your package.json configuring the bin name, data directory, and command discovery strategy. There are other configuration options, some of which we'll cover later in this tutorial\n\nBefore we move on, we need to update our package.json file with the module\ntype that we selected during the oclif init command. Add a top-level property\ntype set to module for ESM or commonjs for CommonJS.\n\n    \n    \n    // package.json { // ... other properties \"type\": \"module\" // ... or \"type\": \"commonjs\" }\n\nNow we're ready to create our first command! The oclif CLI includes the\nhelpful oclif generate command COMMAND_NAME that we can use but, like oclif\ngenerate, it includes a lot of boilerplate so we'll build ours from scratch.\n\nCreate a directory commands in ./src and add a file called hello.ts:\n\n    \n    \n    $ mkdir ./src/commands $ touch ./src/commands/hello.ts\n\nIn the hello.ts file, add the following:\n\n    \n    \n    // src/commands/hello.ts import { Command } from \"@oclif/core\";\n    \n    export default class Hello extends Command { public async run(): Promise<void> { this.log(\"Hello from oclif!\"); } }\n\nThis is the basic form that all commands will take: extending the Command\nclass and defining a run() method. There are a number of methods that are\navailable in the parent class, including the log() method we're using here\nthat outputs messages to stdout.\n\nWe have not packaged up our CLI into an executable binary but we can easily\ntest the command by using one of the files that was added during\ninitialization:\n\n    \n    \n    $ npm exec tsc $ ./bin/run.js hello Hello from oclif!\n\nNote: Going forward, we'll assume that you're running tsc after TS files\nchanges or are running tsc -w in another tab to compile automatically on\nchange.\n\nOne of oclif's selling points is it's ability to parse and validate the\narguments and flags that are passed when the command is run.\n\nWe can add an argument to our command by defining a static args property on\nthe class we created set to an object. The keys in this object define the\nproperty names we'll use during runtime and the values indicate the type of\nargument we expect.\n\nLet's add an argument to our command and simply output the value to the\nterminal:\n\n    \n    \n    // src/commands/hello.ts import { Args, Command } from \"@oclif/core\";\n    \n    export default class Hello extends Command { static override args = { arg1: Args.string(), };\n    \n    public async run(): Promise<void> { const { args } = await this.parse(Hello); this.log(\"Hello from oclif!\"); this.log(\"arg1: %s\", args.arg1); } }\n\nIn this case, we created a string argument in the first position, parsed all\nthe arguments from the command, then output the value using the formatting\ncapability of this.log. When we run the command with an argument, we can see\nthe value immediately:\n\n    \n    \n    $ ./bin/run.js hello an_argument Hello from oclif! arg1: an_argument\n\nIf we add a second argument without modifying the command code, we'll see an\nerror:\n\n    \n    \n    ./bin/run.js hello an_argument another_argument \u203a Error: Unexpected argument: another_argument \u203a See more help with --help\n    \n    USAGE $ new-oclif-cli hello [ARG1]\n\nThe parse() method does two jobs: it both validates the incoming arguments and\nmakes them available to the logic in the run() method. If your command is\nusing arguments or flags then this should be called on the first line of the\nrun() function to avoid partial execution.\n\nThere is a lot more that's possible with command arguments, including\ndocumentation, pre-processing, default values and more. Take some time to play\naround with the different argument types and options to get a feel for what\ncan be done.\n\nNow, let's add a flag to our command. Flag parsing and validation in oclif is\nquite powerful and flexible so we'll only scratch the surface in this\ntutorial.\n\nLet's adjust our command to add a simple flag. The code below excludes the\nargument code from above for simplicity but the two can co-exist:\n\n    \n    \n    import { Command, Flags } from \"@oclif/core\";\n    \n    export default class Hello extends Command { static override flags = { flag: Flags.boolean(), };\n    \n    public async run(): Promise<void> { const { flags } = await this.parse(Hello); this.log(\"Hello from oclif!\"); this.log(\"flag: %s\", flags.flag ? \"yes\" : \"no\"); } }\n\nYou'll notice that the syntax here is quite similar as that for arguments. We\nhave a static property flags set to an object with keys that define the flag\nname and values that indicate the flag type.\n\nIf we run our command with the flag present, the output should be:\n\n    \n    \n    $ ./bin/run.js hello --flag Hello from oclif! flag: yes\n\nSimilar to arguments, if we run a command with a flag we did not define, the\nresult is an error and usage docs:\n\n    \n    \n    ./bin/run.js hello --notflag \u203a Error: Nonexistent flag: --notflag \u203a See more help with --help\n    \n    USAGE $ new-oclif-cli hello [--flag]\n    \n    FLAGS --flag\n\nThere is a lot more you can do with command flags, including character\naliases, dependencies on other flags, reversibility, and more.\n\nNow that we understand more about how commands are built, the command that\noclif can generate should make more sense. Run the following to use a template\nto create a new command:\n\n    \n    \n    $ npm exec oclif generate command hello2 Adding hello2 to new-oclif-cli! Creating src/commands/hello2.ts\n\nThis will create a new file ./src/commands/hello2.ts with both arguments and\nflags. Running the help flag for this new command will show how it's used:\n\n    \n    \n    ./bin/run.js hello2 --help describe the command here\n    \n    USAGE $ new-oclif-cli hello2 [FILE] [-f] [-n <value>]\n    \n    ARGUMENTS FILE file to read\n    \n    FLAGS -f, --force -n, --name=<value> name to print\n    \n    DESCRIPTION describe the command here\n    \n    EXAMPLES $ new-oclif-cli hello2\n\nTry running the base command with the --help flag to see the output.\n\nFinally, we want users to know how the CLI can be used so we'll use oclif to\ncreate a README file. First, create a README.md file in your project directory\nor open the existing one. Add the following template anywhere in the file:\n\n    \n    \n    ## Table of contents <!-- toc -->\n    \n    ## Usage <!-- usage -->\n    \n    ## Commands <!-- commands -->\n\nNote that the order, headlines, and which tags are used are all up to you. If\nyou only want the commands to be output, just use the <!-- commands --> tag.\nWhen you have everything where you want it, run the oclif readme command:\n\n    \n    \n    $ npm exec oclif readme replacing <!-- usage --> in README.md replacing <!-- commands --> in README.md replacing <!-- toc --> in README.md\n\nYou now have a functional CLI built and documented using oclif!\n\nRecommended next steps are:\n\n  * If you're building a large CLI with multiple commands, look into adding a custom base class to manage duplicate arguments, inherited flags, and shared functionality.\n  * If your CLI needs user-defined functionality, look into plugins.\n  * If you need assistance troubleshooting, look into oclif's debugging features and error handling.\n  * When you're ready to put your command out there in the world, oclif has a number of ways it can help with releasing.\n\n## < Take Action >\n\nSuggest changes on GitHub \u203a\n\n###### Comment via:\n\nEmail \u203a GitHub \u203a Hacker News \u203a\n\n###### Subscribe via:\n\nRSS \u203a Twitter \u203a GitHub \u203a\n\n## < Read More >\n\n###### Tags\n\nJavaScript + TypeScript Software Engineering\n\n###### Older\n\nFeb 09, 2024\n\n## Goodbye Auth0\n\nMy 6 years at Auth0 ... how it all started, what Auth0 meant to me, and why I\nwill proudly wear that shield for as long as the swag holds up.\n\n## < Footer >\n\n  * Find out more about me and see what I'm doing now.\n  * Read my posts, see my tags, make a cocktail, explore site updates, and parse the RSS.\n  * Find me on GitHub, LinkedIn, Composer, and Twitter\n\nUnless attributed, words, photographs, and graphics are my own. This blog is\nproudly built using Eleventy.\n\nThis work is licensed under a Creative Commons Attribution-NonCommercial-\nShareAlike 4.0 International License. This means you are free to copy and\nredistribute the material in any medium or format, and remix, transform, and\nbuild upon the material.\n\n", "frontpage": false}
