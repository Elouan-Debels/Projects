{"aid": "39980840", "title": "MoonBit: A Prototype Ideal for the WebAssembly Era", "url": "https://gist.github.com/mizchi/e4801fd55760f010893cd7fa80f04289", "domain": "gist.github.com", "votes": 1, "user": "cosmosjeong", "posted_at": "2024-04-09 16:02:27", "comments": 0, "source_title": "moonbit-is-great.md", "source_text": "moonbit-is-great.md \u00b7 GitHub\n\nSkip to content\n\nSign in Sign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nInstantly share code, notes, and snippets.\n\n# mizchi/moonbit-is-great.md\n\nCreated April 9, 2024 03:28\n\nShow Gist options\n\n  * Download ZIP\n\n  * Star 1 You must be signed in to star a gist\n  * Fork 0 You must be signed in to fork a gist\n\n  *     * Learn more about clone URLs\n\n  * Save mizchi/e4801fd55760f010893cd7fa80f04289 to your computer and use it in GitHub Desktop.\n\n  * Learn more about clone URLs\n\nSave mizchi/e4801fd55760f010893cd7fa80f04289 to your computer and use it in\nGitHub Desktop.\n\nDownload ZIP\n\nRaw\n\nmoonbit-is-great.md\n\nThis is translation of https://zenn.dev/mizchi/articles/introduce-moonbit from\njapanese\n\n# MoonBit: A Prototype Ideal for the WebAssembly Era\n\nRecently, I came across a language called MoonBit, and the more I looked into\nit, the more I liked it, so I'd like to introduce it.\n\nhttps://www.moonbitlang.com/\n\nGrammatically, it's like Rust with garbage collection, and it compiles to\nWebAssembly. It seems particularly designed for running on CDN Edge Workers,\nwhich I love.\n\nNote: Since it's a young language, the language specifications are expected to\nchange significantly. This information is accurate as of now.\n\n## tl;dr\n\n  * Pros\n\n    * Can mostly be seen as Rust with garbage collection\n\n      * Easy to catch up on the syntax\n      * No need to worry about the complexity of lifetimes\n    * Already has an ecosystem with a VS Code extension and package manager\n  * Cons\n\n    * Still unstable / source code might not be published for a while\n    * Currently lacks learning resources and packages, requiring significant effort from the writer\n\n## Introduction: Dissatisfaction with JS/TS/Rust\n\nI've been searching for an alternative language to TypeScript for front-end\nuse.\n\nThe reason being, I believe there are inherent limitations to extending\nTypeScript, which is based on JavaScript. These are some issues I've always\nhad:\n\n  * No distinction between integers and floating-point numbers; the Number type is the standard\n\n    * This makes it difficult to compile for wasm or integrate with vanilla JS\n    * Performance optimization requires understanding the quirks of JIT\n  * Despite having a type system, it's discarded at transpilation time, not utilized by the compiler, which is a waste\n  * Due to backward compatibility, old syntax cannot be discarded, leading to some rigid specifications\n\n    * TC39 is doing a great job, but still...\n  * No pattern matching\n  * Using objects as substitutes for records, resulting in forced practices like adding a type: \"datatype\" property to everything\n\nRust would be a better foundation for extensions. However, it can be pretty\ntough to use for application layers like GUIs.\n\nTo understand the difficulty of Rust Wasm, let's look at an example using\nrequestAnimationFrame.\n\n    \n    \n    #[wasm_bindgen(start)] fn run() -> Result<(), JsValue> { let f = Rc::new(RefCell::new(None)); let g = f.clone(); let mut i = 0; *g.borrow_mut() = Some(Closure::new(move || { if i > 300 { body().set_text_content(Some(\"All done!\")); let _ = f.borrow_mut().take(); return; } i += 1; let text = format!(\"requestAnimationFrame has been called {} times.\", i); body().set_text_content(Some(&text)); request_animation_frame(f.borrow().as_ref().unwrap()); })); request_animation_frame(g.borrow().as_ref().unwrap()); Ok(()) }\n\nThis isn't to say Rust is a bad language, but in front-end GUIs with frequent\nevent handlers, the complexity and nuisance of lifetime management are\nglaringly apparent.\n\nI've previously discussed this in a stream with koba789 on YouTube.\n\nhttps://www.youtube.com/watch?v=Cij3CUJmLXI\n\nLanguages like Zig or Grain aren't bad for wasm, but they're not primarily\nfocused on wasm, so there were some impracticalities.\n\nSo, let's try using MoonBit\n\n## Installation\n\nYou can try it on VS Code in the browser.\n\nhttps://try.moonbitlang.com/\n\nFor local installation:\n\nhttps://www.moonbitlang.com/download/\n\nInstalling the VS Code extension allows for smooth local development.\n\nhttps://marketplace.visualstudio.com/items?itemName=moonbit.moonbit-lang\n\nThe official completion extension is also useful, incorporating concepts like\nlocal and global sampling at the language level for Copilot-like completions.\n\nhttps://marketplace.visualstudio.com/items?itemName=moonbit.moonbit-ai\n\n## Quick MoonBit Tutorial\n\nLet's create and run a project.\n\n    \n    \n    $ moon new hello $ cd hello $ moon run main hello, world\n\nNow, let's write in main/main.mbt.\n\nIt's mostly like Rust. There are no lifetime traits since it's a GC language.\n\n    \n    \n    // function fn add(a: Int, b: Int) -> Int { return a + b } // generics fn self[T](v: T) -> T { return v } // generics trait fn _lge[X : Compare](a: X, b: X) -> Bool { return a >= b } // data structure enum T { A B } struct Point { x: Int y: Int } derive(Debug) fn distance(self: Point, other: Point) -> Double { sqrt((self.x * other.x + self.y * other.y).to_double()) } // Generics and derived trait struct Point3d[N] { x: N y: N z: N } derive(Debug) // newtype // type Point3dInt Point3d[Int] // trait trait Animal { speak(Self) -> Unit } struct Duck { name: String } fn speak(self: Duck) -> Unit { let name = self.name println(\"\\(name): Quak!\") } fn main { println(\"Hello, World!\") // variable let _x = \"hello\" let mut y: Int = 2 let _multiline_text = #| hello #| world #| multiline y = 3 let p = Point::{x: 1, y: 2} println(p.distance(Point::{x: 3, y: 4})) debug(p) // function and call let _ = add(1, 2) // pipeline let _ = 1 |> add(2) |> add(4) // call ./foo.mbt: pub fn foo() -> Int { 1 } let _ = foo() // list and iterator let list = [1, p.x, p.y] let mapped = list.map(fn (x) -> Int { return x + 1 }) println(mapped) // inference let _: Int = self(1) // as Int // trait let duck = Duck::{name: \"Donald\"} as Animal duck.speak() // if else if y == 2 { println(\"y is 1\") } else { println(\"y is not 1\") } // match let mut m = T::A m = T::B let _ = match m { T::A => 1 T::B => 2 } // for for i = 1; i < 5; i = i + 1 { print(i) } println(\"\") // while let mut i = 0 while i > 0 { i = i - 1 } // scope { let x = 1 println(x) } } // inline test test { let a = 1 let b = 2 let c = add(a, b) @assertion.assert_eq(c, 3)? }\n\nApart from differences in macros, derive, and generics, it's quite similar to\nRust. Syntax highlighting also borrows from Rust.\n\nThe structure, pattern matching, and pipeline operator feel right. Unlike\nTypeScript, if it compiles, it runs, giving a sense of security. The\ncompletions also feel great once you write in it.\n\nOf course, MoonBit's language features are not limited to this, but if you're\nfamiliar with other programming languages, this should give you a basic\nunderstanding.\n\n## Wasm Compilation: Use in the Browser\n\nSince MoonBit compiles to wasm, it can be executed in the browser.\n\n    \n    \n    $ moon build\n    \n    \n    <html lang=\"en\"> <body> <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas> </body> <script> let memory; const [log, flush] = (() => { let buffer = []; function flush() { if (buffer.length > 0) { console.log(new TextDecoder(\"utf-16\").decode(new Uint16Array(buffer).valueOf())); buffer = []; } } function log(ch) { if (ch == '\\n'.charCodeAt(0)) { flush(); } else if (ch == '\\r'.charCodeAt(0)) { /* noop */ } else { buffer.push(ch); } } return [log, flush] })(); const importObject = { spectest: { print_char: log }, js_string: { new: (offset, length) => { const bytes = new Uint16Array(memory.buffer, offset, length); const string = new TextDecoder(\"utf-16\").decode(bytes); return string }, empty: () => { return \"\" }, log: (string) => { console.log(string) }, append: (s1, s2) => { return (s1 + s2) }, } }; WebAssembly.instantiateStreaming(fetch(\"/target/wasm/release/build/main/main.wasm\"), importObject).then( (obj) => { memory = obj.instance.exports[\"moonbit.memory\"]; obj.instance.exports._start(); flush(); } ) </script> </html>\n\n## MoonBit for Troubleshooting\n\nWhen in doubt, the official examples usually cover most scenarios.\n\nhttps://github.com/moonbitlang/moonbit-docs/tree/main/examples\n\nDiscussions often provide a wealth of information.\n\nhttps://discuss.moonbitlang.com\n\nawesome-moonbit doesn't have a lot yet, but it's worth checking out.\n\nhttps://github.com/moonbitlang/awesome-moonbit\n\n## The Appeal of MoonBit\n\nMoonBit is strongly focused on Rust, AI, and Wasm for Edge Workers. I'm\nalready a fan of this direction.\n\nhttps://www.moonbitlang.com/blog/moonbit-ai\n\nAI-integrated completion is an interesting feature, and the toolchain is\nalready well-established, making it pleasant to write in.\n\n## Complaints About MoonBit\n\n### Lack of Libraries\n\nFirstly, there are simply not enough packages yet, which is understandable\ngiven its newness.\n\nhttps://mooncakes.io/\n\n### Module System\n\nThe explicit scoping in moon.pkg.json or moon.mod.json means there's no direct\nequivalent to JS's import or Rust's use, which can make file scopes a bit\nchallenging to grasp.\n\n### Ineffective AI Completions\n\nDespite the hype around AI-powered completions, they often lean too heavily on\nRust, leading to irrelevant suggestions. Consequently, I've turned off\nCopilot.\n\n    \n    \n    { \"github.copilot.editor.enableCodeActions\": false, \"github.copilot.editor.enableAutoCompletions\": false }\n\n## Looking Forward\n\nMoonBit is still too new, and I haven't used it for large projects outside of\ngame-like scenarios with few assumptions. However, the potential is exciting,\nespecially for technologies with minimal prerequisites like CDN edge workers,\nmaking them ideal for new tech.\n\nOfficial examples include CF Worker demos.\n\nhttps://github.com/moonbitlang/moonbit-docs/tree/main/examples/cf_worker\n\n    \n    \n    pub fn fib(n : Int) -> Int64 { loop 0L, 1L, n { a, _, 0 => a a, b, n => continue b, a + b, n - 1 } }\n    \n    \n    import wasm from '../target/wasm-gc/release/build/hello.wasm'; const module = await WebAssembly.instantiate(wasm); module.exports._start(); export interface Env {} export default { async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> { return new Response(`Hello World! ${module.exports.fib(10)}`); } };\n\nCurrently, it seems limited to numerical computations, but as the ecosystem\ngrows, broader applications should become feasible. Asynchronous runtime\nsupport seems necessary as well.\n\nDespite potential significant changes on the horizon, MoonBit has the\npotential to dominate its niche, a future I'm eagerly anticipating.\n\nSign up for free to join this conversation on GitHub. Already have an account?\nSign in to comment\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
