{"aid": "39980980", "title": "The Distribution Problem: what's wrong with internal CAs (and what to do about", "url": "https://anchor.dev/blog/the-distribution-problem", "domain": "anchor.dev", "votes": 4, "user": "todsacerdoti", "posted_at": "2024-04-09 16:16:28", "comments": 0, "source_title": "The Distribution Problem", "source_text": "The Distribution Problem\n\narticle.featured\n\nApril 10, 2024\n\n# The Distribution Problem\n\nWhat's wrong with internal CAs (and what to do about it)\n\nBen Burkert\n\nApril 10, 2024\n\n## At Anchor, we help developers deploy internal TLS by building and managing\nprivate (aka internal) Certificate Authorities (CAs). It's a lot like a public\nCA, but just for your organization. Give it a try with lcl.host, a free\ndevtool to setup HTTPS in your local dev environment.\n\nHere's something that's happened more than once in my career: a fellow\ndeveloper is considering internal TLS to address a security requirement or\nproblem, and I\u2019m simultaneously thinking:\n\n  * An internal CA could solve this problem, and\n\n  * I do not want to suggest an internal CA solution.\n\nInternal CAs have a reputation for being great on paper, but problematic in\npractice. Instead, we often see public CA issued certificates used for\ninternal TLS rather than internal CA issued certificates. But that can require\nbuilding complex ACME workflows to get public CA certificates onto backend\nservers. Developers will go to astounding, yet often justified, lengths to\navoid internal CAs. The public CA approach avoids most of the problems that\nplague internal CAs, but has its own set of challenges: low API limits, slow\ncertificate provisioning, and little control (more on this later).\n\nWhy do internal CAs feel extra painful to developers? At a fundamental level,\nthere is no real difference between public and internal CAs to a TLS client or\nserver. Once a server has its certificate and a client has its trusted CAs,\nconnections are functionally identical. The organizational structure of the CA\nissuing certificates has no impact on security or feature availability. Let's\nlook at some of the challenges specific to internal CAs, and some ways we can\nsolve them.\n\n### Internal CA Problems\n\nProblems with internal CAs generally fall into two categories:\n\n  * Provisioning: providing certificates to servers.\n\n  * Distribution: updating clients and applications to trust certificates presented by servers.\n\nFrustratingly, certificate management solutions focus entirely on\nprovisioning, whereas internal CA deployments struggle most with distribution.\nTo our knowledge, Anchor is the first product to address distribution\nproblems. Before diving into Anchor\u2019s features, let\u2019s look closer at both\nprovisioning and distribution problems.\n\n### Provisioning Problems\n\nGetting certificates to services so they can terminate TLS is the provisioning\nproblem. Without a valid X.509 certificate, a server cannot securely serve\nencrypted traffic. For services that require TLS encryption, their utility\ndepends on the ability to provision a certificate.\n\nTen years ago, adding certificates to servers was painful. A lack of common\nconfiguration and provisioning workflows made automation difficult. But the\nACME protocol changed that by standardizing how certificates are provisioned.\nIt\u2019s even standardizing how applications configure and load certificates.\n\nThe good news is that ACME is just as applicable for internal CAs. In fact,\nsimpler ACME workflows are possible since the security contexts are quite\ndifferent. An internal CA can employ pre-authorization of clients by utilizing\nan API token based ACME workflow. This means clients don\u2019t have to publish DNS\nrecords or respond to HTTP challenges to get certificates. (We call this zero-\nchallenge ACME.)\n\nOnce servers have valid certificates, distribution problems begin.\n\n### Distribution problems\n\nTo validate server certificates, clients must be configured with the set of\ncertificates for the issuing CAs. It's a lot of work to keep these sets up-to-\ndate and distributed to browsers, OSes, and clients. Public CAs have gotten so\ngood at this that most people (even developers) don't realize just how much\nwork it takes.\n\nUnfortunately, the work of these public CAs does not help internal CAs. By\ndefinition, private CAs cannot be introduced into the set of trusted public\nCAs, leaving the challenges of distribution and maintenance to internal CA\noperators. As services grow and become more interconnected, the toil of\noperating internal CAs grows quickly.\n\nLuckily, most of the tooling created for public CAs is usable with internal\nCAs. For example, the OS package formats for installing public CAs works just\nas well for internal CAs. The tooling may be tedious, but public CAs\ndemonstrate that it can work.\n\nAnchor eliminates this tedious work by building OS and language packages to\ninstall certificate sets into your system and application runtime trust\nstores. You get a seamless trust store management experience more like public\nCAs, but tailored to developer needs.\n\n### What about Public CAs?\n\nUsing a public CA for internal TLS is popular because both provisioning and\ndistribution problems are more or less solved. The ACME protocol is flexible\nenough to provision certificates for most applications and infrastructure. And\ndistribution issues are invisibly handled by the Root CA Programs (a.k.a. the\nOS and browser organizations), making it almost entirely a non-issue for\ndevelopers.\n\nIf shoe-horning public CAs for internal TLS works, why not use one? Although\npopular, this approach comes with problems:\n\n  * Low API limits put in place by public CAs will impact your ability to replace and receive new certificates, causing outages and impacts to service availability.\n\n  * Slow provisioning workflows means even fully automated certificate provisioning can be painfully slow due to DNS record propagation or slow ACME challenge resolution.\n\n  * Public visibility of these certificates (via CT logs) may unintentionally leak details about internal infrastructure and services, or even customer details. For example, using a subdomain per customer means your customer list is public and searchable in tools like crt.sh.\n\n  * Very little control or customization. Expiration periods are set by CA policy, and extensions like mTLS support may be restricted.\n\nThe problems with using public CAs for internal TLS arise from their public\nnature. The need to protect against fraud & abuse necessitates API limits, CT\nlogs, and other policies that manifest as problems for internal TLS users.\n\nPublic CAs may never be a perfect fit for internal TLS, but they do get a lot\nright. And what public CAs do well can be incorporated into internal CAs.\n\n### Solutions\n\nAnchor provides a better developer experience for certificate management than\nany public or internal CA solution that exists today. We do this by adapting\nand improving upon the public CA experience for internal TLS.\n\nFor certificate provisioning, our zero-challenge ACME flow provides near\ninstant certificates. It\u2019s fast enough to move certificate provisioning into\nthe container and service boot process.\n\nOur language and OS packages are a developer-friendly way to manage your\nclient trust stores. Anchor is the only certificate management product that\noffers developer friendly package artifacts.\n\nWe see certificate provisioning as table-stakes for certificate management,\nand we\u2019re obsessive about solving distribution problems. We want to change how\ndevelopers think about internal CAs, and have confidence that an internal CA\nis the best option for internal TLS deployments.\n\nIf you\u2019re interested in using Anchor for internal TLS deployments at your\norganization, please reach out via email to join our private beta. Or give\nAnchor a try right now in your development environment with lcl.host, our free\ndevtool for quick & easy HTTPS in your local dev environment.\n\n## Related Articles\n\nIntroducing lcl host\n\nBen Burkert\n\nMarch 20, 2024\n\nGetting Started with Anchor for Local Development\n\nBen Burkert\n\nOctober 18, 2023\n\nDocs\n\nAbout\n\nContact\n\nGithub\n\n2024 Anchor, Inc.\n\n", "frontpage": false}
