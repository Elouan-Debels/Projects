{"aid": "39993459", "title": "Building a Better Repository Map", "url": "https://aider.chat/docs/repomap.html", "domain": "aider.chat", "votes": 1, "user": "colinprince", "posted_at": "2024-04-10 17:33:35", "comments": 0, "source_title": "Building a better repository map with tree sitter", "source_text": "Building a better repository map with tree sitter | aider\n\nSkip to the content.\n\n# Building a better repository map with tree sitter\n\n## aider is AI pair programming in your terminal\n\nHome Blog GitHub\n\n# Building a better repository map with tree sitter\n\nGPT-4 is extremely useful for \u201cself-contained\u201d coding tasks, like generating\nor modifying a simple function that has no dependencies. Tools like GitHub\nCoPilot serve these simple coding tasks well.\n\nBut making complex changes in a larger, pre-existing codebase is much more\ndifficult, for both humans and AIs. To do this successfully, you need to:\n\n  1. Find the code that needs to be changed.\n  2. Understand how that code relates to the rest of the codebase.\n  3. Make the correct code change to accomplish the task.\n\nGPT-4 is actually great at making the code changes (3), once you tell it which\nfiles need to be changed (1) and show it how they fit into the rest of the\ncodebase (2).\n\nThis article is going to focus on step (2), providing \u201ccode context\u201d:\n\n  * We need to help GPT understand the overall codebase.\n  * This will help it understand the code it needs to change, which may depend on other parts of the codebase.\n  * It will also help GPT write new code and modify the existing code in a way that respects and utilizes existing libraries, modules and abstractions found elsewhere in the codebase.\n  * We must convey all of this \u201ccode context\u201d to GPT in an efficient manner that fits within the limited context window.\n\nTo address these issues, aider sends GPT a concise map of your whole git\nrepository that includes the most important classes and functions along with\ntheir types and call signatures.\n\nThis repository map is now built automatically using tree-sitter to extract\nsymbol definitions from source files. Tree-sitter is used by many IDEs,\neditors and LSP servers to help humans search and navigate large codebases.\nAider now uses it to help GPT better comprehend, navigate and edit code in\nlarger repos.\n\nTo code with GPT-4 using the techniques discussed here, just install aider.\n\n## The problem: code context\n\nGPT-4 is great at \u201cself contained\u201d coding tasks, like writing or modifying a\npure function with no external dependencies. GPT can easily handle requests\nlike \u201cwrite a Fibonacci function\u201d or \u201crewrite this loop using list\ncomprehensions\u201d, because they require no context beyond the code being\ndiscussed.\n\nMost real code is not pure and self-contained, it is intertwined with and\ndepends on code from many different files in a repo. If you ask GPT to \u201cswitch\nall the print statements in class Foo to use the BarLog logging system\u201d, it\nneeds to see and modify the code in the Foo class, but it also needs to\nunderstand how to use the project\u2019s BarLog subsystem.\n\nA simple solution is to send the entire codebase to GPT along with each change\nrequest. Now GPT has all the context! But this won\u2019t work for even moderately\nsized repos, because they won\u2019t fit into the context window.\n\nA better approach is to be selective, and hand pick which files to send. For\nthe example above, you could send the file that contains the Foo class and the\nfile that contains the BarLog logging subsystem. This works pretty well, and\nis supported by aider \u2013 you can manually specify which files to \u201cadd to the\nchat\u201d you are having with GPT.\n\nBut sending whole files is a bulky way to send code context, wasting the\nprecious context window. GPT doesn\u2019t need to see the entire implementation of\nBarLog, it just needs to understand it well enough to use it. You may quickly\nrun out of context window by sending full files of code just to convey\ncontext.\n\nAider also strives to reduce the manual work involved in coding with AI. So in\nan ideal world, we\u2019d like aider to automatically identify and provide the\nneeded code context.\n\n## Using a repo map to provide context\n\nAider sends a repo map to GPT along with each request from the user to make a\ncode change. The map contains a list of the files in the repo, along with the\nkey symbols which are defined in each file. It shows how each of these symbols\nare defined in the source code, by including the critical lines of code for\neach definition.\n\nHere\u2019s a sample of the map of the aider repo, just showing the maps of\nbase_coder.py and commands.py :\n\n    \n    \n    aider/coders/base_coder.py: \u22ee... \u2502class Coder: \u2502 abs_fnames = None \u22ee... \u2502 @classmethod \u2502 def create( \u2502 self, \u2502 main_model, \u2502 edit_format, \u2502 io, \u2502 skip_model_availabily_check=False, \u2502 **kwargs, \u22ee... \u2502 def abs_root_path(self, path): \u22ee... \u2502 def run(self, with_message=None): \u22ee... aider/commands.py: \u22ee... \u2502class Commands: \u2502 voice = None \u2502 \u22ee... \u2502 def get_commands(self): \u22ee... \u2502 def get_command_completions(self, cmd_name, partial): \u22ee... \u2502 def run(self, inp): \u22ee...\n\nMapping out the repo like this provides some key benefits:\n\n  * GPT can see classes, methods and function signatures from everywhere in the repo. This alone may give it enough context to solve many tasks. For example, it can probably figure out how to use the API exported from a module just based on the details shown in the map.\n  * If it needs to see more code, GPT can use the map to figure out by itself which files it needs to look at in more detail. GPT will then ask to see these specific files, and aider will automatically add them to the chat context.\n\n## Optimizing the map\n\nOf course, for large repositories even just the repo map might be too large\nfor GPT\u2019s context window. Aider solves this problem by sending just the most\nrelevant portions of the repo map. It does this by analyzing the full repo map\nusing a graph ranking algorithm, computed on a graph where each source file is\na node and edges connect files which have dependencies. Aider optimizes the\nrepo map by selecting the most important parts of the codebase which will fit\ninto the token budget assigned by the user (via the --map-tokens switch, which\ndefaults to 1k tokens).\n\nThe sample map shown above doesn\u2019t contain every class, method and function\nfrom those files. It only includes the most important identifiers, the ones\nwhich are most often referenced by other portions of the code. These are the\nkey pieces of context that GPT needs to know to understand the overall\ncodebase.\n\n## Using tree-sitter to make the map\n\nUnder the hood, aider uses tree sitter to build the map. It specifically uses\nthe py-tree-sitter-languages python module, which provides simple, pip-\ninstallable binary wheels for most popular programming languages.\n\nTree-sitter parses source code into an Abstract Syntax Tree (AST) based on the\nsyntax of the programming language. Using the AST, we can identify where\nfunctions, classes, variables, types and other definitions occur in the source\ncode. We can also identify where else in the code these things are used or\nreferenced.\n\nAider uses all of these definitions and references to determine which are the\nmost important identifiers in the repository, and to produce the repo map that\nshows just those key lines from the codebase.\n\n## What about ctags?\n\nThe tree-sitter repository map replaces the ctags based map that aider\noriginally used. Switching from ctags to tree-sitter provides a bunch of\nbenefits:\n\n  * The map is richer, showing full function call signatures and other details straight from the source files.\n  * Thanks to py-tree-sitter-languages, we get full support for many programming languages via a python package that\u2019s automatically installed as part of the normal pip install aider-chat.\n  * We remove the requirement for users to manually install universal-ctags via some external tool or package manager (brew, apt, choco, etc).\n  * Tree-sitter integration is a key enabler for future work and capabilities for aider.\n\n## Future work\n\nYou\u2019ll recall that we identified the 3 key steps required to use GPT to\ncomplete a coding task within a large, pre-existing codebase:\n\n  1. Find the code that needs to be changed.\n  2. Understand how that code relates to the rest of the codebase.\n  3. Make the correct code change to accomplish the task.\n\nWe\u2019re now using tree-sitter to help solve the code context problem (2), but\nit\u2019s also an important foundation for future work on automatically finding all\nthe code which will need to be changed (1).\n\nRight now, aider relies on the user to specify which source files will need to\nbe modified to complete their request. Users manually \u201cadd files to the chat\u201d\nusing aider\u2019s /add command, which makes those files available for GPT to\nmodify.\n\nThis works well, but a key piece of future work is to harness the power of GPT\nand tree-sitter to automatically identify which parts of the code will need\nchanges.\n\n## Try it out\n\nTo code with GPT-4 using the techniques discussed here, just install aider.\n\n## Credits\n\nAider uses modified versions of the tags.scm files from these open source\ntree-sitter language implementations:\n\n  * https://github.com/tree-sitter/tree-sitter-c \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-c-sharp \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-cpp \u2014 licensed under the MIT License.\n  * https://github.com/Wilfred/tree-sitter-elisp \u2014 licensed under the MIT License.\n  * https://github.com/elixir-lang/tree-sitter-elixir \u2014 licensed under the Apache License, Version 2.0.\n  * https://github.com/elm-tooling/tree-sitter-elm \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-go \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-java \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-javascript \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-ocaml \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-php \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-python \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-ql \u2014 licensed under the MIT License.\n  * https://github.com/r-lib/tree-sitter-r \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-ruby \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-rust \u2014 licensed under the MIT License.\n  * https://github.com/tree-sitter/tree-sitter-typescript \u2014 licensed under the MIT License.\n\naider is maintained by paul-gauthier. This page was generated by GitHub Pages.\n\n", "frontpage": false}
