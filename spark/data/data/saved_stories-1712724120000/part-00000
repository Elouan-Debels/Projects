{"aid": "39985112", "title": "Discrete Logic IC CPU", "url": "https://qdiv.dev/posts/ccpu/", "domain": "qdiv.dev", "votes": 1, "user": "mbokinala", "posted_at": "2024-04-09 22:41:04", "comments": 0, "source_title": "Discrete logic IC CPU", "source_text": "Discrete logic IC CPU | Ivan's blog\n\nDiscrete logic IC CPU\n\n# Discrete logic IC CPU\n\n##### October 11, 2020\n\nSince I was a kid I\u2019ve always wanted to build my own computer. First I had\nonly vague ideas of how computers are made, then I got myself a book about\nbuilding an 8080-based computer and programming it, later, of course, I\u2019ve got\na lot of experience with various computers and microcontrollers, but I\u2019ve\nnever built one from scratch. Now, when I\u2019m 30, I can say I have fulfilled my\nchildhood dream.\n\nThe main part of the project is the CPU. My CPU has 8-bit data bus width and\nhave the address bus width of 16 bits. The CPU is attached to the peripheral\nmodule which contains program ROM, RAM, display, and keyboard.\n\n## Overview #\n\nI wanted to make the processor as simple as possible, but not too constrained.\nA processor needs to do these few things:\n\n  * Read and write memory;\n  * Perform arithmetics;\n  * Have conditional and unconditional jumps.\n\nTo access memory and perform jumps you have to somehow supply memory\naddresses. Most of the modern processors allow user to encode direct or\nindirect memory address right in the load/store/jump instruction. Doing this\non discrete logic would be too complicated or would require microcode.\nTherefore, I decided to only have indirect memory access and jumps using a\npointer register. To load the registers in the first place, a load immediate\ninstruction is necessary.\n\nThese four classes of instructions (read/write memory, arithmetics, jumps,\nload immediate) are the only instructions implemented.\n\nThe processor operates on 8-bit data and can address up to 65536 bytes of\nmemory (16 bit address). This means the pointer register should hold 16 bits.\nFrom the programmer\u2019s point of view, the pointer register P is split into two\nhalves: PL and PH. These halves can be loaded separately. Then, the whole P\nregister is used to access memory. Jumps are performed by swapping the P\nregister with the instruction pointer. As a side effect, function calls can be\nimplemented: after swapping (and jumping), P shall contain the return address.\n\nThe other two registers are named A and B. The arithmetics is performed\nbetween A and another register. There are four flags implemented:\n\n  * Z - zero;\n  * C - carry;\n  * S - sign;\n  * O - overflow (for signed arithmetics).\n\n## Hardware design #\n\nHere I outline the steps taken to design the hardware.\n\n  1. I thought out the overal layout of the buses and registers and sketched timing diagrams.\n  2. Then I programmed the model in Verilog, added some test benches and ran them using Icarus Verilog.\n  3. Time to draw the schematic diagrams! I opened the list of 7400-series integrated circuits and checked which of them could be bought in my local electronic parts store. Based on that, I selected the exact part numbers to use as registers and buffers in my project. I chose the ACT variant (or AC when ACT wasn\u2019t available) for the best desired electrical characteristics.\n  4. Using KiCad I started drawing schematic diagrams. At the same time I adjusted the Verilog models to match the actual schematics. This way I was sure the CPU will work as desired when I build it.\n  5. After the schematics were ready I traced the PCBs in KiCad and ordered production from a Chinese company. At the same time I ordered the electronic components from the local retailer.\n  6. When everything arrived, I soldered the boards.\n\n## Module layout #\n\nI\u2019ve broken down the computer into four modules for two reasons. First, PCB\nproduction up to 100x100mm is much cheaper than if any dimension exceeds\n100mm. Second, having separate modules makes it easier to fix hardware errors\nand leaves room for improvement. For example, the ALU module now is made using\ntwo ROM chips which is kind of \u201ccheating\u201d if you want to call the CPU\ndiscrete-logic-based.\n\nThe module layout actually helped: I have to redo the control module. The\nfirst version was ROM-based like ALU. I wanted to make it possible to\nreprogram the control signals and change the instruction set. But it turned\nout that ROM chips cannot be used as asynchronous lookup tables: during the\naddress transition the data bus goes through random chagnes. It\u2019s okay for the\nALU because the inputs are changed on the rising clock edge and the outputs\nare used on the falling edge.\n\n## Registers module #\n\nThis simplified diagram shows the register layout inside the processor.\nControl, clock, and reset signals are not shown.\n\nRegisters A and B have one input and two tri-state outputs. Each output can be\nindependently enabled or put into high-z state. Data input is synchronious:\nthe value from the input bus is clocked into the register on a clock edge if\nthe we control signal is asserted.\n\nP is a combined register. It consists of two pairs (16 bit each) of\npreloadable counters. The sel input selects which pair is considered to be the\ninstruction pointer (IP) (and can be incremented) and which one is the pointer\nregister P. The cnt signal controls if the current IP is incremented on the\nclock edge. If addr_dp is asserted, the address bus is driven from the P pair,\notherwise IP is used. we_dh, we_dl, oe_dh, oe_dl signals control whether the\nhalves of the P pair are loaded or drive output bus.\n\nAs you can see on the diagram, one of the ALU inputs is always connected to\nthe register A. The other input can be driven by any of the registers (this\nbus is shown in purple). If none of the oe signals is asserted, the second ALU\ninput would be zero because of the pull-down resistors. This way arithmetics\nbetween A and zero can be performed.\n\nEach register\u2019s input is connected to the internal data bus (green). This bus\ncan be driven either by ALU or by a tri-state buffer connecting it to the\nexternal data bus (red). This allows the registers to be loaded either from\nmemory or from the arithmetic operation result.\n\nThe other outputs of registers A and B are connected to the external data bus.\nThis way the values of these registers can be stored into RAM.\n\nThe input of the instruction register IR is connected to the data bus. This\nregister is loaded with the current instruction on the first exectution phase.\nThe output value of this register is used to provide control signals to\neverything in the processor.\n\nFinally, the flags output from the ALU is stored into a register. Its output\nis then used to control conditional jumps. Additionally, the carry flag stored\nin the flags register is fed back to the ALU to perform arithmetics with\ncarry.\n\n## ALU #\n\nThe ALU provides 16 arithmetic operations. I\u2019ve decided to implement the ALU\nusing a ROM-based lookup table. The straightforward approach would be to use\none large ROM chip, feed everything to it and read the result from the output:\n\nThe following inputs are needed:\n\n  * Operands A and B (16 bits in total);\n  * Opcode (4 bit);\n  * Stored carry (1 bit);\n  * Invert bit - to be able to reorder input.\n\nThe output would be:\n\n  * The result (8 bits)\n  * Flags (4 bits)\n\nIn total, the ROM should have 22 bit input and 12 bit output. The output, of\ncourse, can be easily split into two chips, but still a 22 bit parallel ROM is\npretty expensive and hard to find.\n\nConsidering all of this, I decided to process two 4-bit nibbles separately:\n\nThis way operations like addition, subtraction, bit shifts can\u2019t be done\nwithout communication between the nibbles. I added one feedback line going\nfrom lower nibble\u2019s output to the high nibble\u2019s input (shown in green) and the\nother way around (red). To prevent feedback oscillations, logic gates were\nadded: only one feedback line is activated at a time and selected by bit 3 of\nthe opcode. This means operations like addition or left shift (when an\ninformation bit should go \u201cup\u201d) can be encoded by opcodes from 0 to 7, and\noperations like right shift should occupy opcodes from 8 to 15.\n\nThe overflow flag (for signed arithmetics) is taken from the upper nibble\ntable: only higher bits influence this flag.\n\nThe carry flag is combined from both parts by a NAND gate. This way carry can\nbe set by either of tables.\n\nThe zero flag is calculated by a logical NOR of all the output bits. This way,\nZ will be set if R is zero.\n\nFinally, the sign flag is just the upper bit of the result.\n\nThese tables fitted nicely into two cheap 28C256 32k x 8bit ROM chips.\n\nFor convenience, processor needs a MOV instruction to copy one register\u2019s\nvalue into another. With the selected architecture, it can only be done via\nALU. To make this instruction usable, it shouldn\u2019t modify flags. To assure\nthis, additional control logic was added which stores flags only if the ALU\nopcode is not MOV.\n\n## Instruction encoding #\n\nAll instructions except for LDI are encoded in one byte. LDI is coded in two\nbytes: the second byte is the immediate value.\n\nIn the control unit the following circuit decodes the instruction opcode\nstored in the instruction register:\n\nSignals ir7, ir6 and ir5 are the three upper bits of the IR. When bit 7 is\nlow, op_alu is high indicating an ALU instruction. If bit 7 is high, the\ndecoder U2B is enabled and the other two bits are used to select one of the\nfour remaining instructions.\n\n### ALU instructions #\n\nOne operand for this instruction is always A, the other one is encoded in the\nlast two bits:\n\n    \n    \n    0ooooidd \\__/|\\/ | | -- other register operand (00 - zero, 01 - B, 10 - PL, 11 - PH) | +--- inversion bit (0 - \"SUB A, B\", 1 - \"SUB B, A\") +----- ALU operation\n\nExample: SUB PL, A would be 00001110 (SUB opcode is 0001).\n\n### LD instruction #\n\n    \n    \n    100???rr \\/ -- register operand (00 - A, 01 - B, 10 - PL, 11 - PH)\n\nExample: LD PH would be 10000011.\n\n### ST instruction #\n\nOnly A or B can be stored into memory. Storing PL or PH doesn\u2019t make sense\nanyway: they contain the address of the memory location.\n\n    \n    \n    101????r | -- register operand (0 - A, 1 - B)\n\nExample: ST B would be 10100001.\n\n### LDI instruction #\n\n    \n    \n    110???rr bbbbbbbb \\/ \\______/ \\ +---- immediate value | +---------- register operand, same as for LD\n\nExample: LDI PL, 0xF0 would be 11000010 11110000.\n\n### Jump instructions #\n\n    \n    \n    111?ciff ||\\/ || -- flag (00 - Z, 01 - C, 10 - S, 11 - O) |+--- inversed condition (0 - selected flag should be 1, 1 - selected flag should be 0) +---- flag selection disabled (0 - a flag is selected, 1 - condition result is always 1)\n\nExamples:\n\n  * JMP: 11101000\n  * NOP: 11111111\n  * JNS: 11100110\n\n## Instruction execution #\n\nOn the control board instruction execution is encoded with discrete logic.\nUsing the value of the instruction register (IR), clock, and flags, the\ncontrol signals for the registers, ALU, and memory are calculated. Such\nsignals include (but are not limited to):\n\n  * load IR,\n  * increment IP,\n  * write or read memory,\n  * write any register,\n  * enable a register or ALU output to drive a bus.\n\nMost of the instructions are executed in two clock cycles. The LDI (load\nimmediate) instruction requires four cycles: IP should be incremented twice.\n\nUsing three flip-flops three additional slower clock signals are generated\nfrom the master clock (clk):\n\n  * cycle controls the execution cycle of the instruction. When cycle is low, IR is loaded, when cycle is high, the instruction is executed.\n  * we_cycle is basically cycle phase-shifted by 90\u00b0. It\u2019s used to generate the n_we_mem (write memory) signal for the ST instruction.\n  * supercycle is only active when the long LDI instruction is executed.\n\nThe general rules of the control signals:\n\n  * Data is latched and IP is incremented on falling clock edge;\n  * Control signals change on raising clock edge.\n\nThese rules assure that values on the buses (ALU output, memory output) are\nstable when registers are latched.\n\n### Load register from RAM (LD) #\n\n  * RAM is always set in read mode (n_mem_oe low, n_mem_we hi)\n  * ALU output is disabled\n  * Registers output to external data bus is disabled\n  * During the second phase (cycle is high):\n\n    * P drives the address bus (addr_dp is high),\n    * IP is incremented (inc_ip is high),\n    * IR is not latched (we_ir is low),\n    * Register selected by opcode is latched (n_we_x is low).\n\n### Store register to RAM (ST) #\n\nThis instruction is similar to LD, but the write signals are formed on the\ndata bus. During the second phase n_mem_oe is set to high which makes RAM chip\nrelease the data bus. To write the byte, n_mem_we is pulled down for the first\nhalf of the second phase. The data is written into RAM when this signal goes\nup. This happens on falling clock edge when the data is stable.\n\n### Arithmetic instructions #\n\nThere are two types of instructions involving ALU: direct and inversed. In the\ndirect case the operation result is written into A, in the inversed case the\nALU inputs are flipped and the result is written into the other register (not\nA). For example, SUB A, B is a direct instruction and SUB PL, A is inversed.\nIn the second case PL will be modified.\n\nI\u2019m only showing here the direct ALU waveform. The other one can be found in\nthe repository.\n\n### Load immediate value (LDI) #\n\nThis is the most complex instruction. It takes four clock cycles. IP is\nincremented two times. After the first increment the byte from the data bus is\nlatched into the selected register.\n\nThe timing diagrams are drawn with Wavedrom.\n\n## Peripheral board #\n\nThe peripheral board provides 32k ROM, 28k RAM and minimum IO: a keyboard and\na display. The memory is mapped as follows:\n\n  * 0x0000 - 0x7FFF - ROM\n  * 0x8000 - 0xEFFF - RAM\n  * 0xF000 - keyboard (write column mask, read row mask)\n  * 0xF002 - LCD module control (write only)\n  * 0xF003 - LCD module data (write only)\n\nA matrix keyboard interface is implemented using an 8-bit register to store\nthe column mask and a 3-state 8-bit buffer to drive the data bus with the row\nmask. Keyboards up to 8x8 are possible, but I could only find and buy a 4x4\nmatrix keyboard.\n\nA common 16x2 LCD module is used as a display. Its 8 bit interface bus\nperfectly matches CPU buses with minimal extra logic.\n\n## Programming in assembly #\n\nGiven all the limitations of the processor, programming it in assembly is a\npretty challenging task.\n\n### Functions #\n\nWhen a jump is performed, IP an P are swapped. This way jumps can also be\nviewed as function calls: the return address will be stored in P on function\nentry. We just need to save it in a variable.\n\n    \n    \n    function: mov a, ph ; arithmetics (including MOV) is only possible between A and other register mov b, a mov a, pl ldi ph, hi(ret_addr) ldi pl, lo(ret_addr) st a ; low byte of the return address is stored first inc pl ; ret_addr is aligned, overflow over 256 doesn't happen st b ; ... function body ldi ph, hi(ret_addr) ldi pl, lo(ret_addr) ld a inc pl ld ph ; ph can be loaded directly mov pl, a jmp ; return from the function ; in data section: .align 2 ret_addr: res 2\n\nSince ret_addr is statically allocated, this function cannot be re-entered.\nAnd if you call other functions from this one, they should use distinct\nvariables to store return addresses. If you need recursion, you have to\nimplement a software stack.\n\nThe trick with alignment helps to avoid overflows and save code bytes when\nloading/storing the second byte of a word. With no alignment, we would need\neither to increment PH if carry is set or load PH and PL the second time:\n\n    \n    \n    function: mov a, ph mov b, a mov a, pl ldi ph, hi(ret_addr) ldi pl, lo(ret_addr) st a mov a, 0 ; Arithmetics between A and 0 is allowed inc pl adc ph, a st b\n\n### Parameter passing #\n\nEven a single byte parameter can\u2019t be passed in a register: all the registers\nare used to save the return address. The best way to pass a function parameter\nis to have a static variable for it. Most of the functions aren\u2019t recursive\nanyway.\n\n## High-level language #\n\nAfter I got everything working, I wanted to have a (relatively) high-level\nlanguage compiler for my processor. At first I found an ancient C compiler\nfrom 1980s: SmallC-85. It targets Intel 8080 which is pretty close to what\u2019s\ndesired (8 bit data, 16 bit address). Changing the backend was pretty easy,\nbut there was a problem: SmallC-85 uses stack extensively. For example, a\nsimple line like a = b + c; would compile into something like this (pseudo-\nassembly):\n\n    \n    \n    push b push c pop r1 pop r2 add r1, r2 push r1 pop a\n\nWith a software stack this approach is totally unacceptable.\n\nThen I tried to make my own LLVM backend, but I found myself overwhelmed by\nthe complexity of the task and procrastinating and gave up.\n\n### Natrix #\n\nFinally, I decided to make my own compiler from scratch. I used the Lark\nparsing toolkit for Python and implemented a C-like language which I called\nNatrix after a snake.\n\nBasically, Natrix came out to be almost a subset of C. What makes it different\nis the lack of stack allocations. All local variables are static (the names\nare mangled so that there\u2019s no name collision between functions). Function\nparameters and return values are transferred in static variables too.\n\nInside one translation unit a call graph is built, and if recursion is\ndetected, recursive calls are done via software stack: all local variables are\npushed onto stack before the call and restored afterwards.\n\nInternal temporary variables (also static) are introduced to store\nintermediate results in calculating expressions. These variables are never\nstored on stack.\n\nThese limitations with functions lead to another limitation: a function call\nresult can only be assigned to a variable. You cannot use a function in an\nexpression. Otherwise, each function would have to use its own set of temp\nvariables.\n\nThe other difference with C is the lack of static casts. In C narrow types are\nimplicitly cast to int, then the operation result is cast back if assigned to\na variable of a different type. In Natrix there are no implicit casts.\nCalculations are performed in the explicitly specified type. This helps to\nreduce unnecessary overhead and make it clear for the programmer which type is\ncurrenly used.\n\n## Applications #\n\nThese are the two applications I made for the computer.\n\nThe soft floating point calculator can perform four arithmetic operations. The\nnumbers are coded by 16 bytes (14 bytes for 14 decimal digits of mantissa, 1\nbyte for the exponent and 1 sign byte). You can see how slow it divides two\nnumbers.\n\nIn the maze game you have a 1d view on a 2d maze and must find a key and then\na door to the next, bigger, level. You look at one row of the maze at the\ntime, but you can rotate your view. The game is written in Natrix.\n\n## Project repository #\n\nIf you are interested, you can find the project repository here on GitHub.\n\n## Update #\n\nMaking a new ALU.\n\n", "frontpage": false}
