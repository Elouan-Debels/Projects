{"aid": "40005871", "title": "What Is PDF?", "url": "https://news.speedata.de/2024/03/19/insidepdf-01/", "domain": "speedata.de", "votes": 1, "user": "tajpulo", "posted_at": "2024-04-11 19:29:06", "comments": 0, "source_title": "What is PDF? Part 1 \u2013 the basics", "source_text": "What is PDF? Part 1 \u2013 the basics\n\nNews\n\n  * Start (news)\n  * RSS feed\n  * GitHub page\n  * speedata Publisher examples\n  * Web page\n  * Showcase\n  * speedata Publisher manual\n  * @speedata on mastodon\n\n### speedata news\n\nThis page is about development news from speedata.\n\n### Links\n\n  * Start (news)\n  * RSS feed\n  * GitHub page\n  * speedata Publisher examples\n  * Web page\n  * Showcase\n  * speedata Publisher manual\n  * @speedata on mastodon\n\n### Recent posts\n\n#### 2024\n\n  * What is PDF? Part 3 \u2013 Vector graphis\n  * What is PDF? Part 2 \u2013 Fonts\n  * What is PDF? Part 1 \u2013 the basics\n  * Debugging PDF files\n  * Page shuffling\n  * Reduce PDF file size\n  * Markdown and a layout-quine\n  * Mixing Go and Lua\n  * New logging backend\n  * New stable version 4.16 released\n\n#### 2023\n\n  * The roadmap towards version 5 of the speedata Publisher\n  * Compatibility with older versions of the speedata Publisher\n  * New XML and XPath parser\n\nfrom Patrick Gundlach | March 19 2024\n\n# What is PDF? Part 1 \u2013 the basics\n\nCategories: Development\n\nThis will get very technical again and is for those of you who want to\nunderstand what a PDF file is.\n\nThis is part 1 of a mini-series on PDF. I\u2019ll update this section when the next\nparts are finished.\n\nPart 1 \u2013 PDF syntax and file structure Part 2 \u2013 Fonts Part 3 - Vector graphics\n\n# PDF syntax and file structure\n\n> All the examples will be in a repository on GitHub for download, as copying\n> and pasting from this page may corrupt the code due to the significance of\n> whitespace.\n\nIf you encounter an error, please see the previous post in this blog on how to\ndebug the PDF.\n\n## Let\u2019s dive in\n\nThis is a complete and valid PDF file, which I will explain later (get the\nsource):\n\n    \n    \n    %PDF-1.6 %\u00b7\u00b7 1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj 2 0 obj << /Type /Pages /Kids [ 3 0 R ] /Count 1 >> endobj 3 0 obj << /Type /Page /MediaBox [ 0 0 200 200 ] /Contents 4 0 R /Parent 2 0 R /Resources << >> >> endobj 4 0 obj << /Length 23 >> stream 2 w 10 10 180 180 re S endstream endobj xref 0 5 0000000000 65535 f 0000000015 00000 n 0000000073 00000 n 0000000145 00000 n 0000000272 00000 n trailer << /Size 5 /Root 1 0 R >> startxref 348 %%EOF\n\nThis looks structured, and you may be able to guess the meaning of some of the\nelements, even if you have never looked inside a PDF.\n\n## Basic file structure\n\nThe basic structure of a PDF file is as follows:\n\nwhere the header in my example above is this:\n\n    \n    \n    %PDF-1.6 %\u00b7\u00b7\n\nand the XRef and trailer\n\n    \n    \n    xref 0 5 0000000000 65535 f 0000000015 00000 n 0000000073 00000 n 0000000145 00000 n 0000000272 00000 n trailer << /Size 5 /Root 1 0 R >> startxref 348 %%EOF\n\n## Objects\n\nAnd everything in between is an object, for example the Pages object (I\ncapitalize object names with a special meaning, usually the name after the\nword /Type):\n\n    \n    \n    2 0 obj << /Type /Pages /Kids [ 3 0 R ] /Count 1 >> endobj\n\nThis is object number 2, a dictionary with three entries. There are several\ntypes of objects in PDF\n\nType| Example  \n---|---  \nBoolean values| true, false  \nInteger and real numbers| 1, -3, 4. \u2212.002  \nNames| /Type, /Pages  \nArrays| [ 1 2 3 ]  \nDictionaries| \u00ab /Type /Pages /Count 1 \u00bb  \nStreams| beginstream ... endstream  \nThe null object| null  \nStrings| (a string)  \n  \nObjects can be direct objects, like the number 123, or indirect objects\nstarting with a string similar to 3 0 obj as above. Each indirect object has a\nnumber.\n\nThere is another syntax feature in PDF: it can have comments. Anything\nfollowing a % sign is treated as a comment. There are only two places in the\nPDF where the % signs have a meaning: the start of file marker and the %%EOF\nmarker at the end of the PDF file.\n\n## The header\n\nThere are two leftovers, let me start with the easy one: the header. It\nconsists of the form\n\n    \n    \n    %PDF major.minor %four bytes > 127\n\nThe major.minor must be something like 1.7 or 2.0, and the four bytes > 127\nare there to prevent the file from being recognized as a text file. If you use\ncharacters that are non-ASCII, but still common text characters, you can still\nview the PDF file in a text editor. This is why I use the middle dot (\u00b7) in my\nexample. It is outside the ASCII range, but will still be displayed in most\ntext editors.\n\n## The XRef section and the trailer\n\nNow for the ugliest part of PDF. Each (indirect) object has a byte position\nwithin the PDF file. In my example above, the number 2 in 2 0 obj is exactly\n75 bytes \u201caway\u201d from the beginning of the file. To find the objects in the\nPDF, there is a lookup table at the end of the PDF file that points to each\nindirect object.\n\nThe XRef table has an entry for each object. In front of each chunk there are\ntwo numbers, the object number of the first entry in the chunk and the number\nof entries in the chunk. The first entry is special and must follow exactly\nthe form shown. Each line must be exactly 20 bytes long, which means that\nafter the n in a line there must be a whitespace character, 0000000019 00000 n\n.\n\nAfter the XRef section, the trailer contains information about the root object\n(the Document object) and the number of objects in the PDF file.\n\nAfter the trailer there must be the keyword startxref, the byte offset of the\nlast XRef table (there can be more than one) and followed by %%EOF.\n\n## Multiple \u201cviews\u201d on the PDF\n\nThere are multiple \u201cviews\u201d of the PDF file. You can look at it from a syntax\npoint of view, where the PDF file is a flat collection of (indirect) objects,\neach referenced from the XRef table.\n\nIt is also possible to have a semantic view of the PDF. The PDF file is built\ninto a tree-like data structure where the root node (the Document object) is\nreferenced by the trailer. The Pages object contains a list of all pages, and\neach page has a back reference to the Pages object.\n\n> I don\u2019t always tell the whole truth, that would only cause confusion. For\n> example, there can be multiple Pages objects that can group Page objects.\n\n## Creating a PDF by hand\n\nIf you ever thought about creating a PDF file in your text editor: forget it.\n\nSeriously, creating and maintaining the XRef table is hard. If you add a few\nbytes at the beginning of the file, you have to update every line in the XRef\ntable. And you have to make sure that there is a space at the end of each line\nin the XRef table so that the entry is exactly 20 bytes long.\n\nI have created a simple utility for this purpose. You can write objects in the\nPDF file and it will update the trailer. fixxref (the name of the software)\nalso updates the /Length entries in stream objects (object 4 in my PDF). The\n/Length entry contains the number of bytes between the stream and endstream\nkeywords.\n\nI use Visual Studio Code to edit PDFs, which has a nice PDF mode. You can\nclick on any object reference or entry in the XRef table and jump to the\nbeginning of the object. It also provides syntax highlighting.\n\nTo automate XRef fixing with fixxref, I installed a \u201cRun on Save\u201d extension\nthat runs fixxref every time the PDF file is saved. My configuration is\n\n    \n    \n    { \"emeraldwalk.runonsave\": { \"commands\": [ { \"match\": \"\\\\.pdf$\", \"cmd\": \"fixxref ${file}\", } ] } }\n\nWhich is saved in .vscode/settings.json of the working directory (so it does\nnot affect any other PDF files).\n\nStay tuned for next week\u2019s episode of \u201cInside PDF\u201d....\n\n  * Home\n  * Imprint\n  * speedata webpage\n\n", "frontpage": false}
