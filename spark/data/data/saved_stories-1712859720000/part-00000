{"aid": "40001334", "title": "Show HN: CNDI \u2013 DevOps for Data Teams", "url": "https://github.com/polyseam/cndi", "domain": "github.com/polyseam", "votes": 7, "user": "harshilPat", "posted_at": "2024-04-11 12:19:14", "comments": 0, "source_title": "GitHub - polyseam/cndi: Self-Host Cloud-Native Apps with the Ease of PaaS", "source_text": "GitHub - polyseam/cndi: Self-Host Cloud-Native Apps with the Ease of PaaS\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\npolyseam / cndi Public\n\n  * Notifications\n  * Fork 6\n  * Star 104\n\nSelf-Host Cloud-Native Apps with the Ease of PaaS\n\ncndi.dev\n\n### License\n\nApache-2.0 license\n\n104 stars 6 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# polyseam/cndi\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n367 Branches\n\n65 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\njohnstonmatteks: stringify launch template version5f81d63 \u00b7\n\n## History\n\n2,566 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| rename steps  \n  \n### .vscode\n\n|\n\n### .vscode\n\n| jsonschema updates  \n  \n### bundle\n\n|\n\n### bundle\n\n| remove bundle  \n  \n### dist\n\n|\n\n### dist\n\n| add -cndi to kubeseal and terraform binary names  \n  \n### docs\n\n|\n\n### docs\n\n| argo-ify dependencies; improve validate cndiConfig  \n  \n### src\n\n|\n\n### src\n\n| eks: stringify launch template version  \n  \n### templates\n\n|\n\n### templates\n\n| add info about programatic neo4j access  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| add kubeseal binaries  \n  \n### CODEOWNERS\n\n|\n\n### CODEOWNERS\n\n| codeowners  \n  \n### CODE_OF_CONDUCT.md\n\n|\n\n### CODE_OF_CONDUCT.md\n\n| deno fmt CODE_OF_CONDUCT.md  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Apache 2.0 LICENSE  \n  \n### README.md\n\n|\n\n### README.md\n\n| fix schema and outputs lnks  \n  \n### _here.ts\n\n|\n\n### _here.ts\n\n| rewrite tests in Deno style  \n  \n### cndi_config.yaml\n\n|\n\n### cndi_config.yaml\n\n| rm scratchpad notes  \n  \n### demo.md\n\n|\n\n### demo.md\n\n| update demo.md  \n  \n### deno.json\n\n|\n\n### deno.json\n\n| deno.json@2.7.0  \n  \n### deno.lock\n\n|\n\n### deno.lock\n\n| add bdd mod  \n  \n### install.ps1\n\n|\n\n### install.ps1\n\n| wrap '--help'  \n  \n### install.sh\n\n|\n\n### install.sh\n\n| chmod terraform_cndi and kubeseal_cndi  \n  \n### main.ts\n\n|\n\n### main.ts\n\n| more ow thread wip  \n  \n## Repository files navigation\n\n# cndi\n\nStart with a Template for a popular service and CNDI will help you deploy it\non your own infrastructure, just as easily as you can sign up for a Platform\nas a Service.\n\nOnce your cluster is set up, manage the infrastructure and applications with\nease using GitOps and Infrastructure as Code.\n\n## demo video \ud83c\udfa5\n\nIf you'd like to see a walkthrough for setting up an Airflow cluster using\nCNDI, checkout this demo:\n\n## installation \ud83e\udd41\n\nTo install CNDI we just need to download the binary and add it to our PATH.\nThis can be done using the script below:\n\n    \n    \n    curl -fsSL https://raw.githubusercontent.com/polyseam/cndi/main/install.sh | sh\n\nIf you'd prefer to use Windows we have a one-liner for that too described in\nthis short guide.\n\nIn either case once the script has finished running, the cndi binary and\ndependencies are installed to ~/.cndi/bin.\n\n## usage\n\nCNDI is a tool with which to deploy GitOps enabled Kubernetes application\nclusters on any platform as quickly and easily as possible. The best way to\nunderstand this process is to look at it as a lifecycle.\n\n### lifecycle: init \ud83c\udf31\n\nThe first step in the lifecycle is to initialize the CNDI project. Because\nCNDI's mechanics are based on the GitOps workflow, we should initialize a Git\nrepository before we do anything else.\n\nThe best way to create a repo this as a GitHub user is to install the gh cli,\nand we'll use this tool a bit later too for managing secrets.\n\n    \n    \n    gh repo create cndi-example --private --clone && cd cndi-example\n\nNow that we have a Git repository, we can initialize a new CNDI project.\n\nThe best way to get started if you are new to CNDI is to use the interactive\ncli, so let's look at that first.\n\n    \n    \n    # once cndi is in your \"PATH\" you can run it from anywhere cndi init --interactive\n\nThis will start an interactive cli that will ask you a series of questions,\nthe first prompt is to select a Template. Templates are a CNDI concept, and\nthey can be thought of as a \"blueprint\" for a cloud-native stack. Once you\nselect a Template, CNDI will ask you some general questions about your project\nand some template-specific questions. Then it will write out a few files\ninside your project repo.\n\nIt's also possible to specify a Template URL to initialize with. A Template\nURL resolves to a CNDI Template file, this means that you are not limited to\nonly Templates the CNDI team has put together, you can point to any arbitrary\ntemplate file that follows the Template Schema.\n\nThese Template URLs can be file:// URLs which have an absolute path to the\nfile locally, or typical remote or https:// URLs over the net.\n\n    \n    \n    # file:// URLs must be absolute paths cndi init -i --template file:///absolute/path/to/template.yaml # or cndi init -i --template https://example.com/path/to/template.yaml\n\nCNDI has generated a few files and folders for us based on our Template file.\nIf you want to learn about what CNDI is really creating, the best file to look\nat is the cndi_config.yaml file in the root of your repository.\n\nWe break down all of the generated files later in this document in the outputs\nsection.\n\nThe next step for our one-time project setup is to make sure that we have all\nthe required environment variables for our project in our .env file that CNDI\ngenerated.\n\nSome of these values are required for every deployment. For example, you\nalways need to have GIT_USERNAME, GIT_TOKEN and GIT_REPO. Some are only\nrequired for a specific provider, like AWS_ACCESS_KEY_ID and\nAWS_SECRET_ACCESS_KEY, which are only needed for aws deployments. Lastly, some\nare only required for certain Templates, for example all airflow templates\nrequire GIT_SYNC_PASSWORD for accessing repos that hold Airflow DAGs.\n\nIf you didn't use interactive mode you may have some placeholders in that file\nto overwrite, and they should be easy to spot. CNDI should also tell you if it\nis missing expected values.\n\nWhen all of the values have been set in your .env file, we want to use the gh\ncli again, this time to push our secret environment variables to GitHub.\n\n    \n    \n    # cndi requires version 2.23.0 or later of the GitHub CLI gh secret set -f .env\n\nNow we are ready for the next phase of the lifecycle!\n\n### lifecycle: push \ud83d\ude80\n\nNow that we have initialized our project, CNDI has given us files that\ndescribe our infrastructure resources and files that describe what to run on\nthat infrastructure.\n\nCNDI has also created a GitHub Action for us which is responsible for calling\ncndi run. The run command provided in the cndi binary is responsible for\ncalling terraform apply to deploy our infrastructure. To trigger the process\nwe just need to push our changes to repository:\n\n    \n    \n    git add . git commit -m \"initial commit\" git push\n\nAfter cndi run has exited successfully you should be able to see new resources\nspinning up in the deployment target you selected. When the nodes come online\nin that destination, they will join together to form a Kubernetes cluster.\n\nAs the nodes join the cluster automatically, they are going to begin sharing\nworkloads. Some workloads come bundled, we will call these CNDI platform\nservices. There are a couple such services, one is sealed-secrets, and another\nis ArgoCD. Sealed Secrets enables storing Kubernetes Secrets within git\nsecurely, and ArgoCD is a GitOps tool which monitors a repo for Kubernetes\nmanifests, and applies them.\n\nWhen ArgoCD comes online, it will begin reading files from the\ncndi/cluster_manifests directory in the GitHub repo we have been pushing to.\nUltimately cndi run is only used within GitHub for infrastructure, and ArgoCD\nis solely responsible for what to run on the cluster.\n\nYour cluster will be online in no time!\n\n### lifecycle: overwrite \u267b\ufe0f\n\nThe next phase of the lifecycle is about making changes to your cluster. These\nchanges can be cluster_manifests oriented, if you are making changes to the\nsoftware running on your infrastructure, or they can be infrastructure\noriented if you are horizontally or vertically scaling your cluster.\n\nIn either case, the approach is the same. Open your cndi_config.yaml file in\nyour editor and make changes to your applications, cluster_manifests, or\ninfrastructure then run:\n\n    \n    \n    # shorthand for cndi overwrite cndi ow\n\nUpon execution of the command you should see that some of the files cndi\ngenerated for us before have been modified or supplemented with new files. So\nfar no changes have been made to our cluster. Just like before we need to push\nthe changes up for them to take effect. This is what GitOps is all about, we\ndon't login to our servers to make changes, we simply modify our config, and\ngit push!\n\nWith these 3 phases you have everything you need to deploy a data\ninfrastructure cluster using CNDI and evolve it over time!\n\n### lifecycle: destroy \ud83d\uddd1\ufe0f\n\nWhen it comes down time to teardown your cluster, there is only one step, just\ncall:\n\n    \n    \n    cndi destroy # in your project repo, and we will take care of the rest!\n\nThis will delete all of the infrastructure resources that CNDI created for\nyou, and from there you can choose either to delete the repo or keep it around\nfor later.\n\n### Walkthroughs \ud83e\udd7e\n\nWe've got a few walkthroughs you can follow if you'd like, one for each\ndeployment target. The walkthroughs demonstrate how to deploy a production\ngrade Airflow cluster using CNDI's airflow Template.\n\n  * ec2/airflow - AWS EC2\n  * eks/airflow - AWS EKS\n  * gce/airflow - GCP Compute Engine\n  * gke/airflow - GCP GKE\n  * avm/airflow - Azure Virtual Machines\n  * aks/airflow - Azure AKS\n  * dev/airflow - Local Development\n\nIf you are interested in using CNDI, these walkthroughs will be entirely\ntransferrable to other applications beyond Airflow.\n\n## configuration \ud83d\udcdd\n\nLet's run through the 3 parts of a cndi_config.yaml file. This one file is the\nkey to understanding CNDI, and it's really pretty simple.\n\n### infrastructure.cndi \ud83c\udfd7\ufe0f\n\nThe infrastructure section is used to define the infrastructure that will\npower our cluster. The infrastructure section is broken out into 2 distinct\ncategories. The first category is cndi, and it refers to infrastructure\nabstractions our team has invented that CNDI exposes for you.\n\nCurrently CNDI exposes only one abstraction, the nodes interface, and it's a\nwrapper that simplifies deploying Kubernetes cluster nodes. The CNDI nodes\ninterface wraps the compute resources from every deployment target we support.\n\nAll nodes entries are nearly identical, the most substantial difference is the\nkind field which is used to specify the deployment target. These node\nresources and their supporting infrastructure are ultimately provisioned by\nTerraform, but we've abstracted a lot of complexity through this interface.\n\nDeclaring a node is simple, we give it a name, we give it some specs, and we\nadd it to the array!\n\n    \n    \n    cndi_version: v2 provider: gcp distribution: microk8s infrastructure: cndi: nodes: - name: gcp-alpha kind: gce role: leader # node responsible for instantiating the cluster machine_type: n2-standard-16 - name: gcp-beta # node runs the control plane by default kind: gce - name: gcp-charlie kind: gce - name: gcp-delta kind: gce role: worker # node does not run the control plane\n\nCurrently we have support for Cloud Providers aws , azure, and gcp using\nMicrok8s, as well as their managed offerings, eks , aks, and gke. Finally we\nsupport running a dev cluster locally using multipass.\n\nJust like every other component in CNDI, nodes can be updated in our\ncndi_config.yaml and we can call cndi ow and push the changes to our git\nremote to modify the cluster accordingly.\n\nDon't forget to push up your changes after running cndi ow so that we can kick\noff automation for you!\n\n### infrastructure.terraform \ud83e\uddf1\n\nThe second category within infrastructure is terraform. This is where you can\ndefine any Terraform resources you want to be provisioned alongside your\ncluster.\n\n    \n    \n    infrastructure: cndi: {} terraform: resource: aws_s3_bucket: my-bucket: acl: public-read bucket: s3-website-test.hashicorp.com cors_rule: - allowed_headers: - \"*\" allowed_methods: - PUT - POST allowed_origins: - https://s3-website-test.hashicorp.com expose_headers: - ETag max_age_seconds: 3000\n\n\ud83d\udca1 You can also use this section to override any of the default Terraform\nobjects that CNDI deploys.\n\nGenerally, you should be able to customize CNDI resources through the cndi\nsection instead.\n\nBut, if you do need to patch a Terraform resource CNDI has created for you,\nyou simply need to match the resource name we have used, and specify the\nfields you want to update.\n\n    \n    \n    infrastructure: cndi: {} terraform: resource: aws_vpc: cndi_aws_vpc: cidr_block: 10.0.0.0/24\n\n### applications \ud83d\udcbd\n\nThe next thing we need to configure is the applications that will actually run\non the cluster. With CNDIv1 we focused on making it a breeze to deploy Apache\nAirflow in Kubernetes.\n\nLets see how we accomplish this here in this new and improved CNDI:\n\n    \n    \n    infrastructure: {} applications: airflow: targetRevision: 1.7.0 # version of Helm chart to use destinationNamespace: airflow # kubernetes namespace in which to install application repoURL: https://airflow.apache.org chart: airflow # where you configure your Helm chart values.yaml values: dags: gitSync: enabled: true repo: https://github.com/polyseam/demo-dag-bag branch: main wait: 70 subPath: dags # These options are required by Airflow in this context createUserJob: useHelmHooks: false migrateDatabaseJob: useHelmHooks: false\n\nThis is built on top of ArgoCD's Application CRDs and Helm Charts. If you have\na Helm Chart, CNDI can deploy it!\n\n### cluster_manifests \ud83d\udcd1\n\nThe third aspect of a cndi_config file is the cluster_manifests object. Any\nobjects here will be used as Kubernetes Manifests and they'll be applied to\nyour cluster through ArgoCD. This gives you full access to all the Kubernetes\nsystems and APIs.\n\n    \n    \n    infrastructure: {} applications: {} cluster_manifests: # inside the \"cluster_manifests\" object you can put all of your custom Kubernetes manifests ingress: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: minimal-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: \"/\" spec: {}\n\nIf you are new to Kubernetes and are unsure what any of that meant, don't\nsweat it. CNDI is designed to help with that knowledge gap with templates, and\nyou'll learn along the way too!\n\nPro tip! \ud83e\udd2b\n\nIf you want to add a new Kubernetes Secret to use inside of your Kubernetes\ncluster via GitOps, we make this possible by encrypting your secrets with\nsealed-secrets so they can live in your repo securely and be picked up by\nArgoCD automatically. To add a secret to your cluster add the value to your\n.env file and then add a cluster_manifest entry like the one below. After that\njust call cndi ow to seal your secret.\n\nThe example below results in sealing the environment variables \"GIT_USERNAME\"\nand \"GIT_TOKEN\", into the destination secret key names \"GIT_SYNC_USERNAME\" and\n\"GIT_SYNC_PASSWORD\" respectively.\n\n    \n    \n    infrastructure: {} applications: {} cluster_manifests: airflow-git-credentials-secret: apiVersion: v1 kind: Secret metadata: name: airflow-git-credentials namespace: airflow stringData: GIT_SYNC_USERNAME: \"$cndi_on_ow.seal_secret_from_env_var(GIT_USERNAME)\" GIT_SYNC_PASSWORD: \"$cndi_on_ow.seal_secret_from_env_var(GIT_TOKEN)\"\n\n## outputs \ud83d\udcc2\n\nWhen cndi init is called there are a few files that it produces:\n\n  1. a cndi_config.yaml - autogenerated in interactive mode only, described in the configuration section above\n\n  2. a .github/workflows folder, with a GitHub Action inside. The workflow is mostly just wrapping the cndi run command in the CNDI binary executable. As such, if you have a different CI system, you can execute the cndi run command on the binary there instead.\n\n  3. a cndi/terraform folder, containing the infrastructure resources cndi has generated for terraform, which cndi will apply automatically every time cndi run is executed.\n\n  4. a cndi/cluster_manifests folder, containing Kubernetes manifests that will be installed on your new cluster when it is up and running. This includes manifests like Ingress from the cluster_manifests section of your cndi_config.jsonc.\n\n  5. a cndi/cluster_manifests/applications folder, which contains a folder for each application defined in the applications section of your cndi_config.yaml, and a generated ArgoCD Application CRD inside that contains our expertly chosen defaults for that App, and the spefic parameters you've specified yourself in the applications section of your cndi_config.yaml.\n\n  6. a .env file which contains all of your environment variables that CNDI relies on, these values must be environment variables that are defined and valid when cndi run is executed.\n\n  7. a .gitginore file to ensure secret values never get published as source files to your repo\n\n  8. a ./README.md file that explains how you can use and modify these files yourself for the lifetime of the cluster\n\n## up and running\n\n### logging into ArgoCD \ud83d\udd10\n\nArgoCD's Web UI is a useful tool for visualizing and debugging your cluster\nresources. Some of our templates setup Ingress for ArgoCD automatically, if\nyou don't have an Ingress you can still access it by following our port-\nforwarding doc. Once you can see the login screen for ArgoCD you can login\nwith the username admin and the password we set for you in your .env file\nunder the key ARGOCD_ADMIN_PASSWORD.\n\n### dns \ud83c\udf10\n\nSetting up DNS for your cluster is a critical step if your cluster will be\nserved online. The solution depends on your \"deployment target\". We have a doc\ncoming soon walking through setting up DNS for AWS and GCP coming soon, but in\nshort you just need to point DNS to the load balancer we provisioned for you.\nIn AWS this means using a CNAME record, or an A record for a cluster running\non GCP or Azure.\n\n## building cndi (contributor guide) \ud83d\udee0\ufe0f\n\nIf you are hoping to contribute to this project and want to learn the ropes,\nyou are in the right place. Let's start with setting up your environment:\n\n### setup \ud83e\udd95\n\nThe first step as you might expect is to clone this repo. Take note of where\nyou clone to, it will matter later when we setup some convenience aliases.\n\n1\\. Clone Repo:\n\n    \n    \n    git clone https://github.com/polyseam/cndi\n\n2\\. Install Deno:\n\nNext let's install deno, though it can be installed with a package manager, I\nwould recommend that you install it without one. Once Deno is installed, make\nsure you add it to your PATH.\n\n3\\. Setup cndi Alias: Let's setup an alias that allows us to use the deno\nsource code as if it were the regular CLI, without colliding with the released\ncndi binary\n\n    \n    \n    # make sure the path below is correct, pointing to the main.ts file in the repo alias cndi-next=\"deno run -A ~/dev/polyseam/cndi/main.ts\"\n\nWe're continuously improving CNDI, but if you have an issue, checkout\nfrequently-asked-questions to get unblocked quickly.\n\nIf you have any other issues or questions please message Matt or Tamika in the\nPolyseam Discord Chat.\n\n## About\n\nSelf-Host Cloud-Native Apps with the Ease of PaaS\n\ncndi.dev\n\n### Topics\n\nkubernetes typescript deno cndi\n\n### Resources\n\nReadme\n\n### License\n\nApache-2.0 license\n\n### Code of conduct\n\nCode of conduct\n\nActivity\n\nCustom properties\n\n### Stars\n\n104 stars\n\n### Watchers\n\n6 watching\n\n### Forks\n\n6 forks\n\nReport repository\n\n## Releases 64\n\nv2.7.0 Latest\n\nApr 5, 2024\n\n\\+ 63 releases\n\n## Packages 0\n\nNo packages published\n\n## Contributors 5\n\n## Languages\n\n  * TypeScript 99.0%\n  * Other 1.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": true}
