{"aid": "40000323", "title": "Fundamentals of I/O in Go", "url": "https://andreiboar.com/posts/fundamentals-of-io-part-two/", "domain": "andreiboar.com", "votes": 4, "user": "zuzuleinen", "posted_at": "2024-04-11 09:45:29", "comments": 0, "source_title": "Fundamentals of I/O in Go: Part Two", "source_text": "Fundamentals of I/O in Go: Part Two \u00b7 Andrei Boar\n\n# Fundamentals of I/O in Go: Part Two\n\nApril 11, 2024\n\nGo \u2022 I/O\n\nIt\u2019s time to continue exploring the fundamentals of I/O in Go.\n\nIf you\u2019re not familiar with io.Reader and io.Writer in Go, read my first\narticle, especially the part where I said that a Reader is something we can\nread from, and a Writer is something we can write to.\n\nLet\u2019s see what else is out there and show you some awesome functions.\n\n# io.LimitReader Link to heading\n\nSometimes, you want to limit the number of bytes you read from a piece of\ndata.\n\nTo limit the size of data you read, you can wrap that data source (Reader)\nwith an io.LimitReader function that returns another Reader from which you can\nread only n bytes:\n\n    \n    \n    package main import ( \"io\" \"log\" \"os\" \"strings\" ) func main() { r := strings.NewReader(\"Hello!\") lr := io.LimitReader(r, 4) // Ouput: Hell if _, err := io.Copy(os.Stdout, lr); err != nil { log.Fatal(err) } }\n\nrun in Playground\n\nThe above code outputs Hell. The limited reader lr can be passed into any\nfunction expecting a Reader and will work as expected: only 4 bytes will be\nread from it.\n\n# io.MultiReader Link to heading\n\nSometimes, you can have multiple data sources, and you want to treat those\nsources as one. If you have multiple Readers, you can merge them into one\nReader with io.MultiReader:\n\n    \n    \n    package main import ( \"io\" \"log\" \"os\" \"strings\" ) func main() { r1 := strings.NewReader(\"first reader\\n\") r2 := strings.NewReader(\"second reader\\n\") r3 := strings.NewReader(\"third reader\\n\") // merge all 3 readers into one r := io.MultiReader(r1, r2, r3) if _, err := io.Copy(os.Stdout, r); err != nil { log.Fatal(err) } }\n\nrun in Playground\n\nIn the above example, we merge all three readers into r, and when we read to\nos.Stdout from r, it\u2019s as if we copy sequentially from each reader.\n\nI recently used io.MultiReader, when I needed to write the bytes coming from\ndifferent requests into one file in a parallel downloader implementation:\n\n    \n    \n    package main results := make([]io.Reader, n) // ... if err := writeToFile(destinationFileName, io.MultiReader(results...)); err != nil { return fmt.Errorf(\"could not write to file: %w\", err) }\n\n# io.MultiWriter Link to heading\n\nSimilar to io.MultiReader, we have an io.MultiWriter function, which creates a\nwriter that reproduces its writes to all the provided writers:\n\n    \n    \n    package main import ( \"bytes\" \"fmt\" \"io\" \"strings\" ) func main() { var ( buf1 bytes.Buffer buf2 bytes.Buffer ) // writing into mw will write to both buf1 and buf2 mw := io.MultiWriter(&buf1, &buf2) // r is the source of data(Reader) r := strings.NewReader(\"some io.Reader stream to be read\") // write to mw from r io.Copy(mw, r) fmt.Println(\"data inside buffer1 :\", buf1.String()) fmt.Println(\"data inside buffer2 :\", buf2.String()) }\n\nrun in Playround\n\nI like to use io.MultiWriter when I\u2019m trying to debug what was written in a\ncertain Writer.\n\nIf a function writes to a Writer and, for some reason, it is too hard to get\nthose contents, I connect a bytes.Buffer to it, and then I check the contents\nof the buffer, which will be the same as the contents of my inaccessible\nWriter:\n\n    \n    \n    package main import ( \"bytes\" \"fmt\" \"io\" ) func main() { buf := new(bytes.Buffer) debug := io.MultiWriter(buf, weirdWriter) // attach buf to weirdWriter complicatedFunctionWithAWriter(weirdWriter) // The contents of the buffer will be the same as in weirdWriter fmt.Println(buf.String()) fmt.Println(buf.Bytes()) }\n\n# io.TeeReader Link to heading\n\nImagine reading and writing data in a place, and you want to write the same\ndata somewhere else.\n\nIn the above image, we read from R to W and write to an extra Logs Writer at\nthe same time.\n\nLet\u2019s see how that looks in code:\n\n    \n    \n    package main import ( \"bytes\" \"fmt\" \"io\" \"os\" \"strings\" ) func main() { logs := new(bytes.Buffer) data := strings.NewReader(\"Hello World!\\n\") teeReader := io.TeeReader(data, logs) // logs will also receives contents from teeReader io.Copy(os.Stdout, teeReader) fmt.Println(\"Content of logs:\", logs.String()) }\n\nrun in Playground\n\nThe behavior of the TeeReader is exactly like the tee command from Linux,\nnamed after the T-splitter used in plumbing:\n\n# io.Pipe Link to heading\n\nSpeaking of Linux and plumbing, you might be familiar with the pipe operator,\nwhich combines two or more commands so that the output of one becomes the\ninput of the other.\n\n    \n    \n    echo hello | tr l y\n\nThis outputs:\n\n    \n    \n    heyyo\n\nI like the pipe\u2019s universality. It doesn\u2019t matter what programs you connect as\nlong as one writes and the other reads. I could have just as easily used cat\nto fetch the contents of a file instead of echo:\n\n    \n    \n    cat file | tr l y\n\nIn Go, we achieve this behavior with io.Pipe that can be used to connect code\nexpecting an io.Reader with code expecting an io.Writer.\n\nLet\u2019s try to replicate the same echo hello | tr l y example to see how that works:\n    \n    \n    package main import ( \"fmt\" \"io\" \"strings\" ) func main() { pipeReader, pipeWriter := io.Pipe() echo(pipeWriter, \"hello\") tr(pipeReader, \"e\", \"i\") } func echo(w io.Writer, s string) { fmt.Fprint(w, s) } func tr(r io.Reader, old string, new string) { data, _ := io.ReadAll(r) res := strings.Replace(string(data), old, new, -1) fmt.Println(res) }\n\nrun in Playground\n\nRunning this program, we get an error:\n\n    \n    \n    fatal error: all goroutines are asleep - deadlock!\n\nTo understand why, we need to read the documentation of the io.Pipe function:\n\n    \n    \n    // Pipe creates a synchronous in-memory pipe. // That is, each Write to the [PipeWriter] blocks until it has satisfied // one or more Reads from the [PipeReader] that fully consume // the written data.\n\nOur code is not synchronous but sequential: we call echo and then tr. We get a\ndeadlock when we try to write because no reading is happening.\n\nLet\u2019s fix that:\n\n    \n    \n    package main import ( \"fmt\" \"io\" \"strings\" ) func main() { pipeReader, pipeWriter := io.Pipe() // Run echo concurrently with tr in a separate goroutine go echo(pipeWriter, \"hello\") tr(pipeReader, \"e\", \"i\") } func echo(w io.Writer, s string) { fmt.Fprint(w, s) } func tr(r io.Reader, old string, new string) { data, _ := io.ReadAll(r) res := strings.Replace(string(data), old, new, -1) fmt.Println(res) }\n\nrun in Playground\n\nRunning the modified program gives us the same error:\n\n    \n    \n    fatal error: all goroutines are asleep - deadlock!\n\nWhy is that? Let\u2019s check the PipeReader documentation on the Read method:\n\n    \n    \n    package io // Read implements the standard Read interface: // it reads data from the pipe, blocking until a writer // arrives or the write end is closed. // If the write end is closed with an error, that error is // returned as err; otherwise err is EOF. func (r *PipeReader) Read(data []byte) (n int, err error) { return r.pipe.read(data) }\n\nThe second part of this sentence is key: blocking until a writer arrives or\nthe write-end is closed.\n\nThe read is still blocked because the writer is not closed after writing our\ndata. Let\u2019s fix that by calling Close() on the pipeWriter:\n\n    \n    \n    package main import ( \"fmt\" \"io\" \"strings\" ) func main() { pipeReader, pipeWriter := io.Pipe() go func() { echo(pipeWriter, \"hello\") // we close the writer so we unblock the reader pipeWriter.Close() }() tr(pipeReader, \"e\", \"i\") } func echo(w io.Writer, s string) { fmt.Fprint(w, s) } func tr(r io.Reader, old string, new string) { data, _ := io.ReadAll(r) res := strings.Replace(string(data), old, new, -1) fmt.Println(res) }\n\nrun in Playground\n\n## Conclusion Link to heading\n\nThat was all for today! I hope you found this post helpful and that you now\nhave a couple more functions under your belt.\n\nCovered functions:\n\n  * io.LimitReader\n  * io.MultiReader\n  * io.MultiWriter\n  * io.TeeReader\n  * io.Pipe\n\nDo you have any questions? Connect with me on LinkedIn, and I\u2019ll be happy to\nhelp!\n\n\u00abPREV: Fundamentals of I/O in Go\n\n\u00a9 2024 Andrei Boar \u00b7 Hugo & Coder.\n\n", "frontpage": true}
