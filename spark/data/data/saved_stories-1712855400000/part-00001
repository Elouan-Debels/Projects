{"aid": "40000888", "title": "Strategy Pattern in Go", "url": "https://rednafi.com/go/strategy_pattern/", "domain": "rednafi.com", "votes": 1, "user": "lichtenberger", "posted_at": "2024-04-11 11:09:05", "comments": 0, "source_title": "Strategy pattern in Go", "source_text": "Strategy pattern in Go | Redowan's Reflections\n\nHome \u00bb Go\n\n# Strategy pattern in Go\n\nFebruary 17, 2024\n\nThese days, I don\u2019t build hierarchical types through inheritance even when\nwriting languages that support it. Type composition has replaced almost all of\nmy use cases where I would\u2019ve reached for inheritance before.\n\nI\u2019ve written^1 about how to escape the template pattern^2 hellscape and\nreplace that with strategy pattern^3 in Python before. While by default, Go\nsaves you from shooting yourself in the foot by disallowing inheritance, it\nwasn\u2019t obvious to me how I could apply the strategy pattern to make things\nmore composable and testable.\n\nAlso, often the Go community exhibits a knee-jerk reaction to the word\n\u201cpattern,\u201d even when it has nothing to do with OO. However, I feel it\u2019s\nimportant to use a specific term while explaining a concept, and I\u2019d rather\nnot attempt to relabel a concept when an established term already exists for\nit.\n\nJust a quick recap: the strategy pattern is a design approach where you can\nchoose from a set of methods to solve a problem, each method wrapped in its\nown class. This way, you can swap out these methods easily without messing\nwith the rest of your code, making it simple to adjust behaviors on the fly.\n\nLet\u2019s say you\u2019re writing a display service that prints a message in either\nplain text or JSON formats. Imperatively you could do this:\n\n    \n    \n    # main.rb require 'json' def display(message, format) if format == :text puts message elsif format == :json json_output = { message: message }.to_json puts json_output else puts \"Unknown format\" end end # Usage display(\"Hello, World!\", :text) # Prints \"Hello, World!\" display(\"Hello, World!\", :json) # Prints \"{\"message\":\"Hello, World!\"}\"\n\nWhile this is a trivial example, you can see that adding more formats means\nwe\u2019ll need to extend the conditionals in the display function, and this gets\nout of hand pretty quickly in many real-life situations where you might have a\nnon-trivial amount of cases.\n\nHowever, the biggest reason why the imperative solution isn\u2019t ideal is because\nof how difficult it is to test. Imagine each of the conditionals triggers some\nexpensive side effects when the corresponding block runs. How\u2019d you test\ndisplay then in an isolated manner without mocking the whole universe?\n\nStrategy pattern tells us that each conditional can be converted into a class\nwith one method. We call these classes strategies. Then, we initialize these\nstrategy classes at runtime and explicitly pass the instances to the display\nfunction. The function knows how to use the strategy instances and executes a\nspecific strategy to print a message in a particular format based on a certain\ncondition.\n\nHere\u2019s how you could rewrite the previous example. In the first phase, we\u2019ll\nwrap each formatter in a separate class:\n\n    \n    \n    # main.rb require 'json' # Formatter Interface class MessageFormatter def output(message) raise NotImplementedError, \"This method should be overridden\" end end # Concrete Formatter for Text class TextFormatter < MessageFormatter def output(message) message end end # Concrete Formatter for JSON class JsonFormatter < MessageFormatter def output(message) { message: message }.to_json end end\n\nHere, the TextFormatter and JsonFormatter classes implement the\nMessageFormatter interface. This interface requires the downstream classes to\nimplement the output method. The output methods of the respective formatters\nknow how to format and print the messages.\n\nThe display function simply takes a message and a formatter, and calls\nformatter.output(message) without knowing anything about what the formatter\ndoes.\n\n    \n    \n    # main.rb # Display Function with direct unknown format handling def display(message, formatter) unless formatter.is_a?(MessageFormatter) puts \"Unsupported format\" return end output = formatter.output(message) puts output end\n\nFinally, at runtime, you can instantiate the strategy classes and pass them\nexplicitly to the display function as necessary:\n\n    \n    \n    # main.rb require_relative 'formatter' text_formatter = TextFormatter.new json_formatter = JsonFormatter.new display(\"Hello, World!\", text_formatter) # Prints \"Hello, World!\" display(\"Hello, World!\", json_formatter) # Prints \"{\"message\":\"Hello, World!\"}\"\n\nNow whenever you need to test the display function, you can just create a fake\nformatter and pass that as an argument. The display function will happily\naccept any formatter as long as the strategy class satisfies the\nMessageFormatter interface.\n\nThe same thing can be achieved in a more functional^4 manner and we\u2019ll see\nthat in the Go example.\n\nBut Ruby is still primarily an OO language and it has classes. How\u2019d you model\nthe same solution in a language like Go where there\u2019s no concept of a class or\nexplicit interface implementation? This wasn\u2019t clear to me from the get-go\nuntil I started playing with the language a little more and digging through\nsome OSS codebases.\n\nTurns out, in Go, you can do the same thing using interfaces and custom types,\nand with even fewer lines of code. Here\u2019s how:\n\n    \n    \n    // main.go // Formatter interface defines a method for outputting messages type Formatter interface { Output(message string) string } // OutputFunc is a function type that matches the signature of the Output // method in the Formatter interface type OutputFunc func(message string) string // Output method makes OutputFunc satisfy the Formatter interface func (f OutputFunc) Output(message string) string { return f(message) }\n\nAbove, we\u2019re defining a Formatter interface that contains only a single method\nOutput. Then we define an OutputFunc type that implements the Output method on\nthe function to satisfy the Formatter interface. We could opt in for a struct\ntype here instead of defining a function type but since we don\u2019t need to hold\nany state, a function type keeps things concise.\n\nThe display function will look as follows:\n\n    \n    \n    func Display(message string, format Formatter) { fmt.Println(format.Output(message)) }\n\nSimilar to the Ruby example, Display intakes a string message and an object of\nany type that implements the Formatter interface. Next, it calls the Output\nmethod on format without having any knowledge of what that does, achieving\npolymorphism.\n\nAlso, notice that we aren\u2019t handling the \u201cunknown formatter\u201d case explicitly\nbecause now it\u2019ll be a compile-time error if an unknown formatter is passed to\nthe caller.\n\nNext, you\u2019ll define your strategies and pass them to the Display function as\nfollows:\n\n    \n    \n    func main() { message := \"Hello, World!\" // Each strategy needs to be wrapped in OutputFunc so that the // underlying function satisfies the Formatter interface. TextFormatted := OutputFunc(func (message string) string { return message }) JSONFormatted := OutputFunc(func (message string) string { jsonData, _ := json.Marshal(map[string]string{\"message\": message}) return string(jsonData) }) Display(message, TextFormatted) // Prints \"Hello, World!\" Display(message, JSONFormatted) // Prints \"{\"message\":\"Hello, World!\"}\" }\n\nWe\u2019re defining each formatting strategy as a function and casting it to the\nOutputFunc so that it satisfies the Formatter interface. Then we just pass the\nmessage and the strategy instance to the Display function as before. Notice\nhow your data and strategies are also decoupled in this case; one has no\nknowledge of the existence of the other.\n\nAnd voila, you\u2019re done!\n\nUpdate: The original Go example used struct types rather than a function type\nto meet the Formatter interface requirements. In this particular case, the\nfunction type makes things simpler. However, if your strategy needs to do\nmultiple things, then a struct with multiple methods is probably going to be\nbetter.\n\n  1. Escaping the template pattern hellscape in Python \u21a9\ufe0e\n\n  2. Template method pattern in Ruby \u21a9\ufe0e\n\n  3. Strategy pattern in Ruby \u21a9\ufe0e\n\n  4. All of these festivities can be avoided in languages that support first-class functions. You could just define your strategies as functions and pass them to the caller during runtime; same idea, different implementation. \u21a9\ufe0e\n\n## Recent posts\n\n* ETag and HTTP caching\n* Crossing the CORS crossroad\n* Dysfunctional options pattern in Go\n* Einstellung effect\n* Anemic stack traces in Go\n* Retry function in Go\n* Type assertion vs type switches in Go\n* Patching pydantic settings in pytest\n* Omitting dev dependencies in Go binaries\n* Eschewing black box API calls\n\n  * Go\n  * TIL\n\nblogroll \u2022 reads \u2022 uses\n\n\u00a9 2020-2024 Redowan Delowar\n\n", "frontpage": false}
