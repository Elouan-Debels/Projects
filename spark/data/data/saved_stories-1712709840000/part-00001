{"aid": "39982688", "title": "Complexity Is the Enemy (2011)", "url": "https://neugierig.org/software/blog/2011/04/complexity.html", "domain": "neugierig.org", "votes": 15, "user": "udev4096", "posted_at": "2024-04-09 18:42:47", "comments": 6, "source_title": "Tech Notes: Complexity is the enemy", "source_text": "Tech Notes: Complexity is the enemy\n\n# neugierig.org: Tech Notes\n\nYou're reading a single entry. Go back to the front page for more.\n\n## Complexity is the enemy\n\nApril 23, 2011\n\nI'm almost through my seventh year working at Google(!). I have learned many\nthings there, more than I could ever write down. I thought I would at least\nshare with you something that's only come to me with more experience.\n\nComplexity is the death of software. It's hard to quantify the cost of, and it\ntends to creep in slowly, so it's a slow boil of getting worse that's hard to\nsee until it's too late. On the other side, frequently it's easy to see a\nbenefit of increasing complexity: a new layer of indirection allows new\nfeature X, or splitting a process that ran on one machine into two allows you\nto surmount your current scaling hurdle. But now you must keep another layer\nof indirection in your head, or implement an RPC layer and manage two\nmachines.\n\nThe above is hopefully just as obvious to a new programmer as it is to a\nveteran. What I think I've learned through my few years in the industry is a\nbetter understanding of how the balance works out; when complexity is\nwarranted and when it should be rejected. I frequently think back to a\nfriend's comment on the Go compiler written by Ken Thompson: it's fast because\nit just doesn't do much, the code is very straightforward.\n\nIt turns out that, much like it's easier to write a long blog post than it is\nto make the same point succinctly, it's difficult to write software that is\nstraightforward. This is easiest to see in programming langauge design; new\nlanguages by novices tend to have lots of features, while few have the crisp\nclarity of C. In today's programs it's frequently related to how many objects\nare involved; in distributed systems it's about how many moving parts there\nare.\n\nAnother word for this problem is cleverness: to quote another one of the C\nhackers, \"Debugging is twice as hard as writing the code in the first place.\nTherefore, if you write the code as cleverly as possible, you are, by\ndefinition, not smart enough to debug it.\"\n\nWhat helps? I wonder if it maybe just comes down to experience \u2014 getting\nbitten by one too many projects where someone thought metaprogramming was\ncool. But I've found having specific design goals to evaluate new code by can\nhelp. It's easier to reject new code if you can say \"this does not help solve\nthe initial goals of the project\". Within Google the template document for\ndescribing the design of a new project has a section right at the top to list\nnon-goals: reasonable extensions of the project that you intend to reject.\n\nIronically, I've found that using weaker tools can help with complexity. It's\nhard to write a complicated C program because it can't do very much. C\nprograms tend to use lots of arrays because that's all you get, but it turns\nout that arrays are great \u2014 compact memory representation, O(1) access, good\ndata locality. I'd never advocate intentionally using a weak tool, though.\nInstead, my lesson has been: write Python code like it was C.\n\n", "frontpage": true}
