{"aid": "39985377", "title": "Reverse-Engineering a Real Money Gaming Solitaire iOS App", "url": "https://www.mikem.codes/exploring-solitaire-cash/", "domain": "mikem.codes", "votes": 2, "user": "nestedd", "posted_at": "2024-04-09 23:24:39", "comments": 0, "source_title": "Exploring Solitaire Cash", "source_text": "Exploring Solitaire Cash\n\nNested Tech Write-Ups\n\nSign in Subscribe\n\n# Exploring Solitaire Cash\n\n#### Nested\n\nApr 9, 2024 \u2014 8 min read\n\nSolitaire Cash is a free app on the App Store provided by Papaya Gaming Inc.\nwhere users can compete against one another to win real cash based on their\nperformance in a round of solitaire. In this article, I will examine the app's\nclaims of being \"totally fair and skill-based\" from a technical standpoint.\n\n## What is Solitaire Cash?\n\nLaunched worldwide in 2019, Solitaire Cash is a very popular iOS application\nwith over 300,000 reviews and is ranked #2 under Casino games.\n\nThe premise of the game is simple; you and a random group of players put up\nreal money, or Gems (winning enough Gems allows you to play for real money),\nand are each dealt the same hand. A score is given to each player at the end\nof their game depending on two factors:\n\n  1. How long it took them to complete their game.\n  2. How many of the four decks they filled since not all hands are solvable.\n\nWhoever ends the game with the highest score wins most, or all, of the buy-in\nmoney.\n\n## Digging into the application\n\n### Why look into the app?\n\nComing from the world of sneaker & retail botting, I have a lot of experience\nusing the backend APIs of Android and iOS applications as an alternate method\nto purchase items. Compared to simply viewing network requests in a browser,\nit usually takes a bit more work to uncover what mobile applications are\ndoing.\n\nMobile apps may employ tactics like SSL certificate pinning, encrypting\nrequests, loading shared objects to obscure function calls, and other \"tricks\"\nthat can make it hard to uncover an app's functionality. However, I often find\nthat developers become too comfortable behind their app's labyrinth of\ndefenses, lowering their guard from an antibot perspective, or even allowing\ncritical information to be exposed.\n\nWith all of this in mind, I was very curious about the internals of Solitaire\nCash, specifically relating to how deck information was shared with the\nplayers. Quickly reading some reviews on the App Store revealed many claims of\ncheaters running rampant, so I wanted to see for myself how Papaya Gaming\nattempts to protect the integrity of their game.\n\n### Laying the groundwork\n\nAs I mentioned previously, there can be a steep barrier to entry when it comes\nto dissecting the processes of mobile applications \u2013 iOS in particular. Below,\nI've laid out a list of items and tools I will be using to take a look at the\ngame, some of which may be difficult to come by:\n\n  * Jailbroken iPhone with SSL unpinning capabilities\n  * Charles Proxy\n  * Ghidra\n  * Frida\n\nThere are a lot of good resources out there for both jailbreaking iPhones and\nsetting them up to get around SSL certificate unpinning, so I won't go into\nthat in this article.\n\n### Checking out the application\n\nWith Charles Proxy set up on my jailbroken iPhone, I first opened up the app\nto get an idea of what was going on. Immediately, dozens of requests are fired\noff to different domains, but silver-tiger-api.papayagaming.com particularly\nstands out. With requests to routes like:\n\n  * /getCollectibleGifts\n  * /getUserState\n\nI was very confident that this is how the app is interacting with the Papaya\nservers. Unfortunately, all of the communication appears to be encrypted. To\nget more information, we'll have to continue peeling back layers of the app's\ndefenses.\n\nEncrypted data of type \"application/x-thrift\"\n\n### Going deeper\n\nSeeing as we won't get more information from intercepting the unpinned\nrequests, we're realistically left with one option \u2013 reverse engineering the\napplication's binaries.\n\nAt this point, we know there must be code in the app that handles both the\nencryption and decryption of requests. If we can find out where this takes\nplace in the code, we stand a chance of hooking into these calls and viewing\nthe plaintext communication. To do so, we first need to get our hands on the\nIPA.\n\n### Obtaining the IPA\n\nUnlike Android applications where you can easily extract the app and\nimmediately view the contents within it, Apple handles the distribution and\nsecurity of their apps differently. While APKs and IPAs are both ZIP files\ncontaining the application's contents, applications installed on Apple devices\nare encrypted with Apple's FairPlay DRM software. This would make it very hard\nto continue our search of what the app is doing, but thanks to some fantastic\nopen-source code, frida-ios-dump, this won't be an issue for us.\n\nFollowing the README from the repository, we first must install Frida locally\nand on the device, along with the tool's dependencies. Once this is completed,\nwe can simply call: python .\\dump.py \"Solitaire Cash\" and we are left with our\ndecrypted Solitaire Cash IPA!\n\n### First look at the internals\n\nExtracting the contents of the IPA, we will eventually find these files:\n\nContents of the decrypted Solitaire Cash IPA\n\nNotably, the SolitaireCash file, which is the main binary for the application,\nis fairly small at just 87kb. After tossing it into Detect It Easy to take a\nlook at the strings, I immediately noticed references to Unity scattered\nthroughout. I'm not well-versed in game development, but it'd make sense that\nthis file prepares to load the Unity game, which is likely where the most\ninteresting code exists.\n\nReferences to Unity in SolitiareCash binary\n\n### Understanding Unity applications\n\nThis was entirely new territory for me. I spent a lot of time in the extracted\nIPA reviewing different binaries, running string searches, and trying to get a\nfeel for how everything is set up. Eventually, I came across forums where\nusers discuss hacking Unity games, and finally stumbled upon Il2CppDumper-GUI.\n\nTo explain Unity games a bit and the importance of this repository, I'll pull\nfrom Unity's documentation. \"The IL2CPP backend converts MSIL (Microsoft\nIntermediate Language) code (for example, C# code in scripts) into C++ code,\nthen uses the C++ code to create a native binary file (for example, .exe,\n.apk, or .xap) for your chosen platform.\"\n\nGame hacking forums detailed how the IL2CPP binary included with Unity games\nis the key to modifying the behavior of a game, or in our case, better\nunderstanding how it operates.\n\nBy using IL2CPPDumper, we can get important information like all string\nliterals, function declarations, and the offsets needed to eventually hook\nthese functions. Best of all, IL2CPPDumper should work with mobile\napplications the same as it would with desktop games.\n\n### Using IL2CPPDumper-GUI\n\nNow that we have an idea of how we can get more information into the app,\nlet's run IL2CPPDumper-GUI.\n\nOur executable file will be the IL2CPP executable for the game which in our\ncase is UnityFramework. The global-metadata.dat can be found in\nData/Managed/Metadata.\n\nIf everything works, the output will look like this after clicking \"Start\ndumping\"\n\nSuccessful IL2CPPDumper output\n\n### Reviewing the dumped contents\n\nTo get a better sense of the game and ensure we're on the right track, we can\nreview stringliteral.json for some interesting results. Searching tiger shows\nus the domain where we previously saw the encrypted communication take place.\n\nWe are on the right track!\n\nAt this point, I had to spend a lot of time reviewing the disassembled code in\nGhidra to figure out where to go next. During my search, I found a lot of\nintriguing references, such as those in the below image, which I unfortunately\ndidn't have time to check out further. I'm assuming this may be used by\ndevelopers to troubleshoot the game.\n\nHowever, I was able to narrow down where we might be able to hook into the\nencrypted communication.\n\n### Using Ghidra to investigate requests\n\nSearching through the UnityFramework binary in Ghidra, I wanted to find\nreferences to their HTTP client since this had to be instrumental in building\nrequests, along with decrypting them. I soon came across this code:\n\nGhidra pseudocode from UnityFramework\n\nThe compression code seemed very interesting. It appeared that, before\nencrypting the contents of a request and sending it off to the silver-tiger\nAPI, the data was first compressed. I had a strong hunch that this is where we\ncould finally begin to hook into the app and uncover some of the\ncommunication.\n\n### Hooking into Solitaire Cash with Frida\n\nFinally, we're at a point where we can review the plaintext data being sent to\nthe Papaya servers. In the past, I've used Frida extensively with Android\napplications and some iOS apps, but hooking into functions within\nUnityFramework would prove to be less straightforward.\n\nUsing ChatGPT and again referencing some hacking forums, I came up with this\nFrida script. Note that the offset used can be pulled from the IL2CPPDumper\noutput in the dump.cs file by searching for CompressionUtils\n\ndump.cs snippet where Compress offsets are found\n\nAfter running the Frida script with frida -U -f \"com.papaya.solitairecash\" -l\n./frida-intercept-solitaire-deck.js and starting a new game, we immediately\nsee this output:\n\nTaking a look at the deck shown, which I've also uploaded as a Gist here, and\ncomparing it side-by-side with my game's screenshot, it's clear that we have\naccess to the entire deck as soon as the game starts.\n\n### Closing thoughts\n\nI've shown in this article that a determined attacker can immediately\nintercept a game's deck, determine the best sequence of moves, and achieve the\nhighest score possible.\n\nThis article isn't meant to call out Papaya Gaming, nor do the heavy lifting\nfor would-be attackers, but to instead showcase that no amount of security\nmeasures or tactics can conceal critical data that should not be shared with\nthe client.\n\nWhen it comes to people wagering their money, sometimes with prizes up to $50,\nthere is a real risk that thousands of dollars, if not more, could be won by\npeople using software to cheat the game.\n\nFor the same reason that poker websites don't share the deck and cards of\nother people until it's absolutely necessary, Solitaire Cash might benefit\nfrom a \"just-in-time\" system of information delivery where cards are sent to\nthe user as they require them.\n\nIndeed, a solution like this would require redesigning how their server and\nclient communicate. The requirement for a stable network might negatively\nimpact user experience. But, this would provide a much more \"totally fair and\nskill-based\" game compared to what is currently in place.\n\nNested Tech Write-Ups\n\nPowered by Ghost\n\n## Nested Tech Write-Ups\n\nArticles on automation and web security.\n\n", "frontpage": false}
