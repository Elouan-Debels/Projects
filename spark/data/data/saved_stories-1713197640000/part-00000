{"aid": "40038580", "title": "Ruby Object Model \u2013 Comparison with Smalltalk-80", "url": "http://www.atalon.cz/rb-om/ruby-object-model/co-smalltalk/", "domain": "atalon.cz", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-15 10:13:12", "comments": 0, "source_title": "Ruby Object Model - Comparison with Smalltalk-80", "source_text": "Ruby Object Model - Comparison with Smalltalk-80\n\n# Ruby Object Model\n\n# Data structure in detail\n\n## Comparison with Smalltalk-80\n\nAs an appendix to [5], a description of the Smalltalk-80 object model is\npresented. At present, only the structure correspondent to Ruby's S1-structure\n(built by superclass and eigenclass links) is provided.\n\n##### Author \u22a4 \u22a3\n\n| Ond\u0159ej Pavlata  \n---  \nJablonec nad Nisou  \nCzech Republic  \n  \n##### Document date \u22a4 \u22a3\n\n| Initial release| February 10, 2012  \n---|---  \nLast major release| February 10, 2012  \nLast update| June 21, 2012  \n  \n##### Warning \u22a4 \u22a3\n\n  1. This document has been created without any prepublication review except those made by the author himself.\n\n##### Tested Smalltalk implementations \u22a4 \u22a3\n\nTwo major implementations of Smalltalk-80 have been taken into consideration:\n\n  * Pharo 1.3,\n  * Squeak 4.2.\n\n#### Table of contents \u22a4 \u22a3\n\n\u25b8Author \u25b8Document date \u25b8Warning \u25b8Tested Smalltalk implementations Table of\ncontents\n\nThe class\u2013metaclass dialectics\n\n\u25b8The terminological ambiguity\n\n\u25b9(A) \"metaclasses\" \u2282 \"classes\" \u25b9(B) \"metaclasses\" \u2229 \"classes\" == \u2205\n\n\u25b8The broken one-to-one correspondence\n\nThe broken inheritance hierarchy\n\n\u25b8Inheritance cycles \u25b8Multiple roots\n\nHandling the issues\n\n\u25b8Ruby nomenclature adoption \u25b8Instantiation restrictions \u25b8Subclassing\nrestrictions \u25b8Ruling out cycles \u25b8Ruling out multiple roots\n\nSmT0: The 2x2 nomenclature SmT1: Inheritance and the actualclass pseudotree\n\n\u25b8The actualclass pseudotree \u25b8The real class map \u25b8The kind-of relation \u25b8The\ninstance-of relation\n\nSmT1_R: Rubyfication of SmT1 (up to first eigenclasses) Correspondence table\nThe metaclass term revisited\n\n\u25b8References \u25b8Document history \u25b8License\n\n### \u22a4 \u22a3\n\n#### The class\u2013metaclass dialectics \u22a4 \u22a3\n\nDespite that Smalltalk was created as a pure object-oriented programming\nlanguage in part for educational use, the concept of its classes and\nmetaclasses has not been clearly established.\n\n##### The terminological ambiguity \u22a4 \u22a3\n\nNo convention has been established as to which objects are \"classes\" and which\nare \"metaclasses\". More specifically, there is no standard terminology (known\nto the author) that clearly states whether\n\n  * (A) The set of \"metaclasses\" is a subset of the set of \"classes\" (i.e. each metaclass is a class).\n  * or\n  * (B) The set of \"metaclasses\" is disjoint from the set of \"classes\" (i.e. a metaclass is not a class and vice versa).\n\nAs a result, terminological paradoxes arise, depending on which of (A) or (B)\nis assumed.\n\n###### (A) \"metaclasses\" \u2282 \"classes\" \u22a4 \u22a3\n\nThe inclusion assumption is in correspondence with the (presumably) standard\ndefinition: A metaclass is a class whose instances are classes [2] [1] (*) or\nMetaclasses are classes of classes. Unfortunately, this is in contradiction\nwith the following statements about the Smalltalk-80 object model:\n\n  * Metaclasses are in one-to-one correspondence with classes [4]. (Alternatively: Metaclass inheritance parallels class inheritance.)\n  * The Metaclass class is not a metaclass. (Alternatively: Metaclasses are exactly the Metaclass instances.)\n  * Each class has a name [3].\n\n(*) Note that this definition is incorrect: It implies that all non-\ninstantiable classes are metaclasses.\n\n###### (B) \"metaclasses\" \u2229 \"classes\" == \u2205 \u22a4 \u22a3\n\nThe mutual exclusion assumption is in correspondence with the terminology we\nhave introduced for the Ruby object model. When applied to the Smalltalk-80\nobject model, the following statement becomes contradictory:\n\n  * (\u2217) The class of a class is a class.\n\nIn this statement, the term \"the-class-of\" corresponds to the map between\nobjects. This map is established by a method called class. (Using the\nSmalltalk syntax, the value for an object x is obtained by x class.) In fact,\nif (B) is assumed, then the semantics of the Smalltalk class method yields the\nopposite of (\u2217):\n\n  * (\u2020) The class of a class is NEVER a class.\n\nThis can be called the class map paradox.\n\n##### The broken one-to-one correspondence \u22a4 \u22a3\n\nDespite that authoritative publications proclaim that \"metaclasses are in one-\nto-one correspondence with classes\" [4] or that \"each class\" is \"an instance\nof its own metaclass\" [3], both Smalltalk's two major implementations, Pharo\nand Squeak, allow counter-examples to these statements. The following are the\ntwo main counter-examples (note that they are not based on the terminological\nambiguity):\n\n  * (1) The code m := Metaclass new creates an object m that is reported as\n\n    * a class \u2013 a direct subclass of Object (according to m superclass == Object),\n    * a metaclass \u2013 a (direct) instance of Metaclass (according to m class == Metaclass), that has no corresponding class \u2013 the reference thisClass is nil.\n  * (2) The code c := Class new creates a class (again, it is reported as a direct subclass of Object) such that c class == Class, i.e. the Class class is reported as the corresponding metaclass for c.\n\n#### The broken inheritance hierarchy \u22a4 \u22a3\n\nAs of Pharo 1.3 and Squeak 4.2, the Smalltalk's class inheritance defined by\nsuperclass links is neither acyclic nor single rooted in the general case.\n\n##### Inheritance cycles \u22a4 \u22a3\n\nThe superclass: method allows creation of cycles. For classes X, Y, the code\n\n  * X superclass: X makes X its own superclass,\n  * X superclass: Y. Y superclass: X lets X and Y be superclasses of each other.\n\n##### Multiple roots \u22a4 \u22a3\n\nBoth Pharo 1.3 and Squeak 4.2 have multi-rooted built-in class hierarchy. In\naddition to the ProtoObject class, there is at least one other class x such\nthat x superclass == nil:\n\n  * the PseudoContext class in case of Pharo,\n  * the ObjectTracer class in case of Squeak.\n\nInterestingly, in both cases the additional root x satisfies the \"twist\"\ncondition (just like ProtoObject), namely that\n\nx class superclass == Class.\n\n#### Handling the issues \u22a4 \u22a3\n\n##### Ruby nomenclature adoption \u22a4 \u22a3\n\nIn order to avoid terminological paradoxes, we adopt the nomenclature of Ruby\nobjects from [5]. However, we shorten the term \"implicit metaclass\" to\n\"metaclass\" where the adjective \"implicit\" is present in the tooltip. This\nallows us to assume (B) \u2013 i.e.\n\n  * a metaclass is NOT a class.\n\nWe solve the class map paradox (\u2020) by a change in terminology: We will use\n\"actualclass\" instead of \"class\". Specifically:\n\n  * We write .aclass (instead of just .class) for the Smalltalk's \"the-class-of\" map.\n  * Similarly, if x.aclass == y then we call y the actualclass of x instead of just the \"class\" of x.\n\nThe use of the actualclass/aclass terminology and notation is deliberate. It\nis because the Smalltalk's \"the-class-of\" map corresponds to Ruby's\nactualclass map rather than to the Ruby's class map.\n\nWe also perform the following preparation for a \"rubyfication\" of Smalltalk's\nobject model:\n\n  * We might write actual objects instead of just objects.\n\n##### Instantiation restrictions \u22a4 \u22a3\n\nWe restrict the Smalltalk object model to structures satisfying the one-to-one\ncorrespondence. This means that we have to impose restrictions to object\ninstantiation. In particular, we make the following assumption:\n\n  * There are no objects y created via y := x new where x is an inheritance descendant of the Behavior class (including the Behavior class itself).\n\n##### Subclassing restrictions \u22a4 \u22a3\n\nWe also disallow subclassing of Class and Metaclass, i.e. we assume that\n\n  * The Class class has no subclasses. (The only superclass link to Class is allowed from ProtoObject class which is a metaclass.)\n  * The Metaclass class has no subclasses.\n\n##### Ruling out cycles \u22a4 \u22a3\n\nWe make the assumption that superclass links are preserved - they cannot be\nchanged by transitions.\n\n##### Ruling out multiple roots \u22a4 \u22a3\n\nWe deny the existence of additional inheritance roots like PseudoContext or\nObjectTracer.\n\n### \u22a4 \u22a3\n\n#### SmT0: The 2x2 nomenclature \u22a4 \u22a3\n\nAn SmT0 structure is a structure (O_a, .terminative?, .primary?) where\n\n  * O_a is a finite set of actual objects.\n  * .terminative? is a boolean attribute of objects indicating whether an object is terminative.\n  * .primary? is a boolean attribute of objects indicating whether an object is primary.\n\nThe structure is subject to the following condition:\n\n(SmT0~1)| All terminative actual objects are primary, i.e. there are no\nterminative eigenclasses in O_a.  \n---|---  \n  \nAs a consequence, we can use the word terminal instead of terminative actual\nobject.\n\nUsing the 2x2 Ruby nomenclature from [5], the structure can be diagrammatized\nas follows. In particular, the set O_a is partitioned into terminals, classes\nand metaclasses.\n\nprimordiality \u2192| Primary objects| First eigenclasses  \n---|---|---  \nterminality \u2193  \nClassive objects alias Classives| Classes| Metaclasses  \nTerminative objects alias Terminatives| Terminals| Eigenclasses of terminals  \n  \nNote:\n\n  * The semantics is restricted to the conventional extent \u2013 higher order eigenclasses are not involved.\n\n#### SmT1: Inheritance and the actualclass pseudotree \u22a4 \u22a3\n\nNote: An alternative title of this section is: The superclass and actualclass\nmaps.\n\nAn SmT1 structure is an SmT0 structure equipped with (.sc, .aclass, r,\nMetaclass) where\n\n  * .sc is a partial function between objects, x.sc (if defined) is called the superclass of x.\n  * .aclass is a total function between actual objects, .aclass is called the actualclass of x.\n  * r is an object, called the inheritance root.\n  * Metaclass is an object. We call it the primary actualclass root. Metaclass.aclass is then the secondary actualclass root.\n\nSimilarly to Ruby's S1, additional notation / terminology applies.\n\n  * x.sc(i) (resp. x.aclass(i)) denotes the ith application of .sc (resp. .aclass) to x.\n  * Just like in Ruby, the reflexive transitive closure of the superclass partial function .sc is denoted H and called the (.sc-) inheritance.\n\nThe structure is subject to the following axioms:\n\n(SmT1~1)| The inheritance H is an algebraic tree on non-terminals, its root is\nr. We denote by x.hancs the list of sc-inheritance ancestors of x, starting\nwith x and ending with r. We also let x.hancestors be x.hancs without\nmetaclasses.  \n---|---  \n(SmT1~2)| For the actualclass map .aclass the following hold:\n\n  * Terminals are mapped to classes.\n  * Classes are bijectively mapped to metaclasses \u2013 i.e. .aclass establishes a one-to-one correspondence between classes and metaclasses.\n  * Metaclasses are constantly mapped to the Metaclass object.\n\nFor the Metaclass object the following holds:\n\n  * The Metaclass object is a class. (In particular, it is not a metaclass.)\n\n  \n(SmT1~3)| .sc and .aclass are commutative in the following sense:\n\n> If x is a class, different from r, then x.aclass.sc is defined and is equal\n> to x.sc.ec.\n\n(Using (SmT1~4): The .sc-inheritance on metaclasses is parallel to the .sc-\ninheritance on classes.)  \n(SmT1~4)| .sc preserves being a class.  \n(SmT1~5)| No correspondent to Ruby's (S1~5)  \n(SmT1~6)| No correspondent to Ruby's (S1~6)  \n(SmT1~7)| The list r.aclass.sc.hancs contains exactly n classes, called helix\nclasses, where\n\n  * n == 5, as of Pharo 1.3 or Squeak 4.2, which corresponds to the chain Class < ClassDescription < Behavior < Object < ProtoObject.\n\nIn particular, n is at least 2.  \n(SmT1~8)|\n\n  * Only metaclasses x satisfy x.aclass == Metaclass.\n  * No object x satisfies x.aclass == Class.\n  * No object x satisfies x.sc == Metaclass.\n  * r.aclass is the only object x satisfying x.sc == Class.\n\n  \n(SmT1~9)| Metaclass and Class are siblings in the sc-inheritance, i.e.\n\n  * Metaclass.sc == Class.sc.\n\n  \n  \n##### The actualclass pseudotree \u22a4 \u22a3\n\nProposition:\n\n  * x.aclass(1) == Metaclass for every metaclass x.\n  * x.aclass(2) == Metaclass for every class x,\n  * x.aclass(3) == Metaclass for every terminal x.\n\nAs a consequence, the structure (O_a, .aclass) is a pseudotree with the\npseudoroot being the 2-element set { Metaclass, Metaclass.aclass }. We call\nthis pseudotree the actualclass pseudotree. Its levels are described by the\nfollowing table.\n\nlevel depth| level members  \n---|---  \n0 (top level)| { Metaclass, Metaclass.aclass }  \n1| Metaclasses except Metaclass.aclass  \n2| Classes except Metaclass  \n3| Terminals  \n  \nThe structure can be then diagrammatized as follows.\n\nNote: The Ruby's actualclass map is obtained by redirecting blue arrows to .\n\n##### The real class map \u22a4 \u22a3\n\nIn a correspondence to the Ruby's .class map, the Smalltalk's real class map,\ndenoted .rclass, maps objects to classes. It is defined as follows:\n\n  * x.rclass == x.aclass if x is terminal or a metaclass,\n  * x.rclass == Class otherwise (i.e. if x is a class).\n\nProposition:\n\n  1. (1) For every object x, x.rclass equals the first member of the ancestor list x.aclass.hancs that is a class, i.e. x.rclass == x.aclass.hancestors[0].\n  2. (2) The structure (O_a, .rclass, Class) is an algebraic tree of depth 2.\n\nNote that both (1) and (2) are valid in Ruby (with .rclass replaced by .class\nand O_a replaced by O). The only difference is that the real class of all\nSmalltalk's metaclasses is the Metaclass class whereas in Ruby, the class of\nall eigenclasses is the Class class.\n\nThe structure (O_a, .rclass, Class) can be diagrammatized as follows.\n\nNote: The Ruby's class map is obtained by redirecting blue arrows to .\n\n##### The kind-of relation \u22a4 \u22a3\n\nThe kind-of relation is defined between objects as the composition .aclass \u25e6\nH. Equivalently,\n\n  * x is kind of y iff x.aclass.hancs contains y.\n\n##### The instance-of relation \u22a4 \u22a3\n\nWe define the instance-of relation as the composition .rclass \u25e6 H.\nEquivalently,\n\n  * x is an instance of y iff the real class of x is a (possibly indirect) subclass of y or is y itself.\n\nIf x.rclass == y then we say that x is a direct-instance-of y.\n\nProposition:\n\n  * The instance-of relation is the range-restriction of the kind-of relation to classes.\n\nNote:\n\nWe deviate here from the common definition in Smalltalk which states that the\ninstance-of relation is exactly the actualclass pseudotree, i.e. x is an\ninstance of y iff x.aclass == y. Our definition yields the following\nadvantages:\n\n  * We can write \"instances of y\" instead of \"subinstances of y\" or \"instances of subclasses of y\".\n  * Only classes can have instances.\n  * We have the correspondence of (a) and (b):\n\n    * (a) Classes are not instances of metaclasses.\n    * (b) Classes are not instantiated by metaclasses.\n  * All classes are direct instances of the Class class. (Unfortunately, this is not as much an advantage as it would be if we were allowed to create classes by Class new.)\n\nSimilarly to Ruby, if A is a class, then by As we mean the set of all\ninstances of A.\n\nThe following proposition shows that there is at least one advantage of the\nSmalltalk object model over the Ruby object model.\n\nProposition:\n\n  1. The set of all classes equals the set of all Classes.\n  2. The set of all metaclasses equals the set of all Metaclasses.\n\n#### SmT1_R: Rubyfication of SmT1 (up to first eigenclasses) \u22a4 \u22a3\n\nThe \"Rubyfication\" of SmT1 is performed by adding fictitious eigenclasses of\nterminals. This can be schematized by\n\n\u2192  \n---  \n  \nAn SmT1_R structure is an SmT1 structure extended with (O_01, .ec) where\n\n  * O_01 is a (finite) superset of the set O_a of actual objects. Elements of O_01 are called SmT1_R-objects or just objects, elements of O_01 \u2216 O_a are non-actual(s). The 2x2 nomenclature is still applied: Non-actual objects together with metaclasses form the set of secondary objects, also called (first) eigenclasses.\n  * .ec is a one-to-one map between primary and secondary objects, x.ec is called the eigenclass of x.\n\nThe structure is subject to the following condition:\n\n(SmT1R~1)| In the restriction to classes, the eigenclass map .ec coincides\nwith the actualclass map .aclass.  \n---|---  \n  \nWe denote .ce the inverse of .ec and extend the following maps to non-actual\nobjects x:\n\n  * the superclass partial map .sc by x.sc == x.ce.aclass,\n  * the actualclass map .aclass by x.aclass == x.sc.ec,\n  * the real class map .rclass by x.rclass == Class (thus eigenclasses of terminals are NOT Metaclasses).\n\nProposition A:\n\n  1. (O_01, .sc, .ec) is a Ruby S1_01 structure (up to the number of helix classes). This in particular induces the Ruby's class map, .class, restricted to O_01.\n  2. The set O_a defines an actuality (corresponding to an indicator function .actual?) that has Smalltalk extent. This in particular induces the Ruby's actualclass map, .aclass, restricted to O_01.\n\nProposition B:\n\n  1. Except for metaclasses, the .rclass map coincides with Ruby's .class map. Specifically,\n\n     * x.rclass == Metaclass and x.class == Class if x is a metaclass,\n     * x.rclass == x.class otherwise.\n  2. Except for metaclasses, the .aclass map coincides with Ruby's .aclass. Specifically,\n\n     * x.aclass == Metaclass and x.aclass == Class.ec if x is a metaclass,\n     * x.aclass == x.aclass otherwise.\n\n#### Correspondence table \u22a4 \u22a3\n\nTerminology| Smalltalk| Ruby  \n---|---|---  \nSmalltalk expression| Our expression| Our expression| Ruby expression  \nthe superclass of a non-terminal x| x superclass| x.sc| x.superclass  \nthe eigenclass of x| \u2014| x.ec| x.singleton_class (limited use)  \nthe actualclass / actualclass of x| x class| x.aclass| x.aclass| \u2014  \nthe (real) class of x|\n\n    \n    \n    x class class == Metaclass ifTrue: Class ifFalse: x class\n\n| x.rclass| x.class| x.class  \nthe \"class side\" of a metaclass x (\u2020)| x thisClass| x.ce| Internally, x.ce is\nreferenced by an \"internal instance variable\" __attached__  \ninheritance ancestors of a non-terminal x| {x}, x.allSuperclasses| x.hancs|\nObtainable by following .superclass links.  \nclasses that are inheritance ancestors of x| Obtainable by removing\nmetaclasses from {x}, x.allSuperclasses| x.hancestors| x.ancestors -\nx.included_modules  \nx's actualclass / actualclass is y?| x isMemberOf: y| x.aclass == y| x.aclass\n== y| \u2014  \nx direct-instance-of y?|\n\n    \n    \n    x class class == Metaclass ifTrue: y == Class ifFalse: x class == y\n\n| x.rclass == y| x.class == y| x.class == y  \nx instance-of y?|\n\n    \n    \n    y class class == Metaclass & x isKindOf: y\n\n| (x,y) \u2208 .rclass \u25e6 H| (x,y) \u2208 .class \u25e6 H| x.class \u2264 y && y.class == Class  \nx kind-of y?| x isKindOf: y| (x,y) \u2208 .aclass \u25e6 H| (x,y) \u2208 .aclass \u25e6 H|\nx.kind_of? y && y.kind_of? Class (*)  \nis x terminal?|\n\n    \n    \n    x class class ~= Metaclass & x class ~= Metaclass\n\n| x.class != Class  \nis x a class?|\n\n    \n    \n    x class class == Metaclass\n\n| x.class == Class && x == x.ancestors[0]  \nis x a metaclass?|\n\n    \n    \n    x class == Metaclass\n\n| Class == x.class && !!(Class > x) (**)  \n  \nNotes:\n\n  * (\u2020) By \"class side\" we mean \"primary side\" here. Note that in general there is an ambiguity with the \"class side\" term:\n\n    * When used in the \"class\" versus \"metaclass\" context, it appears on the primary side.\n    * When used in the \"instance methods\" versus \"class methods\" context, it appears on the secondary side.\n  * (*) y.kind_of? Class disallows modules y. This corresponds to the range-restriction of Ruby's \"full\" kind-of, .aclass \u25e6 \u2264, to classes and eigenclasses (resulting in .aclass \u25e6 H).\n  * (**) The strict comparison in Class > x indicates that we are concerned by implicit metaclasses here.\n\n#### The metaclass term revisited \u22a4 \u22a3\n\nWe have renamed the Smalltalk's \"the-class-of\" map to the \"actualclass\" map.\nThis change in terminology can be justified by the argument that\n\na \"real\" class map should be a many-to-one mapping without any part that has\nenforced one-to-one characteristics.\n\nTherefore, we consider the parallel green arrows in the actualclass pseudotree\nas an indication that the Smalltalk's \"the-class-of\" map is NOT a real class\nmap. Instead, we consider the real class map to be .rclass, which is the\nRuby's class map except for the value on metaclasses.\n\nIn .rclass, classes are mapped constantly to the Class class, so that they are\nnot mapped to metaclasses. This means that\n\nimplicit metaclasses are NOT classes-of classes. Thus, our class-of map is\nterminologically consistent with our assumption that a metaclass is not a\nclass.\n\nThe standard definition of a metaclass [2] [1] applies to explicit\nmetaclasses:\n\nExplicit metaclasses are classes of classes. According to this definition,\nboth Ruby and Smalltalk-80 (as well as Smalltalk-76) contain exactly one\nexplicit metaclass: the Class class. This also means that the Smalltalk's\nMetaclass class is neither explicit nor implicit metaclass.\n\n### \u22a4 \u22a3\n\n##### References \u22a4 \u22a3\n\n[1]| Mohamed Dahchour, Alain Pirotte, Esteban Zim\u00e1nyi, Definition and\nApplication of Metaclasses, Proceedings of the 12th International Conference\non Database and Expert Systems Applications, Springer-Verlag 2001,\nhttp://cs.ulb.ac.be/publications/P-01-01.pdf  \n---|---  \n[2]| Ira R. Forman, Scott H. Danforth, Putting Metaclasses to Work, Addison\nWesley 1998  \n[3]| Adele Goldberg, David Robson, Smalltalk-80: The Language and Its\nImplementation, Addison Wesley 1983,\nhttp://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf  \n[4]| John Hunt, Smalltalk and Object Orientation: An Introduction, Springer\nVerlag 1997, http://stephane.ducasse.free.fr/FreeBooks/STandOO/Smalltalk-and-\nOO.pdf  \n[5]| Ond\u0159ej Pavlata, The Ruby Object Model: Data Structure in Detail, 2012,\nhttp://www.atalon.cz/rb-om/ruby-object-model  \n[6]| Wikipedia: The Free Encyclopedia, http://wikipedia.org[6a] Metaclass  \n  \n##### Document history \u22a4 \u22a3\n\nFebruary| 10| 2012| The initial release.  \n---|---|---|---  \nApril| 5| 2012| Minor additions and corrections.  \nJune| 21| 2012| Enhanced terminology for metaclasses (distinguishing between\nexplicit a implicit).  \n  \n##### License \u22a4 \u22a3\n\nThis document is licensed under a Creative Commons Attribution-NonCommercial-\nShareAlike 3.0 License.\n\n", "frontpage": false}
