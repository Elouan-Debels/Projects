{"aid": "39993641", "title": "StGit Tutorial", "url": "https://stacked-git.github.io/guides/tutorial/", "domain": "stacked-git.github.io", "votes": 2, "user": "kqr", "posted_at": "2024-04-10 17:48:35", "comments": 0, "source_title": "StGit Tutorial \u2013 Stacked Git", "source_text": "StGit Tutorial \u2013 Stacked Git\n\n### Stacked Git\n\n# StGit Tutorial\n\nStGit is a command-line application that provides functionality similar to\nQuilt or the Mercurial Queues extension, i.e. pushing and popping patches\nto/from a stack, but using Git instead of diff and patch. StGit patches are\nstored in a Git repository as Git commits, but can be manipulated by StGit\ncommands in a variety of powerful ways beyond what can easily be done with\nregular Git commits.\n\nThis tutorial assumes familiarity with the basics of Git, including commits,\nbranches, and merge conflicts. For more information on Git, see git(1) or the\nGit home page.\n\n## Getting Started\n\n### Online Help\n\nFor a full list of StGit commands:\n\n    \n    \n    $ stg help\n\nFor quick help on an individual stg subcommand:\n\n    \n    \n    $ stg help <cmd>\n\nFor more extensive help on a subcommand:\n\n    \n    \n    $ man stg-<cmd>\n\nThe documentation is also available as online man pages.\n\n### Setup a Repository\n\nStGit operates in the context of a regular Git repository, providing\nadditional capabilities above and beyond those provided by Git.\n\nThis tutorial uses StGit\u2019s own Git repository for its examples, but any\nregular Git repository may be used to work through this tutorial.\n\nUse git init to create or git clone to clone a Git repository.\n\nTo clone the StGit repository:\n\n    \n    \n    $ git clone https://github.com/stacked-git/stgit.git $ cd stgit\n\nBefore creating StGit patches, the StGit stack must be initialized on the\ncurrent Git branch using stg init:\n\n    \n    \n    $ stg init\n\nThis initializes the StGit stack metadata for the current branch. To have\nStGit patches on another branch, stg init must be run again on that branch.\n\n## Patches\n\n### Create a Patch\n\nWith the StGit stack initialized, patches may be created:\n\n    \n    \n    $ stg new my-first-patch\n\nThis will create a patch called my-first-patch, and open an editor to edit the\npatch\u2019s commit message. This patch is empty, which can be seen by running stg\nshow:\n\n    \n    \n    $ stg show\n\n> NOTE stg new may be called without a patch name, in which case the patch\n> name will be generated by StGit based on the first line of the commit\n> message.\n\nBut empty patches are not particularly interesting. So the next step is to\nmake a modification to a file in the working tree using a regular text editor.\n\n    \n    \n    $ $EDITOR README.md $ stg status M README.md\n\nTo update a patch with changes from the working tree, stg refresh is used:\n\n    \n    \n    $ stg refresh\n\nAnd voil\u00e0 \u2013 the patch is no longer empty:\n\n    \n    \n    $ stg show commit d443f7e2d1099d07b37de02ec483691521e3c330 (HEAD -> master, refs/patches/master/my-first-patch) Author: Audrey U. Thor <author@example.com> Date: Tue Sep 20 13:56:33 2022 -0400 Tis but a patch diff --git a/README.md b/README.md index c8a0894ac..0ef993493 100644 --- a/README.md +++ b/README.md @@ -81,3 +81,5 @@ to StGit. StGit is maintained by Catalin Marinas and Peter Grayson. For a complete list of StGit's authors, see [AUTHORS.md](AUTHORS.md). + +This is my first patch!\n\nSince the patch is also a regular Git commit, it can be seen by regular Git\ntools such as gitk.\n\n### Another Topic, Another Patch\n\nWhen making a change for a new topic, create a new patch. This time the\nworking tree is modified before creating the new patch. It is a feature of\nStGit that a patch can be created independent of the working tree state.\n\n    \n    \n    $ echo '- Audrey U. Thor' >> AUTHORS.md $ stg new credit --message 'Give me some credit' $ stg refresh\n\n> NOTE Use the --message (-m) option to stg new to give the patch a message\n> without invoking an editor.\n\n> NOTE Use the --refresh (-r) option to stg new to both create a new patch and\n> refresh it in one step.\n\nThe stack now contains two patches:\n\n    \n    \n    $ stg series --description + my-first-patch # Tis but a patch > credit # Give me some credit\n\nstg series lists the patches from bottom to top; + means that a patch is\n\u2018applied\u2019, and > that it is the current, or topmost, patch.\n\nFurther changes to the topmost patch can be made by just editing files in the\nworking tree and running stg refresh to capture those changes in the topmost\npatch.\n\nBut how to change my-first-patch? The simplest way is to pop the credit patch.\nDoing so will make my-first-patch the topmost applied patch again:\n\n    \n    \n    $ stg pop credit - credit > my-first-patch $ stg series --description > my-first-patch # Tis but a patch - credit # Give me some credit\n\nstg series now indicates that my-first-patch is topmost again. And running stg\nrefresh will update my-first-patch with any changes made to the working tree.\n\nThe minus sign (-) in front of credit in the stg series output indicates that\nthe credit patch is \u2018unapplied\u2019, which means that the changes embodied in the\ncredit patch are not currently applied to the work tree. Unapplied patches are\nnot seen in the regular Git history as seen by git log or gitk.\n\nAn unapplied patch is reapplied and made the topmost patch using stg push:\n\n    \n    \n    $ stg push credit > credit\n\n> NOTE stg push and stg pop may be called without specifying a patch name.\n> Doing so causes the next unapplied patch to be pushed, or the topmost patch\n> to be popped, respectively.\n\n### Advanced Patch Refresh\n\nBy default stg refresh captures changes from the work tree into the topmost\napplied patch, however when working with multiple patches it is often the case\nthat a change in the work tree should be captured by an already applied patch.\nThe --patch (-p) option may be used with stg refresh to do just that.\n\n    \n    \n    $ stg series + my-first-patch > credit\n    \n    \n    $ $EDITOR README.md $ stg refresh --patch my-first-patch > refresh-temp (new) - credit..refresh-temp > refresh-temp - refresh-temp # refresh-temp & my-first-patch > credit\n    \n    \n    $ stg series + my-first-patch > credit\n\nAfter the above refresh operation, the topmost patch remains credit, but the\nchanges from the work tree are now part of my-first-patch and the work tree is\nclean as evidenced by running stg status.\n\n> NOTE Another way to update a non-topmost patch is to create a new patch,\n> refresh the new patch with work tree changes, and then combine the new patch\n> with the other already applied patch using stg squash.\n\n### About Commit Messages\n\nAn important part of StGit\u2019s value is to help create useful Git history. And\ncritical to Git commit history are good commit messages.\n\nWhen creating a patch with stg new, an initial commit message is drafted, but\nas a patch evolves with refreshes and reorderings, the commit message\ntypically needs to evolve as well.\n\nStGit makes it easy to modify (and re-modify) a patch\u2019s commit message using\nstg edit:\n\n    \n    \n    $ stg edit\n\nIn addition to using stg edit anytime, a patch\u2019s message may also be modified\nwhen refreshing by using stg refresh --edit.\n\n> NOTE Using stg edit\u2019s --diff option causes the patch\u2019s diff text to be\n> present inline when editing the commit message, which can be helpful aid for\n> writing a thorough commit message.\n\n> NOTE The commit message of any patch in the stack may be modified at any\n> time using stg edit <patchname>. A patch does not need to be applied\n> (pushed) in order to modify its commit message, so editing patches\u2019 commit\n> messages may be done without risk of encountering a merge conflict.\n\n### Renaming Patches\n\nIf a patch changes considerably, it might even deserve a new name. Use stg\nrename to rename a patch.\n\n## Conflicts\n\nLike with regular Git, there are various times in the normal use of StGit when\nconflicts may occur. With regular Git commands, a conflict may occur during\nmerge, rebase, or pull. With StGit, conflicts may occur when applying or\nreordering a patch using one of the following commands:\n\n  * stg push\n  * stg goto\n  * stg pick\n  * stg float\n  * stg sink\n  * stg pull\n  * stg rebase\n  * stg refresh --patch\n\nNormally, when re-pushing a patch after popping it and making a change to\nanother patch, StGit is able to re-push the patch without conflict. In the\nfollowing example, two patches are created that each modify a different file.\nFirst a test repository is initialized:\n\n    \n    \n    $ git init test-repo $ cd test-repo $ touch a.txt b.txt $ git add a.txt b.txt $ git commit -m \"Add files\" $ stg init\n\nThen the two patches are created:\n\n    \n    \n    $ stg new first -m 'First patch' $ echo 'a change' >> a.txt $ stg refresh $ stg new second -m 'Second patch' $ echo 'b change' >> b.txt $ stg refresh\n\nThen both patches are popped:\n\n    \n    \n    $ stg pop --all\n\nNext, the patches are reordered by pushing in the opposite order:\n\n    \n    \n    $ stg push second first $ stg series + second > first\n\nStGit had no problems reordering these patches since they did not affect the\nsame lines or even the same files. When using StGit, it is the typical case\nthat no conflicts emerge when pushing or reordering patches; especially when\neach patch is limited to one coherent topic.\n\nBut it is inevitable that sometimes multiple patches necessarily affect the\nsame lines of a file. This is when a conflict may arise.\n\n    \n    \n    $ stg pop - first > second $ echo 'another change' >> a.txt $ stg refresh\n\nNow, both patches add a line to the end of a.txt. What happens when attempting\nto apply both patches at once?\n\n    \n    \n    $ stg push > first (conflict) error: Merge conflicts UU a.txt\n\nStGit indicates that when it pushed first on top of second that since both\nmodify the same lines of the same file (a.txt), there is a conflict. stg\nstatus can be used to see the status of files in the work tree, including\nthose with conflicts:\n\n    \n    \n    $ stg status UU a.txt\n\nAs indicated by stg push, the conflict is in the file a.txt. If the patch\nmodified multiple files, all modified files would be listed in the status\noutput, prefixed with UU if there were unresolvable conflicts, or M if StGit\nwas able to resolve all diff hunks within the file.\n\nWhen conflicts occur, there are two general options for how to respond:\n\n  1. Undo the command that caused the conflict(s).\n  2. Resolve the conflicts.\n\n### Undo\n\nThe stg undo command can rewind the state of the StGit stack and work tree.\n\n    \n    \n    $ stg undo --hard > second\n\n> NOTE The --hard flag for stg undo is required when there are modifications\n> in the work tree or index, as is the case when there are unresolved\n> conflicts in the work tree.\n\nUndoing may be helpful when inter-patch dependencies are uncovered when\nattempting to reorder patches. In such cases, the best approach may be to undo\nthe command that caused conflicts and not reorder the patches.\n\nIn other cases, however, it may be that the conflict must be resolved\nmanually...\n\n### Resolve Conflicts\n\nResolving conflicts incurred while using StGit commands is the same process as\nwhen conflicts are incurred using Git commands directly:\n\n  * Modify the affected files to decide on how the conflict should be resolved, removing conflict markers. This can either be done manually using a regular text editor, or with a tool such as git mergetool\n\n  * Tell Git that the conflict is resolved using git add or its StGit alias, stg add.\n\n> NOTE It may be helpful to read the Git Book\u2019s section on handling merge\n> conflicts\n\nBack to the example, opening a.txt in a text editor reveals the following:\n\n    \n    \n    <<<<<<< current another change ======= a change >>>>>>> patched\n\nThe \u2018conflict markers\u2019 <<<<<<<, =======, and >>>>>>> indicate which lines were\nin the file before the patch was applied (current), and which conflicting\nlines were added by the patch (patched).\n\nTo resolve this conflict a.txt is modified to choose which lines of text to\nretain while also removing the conflict markers. In this case, both lines are\nretained:\n\n    \n    \n    a change another change\n\nAnd the next step is to tell Git that the conflict has been resolved:\n\n    \n    \n    $ stg add a.txt $ stg status M a.txt\n\nAt this point, the status indicates that a.txt is modified, but no longer in\nconflict. The patch may now be refreshed:\n\n    \n    \n    $ stg refresh\n\nThe state of the resolved and refreshed patch:\n\n    \n    \n    $ stg show commit 8e3ae5f6fa6e9a5f831353524da5e0b91727338e Author: Audrey U. Thor <author@example.com> Date: Sun Oct 5 14:43:42 2008 +0200 First patch diff --git a/a.txt b/a.txt index 0a131d8..b4c7416 100644 --- a/a.txt +++ b/a.txt @@ -1 +1,2 @@ +a change another change\n\n## Workflows\n\n### Development branch workflow\n\nOne common use of StGit is to \u201cpolish\u201d a Git branch before publishing it to\nanother public repository. The kinds of polish that StGit can help with\ninclude:\n\n  * Complete and correct commit messages.\n  * Each patch limited to one coherent topic.\n  * Each patch standing on its own: passing tests, etc.\n  * Considerate patch (commit) order\n\nCareful curation of Git commit history, as enabled by StGit, can be of high\nvalue to those reviewing pull requests or trying to understand why or how code\ncame to be the way it is.\n\nThere are limits, however, to what history may be safely modified. As a\ngeneral rule, any commits that have been made public (i.e. by pushing to a\npublic repository) should be off-limits to history modification.\n\nAs a concrete example, consider a situation where several Git commits have\nbeen made in a repository with commit messages such as:\n\n  * \u201cImprove the snarfle cache\u201d\n  * \u201cRemove debug printout\u201d\n  * \u201cNew snarfle cache test\u201d\n  * \u201cOops, spell function name correctly\u201d\n  * \u201cFix documentation error\u201d\n  * \u201cMore snarfle cache\u201d\n\nWhile the above may be the \u201ctrue\u201d history of commits to the repository, it may\nnot be the history that is most helpful to code reviewers or the developer who\nneeds to understand what happened in this are of the code six months after the\nfact. Using StGit, this history can be revised to be higher quality and higher\nvalue.\n\nThe first step is to make StGit patches from the Git commits to be revised:\n\n    \n    \n    $ stg uncommit --number 6 > more-snarfle-cache $ stg series --description + improve-the-snarfle-cache # Improve the snarfle cache + remove-debug-printout # Remove debug printout + new-snarfle-cache-test # New snarfle cache test + oops-spell-function-name-corre # Oops, spell function name correctly + fix-documentation-error # Fix documentation error > more-snarfle-cache # More snarfle cache\n\nThe stg uncommit command adds StGit metadata to the last few Git commits,\nturning them into StGit patches, and thus readying them to be operated on by\nother StGit commands.\n\n> NOTE With the --number flag, stg uncommit uncommits that many commits and\n> generates patch names based on their commit messages. Alternativly, patch\n> names may be specified on the stg uncommit command line.\n\nA number of possible history revisions are possible at this point:\n\n  * Continue developing, and take advantage of, for example stg goto or stg refresh --patch to place modifications in the most appropriate patches.\n\n  * Use stg float, stg sink, stg push, and stg pop to reorder patches.\n\n  * Use stg squash to combine two or more patches into one. squash pushes and pops so that the patches to be squashed are consecutive, then makes one big patch out of the patches to be squashed, and finally pushes other patches back on the stack such that the topmost patch is the same as it was prior to running stg squash.\n\n> NOTE The above commands all cause patches to be pushed, either implicitly or\n> explicitly. Thus these commands may trigger conflicts. If a push results in\n> a conflict, the operation will be halted and the choice will have to be made\n> to either undo or resolve the conflicts.\n\nOnce the history in the StGit stack is satisfactorily revised, the patches can\nbe converted back into regular Git commits:\n\n    \n    \n    $ stg commit --all\n\n> TIP: stg commit can commit specific patches, leaving other patches as-is.\n> This can be used to retire patches as they mature, while keeping newer and\n> more volatile changes as patches.\n\nWhen completely done using StGit with a branch, stg branch can be used to\ncleanup (remove) all StGit metadata from the branch or completely delete the\nbranch:\n\n    \n    \n    $ stg branch --cleanup branchname $ stg branch --delete branchname\n\n> NOTE A branch must have an empty stack (no patches) before it is either\n> cleaned-up or deleted.\n\n### Email-based workflow\n\nIn the \u2018Development branch workflow\u2019 described above, it was assumed that only\nsingle developer was working on her own branch without having to worry about\nparallel development by others. While common, this is not the only use model\nfor Git.\n\nAn alternative use model is for many contributors to send their patches via\nemail to a mailing list. This model is used, for example, by the Linux kernel\ncommunity. In this use model, others read the patches posted to the mailing\nlist, trying them out and providing feedback. Often, the patch author is asked\nto send updated versions of patches. When the project maintainer is satisfied\nwith the patches, she will apply them and publish to a public repository.\n\nStGit is ideally suited for the process of creating patches, emailing them out\nfor review, revising them, mailing them off again, and eventually getting them\naccepted into an upstream repository.\n\n#### Getting patches upstream\n\nTwo StGit commands useful for sharing patches in an email-based workflow are\nstg email and stg export.\n\n  * stg email has two subcommands, format and send that may be used to format and send emails containing patches from a StGit stack.\n  * stg export exports patches from a StGit stack to a filesystem directory, one text file per patch. This may be useful if patches need to be transported by something other than email.\n\n> NOTE Git has its own capability for sending commits via email: git send-\n> email. stg email send is a wrapper of git send-email and as such, respects\n> the its configuration (i.e. sendemail.* and format.*) and exposes its most\n> used command line options. The key difference is that stg email send\n> understands patch names from the StGit stack. Since StGit patches are Git\n> commits, git send-email may be used directly for sending patches via email.\n\n> NOTE For exporting a single patch stg show may be used instead of stg\n> export.\n\nMailing a patch is as easy as this:\n\n    \n    \n    $ stg email send --to recipient@example.com <patches>\n\nOne or more patches may be listed on the command line. Each patch will be sent\nas a separate email, with the first line of the commit message used as the\nemail\u2019s subject.\n\n> NOTE stg email send relies on Git being properly configured to send email,\n> e.g. via SMTP. See the documentation for git send-email and the Git book\u2019s\n> section on contributing to a project over email for more detail on how to\n> configure Git for sending email.\n\nThere are many command-line options to control exactly how patch emails are\nsent, as well as user-modifiable message templates. The man page has all the\ndetails, but two worth mentioning here are:\n\n  * \\--compose opens an editor for writing an introductory message. All patch emails are then sent as replies to this \u201ccover message\u201d. Using a cover message is advised whenever sending more than one patch in order to give reviewers a quick overview of the patches.\n\n  * \\--annotate enables editing each patch before it is sent. Any part of the patch email may be modified, but it is not advised to edit the diff itself since that will only affect the outgoing email and not the underlying patch in the StGit stack. What --annotate is useful for, however, is to add notes for the patch recipients:\n\n    \n    \n    From: Audrey U. Thor <author@example.com> Subject: [PATCH] First line of the commit message The rest of the commit message --- Everything after the line with the three dashes and before the diff is just a comment, and not part of the commit message. If there is anything you want the patch recipients to see, but that should not be recorded in the history if the patch is accepted, write it here. README.md | 1 + 1 files changed, 1 insertions(+), 0 deletions(-) diff --git a/README.md b/README.md index e324179..6398958 100644 --- a/README.md +++ b/README.md @@ -171,6 +171,7 @@ +My first patch!\n\n### Working with Remote Changes\n\nIn a project with multiple developers, while a local StGit stack is being\ndeveloped, others will be doing the same. As a result, a stack will need to\nperiodically incorporate changes from other developers. StGit has a few\ndifferent tools to help with this.\n\nBecause multiple developers may be working on the same files, pulling or\nrebasing remote changes may result in conflicts. It is almost always less work\nto rebase often so that smaller sets of conflicts can be resolved versus\nwaiting and having larger sets of conflicts to resolve. And in most workflows,\npatches must be rebased prior to emailing or creating a pull request.\n\n#### Pulling remote changes\n\nThe most straightforward way to incorporate changes from a remote repository\nis to use stg pull.\n\n    \n    \n    $ stg pull\n\nUnder the hood, stg pull first pops any applied patches, fetches changes from\na remote repository, and then reapplies any previously applied patches. The\nnet effect is that the patch stack is rebased on top of the new remote head.\n\nThe outcome of stg pull is thus similar to the outcome of using git pull with\nits --rebase option.\n\n> NOTE Pulling changes from a remote repository may result in conflicts when\n> patches are reapplied. When this occurs, the stg pull command will halt\n> after pushing the first conflicting patch. After resolving conflicts and\n> refreshing the conflicting patch, it becomes the user\u2019s responsibility to\n> push or goto the desired patch.\n\n> NOTE stg pull pulls changes from the default remote associated with the\n> branch, but a remote may also be explicitly specified on the stg pull\n> command line.\n\n#### Fetch remote changes and rebase\n\nWhereas stg pull fetches remote changes, updates the local branch, and rebases\nthe branch\u2019s stack with a single command, there are times when those steps\nneed to be performed separately. stg rebase can be used as part of a two-step\nprocess to rebase a StGit stack with remote changes.\n\nStep one is to fetch changes from a remote repository using either git fetch\nor git remote update:\n\n    \n    \n    $ git remote update\n\nThis updates remote branch pointers, but does not modify corresponding local\nbranches. Step two of this process is to update a local branch with the remote\nchanges and rebase the StGit stack on top of that. The following example\nrebases to the master branch of a remote repository \u201corigin\u201d:\n\n    \n    \n    $ stg rebase remotes/origin/master\n\nLike stg pull, rebase will first pop any applied patches, update the local\nbranch to point at the same commit as the specified remote branch, and then\nreapply (push) any previously applied patches.\n\nThe end result is that patches are now applied on top of the latest\nremotes/origin/master.\n\n### When patches are accepted upstream\n\nWhen patches are accepted into an upstream repository, a good practice is to\npull or rebase those commits into the local repository. The one difference in\nthe process from above is the use of the --merged (-m) flag with stg pull or\nstg rebase:\n\n    \n    \n    $ stg pull --merged\n\nor:\n\n    \n    \n    $ git remote update $ stg rebase --merged remotes/origin/master\n\nThe --merged flag helps StGit detect that local patches have been merged\nupstream, at some cost in performance.\n\nThe merged patches will remain present in the StGit stack after the pull or\nrebase, but empty (no diff) since the change they added is now present in the\nstack base. stg series --empty will prefix any empty patches with a 0. And stg\nclean will delete all empty patches from the stack:\n\n    \n    \n    $ stg series --empty 0+ patch1 + patch2 0> patch3 $ stg clean $ stg series --empty > patch2\n\n### Importing patches\n\nStGit supports importing patches from several non-Git sources using the stg\nimport command.\n\n  1. A patch (diff) file.\n\n  2. Several patch files containing one patch each along with a series file listing the patch files in their correct order.\n\n  3. An email containing a single patch.\n\n  4. A mailbox file (in standard Unix mbox format) containing multiple emails with one patch in each.\n\n#### Importing a plain patch\n\nImporting a plain patch, such as produced by e.g. GNU diff, git diff, git\nshow, stg diff, or stg show, is simply:\n\n    \n    \n    $ stg import patch-file\n\nThe imported patch will be at the top of the stack.\n\nIf a path is not provided on the command line, stg import will read the patch\nfrom its standard input. Thus a patch may be imported by piping the diff into\nstg import.\n\nBy default, the imported patch\u2019s name will be derived from the file name. And\nif present, the patch\u2019s commit message and author info will be taken from the\nbeginning of the patch. However, command line options may be used to override\nthese defaults.\n\n#### Importing a patch series\n\nSome programs\u2014among them stg export\u2014will create a directory of files with one\npatch per file, along with a \u2018series\u2019 file (often called series) listing the\ncorrect patch order. Passing --series with name of the series file to stg\nimport will import the entire series in its correct order.\n\n#### Importing a patch from an e-mail\n\nImporting a patch from an email is simple too:\n\n    \n    \n    $ stg import --mail my-mail\n\nThe email should be in standard Git mail format (which is what stg email\nformat produces)\u2014that is, with the patch in-line in the mail, not attached.\nThe authorship info is taken from the mail headers, and the commit message is\nread from the \u2018Subject:\u2019 header and the mail body.\n\nIf no filename is provided, stg import --mail will read from stdin. Thus a\nmail reader may be configured to pipe email contents into stg import --mail to\nimport (and apply) a patch email.\n\n#### Importing a mailbox full of patches\n\nFinally, in case importing one patch at a time is too much work, stg import\nalso accepts an entire Unix mbox-format mailbox, either on the command line or\non its standard input; just use the --mbox flag. Each mail should contain one\npatch, and is imported just like with --mail.\n\nMailboxes full of patches are produced by e.g. stg mail with the --mbox flag,\nbut most mail readers can produce them too, meaning that patch emails may be\ncopied or moved to a separate mailbox and then imported.\n\n\u00a9 2024 Stacked Git Authors\n\n", "frontpage": false}
