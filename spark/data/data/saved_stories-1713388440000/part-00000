{"aid": "40065821", "title": "libxev: A cross-platform, high-performance event loop", "url": "https://github.com/mitchellh/libxev", "domain": "github.com/mitchellh", "votes": 4, "user": "tosh", "posted_at": "2024-04-17 15:11:26", "comments": 0, "source_title": "GitHub - mitchellh/libxev: libxev is a cross-platform, high-performance event loop that provides abstractions for non-blocking IO, timers, events, and more and works on Linux (io_uring or epoll), macOS (kqueue), and Wasm + WASI. Available as both a Zig and C API.", "source_text": "GitHub - mitchellh/libxev: libxev is a cross-platform, high-performance event\nloop that provides abstractions for non-blocking IO, timers, events, and more\nand works on Linux (io_uring or epoll), macOS (kqueue), and Wasm + WASI.\nAvailable as both a Zig and C API.\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nmitchellh / libxev Public\n\n  * Notifications\n  * Fork 34\n  * Star 1k\n\nlibxev is a cross-platform, high-performance event loop that provides\nabstractions for non-blocking IO, timers, events, and more and works on Linux\n(io_uring or epoll), macOS (kqueue), and Wasm + WASI. Available as both a Zig\nand C API.\n\n### License\n\nMIT license\n\n1k stars 34 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# mitchellh/libxev\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n5 Branches\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nmitchellhupdate build to avoid panic in debugApr 12, 202463e8dd8 \u00b7 Apr 12,\n2024Apr 12, 2024\n\n## History\n\n413 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| build(deps): bump cachix/install-nix-action from 23 to 24 (#80)| Jan 6, 2024  \n  \n### docs\n\n|\n\n### docs\n\n| Update xev-zig.7.scd| Feb 5, 2023  \n  \n### examples\n\n|\n\n### examples\n\n| feat: Watchers implementation| Sep 3, 2023  \n  \n### include\n\n|\n\n### include\n\n| Fix C struct alignment issue| Mar 24, 2023  \n  \n### nix\n\n|\n\n### nix\n\n| nix: use new -Doptimize flag for build| Feb 4, 2023  \n  \n### src\n\n|\n\n### src\n\n| update zig| Apr 11, 2024  \n  \n### website\n\n|\n\n### website\n\n| website: boilerplate| Jan 18, 2023  \n  \n### .envrc\n\n|\n\n### .envrc\n\n| initial commit| Jan 5, 2023  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| initial commit| Jan 5, 2023  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Create LICENSE| Jan 16, 2023  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update README.md| Aug 6, 2023  \n  \n### build.zig\n\n|\n\n### build.zig\n\n| update build to avoid panic in debug| Apr 12, 2024  \n  \n### build.zig.zon\n\n|\n\n### build.zig.zon\n\n| bump zig version after breaking std changes| Mar 9, 2024  \n  \n### flake.lock\n\n|\n\n### flake.lock\n\n| update zig| Apr 11, 2024  \n  \n### flake.nix\n\n|\n\n### flake.nix\n\n| update zig| Jun 30, 2023  \n  \n### shell.nix\n\n|\n\n### shell.nix\n\n| initial commit| Jan 5, 2023  \n  \n## Repository files navigation\n\n# libxev\n\nlibxev is a cross-platform event loop. libxev provides a unified event loop\nabstraction for non-blocking IO, timers, signals, events, and more that works\non macOS, Windows, Linux, and WebAssembly (browser and WASI). It is written in\nZig but exports a C-compatible API (which further makes it compatible with any\nlanguage out there that can communicate with C APIs).\n\nProject Status: \ud83d\udc32 Unstable, alpha-ish quality. The feature list is quite good\nacross multiple platforms, but there are plenty of missing features. The\nproject hasn't been well tested in real-world environments and there are lots\nof low-hanging fruit for performance optimization. I'm not promising any API\ncompatibility at this point, either. If you want a production ready, high\nquality, generalized event loop implementation check out libuv, libev, etc.\n\nWhy a new event loop library? A few reasons. One, I think Zig lacks a\ngeneralized event loop comparable to libuv in features (\"generalized\" being a\nkey word here). Two, I wanted to build a library like this around the design\npatterns of io_uring, even mimicking its style on top of other OS primitives (\ncredit to this awesome blog post). Three, I wanted an event loop library that\ncould build to WebAssembly (both WASI and freestanding) and that didn't really\nfit well into the goals of API style of existing libraries without bringing in\nsomething super heavy like Emscripten. The motivation for this library\nprimarily though is scratching my own itch!\n\n## Features\n\nCross-platform. Linux (io_uring and epoll), macOS (kqueue), WebAssembly + WASI\n(poll_oneoff, threaded and non-threaded runtimes). (Windows support is planned\nand coming soon)\n\nProactor API. Work is submitted to the libxev event loop and the caller is\nnotified of work completion, as opposed to work readiness.\n\nZero runtime allocations. This helps make runtime performance more predictable\nand makes libxev well suited for embedded environments.\n\nTimers, TCP, UDP, Files, Processes. High-level platform-agnostic APIs for\ninteracting with timers, TCP/UDP sockets, files, processes, and more. For\nplatforms that don't support async IO, the file operations are automatically\nscheduled to a thread pool.\n\nGeneric Thread Pool (Optional). You can create a generic thread pool,\nconfigure its resource utilization, and use this to perform custom background\ntasks. The thread pool is used by some backends to do non-blocking tasks that\ndon't have reliable non-blocking APIs (such as local file operations with\nkqueue). The thread pool can be shared across multiple threads and event loops\nto optimize resource utilization.\n\nLow-level and High-Level API. The high-level API is platform-agnostic but has\nsome opinionated behavior and limited flexibility. The high-level API is\nrecommended but the low-level API is always an available escape hatch. The\nlow-level API is platform-specific and provides a mechanism for libxev users\nto squeeze out maximum performance. The low-level API is just enough\nabstraction above the OS interface to make it easier to use without\nsacrificing noticable performance.\n\nTree Shaking (Zig). This is a feature of Zig, but substantially benefits\nlibraries such as libxev. Zig will only include function calls and features\nthat you actually use. If you don't use a particular kind of high-level\nwatcher (such as UDP sockets), then the functionality related to that\nabstraction is not compiled into your final binary at all. This lets libxev\nsupport optional \"nice-to-have\" functionality that may be considered \"bloat\"\nin some cases, but the end user doesn't have to pay for it.\n\nDependency-free. libxev has no dependencies other than the built-in OS APIs at\nruntime. The C library depends on libc. This makes it very easy to cross-\ncompile.\n\n### Roadmap\n\nThere are plenty of missing features that I still want to add:\n\n  * Pipe high-level API\n  * Signal handlers\n  * Filesystem events\n  * Windows backend\n  * Freestanding WebAssembly support via an external event loop (i.e. the browser)\n\nAnd more...\n\n### Performance\n\nThere is plenty of room for performance improvements, and I want to be fully\nclear that I haven't done a lot of optimization work. Still, performance is\nlooking good. I've tried to port many of libuv benchmarks to use the libxev\nAPI.\n\nI won't post specific benchmark results until I have a better environment to\nrun them in. As a very broad generalization, you shouldn't notice a slowdown\nusing libxev compared to other major event loops. This may differ on a\nfeature-by-feature basis, and if you can show really poor performance in an\nissue I'm interested in resolving it!\n\n## Example\n\nThe example below shows an identical program written in Zig and in C that uses\nlibxev to run a single 5s timer. This is almost silly how simple it is but is\nmeant to just convey the overall feel of the library rather than a practical\nuse case.\n\nZig| C  \n---|---  \n      \n    \n    const xev = @import(\"xev\"); pub fn main() !void { var loop = try xev.Loop.init(.{}); defer loop.deinit(); const w = try xev.Timer.init(); defer w.deinit(); // 5s timer var c: xev.Completion = undefined; w.run(&loop, &c, 5000, void, null, &timerCallback); try loop.run(.until_done); } fn timerCallback( userdata: ?*void, loop: *xev.Loop, c: *xev.Completion, result: xev.Timer.RunError!void, ) xev.CallbackAction { _ = userdata; _ = loop; _ = c; _ = result catch unreachable; return .disarm; }\n\n|\n\n    \n    \n    #include <stddef.h> #include <stdio.h> #include <xev.h> xev_cb_action timerCallback(xev_loop* loop, xev_completion* c, int result, void *userdata) { return XEV_DISARM; } int main(void) { xev_loop loop; if (xev_loop_init(&loop) != 0) { printf(\"xev_loop_init failure\\n\"); return 1; } xev_watcher w; if (xev_timer_init(&w) != 0) { printf(\"xev_timer_init failure\\n\"); return 1; } xev_completion c; xev_timer_run(&w, &loop, &c, 5000, NULL, &timerCallback); xev_loop_run(&loop, XEV_RUN_UNTIL_DONE); xev_timer_deinit(&w); xev_loop_deinit(&loop); return 0; }  \n  \n## Installation (Zig)\n\nThese instructions are for Zig downstream users only. If you are using the C\nAPI to libxev, see the \"Build\" section.\n\nThis package works with the Zig package manager introduced in Zig 0.11. Create\na build.zig.zon file like this:\n\n    \n    \n    .{ .name = \"my-project\", .version = \"0.0.0\", .dependencies = .{ .libxev = .{ .url = \"https://github.com/mitchellh/libxev/archive/<git-ref-here>.tar.gz\", .hash = \"12208070233b17de6be05e32af096a6760682b48598323234824def41789e993432c\", }, }, }\n\nAnd in your build.zig:\n\n    \n    \n    const xev = b.dependency(\"libxev\", .{ .target = target, .optimize = optimize }); exe.addModule(\"xev\", xev.module(\"xev\"));\n\n## Documentation\n\n\ud83d\udea7 Documentation is a work-in-progress. \ud83d\udea7\n\nCurrently, documentation is available in three forms: man pages, examples, and\ncode comments. In the future, I plan on writing detailed guides and API\ndocumentation in website form, but that isn't currently available.\n\n### Man Pages\n\nThe man pages are relatively detailed! xev(7) will give you a good overview of\nthe entire library. xev-zig(7) and xev-c(7) will provide overviews of the Zig\nand C API, respectively. From there, API-specifc man pages such as\nxev_loop_init(3) are available. This is the best documentation currently.\n\nThere are multiple ways to browse the man pages. The most immediately friendly\nis to just browse the raw man page sources in the docs/ directory in your web\nbrowser. The man page source is a markdown-like syntax so it renders okay in\nyour browser via GitHub.\n\nAnother approach is to run zig build -Dman-pages and the man pages will be\navailable in zig-out. This requires scdoc to be installed (this is available\nin most package managers). Once you've built the man pages, you can render\nthem by path:\n\n    \n    \n    $ man zig-out/share/man/man7/xev.7\n\nAnd the final approach is to install libxev via your favorite package manager\n(if and when available), which should hopefully put your man pages into your\nman path, so you can just do man 7 xev.\n\n### Examples\n\nThere are examples available in the examples/ folder. The examples are\navailable in both C and Zig, and you can tell which one is which using the\nfile extension.\n\nTo build an example, use the following:\n\n    \n    \n    $ zig build -Dexample-name=_basic.zig ... $ zig-out/bin/example-basic ...\n\nThe -Dexample-name value should be the filename including the extension.\n\n### Code Comments\n\nThe Zig code is well commented. If you're comfortable reading code comments\nyou can find a lot of insight within them. The source is in the src/\ndirectory.\n\n# Build\n\nBuild requires the installation of the latest Zig nightly. libxev has no other\nbuild dependencies.\n\nOnce installed, zig build install on its own will build the full library and\noutput a FHS-compatible directory in zig-out. You can customize the output\ndirectory with the --prefix flag.\n\n## Tests\n\nlibxev has a large and growing test suite. To run the tests for the current\nplatform:\n\n    \n    \n    $ zig build test ...\n\nThis will run all the tests for all the supported features for the current\nhost platform. For example, on Linux this will run both the full io_uring and\nepoll test suite.\n\nYou can build and run tests for other platforms by cross-compiling the test\nexecutable, copying it to a target machine and executing it. For example, the\nbelow shows how to cross-compile and build the tests for macOS from Linux:\n\n    \n    \n    $ zig build -Dtarget=aarch64-macos -Dinstall-tests ... $ file zig-out/bin/xev-test zig-out/bin/xev-test: Mach-O 64-bit arm64 executable\n\nWASI is a special-case. You can run tests for WASI if you have wasmtime\ninstalled:\n\n    \n    \n    $ zig build test -Dtarget=wasm32-wasi -Dwasmtime ...\n\n## About\n\nlibxev is a cross-platform, high-performance event loop that provides\nabstractions for non-blocking IO, timers, events, and more and works on Linux\n(io_uring or epoll), macOS (kqueue), and Wasm + WASI. Available as both a Zig\nand C API.\n\n### Topics\n\nc async zig webassembly kqueue epoll wasi io-uring\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n1k stars\n\n### Watchers\n\n19 watching\n\n### Forks\n\n34 forks\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Contributors 18\n\n\\+ 4 contributors\n\n## Languages\n\n  * Zig 97.5%\n  * CSS 1.1%\n  * C++ 0.7%\n  * Nix 0.5%\n  * JavaScript 0.1%\n  * TypeScript 0.1%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": true}
