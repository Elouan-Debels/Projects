{"aid": "40068110", "title": "YAMLScript Spring Update", "url": "https://yamlscript.org/posts/apr-16-2024/", "domain": "yamlscript.org", "votes": 1, "user": "oalders", "posted_at": "2024-04-17 18:01:49", "comments": 0, "source_title": "YAMLScript Spring Update", "source_text": "YAMLScript Spring Update | YAMLScript\n\n# YAMLScript Spring Update\n\nby Ingy d\u00f6t Net | 16 Apr 2024 | 6 min read\n\nIt's been a while since I let you know what's been happening with YAMLScript.\nI've been busy working on it every day this year and I have a lot to tell you\nabout!\n\n### YAMLScript Activity in 2024\n\nLet me start by telling you about some of the events that have happened in the\nYAMLScript world recently.\n\n  * Seajure Talk - I gave a talk at the Seajure (Seattle Clojure) Meetup in March.\n  * YAMLScript Article - The New Stack published an article about YAMLScript in March\n  * YAMLScript Podcast - I was interviewed on the \"The REPL\" by Daniel Compton in April.\n\nFinally I'm presenting a talk about YAMLScript at the Open Source Summit North\nAmerica this Thursday, April 18th. Super excited about that!\n\n### YAMLScript Progress Since the Advent Series\n\nI blogged about YAMLScript every day in December 2023. That was something. We\nwere madly trying to implement all the stuff I was talking about. I may have\ntold a few small lies along the way, but I'm happy to say that everything I\ntalked about is now implemented and working.\n\nAnd of course we've added a lot more since then.\n\nLet's talk about some of the highlights.\n\n### More YAMLScript Language Binding Libraries\n\nWe've added 4 new binding libraries for YAMLScript in 2024, bringing the total\nto 8: Clojure (new), Java (new), NodeJS (new), Perl, Python, Raku, Ruby (new)\nand Rust.\n\nThe idea is to eventually have binding libraries for every language where YAML\nis currently used. I expect more to come soon. If you see a missing language\nthat you want (and you are handy with FFI), please consider writing a binding\nlibrary for it and submitting a PR to the YAMLScript Mono Repository.\n\nAll the libraries are a small amount of code and are easy to write.\n\nIf you need help, please stop by the YAMLScript Matrix Chat Room and we'll get\nyou what you need.\n\n### New Dot Chaining Operator\n\nIn Clojure you can write:\n\n    \n    \n    (take 5 (shuffle (filter even? (range 100))))\n\n> Evaluates to something like: [94 36 4 70 74]\n\nOften people like to use Clojure's threading macro (->) to make this more\nreadable:\n\n    \n    \n    (->> (range 100) (filter even?) (shuffle) (take 5))\n\nLet's look at the same thing in YAMLScript in various styles.\n\nBasic block style:\n\n    \n    \n    take 5: shuffle: filter even?: range: 100\n\nYes Expression style:\n\n    \n    \n    take(5 shuffle( filter(even? range(100))))\n\nClojure threading style:\n\n    \n    \n    ->> range(100): filter(even?) shuffle take(5)\n\nAnd now with the new dot chaining operator:\n\n    \n    \n    range(100) .filter(even? _) .shuffle() .take(5 _)\n\nOr all on one line:\n\n    \n    \n    $ ys -e 'say: range(100).filter(even? _).shuffle().take(5 _)'\n\n#### More about the Dot Chaining Operator\n\nAbove we used the dot operator to chain function calls together. But it's even\nmore useful than that.\n\nConsider:\n\n    \n    \n    a.b.3.c().d(e).f(g _).$h\n\nIf a is a mapping, the \"b\" (or :b or 'b) key is looked up. 3 is the 4th\nelement of the list that b resolves to. c is called as a function with the\nresult of 3 as an argument. d is called as a function with the result of c and\ne as arguments. f is called as a function with g and the result of d as\narguments. Finally the key in variable h is looked up in the result of f.\n\nOne common idiom is looking up environment variables. For example: ENV.HOME or\nENV.USER.str/upper-case().\n\n### New Operators and Syntax\n\nIn the last section we saw the new chaining operator: ..\n\nThe interesting thing to note here is that . already had a meaning in Clojure.\nIt's the namespace separator, as in clojure.core/println.\n\nYAMLScript uses :: for that separator instead, so we'd say\nclojure::core/println.\n\nIn a similar switch-up, we added the % and %% operators. (a % b) compiles to\nthe Clojure code (rem a b), and (a %% b) compiles to (mod a b); 2 slightly\ndifferent math functions.\n\nIn Clojure, % was already a shorthand for the %1 argument in anonymous\nfunctions.\n\nIn YAMLScript, you'll need to use %1 for that:\n\n    \n    \n    square =: \\(%1 * %1)\n\nNext we added ** for exponentiation. So 2 ** 3 compiles to (pow 2 3). We also\nadded pow to the ys::std YAMLScript standard library, so you can say pow(2 3)\ninstead of Math/pow(2 3). More about the standard library in a bit.\n\nWe added the Perl style regex operator =~ and regex literal /.../.\n\n    \n    \n    if (peanut-butter =~ /chocolate/): say: \"You've got chocolate in my peanut butter!\"\n\nYou might have noticed that YAMLScript uses \\\\( ... ) for anonymous functions,\nwhere Clojure uses #( ... ). Things starting with # are comments in YAML, so\nthat's problematic.\n\nWe decided the \\ would be a general purpose escape character, but Clojure\nalready uses \\ for escaping character literals.\n\nYAMLScript now uses \\\\\\ for that purpose: str(\\\\\\a \\\\\\b \\\\\\c) would evaluate\nto \"abc\".\n\nIn Clojure you see 'foo used extensively for quoting symbols. In YAML, single\nquotes are used for string literals, and I felt it was important to keep that\ndistinction.\n\nLuckily in Clojure you can use (quote foo) for the same thing. In YAMLScript\nyou can use quote(foo). We added the shorthand q(foo) as well as \\'foo for\nquoting.\n\nFinally, we added foo* splatting.\n\nIt is common in Clojure to use apply to call a function with a list of\narguments: (apply f [1 2 3]) is the same as (f 1 2 3). So if xs is a sequence\nof numbers, you'd say (apply f xs).\n\nIn YAMLScript you can say f(xs*) instead.\n\nBut it gets better. You can you use xs* anywhere in a list of arguments: f(1\nxs* 3 ys* 5).\n\n### Standard Global Variables\n\nClojure has dynamic variables like *out* and *command-line-args*.\n\nYAMLScript now has a few of these, but we decided to use symbols with ALL-CAPS\ninstead of *earmuffs* for these. We also made them shorter in some cases.\n\n  * ARGV - Command line arguments\n  * ARGS - Like ARGV but numbers are converted to numeric values\n  * ENV - Environment variable mapping\n  * CWD - Current working directory\n  * FILE - Path to the current file being processed\n  * INC - The YAMLScript module include path\n  * VERSIONS - Mapping of versions of key components in YAMLScript\n\nWe'll be adding more of these as needed.\n\n### The ys::std YAMLScript Standard Library\n\nWe added many libraries that are automatically available in every YAMLScript\nprogram:\n\n  * ys::std - The standard library (also available std)\n  * clojure::str - available as str\n  * clojure::math - available as math\n  * clojure::tools::cli - available as cli\n  * babashka::fs - avaiable as fs\n  * babashka::http - available as http\n\nand more.\n\nThe ys::std library is the most important one. We can see all the functions\navailable in it by running:\n\n    \n    \n    $ ys -e 'say: q(std).ns-publics().keys().sort().vec()' | zprint '{:width 40}' [$$ *_ +++ +++* +_ =-- _& _* _** _T __ _dot abspath curl cwd die dirname each err exec join new num omap out pow pp pretty print process q rng say sh shell sleep throw toBool toFloat toInt toMap toStr use-pod warn www xxx yyy zzz]\n\nYou might note that the print function is part of clojure::core and YAMLScript\noffers all of that by default. In a few places we decided to replace Clojure\nfunctions with our own versions. But we also added a ys::clj library that has\nall the Clojure functions in it.\n\nSo if you really need clojure::core/print, you can say clj/print.\n\nHere are the functions in ys::clj:\n\n    \n    \n    $ ys -e 'say: q(clj).ns-publics().keys().sort().vec()' | zprint '{:width 40}' [compile load load-file num print use]\n\nNot too many.\n\nWe'll look at use in the next section.\n\n### Including YAMLScript Libraries and Modules\n\nI'll start by saying we made the require function nice to use in YAMLScript.\n\nThe best way to describe it is to show you the actual test case for it:\n\n    \n    \n    - name: Various require transformations in one pair yamlscript: | !yamlscript/v0 require: foo::aaa: => fa foo::bbb: one foo::ccc: one two foo::ddd: => fd one two foo::eee: foo::fff: :all clojure: | (require '[foo.aaa :as fa] '[foo.bbb :refer [one]] '[foo.ccc :refer [one two]] '[foo.ddd :as fd :refer [one two]] 'foo.eee '[foo.fff :refer :all])\n\nThat's how we write tests for the YAMLScript compiler.\n\nI think it explains how require works in YAMLScript pretty well.\n\nThe require function is used for including Clojure libraries. We've also added\nsupport for writing libraries in YAMLScript itself. We'll call them \"modules\"\nto distinguish them from Clojure libraries.\n\nTo use a module in YAMLScript, you use the use function.\n\n    \n    \n    use: 'my-module'\n\nThis will look for a file called my-module.ys in the INC path.\n\nThe INC path is a list of directories that YAMLScript will look in for and it\ndefaults to the current directory. You can override the INC path by setting\nthe YSPATH environment variable.\n\nYAMLScript also added support for Babashka Pods. You can use a pod in\nYAMLScript like this:\n\n    \n    \n    use-pod: \"org.babashka/go-sqlite3\" \"0.1.0\"\n\n### Multi-doc and Anchor / Alias Support\n\nThis is the last topic for today, but it's a big one.\n\nAnchors and aliases are an important feature of YAML. They let you mark a node\nwith a name and then refer to that node by name later.\n\nUntil now, YAMLScript has not supported anchors and aliases. Supporting them\nis critical because YAMLScript should be able to load all existing YAML config\nfiles, and config files often use anchors and aliases.\n\nWell not only did we add support, we took them to the next level!\n\nYAML has the concept of multiple documents in a single file. Unfortunately,\nthis is not very useful in the real world; at least not for config files. One\nproblem is that YAML doesn't allow you to make an anchor in one document and\nuse an alias to it in another document.\n\nYAMLScript makes great use of multi-doc combined with anchors and aliases.\n\nHere's an example YAMLScript file file.ys that is part of my upcoming talk at\nOpen Source Summit North America on Thursday:\n\n    \n    \n    --- !yamlscript/v0/\n    \n    - &data ! yaml/load: slurp('data.yaml')\n    \n    - &map1 key: value\n    \n    - &seq1 - one - two\n    \n    - &dogs ! yaml/load: curl:: https://yamlscript.org/dogs.yaml\n    \n    --- !yamlscript/v0/\n    \n    some: plain data string number: 42\n    \n    sentence:: \"$(*data.name) likes $(*data.langs.rand-nth())!!!\" 2 dogs:: .*dogs.big.shuffle().take(2 _)\n    \n    sequence: !concat*: - *seq1 - [three, four] mapping: !merge*: - this: that - *map1\n\nThe data.yaml file that gets loaded looks like this:\n\n    \n    \n    name: Ingy langs: - Bash - Clojure - CoffeeScript - Perl - YAMLScript\n\nWhen you run ys -Y file.ys you get:\n\n    \n    \n    some: plain data string number: 42 sentence: Ingy likes CoffeeScript!!! 2 dogs: - Saint Bernard - Great Dane sequence: - one - two - three - four mapping: this: that key: value\n\nI'll let you figure out what's happening here. It should be fairly obvious and\nI think it's all pretty cool.\n\n### Moving Forward\n\nThat was a lot of information, I know. I haven't really found the time to blog\nabout these changes on a regular basis.\n\nHopefully I'll be able to do that more in the future.\n\nCheers!\n\n#blog\n\n  * GitHub\n  * RSS\n\nPowered by Eleventy. Theme: Eleventy Duo.\n\n", "frontpage": false}
