{"aid": "39990109", "title": "Flattening B\u00e9zier Curves and Arcs", "url": "https://minus-ze.ro/posts/flattening-bezier-curves-and-arcs/", "domain": "minus-ze.ro", "votes": 6, "user": "vg_head", "posted_at": "2024-04-10 12:48:57", "comments": 0, "source_title": "Flattening B\u00e9zier Curves and Arcs", "source_text": "Flattening B\u00e9zier Curves and Arcs\n\n## Minus Zero\n\n# Flattening B\u00e9zier Curves and Arcs\n\nApril 9, 2024\n\n## Intro\n\nWhen processing curves it\u2019s much easier to convert them to a simpler form and\nwork with that, instead of manipulating the curves directly. In this blog post\nI will present three easy ways to convert quadratics, cubics, and elliptical\narcs to a sequence of line segments. These line segments make it almost\ntrivial to solve problems like computing the arc length or dash offset. They\ncan also simplify the process of rendering the curves if you have a renderer\nthat can already handle paths enclosed by polylines, which is much easier to\nimplement compared to rendering the curves directly. If you want an\nintroduction to B\u00e9zier curves in general check out A Primer on B\u00e9zier Curves\nor The Beauty of B\u00e9zier Curves.\n\nWhile it\u2019s a pretty niche area, I actually needed a memory-efficient algorithm\nfor curve flattening when I was working with a vector renderer on a\nmicrocontroller. The default implementation was using way too much memory: it\ngenerated a ton of lines and stored them all in an array. For every single\ncurve, there would be hundreds of lines stored, which is a lot more than what\nI could afford - customers would run out of memory even for very basic scenes.\nNot to mention the whole process was slow as hell too.\n\nThat was because the library was using the reference implementation of OpenVG!\nIn there, a whopping 256 lines are generated for every quadratic/cubic B\u00e9zier\ncurve, and the same applies to arcs too. OpenVG-RI simply samples the curves\nat uniformly-distributed values for and generates lines from there. Proof:\nhere, here, here and here. Being a reference implementation, it\u2019s of course\nexpected not to be some kind of efficient method. It\u2019s more focused on getting\nthings rendered correctly, rather than efficiently.\n\nThankfully though, it turns out we can flatten curves with far fewer segments\nwithout even sacrificing quality that much. And all of that without needing\nrecursive subdivisions!\n\n## Flattening Quadratic B\u00e9zier Curves\n\nThe case of flattening quadratics has already been taken care of by Raph\nLevien. He presents a method that:\n\n  * Can tell you up-front how many segments it will generate beforehand.\n  * Can generate each segment completely independently, without any state to keep track of.\n  * Is adaptive: it doesn\u2019t just split the curve in half repeatedly.\n  * Lets you tune the quality and performance by decreasing the tolerance parameter for higher quality output, or increasing the tolerance parameter to generate fewer segments.\n  * Is not recursive, unlike the usual approach in which a De Casteljau subdivision is used. The consequence of the recursive nature of the De Casteljau subdivision is that you don\u2019t know in advance how many segments it will generate, and computing those segments is not an independent process. You have to store the values somehow, and only after that can you process them.\n\n0.5\n\nNumber of generated segments: 7\n\nPlay around with it by moving the control points and changing the tolerance\nvalue, which I have named . Keep in mind that for demonstration purposes the\ncurve is actually stroked using the generated lines, which makes it look worse\nthan if you would use them to render filled paths. In reality the quality is\ngreat even when the tolerance is set to 0.25. Here\u2019s one example of the @\nglyph rendered with the tolerance set to 0.25 (all curves of the glyphs are\nquadratics). In my opinion it looks more than good enough.\n\nI had to tweak the original algorithm a bit: if you draw the quadratic in a\nway that all its points are collinear and the end point is between the start\npoint and control point, then a straight line between the start and end point\nwill be drawn. That happens no matter what the tolerance is set to, and it\u2019s\nnot really correct. A quick workaround for this is to check when only one\nsegment is generated, compute the value where the derivative of the quadratic\nis 0, and use that to generate two or three segments. This workaround is still\nnot entirely accurate but gives a good estimate in most cases. If you need\nmore accuracy, you can use the traditional recursive method. It won\u2019t be\nexpensive as there will be at most 4 or 5 segments generated even with a very\nsmall tolerance.\n\nThis flattening method is not only memory-efficient but also has excellent\nperformance. The code is simple too. If you want to see the code for all the\nsolutions in this blog post, you can do that here. Keep in mind that for each\nof the presented methods it\u2019s entirely possible to create an iterator that\nwill compute lines on demand, without any extra memory. I store them in arrays\nfor simplicity\u2019s sake. You could write it all as one big fold if you wanted\nto.\n\n## Flattening Cubic B\u00e9zier Curves\n\nWhen it comes to cubics, there is this old Caffeine Owl post that explains an\nalgorithm which maintains pretty much all good properties of the one for\nquadratics. More precisely, we can convert a cubic to a sequence of\nquadratics, and then use the previous method to convert them to line segments.\nConsider the polynomial form of a cubic B\u00e9zier curve:\n\nWith:\n\nWhere is the parameter along the curve, is the start point of the cubic, and\nare the control points, and is the end point. If the third degree term is\nclose enough to zero, then we can approximate our cubic with a quadratic\npretty well. We can make use of this fact and derive an error metric based on\nthe third degree term, as explained in the post linked above:\n\nUsing this metric can estimate how many cubics we\u2019ll need. Given some\ntolerance parameter, we can obtain:\n\nAs the number of quadratics we need. The math is a bit arcane, but thankfully\nsmart people have already done it for us and we can use it for what we want to\nachieve.\n\nNow we can use this number to split the cubic at every step as the value,\nobtaining smaller cubics. And then each of these smaller cubics can be\napproximated by a quadratic. To get the cubic B\u00e9zier curve between two\nparameters blossoming can be used, as explained here. Blossoming is simply an\nexpansion of the De Casteljau subdivision algorithm, in which we compute all\nrelevant points for us, which are nothing more than a sequence of linear\ninterpolations. We can display two runs of the subdivison simultaneously, for\nboth and , from which we can obtain the middle cubic intuitively:\n\n0.25\n\n0.75\n\nThe essence is computing the interpolation for each line on which the points\non the curve evaluated at and reside, but for the other value. This will give\nus the control points for the cubic in the middle.\n\nThen converting a cubic to a quadratic can be done by getting the intersection\npoint between the lines formed by and , and using that as the control point\nfor our new quadratic. Of course this approximation only really works if the\ncubic is sufficiently close to being a quadratic. Since we are doing this in\nthe subdivision step only, that\u2019s okay.\n\nFlattening quadratics has already been covered. All that remains is putting\nall the pieces together:\n\n0.5\n\n0.5\n\nNumber of generated segments: 12\n\nPlay around with the curve, its tolerance value (), and the tolerance value\nfor the quadratics generated inside of it (). I remind you again that result\nwill look a bit worse here compared to real use cases, because the generated\nsegments are stroked.\n\n## Flattening Arcs\n\nAnother graphics primitive that is frequently used is the elliptical arc. In\nthe SVG arc notation the arc is described as fitting an ellipse with certain\nparameters where two user coordinates lie on it. Given these two points, four\npossible arcs can be drawn. Here are the parameters that describe how the\nelliptical arc is constructed, which ultimately decide which of these four\npossible arcs is rendered:\n\n  * \\- the points which lie on the underlying ellipse.\n  * \\- the horizontal and vertical radius for the ellipse. If then the arc will be circular.\n  * \\- the rotation of the underlying ellipse, described as x-axis rotation.\n  * large-arc-flag - a boolean that tells whether the larger or smaller arcs should be chosen. is for large, is for small. Large means more than .\n  * sweep-flag - a boolean which tells whether the arc should move clockwise or counter-clockwise. is for counter-clockwise, where the angle increases from until the arc reaches . is for clockwise, where the angle decreases from until the arc reaches .\n\nThe SVG spec contains an illustration that shows how large-arc and sweep flags\ndecide which arc is chosen out of the four possible elliptical arcs. This\nnotation is intuitive for the user: you know you have two points and you draw\nan arc between them. Unfortunately it\u2019s not as helpful when rendering those\narcs. In that case, converting this representation to a center parametrization\nis more useful. We compute the center of the ellipse, the start angle where we\nhave the first point, and the angle offset until we reach the second point.\n\nThe SVG spec gives us the way to convert to a center parametrization. We can\nthen approximate arcs of the unit circle and scale the resulted points by the\nellipse\u2019s radiuses. Part of the math is explained here. While B\u00e9zier curves\nare not able to represent elliptical arcs exactly, we make use of the fact\nthat a cubic B\u00e9zier can approximate an elliptical arc very well as long as\nthat arc is not longer than . As flattening cubics has already been covered,\nwhat remains to be done is, again, putting the pieces together:\n\n0.5\n\n0.5\n\n50\n\n100\n\n0\n\nNumber of generated segments: 8\n\nYou can again play around with the arc points, the tolerance for the cubics ()\nand quadratics () that are used to approximate the elliptical arc, the\nradiuses for the underlying ellipse ( and ), the rotation (), and the large-\narc and sweep flags respectively.\n\n## Conclusion\n\nThis post illustrates three simple, efficient ways to flatten B\u00e9zier curves\nand elliptical arcs into line segments. While the code is made to be simple\nand easy to read, in a real scenario you can implement flattening for each of\nthese graphics primitives as one big fold, without storing results in\ntemporary lists. You could even generate the lines in parallel if you wanted\nto, thus making these algorithms suited for GPU implementations, possibly in a\ngeometry shader or compute shader.\n\nIt\u2019s possible to work with curves analytically too, at least quadratics, like\nit\u2019s done in Loop-Blinn, RAVG, MPVG, NV_path_rendering, or Slug. Flattening\nstill remains a relevant option though: it\u2019s easy to implement, it gives you\nthe path length almost for free, and it can be made to be efficient, as we\u2019ve\nseen here.\n\n\u00a9 2024 Alexandru Ic\u0103\n\n", "frontpage": true}
