{"aid": "39997680", "title": "Ratarmount: Access large archives as a filesystem efficiently", "url": "https://github.com/mxmlnkn/ratarmount", "domain": "github.com/mxmlnkn", "votes": 1, "user": "PaulHoule", "posted_at": "2024-04-11 01:57:15", "comments": 0, "source_title": "GitHub - mxmlnkn/ratarmount: Access large archives as a filesystem efficiently, e.g., TAR, RAR, ZIP, GZ, BZ2, XZ, ZSTD archives", "source_text": "GitHub - mxmlnkn/ratarmount: Access large archives as a filesystem\nefficiently, e.g., TAR, RAR, ZIP, GZ, BZ2, XZ, ZSTD archives\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nmxmlnkn / ratarmount Public\n\n  * Notifications\n  * Fork 34\n  * Star 600\n\nAccess large archives as a filesystem efficiently, e.g., TAR, RAR, ZIP, GZ,\nBZ2, XZ, ZSTD archives\n\n### License\n\nMIT license\n\n600 stars 34 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# mxmlnkn/ratarmount\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n9 Branches\n\n54 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nmxmlnkn[doc] Update link to AppImage9f3881b \u00b7\n\n## History\n\n670 Commits  \n  \n### .github/workflows\n\n|\n\n### .github/workflows\n\n| [refactor] Use the bzip2 backend that is now integrated with rapidgzi...  \n  \n### AppImage\n\n|\n\n### AppImage\n\n| [build] Revert AppImage compression to gzip after accidentically comi...  \n  \n### benchmarks\n\n|\n\n### benchmarks\n\n| [feature] Add --transform option  \n  \n### core\n\n|\n\n### core\n\n| [version] Bump ratarmountcore version to 0.7.0  \n  \n### presentation\n\n|\n\n### presentation\n\n| [doc] Rename presentation  \n  \n### tests\n\n|\n\n### tests\n\n| [feature] Add support for zlib files  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| [CI] Move AppImage build script out of Github Action into a bash scri...  \n  \n### CHANGELOG.md\n\n|\n\n### CHANGELOG.md\n\n| [version] Bump ratarmount version to 0.15.0  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| [doc] Add open source software attributions  \n  \n### MANIFEST.in\n\n|\n\n### MANIFEST.in\n\n| [build] Remove half-heartedly maintained requirements.txt  \n  \n### README.md\n\n|\n\n### README.md\n\n| [doc] Update link to AppImage  \n  \n### pyproject.toml\n\n|\n\n### pyproject.toml\n\n| [build] Migrate to setup.cfg and pyproject.toml  \n  \n### ratarmount.py\n\n|\n\n### ratarmount.py\n\n| [version] Bump ratarmount version to 0.15.0  \n  \n### ratarmount.svg\n\n|\n\n### ratarmount.svg\n\n| [doc] Use translate inside ratarmount SVG to make letters more easily...  \n  \n### setup.cfg\n\n|\n\n### setup.cfg\n\n| [version] Bump ratarmount version to 0.15.0  \n  \n### setup.py\n\n|\n\n### setup.py\n\n| [build] Migrate to setup.cfg and pyproject.toml  \n  \n## Repository files navigation\n\n# Random Access Tar Mount (Ratarmount)\n\nRatarmount collects all file positions inside a TAR so that it can easily jump\nto and read from any file without extracting it. It, then, mounts the TAR\nusing fusepy for read access just like archivemount. In contrast to\nlibarchive, on which archivemount is based, random access and true seeking is\nsupported. And in contrast to tarindexer, which also collects file positions\nfor random access, ratarmount offers easy access via FUSE and support for\ncompressed TARs.\n\nCapabilities:\n\n  * Highly Parallelized: By default, all cores are used for parallelized algorithms like for the gzip, bzip2, and xz decoders. This can yield huge speedups on most modern processors but requires more main memory. It can be controlled or completely turned off using the -P <cores> option.\n  * Recursive Mounting: Ratarmount will also mount TARs inside TARs inside TARs, ... recursively into folders of the same name, which is useful for the 1.31TB ImageNet data set.\n  * Mount Compressed Files: You may also mount files with one of the supported compression schemes. Even if these files do not contain a TAR, you can leverage ratarmount's true seeking capabilities when opening the mounted uncompressed view of such a file.\n  * Read-Only Bind Mounting: Folders may be mounted read-only to other folders for usecases like merging a backup TAR with newer versions of those files residing in a normal folder.\n  * Union Mounting: Multiple TARs, compressed files, and bind mounted folders can be mounted under the same mountpoint.\n  * Write Overlay: A folder can be specified as write overlay. All changes below the mountpoint will be redirected to this folder and deletions are tracked so that all changes can be applied back to the archive.\n\nTAR compressions supported for random access:\n\n  * BZip2 as provided by indexed_bzip2 as a backend, which is a refactored and extended version of bzcat from toybox. See also the reverse engineered specification.\n  * Gzip and Zlib as provided by rapidgzip or indexed_gzip by Paul McCarthy. See also RFC1952 and RFC1950.\n  * Xz as provided by python-xz by Rogdham or lzmaffi by Tomer Chachamu. See also The .xz File Format.\n  * Zstd as provided by indexed_zstd by Marco Martinelli. See also Zstandard Compression Format.\n\nOther supported archive formats:\n\n  * Rar as provided by rarfile by Marko Kreen. See also the RAR 5.0 archive format.\n  * Zip as provided by zipfile, which is distributed with Python itself. See also the ZIP File Format Specification.\n  * Many Others as provided by libarchive via python-libarchive-c.\n\n    * Formats with tests: 7z, ar, cab, compress, cpio, iso, lrzip, lzma, lz4, lzip, lzo, warc, xar.\n    * Untested formats that might work or not: deb, grzip, rpm, uuencoding.\n    * Beware that libarchive has no performant random access to files and to file contents. In order to seek or open a file, in general, it needs to be assumed that the archive has to be parsed from the beginning. If you have a performance-critical use case for a format only supported via libarchive, then please open a feature request for a faster customized archive format implementation. The hope would be to add suitable stream compressors such as \"short\"-distance LZ-based compressions to rapidgzip.\n\n# Table of Contents\n\n  1. Installation\n\n    1. Installation via AppImage\n    2. Installation via Package Manager\n\n      1. Arch Linux\n    3. System Dependencies for PIP Installation (Rarely Necessary)\n    4. PIP Package Installation\n  2. Benchmarks\n  3. The Problem\n  4. The Solution\n  5. Usage\n\n    1. Metadata Index Cache\n    2. Bind Mounting\n    3. Union Mounting\n    4. File versions\n    5. Compressed non-TAR files\n    6. Xz and Zst Files\n    7. As a Library\n\n# Installation\n\nYou can install ratarmount either by simply downloading the AppImage or via\npip. The latter might require installing additional dependencies.\n\n    \n    \n    pip install ratarmount\n\n## Installation via AppImage\n\nThe AppImage files are attached under \"Assets\" on the releases page. They\nrequire no installation and can be simply executed like a portable executable.\nIf you want to install it, you can simply copy it into any of the folders\nlisted in your PATH.\n\n    \n    \n    appImageName=ratarmount-0.15.0-x86_64.AppImage wget 'https://github.com/mxmlnkn/ratarmount/releases/download/v0.15.0/$appImageName' chmod u+x -- \"$appImageName\" ./\"$appImageName\" --help # Simple test run sudo cp -- \"$appImageName\" /usr/local/bin/ratarmount # Example installation\n\n## Installation via Package Manager\n\n### Arch Linux\n\nArch Linux's AUR offers ratarmount as stable and development package. Use an\nAUR helper, like yay or paru, to install one of them:\n\n    \n    \n    # stable version paru -Syu ratarmount # development version paru -Syu ratarmount-git\n\n### Conda\n\n    \n    \n    conda install -c conda-forge ratarmount\n\n## System Dependencies for PIP Installation (Rarely Necessary)\n\nPython 3.6+, preferably pip 19.0+, FUSE, and sqlite3 are required. These\nshould be preinstalled on most systems.\n\nOn Debian-like systems like Ubuntu, you can install/update all dependencies\nusing:\n\n    \n    \n    sudo apt install python3 python3-pip fuse sqlite3 unar\n\nOn macOS, you have to install macFUSE with:\n\n    \n    \n    brew install macfuse\n\nIf you are installing on a system for which there exists no manylinux wheel,\nthen you'll have to install further dependencies that are required to build\nsome of the Python packages that ratarmount depends on from source:\n\n    \n    \n    sudo apt install \\ python3 python3-pip fuse \\ build-essential software-properties-common \\ zlib1g-dev libzstd-dev liblzma-dev cffi libarchive-dev\n\n## PIP Package Installation\n\nThen, you can simply install ratarmount from PyPI:\n\n    \n    \n    pip install ratarmount\n\nOr, if you want to test the latest version:\n\n    \n    \n    python3 -m pip install --user --force-reinstall \\ 'git+https://github.com/mxmlnkn/ratarmount.git@develop#egginfo=ratarmountcore&subdirectory=core' \\ 'git+https://github.com/mxmlnkn/ratarmount.git@develop#egginfo=ratarmount'\n\nIf there are troubles with the compression backend dependencies, you can try\nthe pip --no-deps argument. Ratarmount will work without the compression\nbackends. The hard requirements are fusepy and for Python versions older than\n3.7.0 dataclasses.\n\n# Benchmarks\n\n  * Not shown in the benchmarks, but ratarmount can mount files with preexisting index sidecar files in under a second making it vastly more efficient compared to archivemount for every subsequent mount. Also, archivemount has no progress indicator making it very unlikely the user will wait hours for the mounting to finish. Fuse-archive, an iteration on archivemount, has the --asyncprogress option to give a progress indicator using the timestamp of a dummy file. Note that fuse-archive daemonizes instantly but the mount point will not be usable for a long time and everything trying to use it will hang until then when not using --asyncprogress!\n  * Getting file contents of a mounted archive is generally vastly faster than archivemount and fuse-archive and does not increase with the archive size or file count resulting in the largest observed speedups to be around 5 orders of magnitude!\n  * Memory consumption of ratarmount is mostly less than archivemount and mostly does not grow with the archive size. Not shown in the plots, but the memory usage will be much smaller when not specifying -P 0, i.e., when not parallelizing. The gzip backend grows linearly with the archive size because the data for seeking is thousands of times larger than the simple two 64-bit offsets required for bzip2. The memory usage of the zstd backend only seems humongous because it uses mmap to open. The memory used by mmap is not even counted as used memory when showing the memory usage with free or htop.\n  * For empty files, mounting with ratarmount and archivemount does not seem be bounded by decompression nor I/O bandwidths but instead by the algorithm for creating the internal file index. This algorithm scales linearly for ratarmount and fuse-archive but seems to scale worse than even quadratically for archives containing more than 1M files when using archivemount. Ratarmount 0.10.0 improves upon earlier versions by batching SQLite insertions.\n  * Mounting bzip2 and xz archives has actually become faster than archivemount and fuse-archive with ratarmount -P 0 on most modern processors because it actually uses more than one core for decoding those compressions. indexed_bzip2 supports block parallel decoding since version 1.2.0.\n  * Gzip compressed TAR files are two times slower than archivemount during first time mounting. It is not totally clear to me why that is because streaming the file contents after the archive being mounted is comparably fast, see the next benchmarks below. In order to have superior speeds for both of these, I am experimenting with a parallelized gzip decompressor like the prototype pugz offers for non-binary files only.\n  * For the other cases, mounting times become roughly the same compared to archivemount for archives with 2M files in an approximately 100GB archive.\n  * Getting a lot of metadata for archive contents as demonstrated by calling find on the mount point is an order of magnitude slower compared to archivemount. Because the C-based fuse-archive is even slower than ratarmount, the difference is very likely that archivemount uses the low-level FUSE interface while ratarmount and fuse-archive use the high-level FUSE interface.\n\n  * Reading files from the archive with archivemount are scaling quadratically instead of linearly. This is because archivemount starts reading from the beginning of the archive for each requested I/O block. The block size depends on the program or operating system and should be in the order of 4 kiB. Meaning, the scaling is O( (sizeOfFileToBeCopiedFromArchive / readChunkSize)^2 ). Both, ratarmount and fuse-archive avoid this behavior. Because of this quadratic scaling, the average bandwidth with archivemount seems like it decreases with the file size.\n  * Reading bz2 and xz are both an order of magnitude faster, as tested on my 12/24-core Ryzen 3900X, thanks to parallelization.\n  * Memory is bounded in these tests for all programs but ratarmount is a lot more lax with memory because it uses a Python stack and because it needs to hold caches for a constant amount of blocks for parallel decoding of bzip2 and xz files. The zstd backend in ratarmount looks unbounded because it uses mmap, whose memory usage will automatically stop and be freed if the memory limit has been reached.\n  * The peak for the xz decoder reading speeds happens because some blocks will be cached when loading the index, which is not included in the benchmark for technical reasons. The value for the 1 GiB file size is more realistic.\n\nFurther benchmarks can be viewed here.\n\n# The Problem\n\nYou downloaded a large TAR file from the internet, for example the 1.31TB\nlarge ImageNet, and you now want to use it but lack the space, time, or a file\nsystem fast enough to extract all the 14.2 million image files.\n\n## The Solution\n\nRatarmount creates an index file with file names, ownership, permission flags,\nand offset information. This sidecar is stored at the TAR file's location or\nin ~/.ratarmount/. Ratarmount can load that index file in under a second if it\nexists and then offers FUSE mount integration for easy access to the files\ninside the archive.\n\nHere is a more recent test for version 0.2.0 with the new default SQLite\nbackend:\n\n  * TAR size: 124GB\n  * Contains TARs: yes\n  * Files in TAR: 1000\n  * Files in TAR (including recursively in contained TARs): 1.26 million\n  * Index creation (first mounting): 15m 39s\n  * Index size: 146MB\n  * Index loading (subsequent mounting): 0.000s\n  * Reading a 64kB file: ~4ms\n  * Running 'find mountPoint -type f | wc -l' (1.26M stat calls): 1m 50s\n\nThe reading time for a small file simply verifies the random access by using\nfile seek to be working. The difference between the first read and subsequent\nreads is not because of ratarmount but because of operating system and file\nsystem caches.\n\n# Usage\n\n## Command Line Options\n\nSee ratarmount --help or here.\n\n## Metadata Index Cache\n\nIn order to reduce the mounting time, the created index for random access to\nfiles inside the tar will be saved to one of these locations. These locations\nare checked in order and the first, which works sufficiently, will be used.\nThis is the default location order:\n\n  1. .index.sqlite\n  2. ~/.ratarmount/<path to tar: '/' -> '_'>.index.sqlite E.g., ~/.ratarmount/_media_cdrom_programm.tar.index.sqlite\n\nThis list of fallback folders can be overwritten using the --index-folders\noption. Furthermore, an explicitly named index file may be specified using the\n--index-file option. If --index-file is used, then the fallback folders,\nincluding the default ones, will be ignored!\n\n## Bind Mounting\n\nThe mount sources can be TARs and/or folders. Because of that, ratarmount can\nalso be used to bind mount folders read-only to another path similar to bindfs\nand mount --bind. So, for:\n\n    \n    \n    ratarmount folder mountpoint\n\nall files in folder will now be visible in mountpoint.\n\n## Union Mounting\n\nIf multiple mount sources are specified, the sources on the right side will be\nadded to or update existing files from a mount source left of it. For example:\n\n    \n    \n    ratarmount folder1 folder2 mountpoint\n\nwill make both, the files from folder1 and folder2, visible in mountpoint. If\na file exists in both multiple source, then the file from the rightmost mount\nsource will be used, which in the above example would be folder2.\n\nIf you want to update / overwrite a folder with the contents of a given TAR,\nyou can specify the folder both as a mount source and as the mount point:\n\n    \n    \n    ratarmount folder file.tar folder\n\nThe FUSE option -o nonempty will be automatically added if such a usage is\ndetected. If you instead want to update a TAR with a folder, you only have to\nswap the two mount sources:\n\n    \n    \n    ratarmount file.tar folder folder\n\n## File versions\n\nIf a file exists multiple times in a TAR or in multiple mount sources, then\nthe hidden versions can be accessed through special .versions folders. For\nexample, consider:\n\n    \n    \n    ratarmount folder updated.tar mountpoint\n\nand the file foo exists both in the folder and as two different versions in\nupdated.tar. Then, you can list all three versions using:\n\n    \n    \n    ls -la mountpoint/foo.versions/ dr-xr-xr-x 2 user group 0 Apr 25 21:41 . dr-x------ 2 user group 10240 Apr 26 15:59 .. -r-x------ 2 user group 123 Apr 25 21:41 1 -r-x------ 2 user group 256 Apr 25 21:53 2 -r-x------ 2 user group 1024 Apr 25 22:13 3\n\nIn this example, the oldest version has only 123 bytes while the newest and by\ndefault shown version has 1024 bytes. So, in order to look at the oldest\nversion, you can simply do:\n\n    \n    \n    cat mountpoint/foo.versions/1\n\nNote that these version numbers are the same as when used with tar's\n--occurrence=N option.\n\n## Prefix Removal\n\nUse ratarmount -o modules=subdir,subdir=<prefix> to remove path prefixes using\nthe FUSE subdir module. Because it is a standard FUSE feature, the -o ...\nargument should also work for other FUSE applications.\n\nWhen mounting an archive created with absolute paths, e.g., tar -P cf\n/var/log/apt/history.log, you would see the whole var/log/apt hierarchy under\nthe mount point. To avoid that, specified prefixes can be stripped from paths\nso that the mount target directory directly contains history.log. Use\nratarmount -o modules=subdir,subdir=/var/log/apt/ to do so. The specified path\nto the folder inside the TAR will be mounted to root, i.e., the mount point.\n\n## Compressed non-TAR files\n\nIf you want a compressed file not containing a TAR, e.g., foo.bz2, then you\ncan also use ratarmount for that. The uncompressed view will then be mounted\nto <mountpoint>/foo and you will be able to leverage ratarmount's seeking\ncapabilities when opening that file.\n\n## Xz and Zst Files\n\nIn contrast to bzip2 and gzip compressed files, true seeking on xz and zst\nfiles is only possible at block or frame boundaries. This wouldn't be\nnoteworthy, if both standard compressors for xz and zstd were not by default\ncreating unsuited files. Even though both file formats do support multiple\nframes and xz even contains a frame table at the end for easy seeking, both\ncompressors write only a single frame and/or block out, making this feature\nunusable. In order to generate truly seekable compressed files, you'll have to\nuse pixz for xz files. For zstd compressed, you can try with t2sz. The\nstandard zstd tool does not support setting smaller block sizes yet although\nan issue does exist. Alternatively, you can simply split the original file\ninto parts, compress those parts, and then concatenate those parts together to\nget a suitable multiframe zst file. Here is a bash function, which can be used\nfor that:\n\n# Writable Mounting\n\nThe --write-overlay <folder> option can be used to create a writable mount\npoint. The original archive will not be modified.\n\n  * File creations will create these files in the specified overlay folder.\n  * File deletions and renames will be registered in a database that also resides in the overlay folder.\n  * File modifications will copy the file from the archive into the overlay folder before applying the modification.\n\nThis overlay folder can be stored alongside the archive or it can be deleted\nafter unmounting the archive. This is useful when building the executable from\na source tarball without extracting. After installation, the intermediary\nbuild files residing in the overlay folder can be safely removed.\n\nIf it is desired to apply the modifications to the original archive, then the\n--commit-overlay can be prepended to the original ratarmount call.\n\nHere is an example for applying modifications to a writable mount and then\ncommitting those modifications back to the archive:\n\n  1. Mount it with a write overlay and add new files. The original archive is not modified.\n    \n        ratarmount --write-overlay example-overlay example.tar example-mount-point echo \"Hello World\" > example-mount-point/new-file.txt\n\n  2. Unmount. Changes persist solely in the overlay folder.\n    \n        fusermount -u example-mount-point\n\n  3. Commit changes to the original archive.\n    \n        ratarmount --commit-overlay --write-overlay example-overlay example.tar example-mount-point\n\nOutput:\n\n    \n        To commit the overlay folder to the archive, these commands have to be executed: tar --delete --null --verbatim-files-from --files-from='/tmp/tmp_ajfo8wf/deletions.lst' \\ --file 'example.tar' 2>&1 | sed '/^tar: Exiting with failure/d; /^tar.*Not found in archive/d' tar --append -C 'zlib-wiki-overlay' --null --verbatim-files-from --files-from='/tmp/tmp_ajfo8wf/append.lst' --file 'example.tar' Committing is an experimental feature! Please confirm by entering \"commit\". Any other input will cancel. > Committed successfully. You can now remove the overlay folder at example-overlay.\n\n  4. Verify the modifications to the original archive.\n    \n        tar -tvlf example.tar\n\nOutput:\n\n    \n        -rw-rw-r-- user/user 652817 2022-08-08 10:44 example.txt -rw-rw-r-- user/user 12 2023-02-16 09:49 new-file.txt\n\n  5. Remove the obsole write overlay folder.\n    \n        rm -r example-overlay\n\n## As a Library\n\nRatarmount can also be used as a library. Using ratarmountcore, files inside\narchives can be accessed directly from Python code without requiring FUSE. For\na more detailed description, see the ratarmountcore readme here.\n\n## About\n\nAccess large archives as a filesystem efficiently, e.g., TAR, RAR, ZIP, GZ,\nBZ2, XZ, ZSTD archives\n\n### Topics\n\npython fuse compression gzip filesystem zip tar rar bzip2 tar-archive zstd\nmounting random-access xz gz bz2 zstandard unionfs overlayfs mergefs\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n600 stars\n\n### Watchers\n\n18 watching\n\n### Forks\n\n34 forks\n\nReport repository\n\n## Releases 30\n\nratarmount 0.15.0 Latest\n\nApr 7, 2024\n\n\\+ 29 releases\n\n## Packages 0\n\nNo packages published\n\n## Contributors 9\n\n## Languages\n\n  * Python 81.7%\n  * Shell 18.3%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
