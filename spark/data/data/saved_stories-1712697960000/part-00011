{"aid": "39979390", "title": "Unlock Git Power: Mastering Commands", "url": "https://yasminteles.com/blog/unlock-git-power-mastering-commands", "domain": "yasminteles.com", "votes": 2, "user": "telesyasmin", "posted_at": "2024-04-09 13:46:53", "comments": 0, "source_title": "Unlock Git Power: Mastering Commands", "source_text": "Unlock Git Power: Mastering Commands\n\nApril 02, 2024\n\n# Unlock Git Power: Mastering Commands\n\n## Introduction\n\nGit, the popular version control system, has totally changed the game for how\nwe all work on code together.\n\nSo, if you're starting with Git, here's the summary: You need to get your\nhands dirty with the basics, like what commands you need to know and how to\nuse them. The more you use Git, the better you'll get at it.\n\nFor newbies, I suggest taking a look at https://learngitbranching.js.org/ -\nit's a super interactive way to learn Git!\n\nDo you want to become super good at Git? You need to go beyond the basics and\nreally delve into the details. It's all about practicing advanced moves and\nfollowing the best tips and tricks.\n\nHere's a quick list to get you started on your Git mastery journey:\n\n## Visualize the log tree\n\nYou have cloned or updated a repository, and to understand it better, you'd\nlike to look at the commit history. Wouldn't it be nice to get a visual\nrepresentation of all that has happened?\n\nThe git log command will display the commits log, so the best way to view the\nlog tree is to customize it. Try this command:\n\n    \n    \n    git log --oneline --graph --all\n\nIt will display the commit history in a graph format. It's beneficial for\nunderstanding the branch structure and commit history.\n\nPersonally, I love using this command for personal projects. But when I work\non team projects, I like to show extra information such as author and commit\ndate.\n\n    \n    \n    git log --graph --all --pretty=format:'%h %C(auto)%d %s - %an, %cr'\n\nThat's it! You have a smart way to browse your commit history.\n\n## Simplify your workflow\n\nWho wants to spend forever typing out long Git commands? Life's too short for\nthat, right?\n\nThat's where Git aliases come in handy. It allows you to create shortcuts for\nyour favorite Git commands. It makes your workflow smoother and more\nefficient.\n\nInstead of typing everything every time, you can set up a quick alias for\nthis. This can be a real-time saver, especially for commands you use all the\ntime. Plus, it makes it easier to remember long and complicated commands.\n\nAnd here's the best part: Git lets you set up as many aliases as you want. But\nremember, having too many aliases can make them hard to remember. So, I\nrecommend limiting yourself to just the commands you use most.\n\nHere are some examples of creating aliases for common Git commands:\n\n    \n    \n    git config --global alias.st status\n\nThis code sets up an alias named st for the git status command.\n\nThe --global flag indicates that this alias will be stored in your home\ndirectory's .gitconfig file. As a result, this alias will be accessible across\nall your repositories.\n\n    \n    \n    $ git st On branch master Your branch is up-to-date with 'origin/master'. nothing to commit, working directory clean\n\nAnother way to configure a git alias is by editing the ~/.gitconfig file. Try\nto include this command:\n\n    \n    \n    [alias] st = status\n\nGit aliases can also be used in git subcommands to, for example, execute two\nor more commands in sequence. For example, I use this alias a lot:\n\n    \n    \n    git config --global alias.ca !git add . && git commit -m\n\nThis alias will add all files that are unstaged with a git add . and then\ncreate a commit message, all with just a git ca.\n\nRemember, the goal of using Git aliases is to make your workflow more\nefficient and enjoyable. So feel free to experiment with different aliases and\nfind the ones that work best for you.\n\n## Group your commands\n\nYou can execute multiple Git commands in one line by separating them with a\nsemicolon ;. This isn't specific to Git but it is a feature of bash-like\nshells. It allows you to execute several commands in one line. This way, you\ncan save time and mix Git commands with other ones.\n\nFor example, if you want to add a library to your project and immediately\ncommit changes, you can use the following command:\n\n    \n    \n    yarn add lodash; git commit -am \"chore: add lodash dependency\"\n\nEach command will be executed sequentially, regardless of whether the previous\none succeeded or failed. So, it's a cool way to keep things tidy and save\nyourself some time.\n\n## Write clear and informative commit messages\n\nIn Git, a commit is a snapshot of your repository at a specific point in time.\nWhen you commit, you record the state of your files with a message describing\nwhat changes were made.\n\nWriting good Git commit messages is super important. It helps everyone stay on\nthe same page about what changes were made and why. This is very useful when\nyou're working on a big project.\n\nPlus, it makes it easier for everyone to work together because they can\nquickly see what changes each person has made. When you write clear commit\nmessages, it saves time for everyone, whether they're looking over the changes\nor trying to fix something.\n\nI believe that commit messages are like letters from developers to developers.\nSo it's essential to try to focus more on why and what instead of how.\n\nYou'll invest a little time writing meaningful messages, but it'll be worth it\nwhen you or your colleagues look back at the code later.\n\nYou can use a structured approach like Conventional Commits. It provides a\ntemplate for your commit messages, ensuring they contain a type and a message,\nwith scope, body, and footer optional extras. It also has a simple way to\nindicate breaking changes.\n\nHere's an example of a well-written commit message using the Conventional\nCommits format:\n\n    \n    \n    fix: prevent racing of requests Introduce a request ID and a reference to the latest request. Dismiss incoming responses other than from the latest request. Remove timeouts that were used to mitigate the racing issue but are obsolete now. Co-authored-by: nickname <name@mail.com> Related to issue #123\n\nAdditionally, you can configure a global commit message template. It will be\nused when you run git commit without the -m|--message flag.\n\nIf you want to learn more about commit messages, I suggest the Github blog\narticle and the CBeans article.\n\nBy following this practice, you contribute to an easy-to-understand and\nnavigate project history. This is super important for keeping the project\nmoving forward smoothly.\n\n## Git Merge vs Git Rebase commands\n\nWhen you work alone on a project, your choice of Git commands can be pretty\nbasic. Your workflow usually involves adding files, making commits, and\nrepeatedly pushing them. Branching becomes less critical, resulting in a more\nsimplistic project tree.\n\nNow, you've got teammates to collaborate with, and that's awesome.\nCollaboration can boost productivity, but it adds new challenges to version\ncontrol. This is when you start to see conflicts. Immediately, two practices\nbecome absolutely essential: branching and pulling changes.\n\nGit branching is a powerful tool that allows teammates to work in parallel on\nthe same codebase. This is great for collaboration. Each team member can focus\non developing a new feature or fixing a bug without disturbing anyone.\n\nBut, sometimes, a feature branch gets out of sync with the main branch. To\nresolve this, you have two main strategies: merging and rebasing.\n\nMerging is all about combining the history of two branches into a new merge\ncommit. This way, you keep the history of both branches intact. You can use\nthe git merge command to do this.\n\nRebasing, on the other hand, moves the feature branch's history to the head of\nthe main one. The cool thing about rebasing is that it gives you a cleaner,\nmore linear commit history. You can use the git rebase command for this.\n\nHere is an image to show how your git tree will look like in each strategy:\n\nThe difference between git merge and git rebase.\n\nRebasing allows you to rewrite the history. It's like a machine time! So you\ncan organize your commits and create a more coherent history.\n\nBut, it must be used carefully. If you don't follow the \"Golden rule of\nrebasing,\" you could end up in hot water. The Golden rule of Git rebase is\nsimple: Never use it on public branches!\n\nSo, knowing when to use git merge and git rebase is the key to keeping your\ncodebase in check.\n\n## Update your local repository frequently\n\nSo, you're busy coding away on a new feature. Meanwhile, the main branch might\nbe getting some updates.\n\nDon't freak out if this happens. It's good practice to apply these changes\nregularly to your local branch. This way, you don't avoid potential code\nconflicts, but manage them proactively.\n\nIn my view, it's a good idea to update your local repository at least once a\nday.\n\nThis way, you can resolve some conflicts as soon as possible. It will make it\neasier to merge your branch with the main one.\n\n## Conclusion\n\nKeeping the development flow smooth and working as a team is essential.\n\nIf you follow the best practices, you'll be at the top of the game. Your\nworkflow will be smart, your team will be closer, and your codebase will be\neasy to navigate.\n\nRemember, mastering Git takes time and a lot of practice. So, make sure to use\nthese commands frequently and understand their implications.\n\nThanks for reading, and enjoy your git adventures!\n\nWritten byYasmin Teles\n\nSoftware engineer, content creator, open-source contributor, and lifelong\nlearner.\n\n2022 - 2024 Yasmin Teles. All rights reserved.\n\n", "frontpage": false}
