{"aid": "39981855", "title": "Lazy way to cause SHA-256 collisions for lazy evaluators", "url": "https://shkspr.mobi/blog/2024/04/lazy-way-to-cause-sha-256-collisions-for-lazy-evaluators/", "domain": "shkspr.mobi", "votes": 2, "user": "ColinWright", "posted_at": "2024-04-09 17:31:05", "comments": 0, "source_title": "Lazy way to cause SHA-256 collisions for lazy evaluators", "source_text": "Lazy way to cause SHA-256 collisions for lazy evaluators \u2013 Terence Eden\u2019s Blog\n\nThis site isn't broken! It is taking part in CSS Naked Day.\n\n# Lazy way to cause SHA-256 collisions for lazy evaluators\n\nBy @edent \u00b7 cryptography \u00b7 2 comments \u00b7 450 words\n\nHumans are lazy. That's why we have computers; to do the boring work for us.\n\nI recently downloaded a file. The website said the file should have a SHA-256\nhash of: ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb\n\nSo I ran sha256 filename on my machine. And then lazily compared the hashes.\nBy which I mean \"Yeah the first few characters match, as do the last few. It's\nprobably fine.\"\n\nStupid lazy humans.\n\nIt's pretty easy to demonstrate that you can take a string, generate a hash,\nand then create a different string which has a hash with the same first\ncharacter as the original.\n\nThis toy example starts with a string \"a\" and then creates a different string\n\"b\". It then pads the \"b\" string with spaces until the first characters of\nboth hashes match:\n\n    \n    \n    $s1 = \"a\"; $h1 = hash(\"sha256\", $s1); $first = substr($h1, 0, 1); echo $first . \"\\n\"; $s2 = \"b\"; for ($x=0; $x<100; $x++) { $s2 .= \" \"; $h2 = hash(\"sha256\", $s2); if ( $first == substr($h2,0,1) ) { echo \"{$s2}.{$h2}\\n\"; } }\n\nAssuming SHA-256 is randomly distributed, and there are 16 possible values for\neach character, this should produce ~6.25 matching hashes.\n\nAnd, indeed it does! Four hashes appear which all have the same first\ncharacter.\n\nWhat about generating a \"collision\" of the first and last characters? 16x16 =\n256. So that should be doable on modest hardware.\n\n    \n    \n    $s1 = \"a\"; $h1 = hash(\"sha256\", $s1); $first = substr($h1, 0, 1); $last = substr($h1, -1); echo \"{$first}-{$last}\\n\"; $s2 = \"b\"; for ($x=0; $x<2000; $x++) { $s2 .= \" \"; $h2 = hash(\"sha256\", $s2); if ( $first == substr($h2,0,1) && $last == substr($h2, -1) ) { echo \"{$s2}.{$h2}\\n\"; } }\n\nThat spits out a bunch of strings where the first and last characters of the\nhash matches the first and last of the original hash.\n\nOf course, from there it gets exponentially harder. If you want to match 2\ncharacters at each end, you'll need around 65,536 attempts. As it happens, it\ntakes 74,653 attempts before a \"collision\" of the first two and last two\ncharacters are found.\n\nOf course, padding with spaces makes the string significantly longer. So you\ncould pad with incrementing Unicode characters. Depending on the contents of\nthe message, you could fill it with invisible characters which wouldn't be\nseen by an ordinary user.\n\nIs this a practical way to generate full-length hashes? No, obviously not. It\ngoes some way to show just how difficult it is to force even a partial\ncollision.\n\nThere is a brilliant explanation of this problem space on David Buchanan's\nblog.\n\n## Share this post on...\n\n  * Mastodon\n  * Twitter\n  * Facebook\n  * LinkedIn\n  * Reddit\n  * HackerNews\n  * Lobsters\n  * Pocket\n  * WhatsApp\n  * Telegram\n\n## The AlgorithmTM suggests:\n\n  * A simple(ish) guide to verifying HTTP Message Signatures in PHP\n\n2024\n\n  * HTTP Signature Infinite Loop?\n\n2024\n\n  * Illegal Hashes\n\n2022\n\n  * Staking Claims with Scheduled Tweets\n\n2020\n\n## 2 thoughts on \u201cLazy way to cause SHA-256 collisions for lazy evaluators\u201d\n\n  1. 2024-04-09 12:56\n\n### Rick says:\n\n@Edent hashing is so cool. Great post!\n\nReply\n\n  2. 2024-04-09 13:38\n\n### Julian Fietkau says:\n\n@Edent There's a topic in the HCI & security field overlap about hash\nvisualization, saying that software may want to offer deterministic\nvisualizations of hashes so people can perceive and compare them more\nholistically. The quintessential work is Perrig & Song (1999):\nhttps://users.ece.cmu.edu/~adrian/projects/validation/validation.pdf\n\nA few years ago I got together with a colleague to survey the landscape and\npropose our own algorithm:\nhttps://fietkau.science/hash_visualization_password_validation See slide 8 for\nmore prior work examples.\n\nFun stuff! \ud83d\ude00\n\nReply\n\n  3. ### More comments on Mastodon.\n\n### What are your reckons? Cancel reply\n\n## Get new posts by email\n\nJoin 494 other subscribers.\n\n## \ud83d\udd0e Search\n\n", "frontpage": false}
