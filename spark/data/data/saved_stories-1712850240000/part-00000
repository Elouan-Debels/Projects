{"aid": "40000300", "title": "Converting a Vue 2 App to Alpine.js", "url": "https://www.raymondcamden.com/2024/03/04/converting-a-vue-2-app-to-alpinejs", "domain": "raymondcamden.com", "votes": 1, "user": "tie-in", "posted_at": "2024-04-11 09:41:22", "comments": 0, "source_title": "Converting a Vue 2 App to Alpine.js", "source_text": "Converting a Vue 2 App to Alpine.js\n\n# Raymond Camden\n\nFather, husband, developer relations and web standards expert, and cat demo\nbuilder.\n\nMarch 4, 2024\n\n# Converting a Vue 2 App to Alpine.js\n\njavascript\n\nA little over two years ago I published an \"idle clicker game\" built in\nVue.js. I called it \"IdleFleet\" and was heavily inspired by games like A Dark\nRoom, where I relied on simple text graphics and game mechanics that would\nchange as you played. In my last <Code><Br> session, I walked through the\nprocess of building a simple text game and brought up IdleFleet as an example.\nWhile playing the game to refresh my memory about what I actually built... I\ndiscovered I actually really liked it. I decided it would be good to give it\nsome attention with new features and other updates, but before I could do\nthat, I knew I needed to switch from Vue to Alpine.js.\n\n## Why Vue to Alpine? #\n\nSo, this is mostly my opinion, and feel free to skip to the next section, but\nas much as I respect Vue, I don't find it as appropriate these days for\nsimpler web pages and non-\"apps\". I put \"apps\" in quotes because that means\nsomething different to different people. In general, when what you are\nbuilding involves multiple different 'views' (a screen for X, a screen for Y),\nI generally consider that an app. A page with JavaScript for interactivity is\nsimpler and Vue feels like overkill there. Alpine really fits the spot for\nthese needs and that's part of the reason I've been so enamored of it the last\nyear or so.\n\nAlso, and this is really now just an opinion, I kind of feel like Vue has lost\nsome of its approachability it had in the older days. It's absolutely\npowerful, performant, and so forth, but I'm just finding myself a lot more\ncomfortable with Alpine.\n\nOk, enough opinions, let's get into the process.\n\n## The Previous Code #\n\nBefore I get started, you can browse the Vue version of the repository here:\nhttps://github.com/cfjedimaster/IdleFleet/tree/820f1bea20a33b6f9248ebdc687f9ce7c93235bf.\nMy changes primarily revolve around two files: index.html and app.js (although\nI made a small change in app.css as well).\n\n## Library Change #\n\nThe first change was the easiest, and resulted in hundreds of awesome console\nerrors - swapping out the Vue CDN (<script\nsrc=\"https://unpkg.com/vue@2.6.14/dist/vue.js\"></script>) for Alpine (<script\nsrc=\"https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js\"\ndefer></script>).\n\n## Cloak Change #\n\nBoth Vue and Alpine support the idea of a 'cloak' that will hide all the\ncontent of your application until the application is loaded. In Vue, you add\nv-cloak to your top-level container for your application and then add CSS to\nhide it. In Alpine, you just change this to x-cloak and rename the directive\nin CSS:\n\n    \n    \n    [x-cloak] {display: none}\n\n## Noting the App Container #\n\nSpeaking of the app container, in a simple Vue app you could mark the 'area'\nwhere it would work with an ID and specify it in your Vue code with el:\"name\nof area\", so for example, this in HTML:\n\n    \n    \n    <div id=\"app\" v-cloak\">\n\nAnd this in the JavaScript:\n\n    \n    \n    const app = new Vue({ el:'#app',\n\nIn Alpine, you specify it in your HTML:\n\n    \n    \n    <div x-data=\"app\" x-cloak>\n\nAnd this is then referenced in JavaScript:\n\n    \n    \n    Alpine.data('app', () => ({\n\n## Filter Removal #\n\nFilters were removed in Vue 3, so I removed it and some config stuff as well:\n\n    \n    \n    Vue.filter('number', s => { return numberFormat(s); }); Vue.config.productionTip = false; Vue.config.devtools = false;\n\nThe filter just called a function (numberFormat) defined later in the code. If\nyour are curious, that function simply makes use of the awesome Intl API:\n\n    \n    \n    function numberFormat(s) { if(!window.Intl) return s; return new Intl.NumberFormat().format(s); }\n\n## Main Application Updating #\n\nIn the previous version, the Vue app defined variables in a data key, had a\nlist of functions in methods, and computed values in, well, computed.\nBasically the new Vue... part wrapped an object where data, methods, and\ncomputed functions were defined in separate blocks, also the init function.\n\nWhen you define an Alpine application, you also define a top-level object, but\nthere's no separation, you just provide a list of key/value pairs where each\nvalue can be simple reactive data or a function. You can mix this up as much\nas you want.\n\nThat being said, I try to organize my Alpine applications by putting data on\ntop, and then methods. I don't usually worry about splitting up computed\nmethods versus regular methods, but due to the size of this application, I\ndid.\n\nSo I start off with variables:\n\n    \n    \n    Alpine.data('app', () => ({ ships:[], credits: constants.INITIAL_CREDITS, log:[], autoShip:false, autoShipFlipped:false, mercantileSkill: 1, mercantileFlipped: false, nextShipReturnTime:null, shipSpeed: 1, shipSpeedFlipped: false, messages:null, ceps:null, cepsFlipped:false, lastCEPS: constants.INITIAL_CREDITS,\n\nThen have my init:\n\n    \n    \n    async init() { this.addShip(); setInterval(() => { this.heartBeat() }, 1000); setInterval(() => { this.randomMsg() }, constants.RANDOM_MSG_INTERVAL * 1000); setInterval(() => { this.doAutoShip() }, constants.AUTO_SHIP_DURATION * 1000); //random events are not on intervals, but kick off first one 5ish minutes setTimeout(() => { this.randomEvent() }, (5000 * 60) + (getRandomInt(0,3000)*60)); // even though we dont show CEPS immediately, track immediately setInterval(() => { this.generateCEPS() }, constants.CEPS_DURATION * 1000); this.messages = await (await fetch('./messages.json')).json(); },\n\nThen a set of methods, where I generally tried to use alphabetical sorting,\nwith the exception of heartBeat as it's a pretty core method to the game.\n\nComputed methods in Alpine are written as getters, but you don't have to\nspecify the get keyword. I like doing so though as it makes it more obvious.\nHere's an example of two of them:\n\n    \n    \n    // getter section get availableShips() { return this.ships.filter(s => s.available); }, get autoShipAllowed() { // only flip once if(this.credits > constants.ALLOW_AUTOSHIP) { this.autoShipFlipped = true; } return this.autoShipFlipped; },\n\nJust like Vue, Alpine will notice when data referenced in these methods are\nupdated and rerun their logic for display.\n\n## This Scope binding #\n\nOne issue I ran into that I've seen before in Alpine, was ensuring my this\nscope was properly referenced. So for example, in Vue, I had this in my start-\nup code:\n\n    \n    \n    setInterval(this.doAutoShip, AUTO_SHIP_DURATION * 1000);\n\nIn Alpine, when doAutoShip ran it lost access to the this scope variables. I\ntweaked them all like so:\n\n    \n    \n    setInterval(() => { this.doAutoShip() }, constants.AUTO_SHIP_DURATION * 1000);\n\n## HTML Updates - Variables #\n\nIn Vue, you can add references to variables with brackets, so for example:\n\n    \n    \n    Total Fleet Size: {{ fleetSize }}<br/>\n\nAlpine requires you to use x-text or x-html, so I switched these to:\n\n    \n    \n    Total Fleet Size: <span x-text=\"fleetSize\"></span><br/>\n\nIt's a bit more verbose and bugs me a tiny bit, but I got over it.\n\n## HTML Updates - Conditions #\n\nVue supports v-if and v-show and in Alpine this, yep, x-if and x-show. I\nswitched my v-if statements to x-show. Another issue is that Alpine doesn't\nsupport x-else. In the one case where I needed it, I just used a condition\nwith a negative (!) in front of it.\n\n    \n    \n    <button @click=\"enableAutoShip\" x-show=\"autoShipAllowed\" title=\"If enabled, this will periodically send out available ships.\"><span x-show=\"autoShip\">Auto Ship Enabled</span><span x-show=\"!autoShip\">Auto Ship Disabled</span></button>\n\n## HTML Updates - Refs #\n\nBoth Vue and Alpine support the ability to specify a 'ref' value in HTML that\ncan then be referenced in code later. It gives you a pointer to the DOM. In\nVue, this was done with ref, but in Alpine it's x-ref. Easy enough, right?\n\n## HTML Updates - numberFormat #\n\nPrevious, I used my number format in HTML like so:\n\n    \n    \n    Credits: {{ credits | number }}\n\nFor Alpine, I moved numberFormat into the Alpine application itself, and just\ncalled it like so:\n\n    \n    \n    Credits: <span x-text=\"numberFormat(credits)\"></span><br/>\n\n## Wrap Up #\n\nAll in all, it took me maybe an hour to make the change, so it wasn't too bad,\nand speaks to how easy it would be for a Vue developer to pick up and learn\nAlpine if they wanted, or needed to. Feel free to check out the current code\nhere, https://github.com/cfjedimaster/IdleFleet, and if you want to waste, I\nmean enjoy, a few hours, check out the game here:\nhttps://idlefleet.netlify.app/. I've got more updates coming this week!\n\n### Support this Content!\n\nIf you like this content, please consider supporting me. You can become a\nPatron, visit my Amazon wishlist, or buy me a coffee! Any support helps!\n\nWant to get a copy of every new post? Use the form below to sign up for my\nnewsletter.\n\nShare: Threads Twitter Facebook LinkedIn\n\n### Webmentions\n\nRaymond Camden \u00a9 2024. Theme by Just Good Themes. Powered by Eleventy.\n\n", "frontpage": false}
