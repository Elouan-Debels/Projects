{"aid": "40006004", "title": "Strcpy: A niche function you don't need. (2021)", "url": "https://nullprogram.com/blog/2021/07/30/", "domain": "nullprogram.com", "votes": 3, "user": "fanf2", "posted_at": "2024-04-11 19:42:04", "comments": 0, "source_title": "strcpy: a niche function you don't need", "source_text": "strcpy: a niche function you don't need\n\n## strcpy: a niche function you don't need\n\nJuly 30, 2021\n\nnullprogram.com/blog/2021/07/30/\n\nThe C strcpy function is a common sight in typical C programs. It\u2019s also a\nsource of buffer overflow defects, so linters and code reviewers commonly\nrecommend alternatives such as strncpy (difficult to use correctly; mismatched\nsemantics), strlcpy (non-standard, flawed), or C11\u2019s optional strcpy_s (no\ncorrect or practical implementations). Besides their individual shortcomings,\nthese answers are incorrect. strcpy and friends are, at best, incredibly\nniche, and the correct replacement is memcpy.\n\nIf strcpy is not easily replaced with memcpy then the code is fundamentally\nwrong. Either it\u2019s not using strcpy correctly or it\u2019s doing something dumb and\nshould be rewritten. Highlighting such problems is part of what makes memcpy\nsuch an effective replacement.\n\nNote: Everything here applies just as much to strcat and friends.\n\nClarification update: This article is about correctness (objective), not\nsafety (subjective). If the word \u201csafety\u201d comes to mind then you\u2019ve missed the\npoint.\n\n### Common cases\n\nBuffer overflows arise when the destination is smaller than the source. Safe\nuse of strcpy requires a priori knowledge of the length of the source string\nlength. Usually this knowledge is the exact source string length. If so,\nmemcpy is not only a trivial substitute, it\u2019s faster since it will not\nsimultaneously search for a null terminator.\n\n    \n    \n    char *my_strdup(const char *s) { size_t len = strlen(s) + 1; char *c = malloc(len); if (c) { strcpy(c, s); // BAD } return c; } char *my_strdup_v2(const char *s) { size_t len = strlen(s) + 1; char *c = malloc(len); if (c) { memcpy(c, s, len); // GOOD } return c; }\n\nA more benign case is a static source string, i.e. trusted input.\n\n    \n    \n    struct err { char message[16]; }; void set_oom(struct err *err) { strcpy(err->message, \"out of memory\"); // BAD }\n\nThe size is a compile time constant, so exploit it as such! Even more, a\nstatic assertion (C11) can catch mistakes at compile time rather than run\ntime.\n\n    \n    \n    void set_oom_v2(struct err *err) { static const char oom[] = \"out of memory\"; static_assert(sizeof(err->message) >= sizeof(oom)); memcpy(err->message, oom, sizeof(oom)); } // Or using a macro: void set_oom_v3(struct err *err) { #define OOM \"out of memory\" static_assert(sizeof(err->message) >= sizeof(OOM)); memcpy(err->message, OOM, sizeof(OOM)); } // Or assignment (implicit memcpy): void set_oom_v4(struct err *err) { static const struct err oom = {\"out of memory\"}; *err = oom; }\n\nThis covers the vast majority of cases of already-correct strcpy.\n\n### Less common cases\n\nstrcpy can still be correct without knowing the exact source string length. It\nis enough to know its upper bound does not exceed the destination length. In\nthis example \u2014 assuming the input is guaranteed to be null-terminated \u2014 this\nstrcpy is correct without ever knowing the source string length:\n\n    \n    \n    struct reply { char message[32]; int x, y; }; struct log { time_t timestamp; char message[32]; }; void log_reply(struct log *e, const struct reply *r) { e->timestamp = time(0); strcpy(e->message, r->message); }\n\nThis is a rare case where strncpy has the right semantics. It zeros out unused\ndestination bytes, destroying any previous contents.\n\n    \n    \n    strncpy(e->message, r->message, sizeof(e->message)); // In this case, same as: memset(e->message, 0, sizeof(e->message)); strcpy(e->message, r->message);\n\nIt\u2019s not a general strcpy replacement because strncpy might not write a null\nterminator. If the source string does not null-terminate within the\ndestination length, then neither will destination string.\n\nAs before, we can do better with memcpy!\n\n    \n    \n    static_assert(sizeof(e->message) >= sizeof(r->message)); memcpy(e->message, r->message, sizeof(r->message));\n\nThis unconditionally copies 32 bytes. But doesn\u2019t it waste time copying bytes\nit won\u2019t need? No! On modern hardware it\u2019s far better to copy a large, fixed\nnumber of bytes than a small, variable number of bytes. After all, branching\nis expensive. Searching for and handling that null terminator has a cost. This\nfixed-size copy is literally two instructions on x86-64 (output of clang\n-march=x86-64-v3 -O3):\n\n    \n    \n    vmovups ymm0, [rsi] vmovups [rdi + 8], ymm0\n\nIt\u2019s faster and there\u2019s no strcpy to attract complaints.\n\n### Niche cases\n\nSo where is strcpy useful? Only where all of the following apply:\n\n  1. You only know the upper bound of the source string.\n\n  2. It\u2019s undesirable to read beyond that length. Maybe storage is limited to the exact length of the string, or the upper bound is very large so an unconditional copy is too expensive.\n\n  3. The source string is so long, and the function so hot, that it\u2019s worth avoiding two passes: strlen followed by memcpy.\n\nThese circumstances are very unusual which makes strcpy a niche function you\nprobably don\u2019t need. This is the best case I can imagine, and it\u2019s pretty\ndumb:\n\n    \n    \n    struct doc { unsigned long long id; char body[1L<<20]; }; // Create a new document from a buffer. // // If body is more than 1MiB, the behavior is undefined. struct doc *doc_create(const char *body) { struct doc *c = calloc(1, sizeof(*c)); if (c) { c->id = id_gen(); assert(strlen(body) < sizeof(c->body)); strcpy(c->body, body); } return c; }\n\nIf you\u2019re dealing with such large null-terminated strings that (2) and (3)\napply then you\u2019re already doing something fundamentally wrong and self-\ncontradictory. The pointer and length should be kept and passed together. It\u2019s\nespecially essential for a hot function.\n\n    \n    \n    struct doc_v2 { unsigned long long id; size_t len; char body[]; };\n\n### Bonus: *_s isn\u2019t helping you\n\nC11 introduced \u201csafe\u201d string functions as an optional \u201cAnnex K\u201d, each named\nwith a _s suffix to its \u201cunsafe\u201d counterpart. Here is the prototype for\nstrcpy_s:\n\n    \n    \n    errno_t strcpy_s(char *restrict s1, rsize_t s1max, const char *restrict s2);\n\nThe rsize_t is a size_t with a \u201crestricted\u201d range (RSIZE_MAX, probably\nSIZE_MAX/2) intended to catch integer underflows. If you accidentally compute\na negative length, it will be a very large number in unsigned form. (An\nindicator that size_t should have originally been defined as signed.) This\nwill be outside the restricted range, and so the operation isn\u2019t attempted due\nto a likely underflow.\n\nThese \u201csafe\u201d functions were modeled after functions of the same name in MSVC.\nHowever, as noted, there are no practical implementations of Annex K. The\nfunctions in MSVC have different semantics and behavior, and they do not\nattempt to implement the standard.\n\nWorse, they don\u2019t even do what\u2019s promised in their documentation. The\nfollowing program should cause a runtime-constraint violation since -1 is an\ninvalid rsize_t in any reasonable implementation:\n\n    \n    \n    #define __STDC_WANT_LIB_EXT1__ 1 #include <stdio.h> #include <string.h> int main(void) { char buf[8] = {0}; errno_t r = strcpy_s(buf, -1, \"hello\"); printf(\"%d %s\\n\", (int)r, buf); }\n\nWith the latest MSVC as of this writing (VS 2019), this program prints \u201c0\nhello\u201d. Using strcpy_s did not make my program any safer than had I just used\nstrcpy. If anything, it\u2019s less safe due to a false sense of security. Don\u2019t\nuse these functions.\n\n  * c\n\nHave a comment on this article? Start a discussion in my public inbox by\nsending an email to ~skeeto/public-inbox@lists.sr.ht [mailing list etiquette]\n, or see existing discussions.\n\n# null program\n\n## Chris Wellons\n\nwellons@nullprogram.com (PGP)\n\n~skeeto/public-inbox@lists.sr.ht (view)\n\nAll information on this blog, unless otherwise noted, is hereby released into\nthe public domain, with no rights reserved.\n\n", "frontpage": false}
