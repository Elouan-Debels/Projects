{"aid": "40006021", "title": "Why is there no realloc that takes the number of bytes to copy?", "url": "https://shift.click/blog/missing-alloc-api/", "domain": "shift.click", "votes": 1, "user": "g0xA52A2A", "posted_at": "2024-04-11 19:43:10", "comments": 0, "source_title": "Why is there no realloc that takes the number of bytes to copy?", "source_text": "Why is there no realloc that takes the number of bytes to copy? - shift.click\n\n### Thom Chiovoloni\n\n  * About\n  * Twitter\n  * GitHub\n  * Email\n\n# Why is there no realloc that takes the number of bytes to copy?\n\n2 minute read\n\nI\u2019d like a variant of realloc that takes the number of bytes that should be\ncopied, in the case a copy is needed.\n\nThis doesn\u2019t seem to be part of any allocator API I can find^1, unless I\nmissed it. It doesn\u2019t seem to be in the common standard APIs, nor in the\nextended/custom APIs of the allocators I looked at, etc. It seems like low-\nhanging fruit, and is something I want whenever I implement a vec-style\ncontainer type.\n\nWhy is this useful? Consider the following case: Let\u2019s say a user is using the\nfirst 100 bytes of a vector with a capacity of 1000 bytes (so, size=100,\ncapacity=1000 for this vector). The user calls v.reserve(2000) (they\u2019re about\nto add that many elements or whatever). The vector implementation needs to\nexpand its capacity, and dutifully does so using some realloc-style function.\nNow imagine that in this case, the allocator can\u2019t reuse the existing\nstorage^2, and is forced to copy the allocation to new storage.\n\nIn this case, it\u2019d be very useful for the implementation of the allocator\n(specifically of the realloc-style function), to know that only the first 100\nbytes of the allocation are actually relevant, and not the whole 1000 bytes.\nBut it doesn\u2019t know that, so it has to copy all 1000 bytes, 90% of which is\nwasted effort.\n\nAnyway, there\u2019s probably some allocator out there with this, I\u2019m just\nsurprised that I can\u2019t find it^3. At the very least, more allocators should\nhave this in their APIs, even if it only shows up in their extended^4 APIs.\n\nAll that said, this is really just a minor gripe I\u2019ve had for a while. For\nsome reason this of all things overcame the inertia to become a real blog\npost. Hope it made sense.\n\nP.S. I intend to push for this to be added to Rust\u2019s allocator APIs. We could\nat least use it in our fallback realloc impl.\n\nP.P.S. Okay okay, I\u2019ll address the elephant in the room: I know I said I\u2019d\nwrite more about Rust\u2019s allocator API design, I still intend to, just life got\nin the way.\n\nP.P.P.S. I know I halfassed this explanation, so feel free to reach out if it\ndidn\u2019t make sense. This post is this is just a quick note since it\u2019s bugging\nme.\n\n  1. Now that I\u2019ve written this, I\u2019m sure either I\u2019ll find something with it, or someone will point out the places I\u2019ve missed. Still. \u21a9\n\n  2. Pretty likely that most allocators will have to copy if reallocating from 1000b to 2100b, since it\u2019s over 2x as big, so it probably wouldn\u2019t fit in the same size class in size-segregated allocators (Not guaranteed tho; for example, bump allocators could avoid needing the copy in some cases... either way it\u2019s besides the point). \u21a9\n\n  3. Note: this is different from how Rust\u2019s grow functions take the \u201cold size\u201d. This is the old capacity, which would be 1000 in the example, not 100. \u21a9\n\n  4. It\u2019d be even better if something standardized and popular like C++ got it too, since then allocator implementors are more likely to provide it. \u21a9\n\nTags: allocators, code, quick-thoughts, rants, rust, why-did-i-post-this\n\nCategories: Blog\n\nUpdated: April 9, 2024\n\nTwitter Facebook LinkedIn\n\n## You May Also Enjoy\n\n## I wish #[non_exhaustive] worked with struct update syntax\n\n3 minute read\n\nIt\u2019s pretty annoying that in Rust, #[non_exhaustive] structs don\u2019t support\n\u201cstruct update\u201d / \u201cfunctional record update\u201d syntax (the syntax that powers\nStuff { a: b, c: d, ..blah }).\n\n## Allocator trait 1: Let\u2019s talk about the Allocator trait\n\n5 minute read\n\nThere are... several things I find wanting about the current version of the\ncore::alloc::Allocator trait (as of 2023-08-06). I\u2019m going to do a short\nseries where I post about some of the bigger issues, and explore the different\ntradeoffs and design choices we might make. This post is an introduction to\nthat.\n\n## Miri Feature Wishlist\n\n8 minute read\n\nMiri is an evaluator for rust that detects many kinds of undefined behavior.\nHere are some things it could (possibly) do that would catch bugs I\u2019ve\nhad/seen before.\n\n## Codelet: A better saturate/clamp01 function\n\n4 minute read\n\nLet\u2019s talk about clamping a float between 0.0 and 1.0.\n\n  * Twitter\n  * GitHub\n  * Email\n  * Feed\n\n\u00a9 2024 shift.click. Powered by Jekyll & Minimal Mistakes.\n\n", "frontpage": false}
