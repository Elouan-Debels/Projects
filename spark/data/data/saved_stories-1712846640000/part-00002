{"aid": "39999855", "title": "Metaprogramming in Ruby: It's All About the Self (2009)", "url": "https://yehudakatz.com/2009/11/15/metaprogramming-in-ruby-its-all-about-the-self/", "domain": "yehudakatz.com", "votes": 2, "user": "Tomte", "posted_at": "2024-04-11 08:42:52", "comments": 0, "source_title": "Metaprogramming in Ruby: It's All About the Self", "source_text": "Metaprogramming in Ruby: It's All About the Self\n\nNov 15, 2009 5 min read\n\n# Metaprogramming in Ruby: It's All About the Self\n\nAfter writing my last post on Rails plugin idioms, I realized that Ruby\nmetaprogramming, at its core, is actually quite simple.\n\nIt comes down to the fact that all Ruby code is executed code--there is no\nseparate compile or runtime phase. In Ruby, every line of code is executed\nagainst a particular self. Consider the following five snippets:\n\n    \n    \n    class Person def self.species \"Homo Sapien\" end end class Person class << self def species \"Homo Sapien\" end end end class << Person def species \"Homo Sapien\" end end Person.instance_eval do def species \"Homo Sapien\" end end def Person.species \"Homo Sapien\" end\n\nAll five of these snippets define a Person.species that returns Homo Sapien.\nNow consider another set of snippets:\n\n    \n    \n    class Person def name \"Matz\" end end Person.class_eval do def name \"Matz\" end end\n\nThese snippets all define a method called name on the Person class. So\nPerson.new.name will return \"Matz\". For those familiar with Ruby, this isn't\nnews. When learning about metaprogramming, each of these snippets is presented\nin isolation: another mechanism for getting methods where they \"belong\". In\nfact, however, there is a single unified reason that all of these snippets\nwork the way they do.\n\nFirst, it is important to understand how Ruby's metaclass works. When you\nfirst learn Ruby, you learn about the concept of the class, and that each\nobject in Ruby has one:\n\n    \n    \n    class Person end Person.class #=> Class class Class def loud_name \"#{name.upcase}!\" end end Person.loud_name #=> \"PERSON!\"\n\nPerson is an instance of Class, so any methods added to Class are available on\nPerson as well. What they don't tell you, however, is that each object in Ruby\nalso has its own metaclass, a Class that can have methods, but is only\nattached to the object itself.\n\n    \n    \n    matz = Object.new def matz.speak \"Place your burden to machine's shoulders\" end\n\nWhat's going on here is that we're adding the speak method to matz's\nmetaclass, and the matz object inherits from its metaclass and then Object.\nThe reason this is somewhat less clear than ideal is that the metaclass is\ninvisible in Ruby:\n\n    \n    \n    matz = Object.new def matz.speak \"Place your burden to machine's shoulders\" end matz.class #=> Object\n\nIn fact, matz's \"class\" is its invisible metaclass. We can even get access to\nthe metaclass:\n\n    \n    \n    metaclass = class << matz; self; end metaclass.instance_methods.grep(/speak/) #=> [\"speak\"]\n\nAt this point in other articles on this topic, you're probably struggling to\nkeep all of the details in your head; it seems as though there are so many\nrules. And what's this class << matz thing anyway?\n\nIt turns out that all of these weird rules collapse down into a single\nconcept: control over the self in a given part of the code. Let's go back and\ntake a look at some of the snippets we looked at earlier:\n\n    \n    \n    class Person def name \"Matz\" end self.name #=> \"Person\" end\n\nHere, we are adding the name method to the Person class. Once we say class\nPerson, the self until the end of the block is the Person class itself.\n\n    \n    \n    Person.class_eval do def name \"Matz\" end self.name #=> \"Person\" end\n\nHere, we're doing exactly the same thing: adding the name method to instances\nof the Person class. In this case, class_eval is setting the self to Person\nuntil the end of the block. This is all perfectly straight forward when\ndealing with classes, but it's equally straight forward when dealing with\nmetaclasses:\n\n    \n    \n    def Person.species \"Homo Sapien\" end Person.name #=> \"Person\"\n\nAs in the matz example earlier, we are defining the species method on Person's\nmetaclass. We have not manipulated self, but you can see using def with an\nobject attaches the method to the object's metaclass.\n\n    \n    \n    class Person def self.species \"Homo Sapien\" end self.name #=> \"Person\" end\n\nHere, we have opened the Person class, setting the self to Person for the\nduration of the block, as in the example above. However, we are defining a\nmethod on Person's metaclass here, since we're defining the method on an\nobject (self). Also, you can see that self.name while inside the person class\nis identical to Person.name while outside it.\n\n    \n    \n    class << Person def species \"Homo Sapien\" end self.name #=> \"\" end\n\nRuby provides a syntax for accessing an object's metaclass directly. By doing\nclass << Person, we are setting self to Person's metaclass for the duration of\nthe block. As a result, the species method is added to Person's metaclass,\nrather than the class itself.\n\n    \n    \n    class Person class << self def species \"Homo Sapien\" end self.name #=> \"\" end end\n\nHere, we combine several of the techniques. First, we open Person, making self\nequal to the Person class. Next, we do class << self, making self equal to\nPerson's metaclass. When we then define the species method, it is defined on\nPerson's metaclass.\n\n    \n    \n    Person.instance_eval do def species \"Homo Sapien\" end self.name #=> \"Person\" end\n\nThe last case, instance_eval, actually does something interesting. It breaks\napart the self into the self that is used to execute methods and the self that\nis used when new methods are defined. When instance_eval is used, new methods\nare defined on the metaclass, but the self is the object itself.\n\nIn some of these cases, the multiple ways to achieve the same thing arise\nnaturally out of Ruby's semantics. After this explanation, it should be clear\nthat def Person.species, class << Person; def species, and class Person; class\n<< self; def species aren't three ways to achieve the same thing by design,\nbut that they arise out of Ruby's flexibility with regard to specifying what\nself is at any given point in your program.\n\nOn the other hand, class_eval is slightly different. Because it take a block,\nrather than act as a keyword, it captures the local variables surrounding it.\nThis can provide powerful DSL capabilities, in addition to controlling the\nself used in a code block. But other than that, they are exactly identical to\nthe other constructs used here.\n\nFinally, instance_eval breaks apart the self into two parts, while also giving\nyou access to local variables defined outside of it.\n\nIn the following table, defines a new scope means that code inside the block\ndoes not have access to local variables outside of the block.\n\nmechanism| method resolution| method definition| new scope?  \n---|---|---|---  \nclass Person| Person| same| yes  \nclass << Person| Person's metaclass| same| yes  \nPerson.class_eval| Person| same| no  \nPerson.instance_eval| Person| Person's metaclass| no  \n  \nAlso note that class_eval is only available to Modules (note that Class\ninherits from Module) and is an alias for module_eval. Additionally,\ninstance_exec, which was added to Ruby in 1.8.7, works exactly like\ninstance_eval, except that it also allows you to send variables into the\nblock.\n\nUPDATE: Thank you to Yugui of the Ruby core team for correcting the original\npost, which ignored the fact that self is broken into two in the case of\ninstance_eval.\n\n### Published by:\n\nKatz Got Your Tongue \u00a9 2024\n\nPowered by Ghost\n\n", "frontpage": false}
