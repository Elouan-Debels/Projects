{"aid": "40040470", "title": "Cross-Device Flows: Security Best Current Practice", "url": "https://www.ietf.org/archive/id/draft-ietf-oauth-cross-device-security-06.html", "domain": "ietf.org", "votes": 2, "user": "mooreds", "posted_at": "2024-04-15 13:43:29", "comments": 0, "source_title": "Cross-Device Flows: Security Best Current Practice", "source_text": "Cross-Device Flows: Security Best Current Practice\n\nInternet-Draft| CDFS| April 2024  \n---|---|---  \nKasselman, et al.| Expires 6 October 2024| [Page]  \n  \nWorkgroup:\n\n    Web Authorization Protocol\nInternet-Draft:\n\n    draft-ietf-oauth-cross-device-security-06\nPublished:\n\n    4 April 2024\nIntended Status:\n\n    Best Current Practice\nExpires:\n\n    6 October 2024\nAuthors:\n\n    \n\nP. Kasselman\n\nMicrosoft\n\nD. Fett\n\nAuthlete\n\nF. Skokan\n\nOkta\n\n# Cross-Device Flows: Security Best Current Practice\n\n## Abstract\n\nThis document describes threats against cross-device flows along with\npractical mitigations, protocol selection guidance, and a summary of formal\nanalysis results identified as relevant to the security of cross-device flows.\nIt serves as a security guide to system designers, architects, product\nmanagers, security specialists, fraud analysts and engineers implementing\ncross-device flows.\u00b6\n\n## Discussion Venues\n\nThis note is to be removed before publishing as an RFC.\u00b6\n\nDiscussion of this document takes place on the Web Authorization Protocol\nWorking Group mailing list (oauth@ietf.org), which is archived at\nhttps://mailarchive.ietf.org/arch/browse/oauth/.\u00b6\n\nSource for this draft and an issue tracker can be found at\nhttps://github.com/oauth-wg/oauth-cross-device-security.\u00b6\n\n## Status of This Memo\n\nThis Internet-Draft is submitted in full conformance with the provisions of\nBCP 78 and BCP 79.\u00b6\n\nInternet-Drafts are working documents of the Internet Engineering Task Force\n(IETF). Note that other groups may also distribute working documents as\nInternet-Drafts. The list of current Internet-Drafts is at\nhttps://datatracker.ietf.org/drafts/current/.\u00b6\n\nInternet-Drafts are draft documents valid for a maximum of six months and may\nbe updated, replaced, or obsoleted by other documents at any time. It is\ninappropriate to use Internet-Drafts as reference material or to cite them\nother than as \"work in progress.\"\u00b6\n\nThis Internet-Draft will expire on 6 October 2024.\u00b6\n\n## Copyright Notice\n\nCopyright (c) 2024 IETF Trust and the persons identified as the document\nauthors. All rights reserved.\u00b6\n\nThis document is subject to BCP 78 and the IETF Trust's Legal Provisions\nRelating to IETF Documents (https://trustee.ietf.org/license-info) in effect\non the date of publication of this document. Please review these documents\ncarefully, as they describe your rights and restrictions with respect to this\ndocument. Code Components extracted from this document must include Revised\nBSD License text as described in Section 4.e of the Trust Legal Provisions and\nare provided without warranty as described in the Revised BSD License.\u00b6\n\n\u25b2\n\n## Table of Contents\n\n## 1\\. Introduction\n\nProtocol flows that span multiple end-user devices are in widespread use\ntoday. These flows are often referred to as cross-device flows. A common\nexample is a user that uses their mobile phone to scan a QR code from their\nSmartTV, giving an app on the TV access to their video streaming service.\nBesides QR codes, other mechanisms are often used such as PIN codes that the\nuser has to enter on one of the devices, or push notifications to a mobile app\nthat the user has to approve.\u00b6\n\nIn all cases, it is up to the user to decide whether to grant authorization or\nnot. However, the QR code or PIN are transferred via an unauthorized channel,\nleaving it up to the user to decide in which context an authorization is\nrequested. This may be exploited by attackers to gain unauthorized access to a\nuser's resources.\u00b6\n\nTo accommodate the various nuances of cross-device flows, this document\ndistinguished between cases where the cross-device flow is used to authorize\naccess to a resource (cross-device authorization flows) and cases where the\ncross-device flow is used to transfer an existing session (cross-device\nsession transfer flows).\u00b6\n\n### 1.1. Cross-Device Authorization\n\nCross-device authorization flows enable a user to initiate an authorization\nflow on one device (the Consumption Device) and then use a second, personally\ntrusted, device (Authorization Device) to authorize the Consumption Device to\naccess a resource (e.g., access to a service). The Device Authorization Grant\n[RFC8628] and Client-Initiated Backchannel Authentication [CIBA] are two\nexamples of popular cross-device authorization flows.\u00b6\n\nIn these flows, it is the user's decision whether to continue the session by\nscanning a QR code, entering a user code, or accepting an authorization\nrequest pushed to their Authorization Device.\u00b6\n\nCross-Device Consent Phishing (CDCP) attacks exploit the unauthenticated\nchannel between the Consumption Device and Authorization Device using social\nengineering techniques to gain unauthorized access to the user's data. Several\npublications have emerged in the public domain ([Exploit1], [Exploit2],\n[Exploit3], [Exploit4], [Exploit5], [Exploit6]), describing how the\nunauthenticated channel can be exploited using social engineering techniques\nborrowed from phishing. Unlike traditional phishing attacks, these attacks\ndon't harvest credentials. Instead, they skip the step of collecting\ncredentials by persuading users to grant authorization using their\nAuthorization Devices.\u00b6\n\nOnce the user grants authorization, the attacker has access to the user's\nresources and in some cases is able to collect access and refresh tokens. Once\nin possession of the access and refresh tokens, the attacker may use these\ntokens to execute lateral attacks and gain additional access, or monetize the\ntokens by selling them. These attacks are effective even when multi-factor\nauthentication is deployed, since the attacker's aim is not to capture and\nreplay the credentials, but rather to persuade the user to grant\nauthorization.\u00b6\n\n### 1.2. Cross-Device Session Transfer\n\nSession transfer flows enable a user to transfer access to a service or\nnetwork from a device on which the user is already authenticated to a second\ndevice such as a mobile phone. In these flows, the user is authenticated and\nthen authorizes the session transfer on one device, referred to as the\nAuthorization Device (e.g., a personal computer, web portal or application),\nand transfers the session to the device where they will continue to consume\nthe session, referred to as the Consumption Device (e.g., a mobile phone or\nportable device).\u00b6\n\nThe session may be transferred by showing the user a session transfer code on\nthe Authorization Device, which is then entered on the Consumption Device.\nThis flow may be streamlined by rendering the session transfer code as a QR\ncode on the Authorization Device and scanned by the Consumption Device.\u00b6\n\nThe session transfer preserves state information, including authentication\nstate, at the second device to avoid additional configuration and optimize the\nuser experience. These flows are often used to add new devices to a network,\nonboard customers to a mobile application, or provision new credentials (e.g.,\n[OpenID.SIOPV2]).\u00b6\n\nIn these cross-device session transfer flows, the channel between the\nAuthorization Device and the Consumption Device is unauthenticated.\u00b6\n\nCross-Device Session Phishing (CDSP) attacks exploit the unauthenticated\nchannel between the Authorization Device and Consumption Device by using\nsocial engineering techniques to convince the user to send the session\ntransfer code to the attacker. These attacks borrow techniques from\ntraditional phishing attacks, but instead of collecting passwords, attackers\ncollect session transfer codes and other artefacts that allow them to setup a\nsession and then use it to access a user's data.\u00b6\n\n### 1.3. Defending Against Cross-Device Attacks\n\nThis document provides guidance to implementers to defend against Cross-Device\nConsent Phishing and Cross-Device Session Phishing attacks. This guidance\nincludes:\u00b6\n\n  1. Practical mitigations for susceptible protocols (Section 6.1).\u00b6\n  2. Protocol selection guidance to avoid using susceptible protocols (Section 6.2).\u00b6\n  3. Results from formal analysis of susceptible protocols (Section 6.3).\u00b6\n\n### 1.4. Conventions and Terminology\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n\"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\ndocument are to be interpreted as described in BCP 14 [RFC2119] [RFC8174]\nwhen, and only when, they appear in all capitals, as shown here.\u00b6\n\nThis specification uses the terms \"access token\", \"refresh token\",\n\"authorization server\", \"resource server\", \"authorization endpoint\",\n\"authorization request\", and \"client\" defined by The OAuth 2.0 Authorization\nFramework [RFC6749].\u00b6\n\n## 2\\. Best Practices\n\nThis section describes the set of security mechanisms and measures to secure\ncross-device protools against Cross-Device Consent Phishing and Cross-Device\nSession Phishing attacks that the OAuth working group considers best practices\nat the time of writing.\u00b6\n\n  1. Implementers MUST perform a risk assessment before implementing cross-device flows, weighing the risks from Cross-Device Consent Phishing and Cross-Device Session Phishing attacks against benefits for users.\u00b6\n  2. Implementers SHOULD avoid cross-device flows if risks cannot be sufficiently mitigated.\u00b6\n  3. Implementers SHOULD follow the guidance provided in Section 6.2 for protocol selection.\u00b6\n  4. Implementers MUST implement practical mitigations as listed in Section 6.1 that are appropriate for the use case, architecture, and selected protocols.\u00b6\n  5. Implementers SHOULD implement proximity checks as defined in Section 6.1.1 if possible.\u00b6\n\nThese best practices apply to the Device Authorization Grant ([RFC8628]) as\nwell as other cross-device protocols such as the Client Initiated Backchannel\nAuthentication [CIBA], Self-Issued OpenID Provider v2 [OpenID.SIOPV2], OpenID\nfor Verifiable Presentations [OpenID.VP], the Pre-Authorized Code Flow in\n([OpenID.VCI]) and other cross-device protocols that rely on the user to\nauthenticate the channel between devices.\u00b6\n\nSection 3 provides details about susceptible protocols and Section 4 provides\nattack descriptions. Section 6.1 provides details about the security\nmechanisms and mitigations, (protocol-selection) provides protocol selection\nguidance and Section 6.3 provides details from formal analysis of protocols\nthat apply to cross device flows.\u00b6\n\n## 3\\. Cross-Device Flow Patterns\n\nCross-device flows allow a user to start a flow on one device (e.g., a\nSmartTV) and then transfer the session to continue it on a second device\n(e.g., a mobile phone). The second device may be used to access the service\nthat was running on the first device, or to perform an action such as\nauthenticating or granting authorization before potentially passing control\nback to the first device.\u00b6\n\nThese flows typically involve using a mobile phone to scan a QR code or enter\na user code displayed on the first device (e.g., Smart TV, Kiosk, Personal\nComputer etc.).\u00b6\n\n### 3.1. Cross-Device Authorization\n\nIn a cross-device authorization flow, a user attempts to access a service on\none device, referred to as the Consumption Device, (e.g., a smart TV) and then\nuses a second device, referred to as the Authorization Device (e.g., a\nsmartphone), to authorize access to a resource (e.g., access to a streaming\nservice) on the Consumption Device.\u00b6\n\nCross-device authorization flows have several benefits, including:\u00b6\n\n  * Authorization on devices with limited input capabilities: End-users can authorize devices with limited input capabilities to access content (e.g., smart TVs, digital whiteboards, printers, etc).\u00b6\n  * Secure authentication on shared or public devices: End-users can perform authentication and authorization using a personally trusted device, without risk of disclosing their credentials to a public or shared device.\u00b6\n  * Ubiquitous multi-factor authentication: Enables a user to use multi-factor authentication, independent of the device on which the service is being accessed (e.g., a kiosk, smart TV or shared Personal Computer).\u00b6\n  * Convenience of a single, portable, credential store: Users can keep all their credentials in a mobile wallet or mobile phone that they already carry with them.\u00b6\n\nThere are three cross-device flow patterns for transferring the authorization\nrequest between the Consumption Device to the Authorization Device.\u00b6\n\n  * User-Transferred Session Data Pattern: In the first pattern, the user initiates the authorization process with the authorization server by copying information from the Consumption Device to the Authorization Device, before authorizing an action. By transferring the data from the Consumption Device to the Authorization Device, the user transfers the authorization session. For example the user may read a code displayed on the Consumption Device and enter it on the Authorization Device, or they may scan a QR code displayed on the Consumption Device with the Authorization Device. The Device Authorization Grant ([RFC8628]) is an example of a cross-device flow that follow this pattern.\u00b6\n  * Backchannel-Transferred Session Pattern: In the second pattern, the OAuth client on the Consumption Device is responsible for transferring the session and initiating authorization on the Authorization Device via a backchannel with the Authorization Server. For example the user may attempt an online purchase on a Consumption Device (e.g., a personal computer) and receive an authorization request on their Authentication Device (e.g., mobile phone). The Client Initiated Backchannel Authentication [CIBA] is an example of a cross-device flow that follow this pattern.\u00b6\n  * User-Transferred Authorization Data Pattern: In the third pattern, the OAuth client on the Consumption Device triggers the authorization request via a backchannel with the Authorization Server. Authorization data (e.g., a 6 digit authorization code) is displayed on the Authorization Device, which the user transfers to Consumption Device (e.g., by manually entering it). For example the user may attempt to access data in an enterprise application and receive a 6 digit authorization code on their Authentication Device (e.g., mobile phone) that they enter on Consumption Device.\u00b6\n\n#### 3.1.1. User-Transferred Session Data Pattern\n\nThe Device Authorization Grant ([RFC8628]) is an example of a cross-device\nflow that relies on the user copying information from the Consumption Device\nto the Authorization Device by either entering data manually or scanning a QR\ncode. The figure below shows a typical example of this flow:\u00b6\n\n    \n    \n    (B) Consumption Device +--------------+ Get QR/User Code +---------------+ (A)User +---| Consumption |<--------------------->| | Start | | Device |(E) Grant Authorization| Authorization | Flow +-->| |<--------------------->| Server | +--------------+ | | | | | | (C) Scan QR code | | | or | | | enter User Code | | v | | +--------------+ | | | Authorization| | | | Device |<--------------------->| | | |(D) User Authenticates | | | | and Authorize Access | | +--------------+ +---------------+\n\nFigure 1: Cross-Device Flows: User-Transferred Session Data Pattern\n\n  * (A) The user takes an action on the Consumption Device by starting a purchase, adding a device to a network or connecting a service to the Consumption Device.\u00b6\n  * (B) The Consumption Device retrieves a QR code or user code from an Authorization Server.\u00b6\n  * (C) The QR code or user code is displayed on the Consumption Device where the user scans the QR code or enters the user code on the Authorization Device.\u00b6\n  * (D) The user authenticates to the Authorization Server before granting authorization.\u00b6\n  * (E) The Authorization Server issues tokens or grants authorization to the Consumption Device to access the user's resources.\u00b6\n\n#### 3.1.2. Backchannel-Transferred Session Pattern\n\nThe Client Initiated Backchannel Authentication [CIBA] transfers the session\non the backchannel with the Authorization Server to request authorization on\nthe Authorization Device. The figure below shows an example of this flow.\u00b6\n\n    \n    \n    (B) Backchannel Authorization +--------------+ Request +---------------+ (A)User +---| Consumption |<--------------------->| | Start | | Device |(E) Grant Authorization| Authorization | Flow +-->| |<--------------------->| Server | +--------------+ | | | | | | | | | | (D)User | | Authorize +--------------+ | | Action +---| Authorization| | | | | Device |<--------------------->| | +-->| |(C) Request User | | | | Authorization | | +--------------+ +---------------+\n\nFigure 2: Cross-Device Flows: Backchannel-Transferred Session Pattern\n\n  * (A) The user takes an action on the Consumption Device by starting a purchase, adding a device to a network or connecting a service to the Consumption Device.\u00b6\n  * (B) The client on the Consumption Device requests user authorization on the backchannel from the Authorization Server.\u00b6\n  * (C) The Authorization Server requests the authorization from the user on the user's Authorization Device.\u00b6\n  * (D) The user authenticates to the Authorization Server before using their device to grant authorization.\u00b6\n  * (E) The Authorization Server issues tokens or grants authorization to the Consumption Device to access the user's resources.\u00b6\n\nThe Authorization Server may use a variety of mechanisms to request user\nauthorization, including a push notification to a dedicated app on a mobile\nphone, or sending a text message with a link to an endpoint where the user can\nauthenticate and authorize an action.\u00b6\n\n#### 3.1.3. User-Transferred Authorization Data Pattern\n\nExamples of the user-transferred authorization data pattern include flows in\nwhich the Consumption Device requests the Authorization Server to send\nauthorization data (e.g., a 6 digit authorization code in a text message or\ne-mail) to the Authorization Device. Once the Authorization Device receives\nthe authorization data, the user enters it on the Consumption Device. The\nConsumption Device sends the authorization data back to the Authorization\nServer for validation before gaining access to the user's resources. The\nfigure below shows an example of this flow.\u00b6\n\n    \n    \n    (B) Backchannel Authorization +--------------+ Request +---------------+ (A)User +---| Consumption |<--------------------->| | Start | | Device |(E) Grant Authorization| Authorization | Flow +-->| |<--------------------->| Server | +--------------+ | | ^ | | | (D)User Enters | | | Authorization Data | | | | | | | | +--------------+ | | | Authorization| | | | Device |<--------------------->| | | |(C) Send Authorization | | | | Data | | +--------------+ +---------------+\n\nFigure 3: Cross-Device Flow: User-Transferred Authorization Data Pattern\n\n  * (A) The user takes an action on the Consumption Device by starting a purchase, adding a device to a network or connecting a service to the Consumption Device.\u00b6\n  * (B) The client on the Consumption Device requests user authorization on the backchannel from the Authorization Server.\u00b6\n  * (C) The Authorization Server sends authorization data (e.g., a 6 digit authorization code) to the Authorization Device.\u00b6\n  * (D) The user enters the authorization data (e.g., the 6 digit authorization code) on the Consumption Device.\u00b6\n  * (E) The Authorization Server issues tokens or grants authorization to the Consumption Device to access the user's resources.\u00b6\n\nThe Authorization Server may choose to authenticate the user before sending\nthe authorization data. The authorization data may be delivered as a text\nmessage or through a mobile application.\u00b6\n\n### 3.2. Cross-Device Session Transfer\n\nSession transfer flows enable a user to transfer access to a service or\nnetwork from a device on which the user is already authenticated to a second\ndevice such as a mobile phone. In these flows, the user is authenticated and\nthen authorizes the session transfer on one device, referred to as the\nAuthorization Device (e.g., a personal computer, web portal or application),\nand transfers the session to the device where they will continue to consume\nthe session, referred to as the Consumption Device (e.g., a mobile phone or\nportable device).\u00b6\n\nThe session transfer preserves state information, including authentication\nstate, at the second device to avoid additional configuration and optimize the\nuser experience. These flows are often used to add new devices to a network,\nonboard customers to a mobile application, or provision new credentials (e.g.,\n[OpenID.SIOPV2]).\u00b6\n\n#### 3.2.1. Cross-Device Session Transfer Pattern\n\nIn this flow, the user is authenticated and starts the flow by authorizing the\ntransfer of the session on the Authorization Device. The Authorization Device\nrequests a session transfer code that may be rendered as a QR code on the\nAuthorization Device. When the user scans the QR code or enters it on the\nConsumption Device where they would like the session to continue, the\nConsumption Device presents it to the Authorization Server. The Authorization\nServer then transfers the session to the Consumption Device. This may include\ntransferring authentication and authorization state to optimize the user\nexperience. This type of flow is used, for example, for adding new devices to\nnetworks, bootstrapping new applications, or provisioning new credentials. The\nPre-Authorized Code Flow in ([OpenID.VCI]) is an instance of using this\npattern to provision a new credential. The figure below shows a typical flow.\u00b6\n\n    \n    \n    (B) Session Transfer +--------------+ Request +---------------+ (A)User +---| Authorization|---------------------->| | Start | | Device |(C) Session Transfer | | Flow | | | Code | Authorization | +-->| |<----------------------| Server | +--------------+ | | | | | | (D) Scan QR code | | | or enter | | | Session Transfer Code | | | | | v (E) Present Session | | +--------------+ Transfer Code | | | Consumption |---------------------->| | (G)User +---| Device | | | Resumes | | | (F) Return Session | | Session | | | Context | | +-->| |<----------------------| | +--------------+ +---------------+\n\nFigure 4: Cross-Device Flows: Session Transfer Pattern\n\n  * (A) The user is authenticated on the Authorization Device and authorizes the transfer of the session to the Consumption device.\u00b6\n  * (B) The client on the Authorization Device requests a session transfer code from the Authorization Server.\u00b6\n  * (C) The Authorization Server responds with a session transfer code, which may be rendered as a QR code on the Authorization Device.\u00b6\n  * (D) The user scans the QR code with the Consumption Device (e.g., their mobile phone), or enters the session transfer code on the target Consumption Device.\u00b6\n  * (E) The client on the Consumption Device presents the session transfer code to the Authorization Server.\u00b6\n  * (F) The Authorization Server verifies the session transfer code and retrieves the session context information needed to resume the session on the Consumption Device.\u00b6\n  * (G) The user resumes the session and is able to access the information on the Consumption Device that they authorized on the Authorization Device.\u00b6\n\n### 3.3. Examples of Cross-Device Flows\n\nExamples of cross-device flow scenarios include:\u00b6\n\n#### 3.3.1. Example A1: Authorize Access to a Video Streaming Service (User-\nTransferred Session Data Pattern)\n\nAn end-user sets up a new smart TV and wants to connect it to their favorite\nstreaming service. The TV displays a QR code that the user scans with their\nmobile phone. The user is redirected to the streaming service provider's web\npage and asked to enter their credentials to authorize the smart TV to access\nthe streaming service. The user enters their credentials and grants\nauthorization, after which the streaming service is available on the smart\nTV.\u00b6\n\n#### 3.3.2. Example A2: Authorize Access to Productivity Services (User-\nTransferred Session Data Pattern)\n\nAn employee wants to access their files on an interactive whiteboard in a\nconference room. The interactive whiteboard displays a URL and a code. The\nuser enters the URL on their personal computer and is prompted for the code.\nOnce they enter the code, the user is asked to authenticate and authorize the\ninteractive whiteboard to access their files. The user enters their\ncredentials and authorizes the transaction and the interactive whiteboard\nretrieves their files and allows the user to interact with the content.\u00b6\n\n#### 3.3.3. Example A3: Authorize Use of a Bike Sharing Scheme (User-\nTransferred Session Data Pattern)\n\nAn end-user wants to rent a bicycle from a bike sharing scheme. The bicycles\nare locked in bicylce racks on sidewalks throughout a city. To unlock and use\na bicycle, the user scans a QR code on the bicycle using their mobile phone.\nScanning the QR code redirects the user to the bicycle sharing scheme's\nauthorization page where the user authenticates and authorizes payment for\nrenting the bicycle. Once authorized, the bicycle sharing service unlocks the\nbicycle, allowing the user to use it to cycle around the city.\u00b6\n\n#### 3.3.4. Example A4: Authorize a Financial Transaction (Backchannel-\nTransferred Session Pattern)\n\nAn end-user makes an online purchase. Before completing the purchase, they get\na notification on their mobile phone, asking them to authorize the\ntransaction. The user opens their app and authenticates to the service before\nauthorizing the transaction.\u00b6\n\n#### 3.3.5. Example A5: Add a Device to a Network (Session Transfer Pattern)\n\nAn employee is issued with a personal computer that is already joined to a\nnetwork. The employee wants to add their mobile phone to the network to allow\nit to access corporate data and services (e.g., files and e-mail). The\nemployee is logged-in on the personal computer where they initiate the process\nof adding their mobile phone to the network. The personal computer displays a\nQR code which authorizes the user to join their mobile phone to the network.\nThe employee scans the QR code with their mobile phone and the mobile phone is\njoined to the network. The employee can start accessing corporate data and\nservices on their mobile device.\u00b6\n\n#### 3.3.6. Example A6: Remote Onboarding (User-Transferred Session Data\nPattern)\n\nA new employee is directed to an onboarding portal to provide additional\ninformation to confirm their identity on their first day with their new\nemployer. Before activating the employee's account, the onboarding portal\nrequests that the employee present a government issued ID, proof of a\nbackground check and proof of their qualifications. The onboarding portal\ndisplays a QR code, which the user scans with their mobile phone. Scanning the\nQR code invokes the employee's digital wallet on their mobile phone, and the\nemployee is asked to present digital versions of an identity document (e.g., a\ndriving license), proof of a background check by an identity verifier, and\nproof of their qualifications. The employee authorizes the release of the\ncredentials and after completing the onboarding process, their account is\nactivated.\u00b6\n\n#### 3.3.7. Example A7: Application Bootstrap (Session Transfer Pattern)\n\nAn employee is signed into an application on their personal computer and wants\nto bootstrap the mobile application on their mobile phone. The employee\ninitiates the cross-device flow and is shown a QR code in their application.\nThe employee launches the mobile application on their phone and scans the QR\ncode which results in the user being signed into the application on the mobile\nphone.\u00b6\n\n#### 3.3.8. Example A8: Access a Productivity Application (User-Transferred\nAuthorization Data Pattern)\n\nA user is accessing a Computer Aid Design (CAD) application. When accessing\nthe application, authorization data in the form of a 6 digit authorization\ncode is sent to the user's mobile phone. The user views the 6 digit\nauthorization code on their phone and enters it in the CAD application, after\nwhich the CAD application displays the user's most recent designs.\u00b6\n\n#### 3.3.9. Example A9: Administer a System (Backchannel-Transferred Session\nPattern)\n\nA network administrator wants to access an adminstration portal used to\nconfigure network assets and deploy new applications. When attempting to\naccess the service, the network administrator receives a notification in an\napp on their mobile device, requesting them to confirm access to the portal.\nThe network administrator approves the request on their mobile phone and is\ngranted access to the portal.\u00b6\n\n## 4\\. Cross-Device Flow Exploits\n\nAttackers exploit the absence of an authenticated channel between the two\ndevices used in a cross-device flow by using social engineering techniques\ntypicaly used in phishing attacks.\u00b6\n\nIn cross-device authorization flows the attacker uses these social engineering\ntechniques by changing the context in which the authorization request is\npresented to convince the user to grant authorization when they shouldn't.\nThese attacks are also known as Cross-Device Consent Phishing (CDCP) attacks.\u00b6\n\nIn cross-device session transfer flows the attacker uses these social\nengineering techniques to convince the user to initiate a session transfer and\nsend them a session transfer code. Once the attacker is in posession of this\nsession transfer code, they present it to the Authorization Server to transfer\nthe session and access the users resources. These attacks are referred to as\nCross-Device Session Phishing (CDSP) attacks.\u00b6\n\n### 4.1. Cross-Device Authorization Flow Exploits\n\nAttackers exploit cross-device authorization flows by initiating an\nauthorization flow on the Consumption Device and then use social engineering\ntechniques to change the context in which the request is presented to the user\nin order to convince them to grant authorization on the Authorization Device.\nThe attacker is able to change the context of the authorization request\nbecause the channel between the Consumption Device and the Authorization\nDevice is unauthenticated. These attacks are also known as Cross-Device\nConsent Phishing (CDCP) attacks.\u00b6\n\n#### 4.1.1. User-Transferred Session Data Pattern Exploits\n\nA common action in cross-device flows is to present the user with a QR code or\na user code on the Consumption Device (e.g., Smart TV) which is then scanned\nor entered on the Authorization Device (the mobile phone). When the user scans\nthe code or copies the user code, they do so without any proof that the QR\ncode or user code is being displayed in the place or context intended by the\nservice provider. It is up to the user to decide whether they should trust the\nQR code or user code. In effect the user is asked to compensate for the\nabsence of an authenticated channel between the Consumption Device (e.g.,\nsmart TV) and the Authorization Device (e.g., the mobile phone).\u00b6\n\nAttackers exploit this absence of an authenticated channel between the two\ndevices by obtaining QR codes or user codes (e.g., by initiating the\nauthorization flows). They then use social engineering techniques to change\nthe context in which authorization is requested to convince end-users to scan\nthe QR code or enter it on their Authorization Device (e.g., mobile phone).\nOnce the end-user performs the authorization on the mobile device, the\nattacker who initiated the authentication or authorization request obtains\naccess to the users resources. The figure below shows an example of such an\nattack.\u00b6\n\n    \n    \n    (B) Consumption Device +--------------+ Get QR/User Code +---------------+ | Attacker's |<--------------------->| | | Consumption |(G) Grant Authorization| Authorization | | Device |<--------------------->| Server | +--------------+ | | ^ | (C) Attacker Copy | | (A) Attacker | | QR or User Code | | Start | | | | Flow | V | | +--------------+ | | | | | | | Attacker | | | | | (D) Attacker Change | | | | QR Code/User Code | | | | Context | | +--------------+ | | | (E) User is convinced by the | | | attacker and scans QR code| | | or enters User Code | | v | | +--------------+ | | | End User | | | | Authorization| | | | Device |<--------------------->| | | |(F) User Authenticates | | | | and Authorize Access | | +--------------+ +---------------+\n\nFigure 5: Cross-Device Consent Phishing: User-Transferred Session Data Pattern\nExploits\n\n  * (A) The attacker initiates the protocol on the Consumption Device (or mimicks the Consumption Device) by starting a purchase, adding a device to a network or connecting a service to the Consumption Device.\u00b6\n  * (B) The Consumption Device retrieves a QR code or user code from an Authorization Server.\u00b6\n  * (C) The attacker copies the QR code or user code.\u00b6\n  * (D) The attacker changes the context in which the QR code or user code is displayed in such a way that the user is likely to scan the QR code or use the user code when completing the authorization. For example, the attacker could craft an e-mail that includes the user code or QR code and send it to the user. The e-mail might encourage the user to scan the QR code or enter the user code by suggesting that doing so would grant them a reward through a loyalty program or prevent the loss of their data.\u00b6\n  * (E) The QR code or user code is displayed to the user in a context chosen by the attacker. The user is convinced by the attacker's effort and scans the QR code or enters the user code on the Authorization Device.\u00b6\n  * (F) The user authenticates to the Authorization Server before granting authorization.\u00b6\n  * (G) The Authorization Server issues tokens or grants authorization to the Consumption Device, which is under the attacker's control, to access the user's resources. The attacker gains access to the resources and any authorization artifacts (like access and refresh tokens) which may be used in future exploits.\u00b6\n\n#### 4.1.2. Backchannel-Transferred Session Pattern Exploits\n\nIn the backchannel-transferred session pattern, the client requests the\nauthorization server to authenticate the user and obtain authorization for an\naction. This may happen as a result of user interaction with the Consumption\nDevice, but may also be triggered without the users direct interaction with\nthe Consumption Device, resulting in an authorization request presented to the\nuser without context of why or who triggered the request.\u00b6\n\nAttackers exploit this lack of context by using social engineering techniques\nto prime the user for an authorization request and thereby convince them to\ngranting authorization. The social engineering techniques range in\nsophistication from messages misrepresenting the reason for receiving an\nauthorization request, to triggering a large volume of requests at an\ninconvenient time for the user, in the hope that the user will grant\nauthorization to make the requests stop. The figure below shows an example of\nsuch an attack.\u00b6\n\n    \n    \n    (C) Backchannel Authorization +--------------+ Request +---------------+ | Attacker's |<--------------------->| | | Consumption |(F) Grant Authorization| Authorization | | Device |<--------------------->| Server | +--------------+ | | ^ | | (B) Attacker | | | Starts | | | Flow | | | +--------------+ | | | | | | | Attacker | | | | | | | | | | | | | | | +--------------+ | | | (A) Attacker Sends | | | Social Engineering | | | Message to User | | | | | (E)User v | | Authorize +--------------+ | | Action +---| Authorization| | | | | Device |<--------------------->| | +-->| |(D) Request User | | | | Authorization | | +--------------+ +---------------+\n\nFigure 6: Cross-Device Consent Phishing: Backchannel-Transferred Session\nPattern Exploits\n\n  * (A) The attacker sends a social engineering message to prepare the user for the upcoming authorization (optional).\u00b6\n  * (B) The attacker initiates the protocol on the Consumption Device (or by mimicking the Consumption Device) by starting a purchase, adding a device to a network or accessing a service on the Consumption Device.\u00b6\n  * (C) The client on the Consumption Device requests user authorization on the backchannel from the Authorization Server.\u00b6\n  * (D) The Authorization Server requests the authorization from the user on the user's device.\u00b6\n  * (E) The user authenticates to the authorization server before granting authorization on their device.\u00b6\n  * (G) The Authorization Server issues tokens or grants authorization to the Consumption Device, which is under the attacker's control. The attacker gains access to the user's resources and possibly any authorization artifacts like access and refresh tokens.\u00b6\n\n#### 4.1.3. User-Transferred Authorization Data Pattern Exploits\n\nIn cross-device flows that follow the user-transferred authorization data\npattern, the client on the Consumption Device initiates the authorization\nrequest, but the user still has to transfer the authorization data to the\nConsumption Device. The authorization data may take different forms, including\na numerical value such as a 6 digit authorization code. The authorization\nrequest may happen as a result of user interaction with the Consumption\nDevice, but may also be triggered without the user's direct interaction with\nthe Consumption Device.\u00b6\n\nAttackers exploit the user-transferred authorization data pattern by combining\nthe social engineering techniques used to set context for users and convincing\nusers to providing them with authorization data sent to their Authorization\nDevices (e.g., mobile phones). These attacks are very similar to phishing\nattacks, except that the attacker also has the ability to trigger the\nauthorization request to be sent to the user directly by the Authorization\nServer.\u00b6\n\n    \n    \n    (C) Backchannel Authorization +--------------+ Request +---------------+ | Attacker's |<--------------------->| | | Consumption |(G) Grant Authorization| Authorization | | Device |<--------------------->| Server | +--------------+ | | ^ ^ | | (B) Attacker | | (F) Attacker Forwards | | Starts | | Authorization Data | | Flow | | | | +--------------+ | | | | | | | Attacker | | | | | | | | | | | | | | | +--------------+ | | (A) Attacker | ^ (E) User | | Sends | | Sends | | Social | | Authorization Data | | Engineering | | | | Message | | | | v | | | +--------------+ | | | Authorization| | | | Device |<--------------------->| | | |(D) Send Authorization | | | | Data | | +--------------+ +---------------+\n\nFigure 7: Cross-Device Consent Phishing: User-Transferred Authorization Data\nPattern Exploits\n\n  * (A) The attacker sends a social engineering message to prime the user for the authorization request they are about to receive, including instructions on what to do with the authorization data once they receive it.\u00b6\n  * (B) The attacker initiates the protocol on the Consumption Device (or by mimicking the Consumption Device) by starting a purchase, adding a device to a network or accessing a service on the Consumption Device.\u00b6\n  * (C) The client on the Consumption Device requests user authorization on the backchannel from the Authorization Server.\u00b6\n  * (D) The Authorization Server sends authorization data (e.g., a 6 digit authorization code) to the user's Authorization Device (the authorization data may be presented as a QR code, or text message).\u00b6\n  * (E) The user is convinced by the social engineering message received in step (A) and forwards the authorization data (e.g., a 6 digit authorization code) to the attacker.\u00b6\n  * (F) The attacker enters the authorization data (e.g., a 6 digit authorization code) on the Consumption Device.\u00b6\n  * (G) The Authorization Server grants authorization and issues access and refresh tokens to the Consumption Device, which is under the attacker's control. On completion of the exploit, the attacker gains access to the user's resources.\u00b6\n\nThe unauthenticated channel may also be exploited in variations of the above\nscenario where the user (as opposed to the attacker) initiates the flow and is\nthen convinced using social engineering techniques into sending the\nauthorization data (e.g., a 6 digit authorization code) to the attacker. In\nthese flows, the user is already authenticated and they request authorization\ndata to transfer a session or obtain some other privilege such as joining a\ndevice to a network. The authorization data may be represented as a QR code or\ntext string (e.g., 6 digit authorization code). The attacker then proceeds to\nexploit the unauthenticated channel by using social engineering techniques to\nconvince the user to send the QR code or user code to the attacker. The\nattacker then use the authorization data to obtain the privileges that would\nhave been assigned to the user.\u00b6\n\n### 4.2. Cross-Device Session Transfer Exploits\n\nAttackers exploit cross-device session transfer flows by using social\nengineering techniques typically used in phishing attacks to convince the user\nto authorize the transfer of a session and then send the session transfer code\nor QR code to the attacker. The absence of an authenticated channel between\nthese two devices enables the attacker to use the session transfer code on\ntheir own device to obtain access to the session and access the users data.\nThese attacks are referred to as Cross-Device Session Phishing (CDSP)\nattacks.\u00b6\n\n    \n    \n    (C) Session Transfer +--------------+ Request +---------------+ (B)User +---| Authorization|---------------------->| | Start | | Device |(D) Session Transfer | | Flow | | | Code | Authorization | +-->| |<----------------------| Server | +--------------+ | | (A)Attacker ^ | | | Sends Social| | (E) User sends QR code | | Engineering | | or Session Transfer | | Message | v Code to Attacker | | +--------------+ | | | | | | | Attacker | | | | | | | | | | | | | | | +--------------+ | | (F)Attacker scans | | | QR code or enters| | | Session Transfer | | | Code v (G) Present Session | | +--------------+ Transfer Code | | | Attacker's |---------------------->| | (I) +---| Consumption | | | Attacker| | Device | (H) Return Session | | Resumes | | | Context | | Session +-->| |<----------------------| | +--------------+ +---------------+\n\nFigure 8: Cross-Device Flows: Session Transfer Pattern Exploit\n\n  * (A) The attacker sends a social engineering message to that convinces the user that they should authorize a session transfer including instructions on what to do with the QR code or session transfer code once they receive it.\u00b6\n  * (B) The user is authenticated on their Authorization Device and authorizes the transfer of the session to the Consumption Device.\u00b6\n  * (C) The client on the Authorization Device requests a session transfer code from the Authorization Server.\u00b6\n  * (D) The Authorization Server responds with a session transfer code, which may be rendered as a QR code on the Authorization Device.\u00b6\n  * (E) The user sends the QR code or session transfer code to the attacker, following the instructions they received in step (A).\u00b6\n  * (F) Once the attacker receives the QR code, they scan it or enter it on their own Consumption Device.\u00b6\n  * (G) The client on the Consumption Device presents the session transfer code to the Authorization Server.\u00b6\n  * (H) The Authorization Server verifies the session transfer code and retrieves the session context information needed to resume the session on the Consumption Device.\u00b6\n  * (I) The attacker resumes the session on their own Consumption Device and is able to access the information that the user authorized on their Authorization Device in step (B).\u00b6\n\n### 4.3. Examples of Cross-Device Flow Exploits\n\nThe following examples illustrate these attacks in practical settings and show\nhow the unauthenticated channel is exploited by attackers who can copy the QR\ncodes and user codes, change the context in which they are presented using\nsocial engineering techniques and mislead end-users into granting consent to\navail of services, access data and make payments.\u00b6\n\n#### 4.3.1. Example B1: Illicit Access to a Video Streaming Service (User-\nTransferred Session Data Pattern)\n\nAn attacker obtains a smart TV and attempts to access an online streaming\nservice. The smart TV obtains a QR code from the authorization server and\ndisplays it on screen. The attacker copies the QR code and embeds it in an\ne-mail that is sent to a large number of recipients. The e-mail contains a\nmessage stating that the streaming service wants to thank them for their loyal\nsupport and by scanning the QR code, they will be able to add a bonus device\nto their account for no charge. One of the recipients open the e-mail and scan\nthe QR code to claim the loyalty reward. The user performs multi-factor\nauthentication, and when asked if they want a new device to be added to their\naccount, they authorize the action. The attacker's device is now authorized to\naccess the content and obtains an access and refresh token. The access token\nallows the attacker to access content and the refresh token allows the\nattacker to obtain fresh tokens whenever the access token expires.\u00b6\n\nThe attacker scales up the attack by emulating a new smart TV, obtaining\nmultiple QR codes and widening the audience it sends the QR code to. Whenever\na recipient scans the QR code and authorizes the addition of a new device, the\nattacker obtains an access and refresh token, which they sell for a profit.\u00b6\n\n#### 4.3.2. Example B2: Illicit Access to Productivity Services (User-\nTransferred Session Data Pattern)\n\nAn attacker emulates an enterprise application (e.g., an interactive\nwhiteboard) and initiates a cross-device flow by requesting a user code and\nURL from the authorization server. The attacker obtains a list of potential\nvictims and sends an e-mail informing users that their files will be deleted\nwithin 24 hours if they don't follow the link, enter the user code and\nauthenticate. The e-mail reminds them that this is the third time that they\nhave been notified and their last opportunity to prevent deletion of their\nwork files. One or more employees respond by following the URL, entering the\ncode and performing multi-factor authentication. Throughout the authentication\nexperience, the user is interacting with a trusted user experience, re-\nenforcing the legitimacy of the request. Once these employees authorized\naccess, the attacker obtains access and refresh tokens from the authorization\nserver and uses it to access the users' files, perform lateral attacks to\nobtain access to other information and continuously refresh the session by\nrequesting new access tokens. These tokens may be exfiltrated and sold to\nthird parties.\u00b6\n\n#### 4.3.3. Example B3: Illicit Access to Physical Assets (User-Transferred\nSession Data Pattern)\n\nAn attacker copies a QR code from a bicycle locked in a bicycle rack in a\ncity, prints it on a label and places the label on a bicycle at the other end\nof the bicycle rack. A customer approaches the bicycle that contains the\nreplicated QR code and scans the code and authenticates before authorizing\npayment for renting the bicycle. The bicycle rack unlocks the bicycle\ncontaining the original QR code and the attacker removes the bicycle before\ncycling down the street while the customer is left frustrated that the bicycle\nthey were trying to use is not being unlocked [NYC.Bike]. The customer\nproceeds to unlock another bicycle and lodges a complaint with the bicycle\nrenting company.\u00b6\n\n#### 4.3.4. Example B4.1: Illicit Transaction Authorization (Backchannel-\nTransferred Session Pattern)\n\nAn attacker obtains a list of user identifiers for a financial institution and\ntriggers a transaction request for each of the users on the list. The\nfinancial institution's authorization server sends push notifications to each\nof the users, requesting authorization of a transaction. The vast majority of\nusers ignore the request to authorize the transaction, but a small percentage\ngrants authorization by approving the transaction.\u00b6\n\n#### 4.3.5. Example B4.2: Fake Helpdesk (Backchannel-Transferred Session\nPattern)\n\nAn attacker obtains the contact information for a user and contacts them,\npretending to be a representative of the user's financial institution. The\nattacker informs the user that there were a number of fraudulent transactions\nagainst their account and asks them to review these transactions by approving\nor rejecting them. The attacker then triggers a sequence of transactions. The\nuser receives an authorization request for each transaction and declines them\nas they do not recognize them. The attacker then informs the user that they\nneed to close the users account and transfer all the funds to a new account to\nprevent further fraudulent transactions. The user receives another\nauthorization request which they approve, or provide additional authorization\ninformation to the attacker which enables the attacker to complete their\nattack and defraud the user.\u00b6\n\n#### 4.3.6. Example B5: Illicit Network Join (Session Transfer Pattern\nExploit)\n\nAn attacker creates a message to all employees of a company, claiming to be\nfrom a trusted technology provider investigating a suspected security breach.\nThey ask employees to send them the QR code typically used to join a new\ndevice to the network, along with detailed steps on how to obtain the QR code.\nThe employee, eager to assist, initiates the process to add a new mobile\ndevice to the network. They authenticate to the network and obtain a QR code.\nThey send the QR code to the attacker. The attacker scans the QR code and adds\ntheir own device to the network. They use this device access as an entry point\nand perform lateral moves to obtain additional privileges and access to\nrestricted resources.\u00b6\n\n#### 4.3.7. Example B6: Illicit Onboarding (User-Transferred Session Data\nPattern)\n\nAn attacker initiates an employee onboarding flow and obtains a QR code from\nthe onboarding portal to invoke a digital wallet and present a verifiable\ncredential attesting to a new employee's identity. The attacker obtains a list\nof potential new employees and sends an e-mail informing them that it is time\nto present proof of their background check or government issued ID. The new\nemployee scans the QR code, invokes their digital wallet and presents their\ncredentials. Once the credentials are presented, the employee's account is\nactivated. The employee portal accessed by the attacker to obtain the QR code\ndisplays a message to the attacker with instructions on how to access their\naccount.\u00b6\n\n#### 4.3.8. Example B7: Illicit Application Bootstrap (Session Transfer\nPattern Exploit)\n\nAn attacker creates a message to all employees of a company, claiming to be\nfrom the company's IT service provider. They claim that they are trying to\nresolve an application performance issue and ask employees to send them the QR\ncode typically used to transfer a session. The employee, eager to assist,\ninitiates the process to transfer a session. They authenticate and obtain a QR\ncode and then send the QR code to the attacker. The attacker scans the QR code\nwith their mobile phone and access the users data and resources.\u00b6\n\n#### 4.3.9. Example B8: Account Takeover (User-Transferred Session Data\nPattern)\n\nAn attacker wants to use some website which requires presentation of a\nverifiable credential for authentication. The attacker creates a phishing\nwebsite which will in real time capture log-in QR Codes from the original\nwebsite and present these to the user. The attacker tries to get the user to\nuse the phishing website using an e-mail campaign etc. The user scans the QR\ncode on the phishing website, invokes their digital wallet and presents their\ncredentials. Once the credentials are presented, the original session from the\nattackers device is authorized with the user's credentials.\u00b6\n\n#### 4.3.10. Example B9: Illicit Access to Administration Capabilities Through\nConsent Request Overload (Backchannel-Transferred Session Pattern)\n\nAn attacker attempts to access an adminstration portal repeatedly, generating\na stream of authorization requests to the network administrator. The attempts\nare timed to occur while the administrator is asleep. The administrator is\nwoken by the incoming requests on their phone, and, in an attempt to stop the\nnotifications, they accidentally approve access and the attacker gains access\nto the portal.\u00b6\n\n#### 4.3.11. Out of Scope\n\nIn all of the attack scenarios listed above, a user is misled or exploited.\nFor other attacks, where the user is willingly colluding with the attacker,\nthe threat model, security implications and potential mitigations are very\ndifferent. For example, a cooperating user can bypass software mitigations on\ntheir device, share access to hardware tokens with the attacker, and install\nadditional devices to forward radio signals to circumvent proximity checks.\u00b6\n\nThis document only considers scenarios where a user does not collude with an\nattacker.\u00b6\n\n## 5\\. Cross-Device Protocols and Standards\n\nCross-device flows that are subject to the attacks described earlier typically\nshare the following characteristics:\u00b6\n\n  1. The attacker can initiate the flow and manipulate the context of an authorization request. E.g., the attacker can obtain a QR code or user code, or can request an authentication/authorization decision from the user.\u00b6\n  2. The interaction between the Consumption Device and Authorization Device is unauthenticated. I.e., it is left to the user to decide if the QR code, user code, or authentication request is being presented in a legitimate context.\u00b6\n\nA number of protocols that have been standardized, or are in the process of\nbeing standardized that share these characteristics include:\u00b6\n\n  * IETF OAuth 2.0 Device Authorization Grant ([RFC8628]): A standard to enable authorization on devices with constrained input capabilities (smart TVs, printers, kiosks). In this protocol, the user code or QR code is displayed on the Consumption Device and entered on a second device (e.g., a mobile phone).\u00b6\n\n  * Open ID Foundation Client Initiated Back-Channel Authentication (CIBA) [CIBA]: A standard developed in the OpenID Foundation that allows a device or service (e.g., a personal computer, Smart TV, Kiosk) to request the OpenID Provider to initiate an authentication flow if it knows a valid identifier for the user. The user completes the authentication flow using a second device (e.g., a mobile phone). In this flow the user does not scan a QR code or obtain a user code from the Consumption Device, but is instead contacted by the OpenID Provider to complete the authentication using a push notification, e-mail, text message or any other suitable mechanism.\u00b6\n\n  * OpenID for Verifiable Credential Protocol Suite (Issuance, Presentation): The OpenID for Verifiable Credentials enables cross-device scenarios by allowing users to scan QR codes to retrieve credentials (Issuance - see [OpenID.VCI]) or present credentials (Presentation - see [OpenID.VP]). The QR code is presented on a device that initiates the flow.\u00b6\n\n  * Self-Issued OpenID Provider v2 (SIOP V2): A standard that allows end-user to present self-attested or third party attested attributes when used with OpenID for Verifiable Credential protocols. The user scans a QR code presented by the relying party to initiate the flow.\u00b6\n\nCross-device protocols SHOULD not be used for same-device scenarios. If the\nConsumption Device and Authorization Device are the same device, protocols\nlike OpenID Connect Core [OpenID.Core] and OAuth 2.0 Authorization Code Grant\nas defined in [RFC6749] are more appropriate. If a protocol supports both\nsame-device and cross-device modes (e.g., [OpenID.SIOPV2]), the cross-device\nmode SHOULD not be used for same-device scenarios. If an implementor decides\nto use a cross-device protocol or a protocol with a cross-device mode in a\nsame-device scenario, the mitigations recommended in this document SHOULD be\nimplemented to reduce the risks that the unauthenticated channel is\nexploited.\u00b6\n\n## 6\\. Mitigating Against Cross-Device Flow Attacks\n\nThe unauthenticated channel between the Consumption Device and the\nAuthorization Device allows attackers to change the context in which the\nauthorization request is presented to the user. This shifts responsibility of\nauthenticating the channel between the two devices to the end-user. End-users\nhave \"expertise elsewhere\" and are typically not security experts and don't\nunderstand the protocols and systems they interact with. As a result, end-\nusers are poorly equipped to authenticate the channel between the two devices.\nMitigations should focus on:\u00b6\n\n  1. Minimizing reliance on the user to make decisions to authenticate the channel.\u00b6\n  2. Providing better information with which to make decisions to authenticate the channel.\u00b6\n  3. Recovering from incorrect channel authentication decisions by users.\u00b6\n\nTo achieve the above outcomes, mitigating against Cross-Device Consent\nPhishing attacks require a three-pronged approach:\u00b6\n\n  1. Reduce risks of deployed protocols with practical mitigations.\u00b6\n  2. Adopt or develop protocols that are less susceptible to these attacks where possible.\u00b6\n  3. Provide analytical tools to assess vulnerabilities and effectiveness of mitigations.\u00b6\n\n### 6.1. Practical Mitigations\n\nA number of protocols that enable cross-device flows that are susceptible to\nCross-Device Consent Phishing attacks are already deployed. The security\nprofile of these protocols can be improved through practical mitigations that\nprovide defense in depth that either:\u00b6\n\n  1. Prevents the attack from being initiated.\u00b6\n  2. Disrupts the attack once it is initiated.\u00b6\n  3. Remediates or reduces the impact if the attack succeeds.\u00b6\n\nIt is RECOMMENDED that one or more of the mitigations are applied whenever\nimplementing a cross-device flow. Every mitigation provides an additional\nlayer of security that makes it harder to initiate the attack, disrupts\nattacks in progress or reduces the impact of a successful attack.\u00b6\n\n#### 6.1.1. Establish Proximity\n\nThe unauthenticated channel between the Consumption Device and Authorization\nDevice allows attackers to obtain a QR code or user code in one location and\ndisplay it in another location. Consequently, proximity-enforced cross-device\nflows are more resistant to Cross-Device Consent Phishing attacks than\nproximity-less cross-device flows. Establishing proximity between the location\nof the Consumption Device and the Authorization Device limits an attacker's\nability to launch attacks by sending the user or QR codes to large numbers of\nusers that are geographically distributed. There are a couple of ways to\nestablish proximity:\u00b6\n\n  * Physical connectivity: This is a good indicator of proximity, but requires specific ports, cables and hardware and may be challenging from a user experience perspective or may not be possible in certain settings (e.g., when USB ports are blocked or removed for security purposes). Physical connectivity may be better suited to dedicated hardware like FIDO devices that can be used with protocols that are resistant to the exploits described in this document.\u00b6\n\n  * Wireless proximity: Near Field Communications (NFC), Bluetooth Low Energy (BLE), and Ultra Wideband (UWB) services can be used to prove proximity between the two devices. NFC technology is widely deployed in mobile phones as part of payment solutions, but NFC readers are less widely deployed. BLE presents another alternative for establishing proximity, but may present user experience challenges when setting up. UWB standards such as IEEE 802.15.4 and the IEEE 802.15.4z-2020 Amendment 1 enable secure ranging between devices and allow devices to establish proximity relative to each other [IEEE802154].\u00b6\n\n  * Shared network: Device proximity can be inferred by verifying that both devices are on the same network. This check may be performed by the authorization server by comparing the network addresses of the device where the code is displayed (Consumption Device) with that of the Authorization Device. Alternatively the check can be performed on the device, provided that the network address is available. This could be achieved if the authorization server encodes the Consumption Device's network address in the QR code and uses a digital signature to prevent tampering with the code. This does require the wallet to be aware of the countermeasure and effectively enforce it.\u00b6\n\n  * Geo-location: Proximity can be established by comparing geo-location information derived from global navigation satellite-system (GNSS) co-ordinates or geolocation lookup of IP addresses and comparing proximity. Due to inaccuracies, this may require restrictions to be at a more granular level (e.g., same city, country, region or continent). Similar to the shared network checks, these checks may be performed by the authorization server or on the users device, provided that the information encoded in a QR code is integrity protected using a digital signature.\u00b6\n\nDepending on the risk profile and the threat model in which a system is\noperating, it MAY be necessary to use more than one mechanism to establish\nproximity to raise the bar for any potential attackers.\u00b6\n\nNote: There are scenarios that require that an authorization takes place in a\ndifferent location than the one in which the transaction is authorized. For\nexample, there may be a primary and secondary credit card holder and both can\ninitiate transactions, but only the primary holder can authorize it. There is\nno guarantee that the primary and secondary holders are in the same location\nat the time of the authorization. In such cases, proximity (or lack of\nproximity) may be an indicator of risk and the system may deploy additional\ncontrols (e.g., transaction value limits, transaction velocity limits) or use\nthe proximity information as input to a risk management system.\u00b6\n\nLimitations: Proximity mechanisms make it harder to perform Cross-Device\nConsent Phishing (CDCP) attacks. However, depending on how the proximity check\nis performed, an attacker may be able to circumvent the protection: The\nattacker can use a VPN to simulate a shared network or spoof a GNSS position.\nFor example, the attacker can try to request the location of the end-user's\nAuthorization Device through browser APIs and then simulate the same location\non their Consumption Device using standard debugging features available on\nmany platforms.\u00b6\n\n#### 6.1.2. Short Lived/Timebound QR or User Codes\n\nThe impact of an attack can be reduced by making QR or user codes short lived.\nIf an attacker obtains a short lived code, the duration during which the\nunauthenticated channel can be exploited is reduced, potentially increasing\nthe cost of a successful attack.\u00b6\n\nLimitations: There is a practical limit to how short a user code can be valid\ndue to network latency and user experience limitations (time taken to enter a\ncode, or incorrectly entering a code). More sophisticated Cross-Device Consent\nPhishing attacks counter the effectiveness of short lived codes by convincing\na user to respond to a phishing e-mail and only request the QR or user code\nonce the user clicks on the link in the phishing e-mail [Exploit6].\u00b6\n\n#### 6.1.3. One-Time or Limited Use Codes\n\nBy enforcing one-time use or limited use of user or QR codes, the\nauthorization server can limit the impact of attacks where the same user code\nor QR code is sent to multiple victims. One-time use may be achieved by\nincluding a nonce or date-stamp in the user code or QR code which is validated\nby the authorization server when the user scans the QR code against a list of\npreviously issued codes.\u00b6\n\nLimitations: Enforcing one-time use may be difficult in large globally\ndistributed systems with low latency requirements, in which case short lived\ntokens may be more practical. One-time use codes may also have an impact on\nthe user experience. For example, a user may enter a code, but their session\nmay be interrupted before the access request is completed. If the code is a\none-time use code, they would need to restart the session and obtain a new\ncode since they won't be allowed to enter the same code a second time. To\navoid this, implementers MAY allow the same code to be presented a small\nnumber of times.\u00b6\n\n#### 6.1.4. Unique Codes\n\nBy issuing unique user or QR codes, an authorization server can detect if the\nsame codes are being repeatedly submitted. This may be interpreted as\nanomalous behavior and the authorization server MAY choose to decline issuing\naccess and refresh tokens if it detects the same codes being presented\nrepeatedly. This may be achieved by maintaining a deny list that contains QR\ncodes or user codes that were previously used. The authorization server MAY\nuse a sliding window equal to the lifetime of a token if short lived/timebound\ntokens are used (see Short Lived/Timebound Codes). This will limit the size of\nthe deny list.\u00b6\n\nLimitations: Maintaining a deny list of previously redeemed codes, even for a\nsliding window, may have an impact on the latency of globally distributed\nsystems. One alternative is to segment user codes by geography or region and\nmaintain local deny lists.\u00b6\n\n#### 6.1.5. Content Filtering\n\nAttackers exploit the unauthenticated channel by changing the context of the\nuser code or QR code and then sending a message to a user (e-mail, text,\ninstant messaging etc). By deploying content filtering (e.g., anti-spam\nfilter), these messages can be blocked and prevented from reaching the end-\nusers. It may be possible to fine-tune content filtering solutions to detect\nartefacts like QR codes or user codes that are included in a message that is\nsent to multiple recipients in the expectation that at least one of the\nrecipients will be convinced by the message and grant authorization to access\nrestricted resources.\u00b6\n\nLimitations: Some scenarios may require legitimate re-transmission of user, QR\nand authorization data (e.g., retries). To prevent the disruption of\nlegitimate scenarios, content filters may use a threshold and allow a limited\nnumber of messages with the same QR or user codes to be transmitted before\ninterrupting the delivery of those messages. Content filtering may also be\nfragmented across multiple communications systems and channels (e-mail,\nmessaging, text etc), making it harder to detect or interrupt attacks that are\nexecuted over multiple channels, unless here is a high degree of integration\nbetween content filtering systems.\u00b6\n\n#### 6.1.6. Detect and Remediate\n\nThe authorization server may be able to detect misuse of the codes due to\nrepeated use as described in Unique Codes, as an input from a content\nfiltering engine as described in Content Filtering, or through other\nmechanisms such as reports from end-users. If an authorization server\ndetermines that a user code or QR code is being used in an attack it may\nchoose to invalidate all tokens issued in response to these codes and make\nthat information available through a token introspection endpoint (see\n[RFC7662]). In addition it may notify resource servers to stop accepting these\ntokens or to terminate existing sessions associated with these tokens using\nContinuous Access Evaluation Protocol (CAEP) messages [CAEP] using the Shared\nSignals Framework (SSF) [SSF] framework or an equivalent notification system.\u00b6\n\nLimitations: Detection and remediation requires that resource servers are\nintegrated with security eventing systems or token introspection services.\nThis may not always be practical for existing systems and may need to be\ntargeted to the most critical resource services in an environment.\u00b6\n\n#### 6.1.7. Trusted Devices\n\nIf an attacker is unable to initiate the protocol, they are unable to obtain a\nQR code or user code that can be leveraged for the attacks described in this\ndocument. By restricting the protocol to only be executed on devices trusted\nby the authorization server, it prevents attackers from using arbitrary\ndevices, or by mimicking devices to initiate the protocol.\u00b6\n\nAuthorization Servers MAY use different mechanisms to establish which devices\nit trusts. This includes limiting cross-device flows to specific device types\nsuch as intractive whiteboards or smart TVs, pre-registering devices with the\nauthorization server or only allow cross-device flows on devices managed\nthrough device management systems. Device management systems may enforce\npolicies that govern patching, version updates, on-device anti-malware\ndeployment, revocation status and device location amongst others. Trusted\ndevices MAY have their identities rooted in hardware (e.g., a TPM or\nequivalent technology).\u00b6\n\nBy only allowing trusted devices to initiate cross-device flows, it requires\nthe attacker to have access to such a device and maintain access in a way that\ndoes not result in the device's trust status from being revoked.\u00b6\n\nLimitations: An attacker may still be able to obtain access to a trusted\ndevice and use it to initiate authorization requests, making it necessary to\napply additional controls and integrating with other threat detection and\nmanagement systems that can detect suspicious behaviour such as repeated\nrequests to initiate authorization or high volume of service activation on the\nsame device.\u00b6\n\n#### 6.1.8. Trusted Networks\n\nAn attacker can be prevented from initiating a cross-device flow protocol by\nonly allowing the protocol to be initiated on a trusted network or within a\nsecurity perimeter (e.g., a corporate network). A trusted network may be\ndefined as a set of IP addresses and joining the network is subject to\nsecurity controls managed by the network operator, which may include only\nallowing trusted devices on the network, device management, user\nauthentication and physical access policies and systems. By limiting protocol\ninitiation to a specific network, the attacker needs to have access to a\ndevice on the network.\u00b6\n\nLimitations: Network level controls may not always be feasible, especially\nwhen dealing with consumer scenarios where the network may not be under\ncontrol of the service provider. Even if it is possible to deploy network\nlevel controls, it SHOULD be used in conjunction with other controls outlined\nin this document to achieve defence in-depth.\u00b6\n\n#### 6.1.9. Limited Scopes\n\nAuthorization servers MAY choose to limit the scopes they include in access\ntokens issued through cross-device flows where the unauthenticated channel\nbetween two devices are susceptible to being exploited. Including limited\nscopes lessens the impact in case of a successful attack. The decision about\nwhich scopes are included may be further refined based on whether the protocol\nis initiated on a trusted device or the user's location relative to the\nlocation of the Consumption Device.\u00b6\n\nLimitations: Limiting scopes reduces the impact of a compromise, but does not\navoid it. It SHOULD be used in conjunction with other mitigations described in\nthis document.\u00b6\n\n#### 6.1.10. Short Lived Tokens\n\nAnother mitigation strategy includes limiting the life of the access and\nrefresh tokens. The lifetime can be lengthened or shortened, depending on the\nuser's location, the resources they are trying to access or whether they are\nusing a trusted device. Short lived tokens do not prevent or disrupt the\nattack, but serve as a remedial mechanism in case the attack succeeded.\u00b6\n\nLimitations: Short lived tokens reduces the time window during which an\nattacker can benefit from a successful attack. This is most effective for\naccess tokens. However, once an attacker obtains a refresh token, they can\ncontinue to request new access tokens, as well as refresh tokens. Forcing the\nexpiry of refresh tokens may cause the user to re-authorize an action more\nfrequently, which results in a negative user experience.\u00b6\n\n#### 6.1.11. Rate Limits\n\nAn attacker that engages in a scaled attack may need to request a large number\nof user codes (see exploit Example B1) or initiate a large number of\nauthorization requests (see exploit Example B4) in a short period of time. An\nauthorization server MAY apply rate limits to minimize the number of requests\nit would accept from a client in a limited time period.\u00b6\n\nLimitations: Rate limits are effective at slowing an attacker down and help to\ndegrade scaled attacks, but do not prevent more targeted attacks that are\nexecuted with lower volumes and velocity. Therefore, it should be used along\nwith other techniques to provide a defence-in-depth defence against cross-\ndevice attacks.\u00b6\n\n#### 6.1.12. Sender-Constrained Tokens\n\nSender-constrained tokens limit the impact of a successful attack by\npreventing the tokens from being moved from the device on which the attack was\nsuccessfully executed. This makes attacks where an attacker gathers a large\nnumber of access and refresh tokens on a single device and then sells them for\nprofit more difficult, since the attacker would also have to export the\ncryptographic keys used to sender-constrain the tokens or be able to access\nthem and generate signatures for future use. If the attack is being executed\non a trusted device to a device with anti-malware, any attempts to exfiltrate\ntokens or keys may be detected and the device's trust status may be changed.\nUsing hardware keys for sender-constraining tokens will further reduce the\nability of the attacker to move tokens to another device.\u00b6\n\nLimitations: Sender-constrained tokens, especially sender-constrained tokens\nthat require proof-of-posession, raise the bar for executing the attack and\nprofiting from exfiltrating tokens. Although a software proof-of-posession key\nis better than no proof-of-posession key, an attacker may still exfiltrate the\nsoftware key. Hardware keys are harder to exfiltrate, but come with additional\nimplementation complexity. An attacker that controls the Consumption Device\nmay still be able to excercise the key, even if it is in hardware.\nConsequently the main protection derived from sender-constrained tokens is\npreventing tokens from being moved from the Consumption Device to another\ndevice, thereby making it harder sell stolen tokens and profit from the\nattack.\u00b6\n\n#### 6.1.13. User Education\n\nResearch shows that user education is effective in reducing the risk of\nphishing attacks [Baki2023]. The service provider MAY educate users on the\nrisks of cross-device consent phishing and provide out-of-band reinforcement\nto the user on the context and conditions under which an authorization grant\nmay be requested. For example, if the service provider does not send e-mails\nwith QR codes requesting users to grant authorization, this may be reinforced\nin marketing messages and anti-fraud awareness campaigns. The service provider\nMAY also choose to reinforce these user education messages through in-app\nexperiences. In [PCRSM2023], it is proposed to advise users to verify the\ntrustworthiness of the source of a QR code, for instance by checking that the\nconnection is protected through TLS or by verifying that the URL really\nbelongs to the Authorization Server.\u00b6\n\nLimitations: Although user education helps to raise awareness and reduce the\noverall risk to users, it is insufficient on its own to mitigate cross-device\nconsent phishing attacks. In particular, carefully designed phishing attacks\ncan be practically indistinguishable from benign authorization flows even for\nwell-trained users. User education SHOULD therefore be used in conjunction\nwith other controls described in this document.\u00b6\n\n#### 6.1.14. User Experience\n\nThe user experience SHOULD preserve the context within which the protocols\nwere initiated and communicate this clearly to the user when they are asked to\nauthorize, authenticate or present a credential. In preserving the context, it\nshould be clear to the user who invoked the flow, why it was invoked and what\nthe consequence of completing the authorization, authentication or credential\npresentation is. The user experience SHOULD reinforce the message that unless\nthe user initiated the authorization request, or was expecting it, they should\ndecline the request.\u00b6\n\nThis information MAY be communicated graphically or in a simple message (e.g.,\n\"It looks like you are trying to access your files on a digital whiteboard in\nyour city center office. Click here to grant access to your files. If you are\nnot trying to access your files, you should decline this request and notify\nthe security department\").\u00b6\n\nIt SHOULD be clear to the user how to decline the request. To avoid accidental\nauthorization grants, the \"decline\" option SHOULD be the default option or\ngiven similar prominence in the user experience as the \"grant\" option.\u00b6\n\nIf the user uses an application on a mobile device to scan a QR code, the\napplication MAY display information advising the user under which conditions\nthey should expect to be asked to scan a QR code and under which circumstances\nthey should never scan a QR code (e.g., display a message that the QR code\nwill only be displayed on kiosks within trusted locations or on trusted\nwebsites hosted on a specific domain, and never in e-mail or other media and\nlocations).\u00b6\n\nThe user experience MAY include information to further educate the user on\ncross-device consent phishing attacks and reinforce the conditions under which\nauthorization grants may be requested.\u00b6\n\nLimitations: Improvements to user experience on their own is unlikely to be\nsufficient and SHOULD be used in conjunction with other controls described in\nthis document.\u00b6\n\n#### 6.1.15. Authenticate-then-Inititiate\n\nBy requiring a user to authenticate on the Consumption Device with a phishing\nresistant authentication method before initiating a cross-device flow, the\nserver can prevent an attacker from initiating a cross-device flow and\nobtaining QR codes or user codes. This prevents the attacker from obtaining a\nQR code or user code that they can use to mislead an unsuspecting user. This\nrequires that the Consumption Device has sufficient input capabilities to\nsupport a phishing resistant authentication mechanism, which may in itself\nnegate the need for a cross-device flow.\u00b6\n\nLimitations: Authenticating on the Consumption Device before starting a cross-\ndevice flow does not prevent the attacks described in Example B5: Illicit\nNetwork Join and Example B7: Illicit Session Transfer and it is RECOMMENDED\nthat additional mitigations described in this document is used if the cross-\ndevice flows are used in scenarios such as Example A5: Add a device to a\nnetwork and Example A7: Transfer a session.\u00b6\n\n#### 6.1.16. Request Initiation Verification\n\nThe user MAY be asked to verify if they initiated an authentication or\nauthorization request by sending a one-time password (OTP) or PIN to the\nuser's Authorization Device and asking them to enter it on the Consumption\nDevice to confirm the request. If the request was initiated without the users'\nconsent, they would receive an OTP or PIN out of context which may raise\nsuspicion for the user. In addition, they would not have information on where\nto enter the OTP or PIN. The user experience on the Authorization Device MAY\nreinforce the risk of receiving an out-of-context OTP or PIN and provide\ninformation to the user on how to report an unauthorized authentication or\nauthorization request.\u00b6\n\nLimitations: The additional verification step may reduce the overall usability\nof the system as it is one more thing users need to do right. Attackers may\ncombine traditional phishing attacks and target users who respond to those\nmessages with an interactive attack that sets the expectation with the user\nthat they will have to provide the OTP or PIN, in addition to granting\nauthorization for the request.\u00b6\n\n#### 6.1.17. Request Binding with Out-of-Band Data\n\nIn the User-Transferred Session Data Pattern, users MAY enter out-of-band\ninformation on the Consumption Device to start the authorization process. The\nout-of-band data entered by the user MAY then be included in the QR code which\nis displayed on the Consumption Device. When the QR code is scanned by the\nAuthorization Device, the out-of-band data is verified by the user or by the\nAuthorization Device. The out-of-band data could be any attribute that the\nuser or Authorization Device can retrieve during the authorization process.\nExamples include a serial number, one-time password or PIN, location or any\nother data that the user or the Authorization Device can recall or retrieve\nduring the authorization process ([MPRCS2020], [PCRSM2023]).\u00b6\n\nLimitations: A sophistacted attacker may include an additional step in their\nattack where they create a phishing attack that gathers the out-of-band data\nfrom the user before initiating the authorization request. The additional step\ncould also have a negative impact on the usability level of the solution.\u00b6\n\n#### 6.1.18. Practical Mitigation Summary\n\nThe practical mitigations described in this section can prevent the attacks\nfrom being initiated, disrupt attacks once they start or reduce the impact or\nremediate an attack if it succeeds. When combining one or more of these\nmitigations the overall security profile of a cross-device flow improves\nsignificantly. The following table provides a summary view of these\nmitigations:\u00b6\n\nTable 1Mitigation| Prevent| Disrupt| Recover  \n---|---|---|---  \nEstablish Proximity| X| X  \nShort Lived/Timebound Codes| X  \nOne-Time or Limited Use Codes| X  \nUnique Codes| X  \nContent Filtering| X  \nDetect and remediate| X  \nTrusted Devices| X  \nTrusted Networks| X  \nLimited Scopes| X  \nShort Lived Tokens| X  \nRate Limits| X| X  \nSender-Constrained Tokens| X  \nUser Education| X  \nUser Experience| X  \nAuthenticate-then-Inititiate| X  \nRequest Initiation Verification| X  \nRequest Binding with Out-of-Band Data| X  \n  \nTable: Practical Mitigation Summary\u00b6\n\n### 6.2. Protocol Selection\n\nSome cross-device protocols are more susceptible to the exploits described in\nthis document than others. In this section we will compare three different\ncross-device protocols in terms of their susceptibility to exploits focused on\nthe unauthenticated channel, the prerequisites to implement and deploy them,\nalong with guidance on when it is appropriate to use them.\u00b6\n\n#### 6.2.1. IETF OAuth 2.0 Device Authorization Grant [RFC8628]:\n\n##### 6.2.1.1. Description\n\nA standard to enable authorization on devices with constrained input\ncapabilities (smart TVs, printers, kiosks). In this protocol, the user code or\nQR code is displayed or made available on the Consumption Device (smart TV)\nand entered on a second device (e.g., a mobile phone).\u00b6\n\n##### 6.2.1.2. Susceptibility\n\nThere are several reports in the public domain outlining how the\nunauthenticated channel may be exploited to execute a Cross-Device Consent\nPhishing attack ([Exploit1], [Exploit2], [Exploit3], [Exploit4], [Exploit5],\n[Exploit6]).\u00b6\n\n##### 6.2.1.3. Device Capabilities\n\nThere are no assumptions in the protocol about underlying capabilities of the\ndevice, making it a \"least common denominator\" protocol that is expected to\nwork on the broadest set of devices and environments.\u00b6\n\n##### 6.2.1.4. Mitigations\n\nIn addition to the security considerations section in the standard, it is\nRECOMMENDED that one or more of the mitigations outlined in this document be\nconsidered, especially mitigations that can help establish proximity or\nprevent attackers from obtaining QR or user codes.\u00b6\n\n##### 6.2.1.5. When to use\n\nOnly use this protocol if other cross-device protocols are not viable due to\ndevice or system constraints. Avoid using if the protected resources are\nsensitive, high value, or business critical. Always deploy additional\nmitigations like proximity or only allow with pre-registered devices. Do not\nuse for same-device scenarios (e.g., if the Consumption Device and\nAuthorization Device is the same device).\u00b6\n\n#### 6.2.2. OpenID Foundation Client Initiated Back-Channel Authentication\n(CIBA):\n\n##### 6.2.2.1. Description\n\nClient Initiated Back-Channel Authentication (CIBA) [CIBA]: A standard\ndeveloped in the OpenID Foundation that allows a device or service (e.g., a\npersonal computer, Smart TV, Kiosk) to request the OpenID Provider to initiate\nan authentication flow if it knows a valid identifier for the user. The user\ncompletes the authentication flow using a second device (e.g., a mobile\nphone). In this flow the user does not scan a QR code or obtain a user code\nfrom the Consumption Device, but is instead contacted by the OpenID Provider\nto complete the authentication using a push notification, e-mail, text message\nor any other suitable mechanism.\u00b6\n\n##### 6.2.2.2. Susceptibility\n\nLess susceptible to unauthenticated channel attacks, but still vulnerable to\nattackers who know or can guess the user identifier and initiate an attack as\ndescribed in Example B4: Illicit Transaction Authorization.\u00b6\n\n##### 6.2.2.3. Device Capabilities\n\nThere is no requirement on the Consumption Device to support specific\nhardware. The Authorization Device must be registered/associated with the user\nand it must be possible for the Authorization Server to trigger an\nauthorization on this device.\u00b6\n\n##### 6.2.2.4. Mitigations\n\nIn addition to the security considerations section in the standard, it is\nRECOMMENDED that one or more of the mitigations outlined in this document be\nconsidered, especially mitigations that can help establish proximity or\nprevent attackers from initiating authorization requests.\u00b6\n\n##### 6.2.2.5. When to Use\n\nUse CIBA instead of Device Authorization Grant if it is possible for the\nConsumption Device to obtain a user identifier on the Consumption Device\n(e.g., through an input or selection mechanism) and if the Authorization\nServer can trigger an authorization on the Authorization Device. Do not use\nfor same-device scenarios (e.g., if the Consumption Device and Authorization\nDevice is the same device).\u00b6\n\n#### 6.2.3. FIDO2/WebAuthn\n\n##### 6.2.3.1. Description\n\nFIDO2/WebAuthn is a stack of standards developed in the FIDO Alliance and W3C\nrespectively which allow for origin-bound, phishing-resistant user\nauthentication using asymmetric cryptography that can be invoked from a web\nbrowser or native client. Version 2.2 of the FIDO Client to Authenticator\nProtocol (CTAP) supports a new cross-device authentication protocol, called\n\"hybrid\", which enables an external device, such as a phone or tablet, to be\nused as a roaming authenticator for signing into the primary device, such as a\npersonal computer. This is commonly called FIDO Cross-Device Authentication\n(CDA).\u00b6\n\nWhen a user wants to authenticate using their mobile device (authenticator)\nfor the first time, they need to link their authenticator to their main\ndevice. This is done using a scan of a QR code. When the authenticator scans\nthe QR code, the device sends an encrypted BLE advertisement containing keying\nmaterial and a tunnel ID. The main device and authenticator both establish\nconnections to the web service, and the normal CTAP protocol exchange occurs.\u00b6\n\nIf the user chooses to keep their authenticator linked with the main device,\nthe QR code link step is not necessary for subsequent use. The user will\nreceive a push notification on the authenticator.\u00b6\n\n##### 6.2.3.2. Susceptibility\n\nThe Cross-Device Authentication flow proves proximity by leveraging BLE\nadvertisements for service establishment, significantly reducing the\nsusceptibility to any of the exploits described in Examples 1-6.\u00b6\n\n##### 6.2.3.3. Device Capabilities\n\nBoth the Consumption Device and the authenticator require BLE support. The\nConsumption Device must support both FIDO2/WebAuthn, specifically CTAP 2.2\nwith hybrid transport. The mobile phone must support CTAP 2.2+ to be used as a\ncross-device authenticator.\u00b6\n\n##### 6.2.3.4. Mitigations\n\nFIDO Cross-Device Authentication (CDA) establishes proximity through the use\nof BLE, reducing the need for additional mitigations. An implementer MAY still\nchoose to implement additional mitigation as described in this document.\u00b6\n\n##### 6.2.3.5. When to Use\n\nFIDO2/WebAuthn SHOULD be used for cross-device authentication scenarios\nwhenever the devices are capable of doing so. It MAY be used as an\nauthentication method with the Authorization Code Grant [RFC6749] and PKCE\n[RFC7663], to grant authorization to an Consumption Device (e.g., Smart TV or\ninteractive whiteboard) using a mobile phone as the authenticating device.\nThis combination of FIDO2/WebAuthn and Authorization Code Flow with PKCE\nenables cross device authorization flows, without the risks posed by the\nDevice Authorization Grant [RFC8628].\u00b6\n\n#### 6.2.4. Protocol Selection Summary\n\nThe FIDO Cross-Device Authentication (CDA) flow provides the best protection\nagainst attacks on the unauthenticated channel for cross device flows. It can\nbe combined with OAuth 2.0 and OpenID Connect protocols for standards-based\nauthorization and authentication flows. If FIDO2/WebAuthn support is not\navailable, Client Initiated Backchannel Authentication (CIBA) provides an\nalternative, provided that there is a channel through which the authorization\nserver can contact the end user. Examples of such a channel include device\npush notifications, e-mail or text messages which the user can access from\ntheir device. If CIBA is used, additional mitigations to enforce proximity and\ninitiate transactions from trusted devices or trusted networks SHOULD be\nconsidered. The OAuth 2.0 Device Authorization Grant provides the most\nflexibility and has the lowest requirements on devices used, but it is\nRECOMMENDED that it is only used when additional mitigations are deployed to\nprevent attacks that exploit the unauthenticated channel between devices.\u00b6\n\n### 6.3. Foundational Pillars\n\nExperience with web authorization and authentication protocols such as OAuth\nand OpenID Connect has shown that securing these protocols can be hard. The\nmajor reason for this is that the landscape in which they are operating - the\nweb infrastructure with browsers, servers, and the underlying network - is\ncomplex, diverse, and ever-evolving.\u00b6\n\nAs is the case with other kinds of protocols, it can be easy to overlook\nvulnerabilities in this environment. One way to reduce the chances of hidden\nsecurity problems is to use mathematical-logical models to describe the\nprotocols, their environments and their security goals, and then use these\nmodels to try to prove security. This approach is what is usually subsumed as\n\"formal security analysis\".\u00b6\n\nThere are two major strengths of formal analysis: First, finding new\nvulnerabilities does not require creativity - i.e., new classes of attacks can\nbe uncovered even if no one thought of these attacks before. In a faithful\nmodel, vulnerabilities become clear during the proof process or even earlier.\nSecond, formal analysis can exclude the existence of any attacks within the\nboundaries of the model (e.g., the protocol layers modeled, the level of\ndetail and functionalities covered, the assumed attacker capabilities, and the\nformalized security goals). As a downside, there is usually a gap between the\nmodel (which necessarily abstracts away from details) and implementations. In\nother words, implementations can introduce flaws where the model does not have\nany. Nonetheless, for protocol standards, formal analysis can help to ensure\nthat the specification is secure when implemented correctly.\u00b6\n\nThere are various different approaches to formal security analysis and each\nbrings its own strengths and weaknesses. For example, models differ in the\nlevel of detail in which they can capture a protocol (granularity,\nexpressiveness), in the kind of statements they can produce, and whether the\nproofs can be assisted by tools or have to be performed manually.\u00b6\n\nThe following works have been identified as relevant to the analysis of cross-\ndevice flows:\u00b6\n\n  * In \"Formal analysis of self-issued OpenID providers\" [Bauer2022], the protocol of [OpenID.SIOPV2] was analyzed using the Web Infrastructure Model (WIM). The WIM is specifically designed for the analysis of web authentication and authorization protocols. While it is a manual (pen-and-paper) model, it captures details of browsers and web interactions to a degree that is hard to match in automated models. In previous works, previously unknown flaws in OAuth, OpenID Connect, and FAPI were discovered using the WIM. In the analysis of a cross-device SIOP V2 flow in [Bauer2022], the request replay attack already described in Section 13.3 of [OpenID.SIOPV2] was confirmed in the model. A mitigation was implemented based on a so-called Cross-Device Stub, essentially a component that serves to link the two devices before the protocol flow starts. This can be seen as an implementation of a trusted device relationship as described in Section 6.1.7. The mitigation was shown to be effective in the model.\u00b6\n  * In \"Security analysis of the Grant Negotiation and Authorization Protocol\" [Helmschmidt2022], an analysis of a draft of the Grant Negotiation and Authorization Protocol (GNAP) [I-D.ietf-gnap-core-protocol] was performed using the Web Infrastructure Model. The same attack as in [Bauer2022] was found to apply to GNAP as well. In this case, a model of a \"careful user\" (see Section 6.1.13) was used to show that the attack can be prevented (at least in theory) by the user.\u00b6\n  * In \"The Good, the Bad and the (Not So) Ugly of Out-of-Band Authentication with eID Cards and Push Notifications: Design, Formal and Risk Analysis\" [MPRCS2020], Pernpruner et al. formally analysed an authentication protocol relying on push notifications delivered to an out-of-band device to approve the authentication attempt on the primary device (Backchannel-Transferred Session Pattern, Section 3.1.2). The analysis was performed using the specification language ASLan++ and the model checker SATMC. According to the results of the analysis, they identified and defined the category of implicit attacks, which manage to deceive users into approving a malicious authentication attempt through social engineering techniques, thus not compromising all the authentication factors involved; these attacks are aligned with the definition of Cross-Device Consent Phishing (CDCP) attacks.\u00b6\n  * In \"An Automated Multi-Layered Methodology to Assist the Secure and Risk-Aware Design of Multi-Factor Authentication Protocols\" [PCRSM2023], Pernpruner et al. defined a multi-layered methodology to analyze multi-factor authentication protocols at different levels of granularity. They leveraged their methodology to formally analyze a protocol relying on a QR code that has to be scanned on a secondary device to approve the authentication attempt on the primary device (User-Transferred Session Data Pattern, Section 3.1.1). Given the results of the analysis, they proposed some practical mitigations either to prevent or reduce the risk of successful attacks, such as those described in Section 6.1.13 and Section 6.1.17.\u00b6\n\n## 7\\. Conclusion\n\nCross-device flows enable authorization on devices with limited input\ncapabilities, allow for secure authentication when using public or shared\ndevices, provide a path towards multi-factor authentication and, provide the\nconvenience of a single, portable credential store.\u00b6\n\nThe popularity of cross-device flows attracted the attention of attackers that\nexploit the unauthenticated channel between the Consumption Device and\nAuthorization Device using techniques commonly used in phishing attacks. These\nCross-Device Consent Phishing (CDCP) attacks allow attackers to obtain access\nand refresh tokens, rather than authentication credentials, resulting in\naccess to resources even if the user used multi-factor authentication.\u00b6\n\nTo address these attacks, we propose a three pronged approach that includes\nthe deployment of practical mitigations to safeguard protocols that are\nalready deployed, provide guidance on when to use different protocols,\nincluding protocols that are not susceptible to these attacks, and the\nintroduction of formal methods to evaluate the impact of mitigations and find\nadditional issues.\u00b6\n\n## 8\\. Contributors\n\nThe authors would like to thank Tim Cappalli, Nick Ludwig, Adrian Frei, Nikhil\nReddy Boreddy, Bjorn Hjelm, Joseph Heenan, Brian Campbell, Damien Bowden,\nKristina Yasuda, Tim W\u00fcrtele, Karsten Meyer zu Selhausen, Maryam Mehrnezhad,\nMarco Pernpruner, Giada Sciarretta and others (please let us know, if you've\nbeen mistakenly omitted) for their valuable input, feedback and general\nsupport of this work.\u00b6\n\n## 9\\. Informative References\n\n[Baki2023]\n\n    Baki, S. and R. M. Verma, \"Sixteen Years of Phishing User Studies: What Have We Learned?\", Volume 20, Number 2, Pages 1200-1212, 2023, <https://doi.org/10.1109/TDSC.2022.3151103>.\n[Bauer2022]\n\n    Bauer, C., \"Formal analysis of self-issued OpenID providers\", 2022, <https://elib.uni-stuttgart.de/handle/11682/12417>.\n[CAEP]\n\n    Tulshibagwale, A. and T. Cappalli, \"OpenID Continuous Access Evaluation Profile 1.0 - draft 01\", June 2021, <https://openid.net/specs/openid-caep-specification-1_0-01.html>.\n[CIBA]\n\n    Fernandez, G., Walter, F., Nennker, A., Tonge, D., and B. Campbell, \"OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0\", September 2021, <https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html>.\n[Exploit1]\n\n    Cooke, B., \"The Art of the Device Code Phish\", July 2021, <https://0xboku.com/2021/07/12/ArtOfDeviceCodePhish.html>.\n[Exploit2]\n\n    \"Microsoft 365 OAuth Device Code Flow and Phishing\", August 2021, <https://www.optiv.com/insights/source-zero/blog/microsoft-365-oauth-device-code-flow-and-phishing>.\n[Exploit3]\n\n    Syynimaa, N., \"Introducing a new phishing technique for compromising Office 365 accounts\", October 2020, <https://o365blog.com/post/phishing/#new-phishing-technique-device-code-authentication>.\n[Exploit4]\n\n    Hwong, J., \"New Phishing Attacks Exploiting OAuth Authentication Flows (DEFCON 29)\", August 2021, <https://www.youtube.com/watch?v=9slRYvpKHp4>.\n[Exploit5]\n\n    \"OAuth's Device Code Flow Abused in Phishing Attacks\", August 2021, <https://www.secureworks.com/blog/oauths-device-code-flow-abused-in-phishing-attacks>.\n[Exploit6]\n\n    \"SquarePhish: Advanced phishing tool combines QR codes and OAuth 2.0 device code flow\", August 2022, <https://www.helpnetsecurity.com/2022/08/11/squarephish-video/>.\n[Helmschmidt2022]\n\n    Helmschmidt, F., \"Security analysis of the Grant Negotiation and Authorization Protocol\", 2022, <https://elib.uni-stuttgart.de/handle/11682/12220>.\n[I-D.ietf-gnap-core-protocol]\n\n    Richer, J. and F. Imbault, \"Grant Negotiation and Authorization Protocol\", Work in Progress, Internet-Draft, draft-ietf-gnap-core-protocol-20, 19 March 2024, <https://datatracker.ietf.org/doc/html/draft-ietf-gnap-core-protocol-20>.\n[IEEE802154]\n\n    Engineers, I. O. E. A. E., \"IEEE Std 802.15.4-2020: IEEE Standard for Low-Rate Wireless Networks\", IEEE 802.15.4-2020, 2020, <https://standards.ieee.org/standard/802_15_4-2020.html>. This standard defines the physical layer and media access control for low-rate wireless personal area networks (LR-WPANs) and is maintained by the IEEE 802.15 working group.\n[MPRCS2020]\n\n    Pernpruner, M., Carbone, R., Ranise, S., and G. Sciarretta, \"The Good, the Bad and the (Not So) Ugly of Out-of-Band Authentication with eID Cards and Push Notifications: Design, Formal and Risk Analysis\", IEEE Proceedings of the Tenth ACM Conference on Data and Application Security and Privacy (CODASPY '20), 2020, <https://doi.org/10.1145/3374664.3375727>.\n[NYC.Bike]\n\n    Byrne, K.J., \"Citi Bikes being swiped by joyriding scammers who have cracked the QR code\", August 2021, <https://nypost.com/2021/08/07/citi-bikes-being-swiped-by-joyriding-scammers-who-have-cracked-the-qr-code/>.\n[OpenID.Core]\n\n    Sakimura, N., Bradley, J., Jones, M.B., Medeiros, B.d., and C. Mortimore, \"OpenID Connect Core 1.0\", November 2014, <http://openid.net/specs/openid-connect-core-1_0.html>.\n[OpenID.SIOPV2]\n\n    Yasuda, K., Jones, M., and T. Lodderstedt, \"Self-Issued OpenID Provider v2\", November 2022, <https://bitbucket.org/openid/connect/src/master/openid-connect-self-issued-v2/openid-connect-self-issued-v2-1_0.md>.\n[OpenID.VCI]\n\n    Lodderstedt, T., Yasuda, K., and T. Looker, \"OpenID for Verifiable Credential Issuance\", October 2023, <https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0.html>.\n[OpenID.VP]\n\n    Terbu, O., Lodderstedt, T., Yasuda, K., and T. Looker, \"OpenID for Verifiable Credential Presentations\", November 2023, <https://openid.net/specs/openid-4-verifiable-presentations-1_0.html>.\n[PCRSM2023]\n\n    Pernpruner, M., Carbone, R., Sciarretta, G., and S. Ranise, \"An Automated Multi-Layered Methodology to Assist the Secure and Risk-Aware Design of Multi-Factor Authentication Protocols\", IEEE IEEE Transactions on Dependable and Secure Computing (TDSC), 2023, <https://doi.org/10.1109/TDSC.2023.3296210>.\n[RFC2119]\n\n    Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.\n[RFC6749]\n\n    Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <https://www.rfc-editor.org/info/rfc6749>.\n[RFC7662]\n\n    Richer, J., Ed., \"OAuth 2.0 Token Introspection\", RFC 7662, DOI 10.17487/RFC7662, October 2015, <https://www.rfc-editor.org/info/rfc7662>.\n[RFC7663]\n\n    Trammell, B., Ed. and M. Kuehlewind, Ed., \"Report from the IAB Workshop on Stack Evolution in a Middlebox Internet (SEMI)\", RFC 7663, DOI 10.17487/RFC7663, October 2015, <https://www.rfc-editor.org/info/rfc7663>.\n[RFC8174]\n\n    Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n[RFC8628]\n\n    Denniss, W., Bradley, J., Jones, M., and H. Tschofenig, \"OAuth 2.0 Device Authorization Grant\", RFC 8628, DOI 10.17487/RFC8628, August 2019, <https://www.rfc-editor.org/info/rfc8628>.\n[SSF]\n\n    Tulshibagwale, A., Cappalli, T., Scurtescu, M., Backman, A., and J. Bradley, \"OpenID Shared Signals and Events Framework Specification 1.0\", June 2021, <https://openid.net/specs/openid-sse-framework-1_0-01.html>.\n\n## Appendix A. Document History\n\n[[ To be removed from the final specification ]]\u00b6\n\n-latest\u00b6\n\n  * Corrected typos.\u00b6\n\n-05\u00b6\n\n  * Added section to provide actionable guidance to implementers on how to use this document.\u00b6\n  * Expanded section on formal analysis to include completed research projects.\u00b6\n  * Added reference to OpenID for Verifiable Presentations.\u00b6\n\n-04\u00b6\n\n  * Corrected formatting issue that prevented history from showing correctly.\u00b6\n\n-03\u00b6\n\n  * Introduced normative SHOULD, RECOMMENDED and MAY when applied to actions the Authorization Server, Resource Server or Client may implement.\u00b6\n  * Added User Education as a standalone mitigation.\u00b6\n  * Added Maryam Mehrnezhad, Marco Pernpruner and Giada Sciarretta to the contributors list.\u00b6\n  * Added Request Binding with Out-of-Band Data as an additional mitigation.\u00b6\n  * Adopted the OpenID Foundation terminology from [CIBA] and changed Initiating Device to Consumption Device\u00b6\n  * Added Fake Helpdesk and Consent Request Overload examples\u00b6\n  * Replaced \"Authenticated Flow\" mitigation name with \"Authenticate-then-Intitiate\"\u00b6\n  * Added Cross-Device Session Transfer pattern\u00b6\n\n-02\u00b6\n\n  * Fixed typos and grammar edits\u00b6\n  * Capitalised Initiating Device and Authorization Device\u00b6\n  * Introduced Cross-Device Consent Phishing as a label for the types of attacks described in this document.\u00b6\n  * Updated labels for different types of flows (User-Transferred Session Data Pattern, Backchannel-Transferred Session Pattern, User-Transferred Authorization Data Pattern)\u00b6\n  * Adopted consistent use of hyphenation in using \"cross-device\"\u00b6\n  * Consistent use of \"Authorization Device\"\u00b6\n  * Update Reference to Secure Signals Framework to reflect name change from Secure Signals and Events\u00b6\n  * Described difference between proximity enforced and proximity-less cross-device flows\u00b6\n  * General editorial pass\u00b6\n\n-01\u00b6\n\n  * Added additional diagrams and descriptions to distinguish between different cross-device flow patterns.\u00b6\n  * Added short description on limitations of each mitigation.\u00b6\n  * Added acknowledgement of additional contributors.\u00b6\n  * Fixed document history format.\u00b6\n\n-00 (Working Group Draft)\u00b6\n\n  * Initial WG revision (content unchanged from draft-kasselman-cross-device-security-03)\u00b6\n\n-03 draft-kasselman-cross-device-security\u00b6\n\n  * Minor edits and typos\u00b6\n\n-02 draft-kasselman-cross-device-security\u00b6\n\n  * Minor edits and typos\u00b6\n  * Upload as draft-ietf-oauth-cross-device-security-best-practice-02\u00b6\n\n-01 draft-kasselman-cross-device-security\u00b6\n\n  * Updated draft based on feedback from version circulated to OAuth working group\u00b6\n  * Upload as draft-ietf-oauth-cross-device-security-best-practice-01\u00b6\n\n-00 draft-kasselman-cross-device-security\u00b6\n\n  * Initial draft adopted from document circulated to the OAuth Security Workshop Slack Channel\u00b6\n  * Upload as draft-ietf-oauth-cross-device-security-best-practice-00\u00b6\n\n## Authors' Addresses\n\nPieter Kasselman\n\nMicrosoft\n\nEmail: pieter.kasselman@microsoft.com\n\nDaniel Fett\n\nAuthlete\n\nEmail: mail@danielfett.de\n\nFilip Skokan\n\nOkta\n\nEmail: panva.ip@gmail.com\n\n", "frontpage": false}
