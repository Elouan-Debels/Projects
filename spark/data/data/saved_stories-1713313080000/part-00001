{"aid": "40055371", "title": "Solving Algorithmic Problems: Painting a Grid", "url": "https://www.alperenkeles.com/blog/paintbrush", "domain": "alperenkeles.com", "votes": 2, "user": "thunderbong", "posted_at": "2024-04-16 18:16:43", "comments": 0, "source_title": "Alperen Keles", "source_text": "Blog | Alperen Keles\n\n# Alperen Keles\n\n## Articles\n\nSolving Algorithmic Problems: Painting a Grid\n\nIntroducing Devy, written using Devy!\n\nAn Introductory Roadmap Into The Functional Programming Concepts\n\nIntroduction to Property Based Testing\n\nDesigning A Cryptic Language Puzzle\n\nSolving Algorithmic Problems in The Wild\n\nAfet An\u0131nda Do\u011fru Bilgiye Ula\u015f\u0131m\n\nThe Lies About Abstraction\n\nSoftware Demystified: How does a Text Box Work?\n\nYaz\u0131l\u0131m Projeleri: Kapsaml\u0131 Rehber\n\nAlgoritmik Problemler: Kapsaml\u0131 Rehber\n\nHurdles of Designing A Layout Model\n\nLearner\u2019s Guide to Functional Programming#0: Sum Types, Booleans and Naturals\nin Javascript\n\nLearner\u2019s Guide to Functional Programming#1: Implementing Lists in JavaScript\n\nExtracting Signals: Playing The Inverse Waldo Game\n\nSinyalleri Ayr\u0131\u015ft\u0131rmak\n\nThe Technical Pie (Yet-Another-Tech-Debt-Analogy)\n\nVisa-Exclusion as A Form of Inequality\n\nLearner\u2019s Guide to Dynamic Programming#2\n\nLearner\u2019s Guide to Dynamic Programming#1\n\nLearner\u2019s Guide to Coq Theorem Prover#1\n\nA Short Story of Inequality\n\n2ClickMail: 2 Clicks to Change\n\n2ClickMail: 2 T\u0131kta D\u00fcnyan\u0131 G\u00fczelle\u015ftir\n\nSome Thoughts on Academia vs Industry(with a focus on Computer Science)\n\nWhere did all the writers go?\n\nAfetBilgi\u2019nin Hikayesi.\n\nYar\u0131m Kalan Projeler#3: Fact Checker\u2019s Tool\n\nYar\u0131m Kalan Projeler#2: Learning from Learners\n\nYar\u0131m Kalan Projeler#1: CengBook\n\nA Brief Essay on Change\n\nSe\u00e7imler v2\n\nDoktorada 1 Y\u0131l Sonunda Baz\u0131 G\u00f6r\u00fc\u015fler\n\nDoktoram\u0131n \u0130lk 6 Ay\u0131 Nas\u0131l Ge\u00e7ti? Yo\u011fun, Yorgun Ama Mutlu.\n\nDoktora Kabulleri: Kapsaml\u0131 Rehber\n\nHat\u0131rlamak\n\nLokasyon Bazl\u0131 \u00d6deme Hakk\u0131nda Baz\u0131 D\u00fc\u015f\u00fcnceler\n\nProje G\u00fcnl\u00fckleri: CVDL(CV Description Language)#1\n\nAmerika\u2019da \u0130lk 3 Ay\u0131m Nas\u0131l Ge\u00e7ti? Bu Sefer Oldu Gibi.\n\nLearner\u2019s Guide to Property Based Testing#1\n\nIntroduction to Learning from Learners\n\nAmerika\u2019da \u0130kinci Ay\u0131m Nas\u0131l Ge\u00e7ti? Bilinmezlikten Bilinirli\u011fe Bir Yolculuk.\n\nToplu Mail Linki Nas\u0131l Haz\u0131rlan\u0131r?\n\nAmerika\u2019da \u0130lk Ay\u0131m Nas\u0131l Ge\u00e7ti? \u00d6\u011fretici, \u015ea\u015f\u0131rt\u0131c\u0131 Derecede D\u00fcr\u00fcst Bir An\u0131\nDefteri.\n\nThe Story of Deviation and Returning\n\nODT\u00dc\u2019de Bilgisayar M\u00fchendisli\u011fi: Nedir? Ne De\u011fildir?\n\nVermek ve Almak: \u0130li\u015fkilere Yeni Bir Bak\u0131\u015f A\u00e7\u0131s\u0131\n\nG\u00f6r\u00fc\u015f\u00fcr\u00fcz ODT\u00dc!\n\nUzaktan E\u011fitimle Ge\u00e7en Bir Y\u0131l\u0131n Ard\u0131ndan\n\nDoktora Ba\u015fvurular\u0131: Kapsaml\u0131 Rehber\n\nLisans Ara\u015ft\u0131rmalar\u0131 Rehberi: Ad\u0131mODT\u00dc Lisans Ara\u015ft\u0131rmalar\u0131\n\nSe\u00e7imler\n\nYurt D\u0131\u015f\u0131 Staj: Kabul Ald\u0131n\u0131z, Peki Ya \u015eimdi?\n\nY\u00fcksek Lisans Doktora Ba\u015fvurular\u0131#2: Neden Y\u00fcksek Lisans?\n\nY\u00fcksek Lisans Doktora Ba\u015fvurular\u0131#1: \u015eimdi Sizin Akl\u0131n\u0131zda 2 Soru Var\n\nStaj Rehberi#4 \u2014 Eski Stajlar\n\nStaj Rehberi#3 \u2014 Projeler\n\nStaj Rehberi#2 \u2014 Niyet Mektubu\n\nStaj Rehberi#1 \u2014 \u00d6zge\u00e7mi\u015f Haz\u0131rlama\n\n\u00d6dedi\u011fimiz Bedeller Mi, \u00d6deyeceklerimiz Mi?\n\nODT\u00dc\u2019de Uzaktan G\u00fcz D\u00f6nemi Nas\u0131l Bitiyor.\n\nPost-Covid Monologlar\u0131#3: Yar\u0131n\u0131 Ka\u00e7\u0131rmak\n\nPost-Covid Monologlar\u0131#2: 2021'e \u00dc\u00e7 Zincirle Girmek\n\nODT\u00dc\u2019de Uzaktan E\u011fitim D\u00f6nemi Nas\u0131l Ge\u00e7iyor?\n\nLisans Ara\u015ft\u0131rmalar\u0131: Giri\u015f Rehberi\n\nPost-Covid Monologlar\u0131#1: Unutulan Vedalar\n\nYurt D\u0131\u015f\u0131 Staj: Geni\u015fletilmi\u015f Rehber\n\nAtam Ne Derdi\n\nKarantina G\u00fcnlerinde Akademik D\u00fcr\u00fcstl\u00fck\n\nK\u0131r Aynalar\u0131\n\nKaos ve D\u00fczen\n\nYurt D\u0131\u015f\u0131nda Staj\n\n# Solving Algorithmic Problems: Painting a Grid\n\nEarlier today, I saw a cute little puzzle on Reddit. The puzzle is pretty\nsimple, we have a 3x3 grid where each square is either pink or turquoise. We\nare also given a target grid with a different configuration of colors.\nFinally, we can use 3 horizontal brushes(A, B, and C) that is pink, or 3\nvertical brushes(D, E, and F) that is turquoise. The goal is to find the\nminimum number of brush strokes required to paint the target grid.\n\nIt took me a couple of minutes to come up with the solution, I\u2019m leaving the\nanswer below in a spoiler box. If you want to try it yourself, please do so\nbefore reading the answer.\n\nThe next thought I had was, how hard would it be to write a program that\nsolves this problem for any given grid?. I thought it would be a fun little\nexercise to write a program that solves this problem. Although I don\u2019t think\nmy solution is perfect(my intuition is that there are cases where it takes the\nwrong step which is possible to detect in the future and revert, but I didn\u2019t\nimplement it), I\u2019m happy with the simplicity of the result.\n\nThe first question that requires answering when solving such a question is,\nwhat does the solution space look like? If the solution space is very small,\nwe can just enumerate all of them(hint: it\u2019s not that large). For a 3x3 grid,\nwe only have 6 brushes, and using a brush twice does not provide any\nadditional benefit. This is an important insight into pushing the solution\nspace down, so let\u2019s think about why that is for a second.\n\nThe reason why, is that there is only one way to paint a square. If we want to\npaint a square pink, we have to use the horizontal brush on that level, if we\nwant to paint a square turquoise, we have to use the vertical brush on that\nlevel. Let\u2019s say that we have a sequence of brush strokes x_1, x_2, x_3....\nThe question we need to ask is, why do we even care about the order of strokes\nto begin with? The reason is that column and row strokes don\u2019t commute.\nApplying r_i where r_i is the row stroke for the i\u2019th row, and c_i where c_i\nis the column stroke for the i\u2019th column, is not the same as applying c_i and\nthen r_i. r_i c_j means that cell[i, j] is painted turqoise, and c_j r_i means\nthat cell[i, j] is painted pink. This gives us two piece of information:\n\n  1. Order of strokes matter.\n  2. By changing the order of two strokes, we can change the color of a cell in the way we want.\n\nAs we can change the color of a cell by changing the order of strokes, running\nc_i ... r_j ... c_i is the same as running r_j ... c_i. That is it is\nsufficient to use each stroke once. Although working, this solution did not\nreally satisfy my curiosity, it was just too inelegant.\n\nThe next step we can take is to invert our thinking process for the previous\nsolution. Previously, we decided that we can always change the order of two\nstrokes when we want to change the color of something. Thinking backwards,\nthis also means that we can just place the strokes in the order we want to\npaint the cells. If we want to paint cell i, j pink, now we know that our\nsolution must be in the form ... c_i ... r_j .... For this solution, we will\nfirst calculate the difference of the current grid and the target grid, then\nwe will find a set of moves required to paint the grid in the way we want. We\nwill order the strokes with respect to the painting order, and apply the first\nstroke in the list. After the application, we recompute the difference, and\ncontinue this process until the paintings are the same.\n\nThis solution scales much better, as it\u2019s local. We use a greedy approach to\nsolve the problem, so we don\u2019t have to generate the whole permutation space of\nstrokes. The solution is also very simple to implement, the solver logic\nrelies on the two functions provided in Typescript below. The order managed\nthe order of strokes to solve commutation issues, and the solve function\napplies the strokes in the order provided by the order function.\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\n    \n    \n    const order = (d1: Directive, d2: Directive, c: Canvas): number => { if (d1.orient === d2.orient) { return 0; } let dr = d1.orient === \"row\" ? d1 : d2; let dc = d1.orient === \"column\" ? d1 : d2; let t = c[dr.index][dc.index]; if (d1.orient === \"row\" && t === \"pink\") { return -1; } else if (d1.orient === \"column\" && t === \"blue\") { return -1; } else { return 1; } } const solve = (c1: Canvas, c2: Canvas): Directive[] => { let path : Directive[] = []; while (different(c1, c2)) { let d = diff(c1, c2); let dirs = getDirectives(d); let sortedDirs = dirs.sort((d1, d2) => order(d1, d2, c2)); let dir = sortedDirs.pop() as Directive; c1 = applyDirective(c1, dir); path.push(dir); } return path; }\n\nIf I\u2019m not mistaken, this method should be able to solve NxNxN...xN grids in K\ndimensional spaces. The solution is not perfect, as it can actually lead to\ndouble strokes in some cases, but this would be immediately solved by keeping\nonly the last stroke in the list. I published the code on Github, and below is\na playground where you can actually generate grids and see the results.\n\nAn important point that I should also not that the problem does not really\nhave a general solution, since there are grid pairs where it\u2019s impossible to\npaint the target grid with the given brushes. I\u2019m not sure how to prove this,\nif we had a proof that the state space is finite(which we believe, as we\nalready said that using each brush only once is enough), then we could just\nprovide a counterexample showing that it\u2019s impossible to paint the target grid\nfrom that starting configuration, but that reasoning does not hold if we don\u2019t\nactually prove that the state space is finite. We could also show cyclicity,\nwhich I think should be easy to do, but I didn\u2019t try it.\n\nAdjust Speed\n\n#### Moves\n\n  * column1\n  * column0\n  * row1\n\n", "frontpage": false}
