{"aid": "39979140", "title": "Supreme Commander Graphics Study (2015)", "url": "http://www.adriancourreges.com/blog/2015/06/23/supreme-commander-graphics-study/", "domain": "adriancourreges.com", "votes": 16, "user": "UglyToad", "posted_at": "2024-04-09 13:18:34", "comments": 2, "source_title": "Supreme Commander - Graphics Study", "source_text": "Supreme Commander - Graphics Study - Adrian Courr\u00e8ges\n\n# Adrian Courr\u00e8ges\n\n# Supreme Commander - Graphics Study\n\nJun 23rd, 2015\n\nTotal Annihilation has a special place in my heart since it was the very first\nRTS I played; it was with Command & Conquer and Starcraft one of the best RTS\nreleased in the late 90\u2019s.\n\n10 years later \u2013 in 2007 \u2013 its successor was released: Supreme Commander. With\nChris Taylor as the designer, Jonathan Mavor in charge of the engine\nprogramming and Jeremy Soule as the music composer (some of the main figures\nbehind the original Total Annihilation), the expectations of the fans were\nvery high.\n\nSupreme Commander turned out to be highly praised by critics and players, with\nnice features like the \u201cstrategic zoom\u201d or physically realistic ballistic.\n\nSo let\u2019s see how Moho, the engine powering SupCom, renders a frame of the\ngame! Since RenderDoc doesn\u2019t support DirectX 9 games, reverse-engineering was\ndone with the good old PIX.\n\n# Terrain Structure\n\nBefore we dig into the frame rendering, it\u2019s important to first talk about how\nterrains are built in SupCom and which technique is used.\n\nHere is an overview of \u201cFinn\u2019s Revenge\u201d, a 1 versus 1 map.\n\nOn the left is a top-view of the entire map like it appears in-game on the\nmini-map. Below is the same map viewed from another angle:\n\nFirst the geometry of the terrain is calculated from an heightmap. The\nheightmap describes the elevation of the terrain. A white color represents a\nhigh altitude and a dark one a low altitude. For our map, a 513x513 single-\nchannel image is used, it represents a terrain of 10x10 km in-game. SupCom\nsupports much larger maps, up to 81x81 km.\n\nHeightmap| Tessellated Terrain  \n---|---  \n  \nSo we have a mesh which represents our terrain. Then the game applies an\nalbedo texture combined with a normal texture to cover all these polygons. For\neach map the sea level is also specified so the game modulates the albedo\ncolor of the pixels under the sea surface to give them a blue tint.\n\nWireframe Terrain\n\nAlbedo + Normal Textures\n\nSea Level Color Modulation\n\nOkay so having altitude-based texturing is nice, but it gets limiting quite\nquickly. How do we add more details and variations to our map?\n\nThe technique used is called \u201cTexture splatting\u201d: the game draws a series of\nadditional albedo+normal textures. Each step adds what\u2019s called a \u201cstratum\u201d to\nthe terrain. We already have stratum 0: the terrain with its original\nalbedo+color textures. To apply the next stratum, we need some extra\ninformation: a \u201csplat map\u201d, to tell us where to draw the new albedo+normal and\nmore importantly where not to draw! Without such a \u201csplat map\u201d also called\nalpha-map, applying a new stratum would completely cover the previous stratum.\nThe albedo and normal textures both have their own scaling factor when they\nare applied to the mesh.\n\nBase Stratum #0| No Splatmap| Albedo| Normal  \n---|---|---|---  \n  \nApplying Stratum #1| Splatmap| Albedo| Normal  \n---|---|---|---  \n  \nApplying Stratum #2| Splatmap| Albedo| Normal  \n---|---|---|---  \n  \nApplying Stratum #3| Splatmap| Albedo| Normal  \n---|---|---|---  \n  \nApplying Stratum #4| Splatmap| Albedo| Normal  \n---|---|---|---  \n  \nSo we applied strata 1, 2, 3 and 4, each one relying on 3 separate textures.\nThe albedo and normal textures use 3 channels (RGB) each, but the splat map\nuses only one channel. So as an optimization the 4 splat maps are combined\ninto a single RGBA texture.\n\nCombined Splat Maps  \n---  \n  \nOkay so we got more texture variations for our terrain. It looks nice from far\naway, but if you zoom-in you quickly notice the lack of high-frequency\ndetails.\n\nThis is when decals are applied: these are like small sprites which modify\nlocally the albedo color and the normal of a pixel. This terrain has 861\ninstances of 21 unique decals.\n\nDecals: Before\n\nDecals: After\n\nDecals Highlight\n\nIt\u2019s much better but what about some vegetation? The next step is to add to\nthe terrain what the engine calls \u201cProps\u201d: tree or rock models. For this map\nthere are 6026 instances of 23 unique models.\n\nProps: Before\n\nProps: After\n\nProps Highlight\n\nNow the final touch: the sea surface. It is a combination of several normal\nmaps with UV scrolling along different directions, an environment map for\nreflections and sprites for the waves near the shores.\n\nSea Surface: Before\n\nSea Surface: After\n\nOur terrain is now ready. Creating good heightmaps and splat maps can be\nchallenging for map designers, but fortunately there are several tools to help\nwith the task: there is the official \u201cSupcom Map Editor\u201d or World Machine with\neven more advanced features.\n\nSo now that we know the theory behind the SupCom terrains, let\u2019s move on to an\nactual frame of the game.\n\n# Frame Breakdown\n\nThis is the game frame we\u2019ll dissect:\n\n### Frustum Culling\n\nThe game has in RAM the terrain mesh, created from the heightmap, it is\ntessellated by the CPU and the position of each vertex is known. When the zoom\nlevel changes, the CPU re-calculates the tessellation of the terrain. Our\ncamera focuses on a scene near the shore. Rendering the whole terrain would be\na waste of calculation, so instead the engine extracts a submesh of the whole\nterrain, only the portion visible to the player, and feeds this small subset\nto the GPU for rendering.\n\nFrustum Culling: Before\n\nFrustum Culling: After\n\n### Normal Map\n\nFirst, only the normals are calculated. A first pass computes the normals\nresulting from the combination of the 5 stratums (5 normal maps and 4 splat\nmaps). The different normal maps are blended together, all the operations are\ndone in tangent space.\n\nSubmeshNormals x5Splatmaps| Normal Map  \n---|---  \n  \nThis is done in a single draw call with 6 texture fetches. You\u2019ll notice the\nresult is quite \u201cyellowish\u201d, it contrasts with the other normal maps which\ntend to be blue. And indeed: here the Blue channel is not used at all, only\nthe Red and Green. But wait, a normal is a 3-component vector, how can it be\nstored only with 2 components? It\u2019s actually a compression technique\n(explained at the end of the post). For now let\u2019s just assume the Red and\nGreen channels contain all the information we need about the normals.\n\nStratums are done, now it\u2019s the turn of the decals: terrain decals and\nbuilding decals are added to modulate the stratum normals.\n\nBase\n\nBase + Terrain Decals\n\nBase + Terrain Decals + Unit Decals\n\nWe still haven\u2019t used the Blue and Alpha channels of our render target. So the\ngame reads from a 512x512 texture representing the whole normals of the\nterrain (baked from the original heightmap), and calculates for each pixel its\nnormal using a bicubic interpolation. The results are stored in the Blue and\nAlpha channels.\n\nNormal Map| Bicubic interpolation stored in Blue and Alpha.| Red & Green:\nStratum/Decal Normals Blue & Alpha: Base Terrain Normal  \n---|---|---  \n  \nThen the game combines these two sets of normals (stratum/decal normals and\nterrain normals) into the final normals used to calculate the lighting.\n\nFinal Normal Map\n\nThis time there\u2019s no compression: the normals use the 3 RGB channels, one for\neach component. It might look very green, but this is because the scene is\nquite flat, the result is correct: you can take any pixel and calculate its\nnormal vector by doing colorRGB * 2.0 - 1.0, you can also check that the norm\nof the vector is 1.\n\n### Shadow Map\n\nThe technique used to render the shadows is the \u201cLight Space Perspective\nShadow Maps\u201d or LiSPSM technique. Here we just have the sun as a directional\nlight. Each mesh of the scene is rendered, and its distance from the sun is\nstored into the Red channel of a 1024x1024 texture. The LiSPSM technique\ncalculates the best projection space to maximize the precision of the shadow\nmap.\n\nIf we stop here, we would just be able to draw hard shadows. When the units\nare rendered, the game actually tries to smooth-out the edges of the shadows\nby using some PCF sampling.\n\nBut even with PCF, there would be no way to obtain the beautiful smooth-\nshadows we see on the screenshot, especially the smooth silhouettes of the\nbuildings on the ground... So how was this achieved?\n\nEven during the final parts of the development process of the game, it seems\nthe implementation of shadows was still an on-going effort. This is what\nJonathan Mavor was saying 11 months before the game public release:\n\n> The shadows in those shots are not finished and we do have a little bit of\n> work to do on them yet. [...] We are not finished with the game graphically\n> by any stretch at this point.\n>\n> Jonathan Mavor February 24th 2006\n\nJust one month after this declaration, a new ground-breaking shadow map\ntechnique was emerging: Variance Shadow Maps or VSM. It was able to render\ngorgeous soft shadows very efficiently. It seems the SupCom team tried to\nexperiment with this new technique: decompiling the D3D bytecode reveals a\nreference to a DepthToVariancePS() function which computes a blur version of\nthe shadow map. Before VSM was invented, shadow maps could not and were never\nblurred. Here SupCom performs a 5x5 Gaussian blur (horizontal and vertical\npass) of the shadow map.\n\nLiSPSM| Gaussian Blur| Blurred Shadow Map  \n---|---|---  \n  \nHowever in the D3D bytecode, there is no instruction about storing the depth\nand the squared-depth (information required by the VSM technique). It seems to\nbe only a partial implementation: maybe there was no time to perfect the\ntechnique during the final stages of the development, but anyway the code as-\nis can already produce nice results.\n\nNote though that the pseudo-VSM map is used only to produce soft-shadows on\nthe ground. When a shadow must be drawn onto a unit, it is done through the\nLiSPSM map with PCF sampling. You can see the difference in the screenshot\nbelow (PCF has blocky artifacts at the shadow border):\n\nDifferent Shadow Map Techniques\n\n### Shadowed Terrain\n\nThanks to the normal map and the shadow map that were generated, it is\npossible to finally start rendering the terrain: a textured mesh with lighting\nand shadows.\n\nSplatMaps| Water Depth Map| Albedo Textures| Shadow| Normal  \n---|---|---|---|---  \n  \nLighting and Shadow\n\n### Decals\n\nThe albedo components of the decals are drawn, using the normal information to\ncalculate the lighting equation.\n\nBase\n\nBase + Terrain Decals\n\nBase + Terrain Decals + Unit Decals\n\n### Water Reflection\n\nWe have the sea on the right of our scene, so if a robot is sitting in the\nmiddle of the water we should be able to see its reflection on the sea\nsurface.\n\nA classic trick exists to render the reflection of a surface: an additional\npass is performed, and just before applying the camera transformation, the\nvertical axis is scaled by -1 so the entire scene becomes symmetric with\nregards to the water surface (just like a mirror) which is exactly the\ntransformation needed to render the reflection. SupCom uses this technique and\nrenders all the mirrored unit meshes into a reflection map.\n\nReflection Map\n\n### Mesh Rendering\n\nAll the units are then rendered one by one. For the vegetation, geometry\ninstancing is used to render multiple trees in one draw call. The sea is\nrendered using a single quad, with a pixel shader fetching several normal\nmaps, a refraction map (the scene rendered up until now), a reflection map\n(just generated above) and a skybox for additional reflection.\n\nMeshes 0%\n\nMeshes 30%\n\nMeshes 60%\n\nMeshes 100%\n\nNotice in the last image the small black artifacts of the sea near the screen\nborder: it\u2019s because the sampling of the surface of the water is disrupted to\ncreate an illusion of movement. Sometimes the disruption brings texels from\noutside the viewport within the viewport: but such information does not exist,\nhence the black areas. During the game the UI actually hides these artifacts\nunder a thin border covering the edges of the viewport.\n\n### Mesh Structure\n\nEach unit in SupCom is rendered in a single draw call. A model is defined by a\nset of textures:\n\n  * an albedo map\n  * a normal map\n  * a \u201cspecular map\u201d which actually contains much more information than the specular. It\u2019s an RGBA texture with:\n\n    * Red: Reflection. How much the environment map is reflected.\n    * Green: Specular. In regards to the sun light.\n    * Blue: Brightness. Used later to control the bloom.\n    * Alpha: Team Color. It modulates the unit albedo depending on the team color.\n\nAlbedo Map| Normal Map  \n---|---  \n  \n### Particles\n\nAll the particles are then rendered and the health bars of each unit are also\nadded.\n\nBase Scene\n\nBase Scene + Particles\n\nBase Scene + Particles + Health Bars\n\n### Bloom\n\nTime to make things shine! But how do we get the \u201cbrightness information\u201d\nsince we\u2019re working with LDR buffers? The brightness map is actually contained\nwithin the alpha channel, it was being built at the same time the previous\nmeshes were drawn. A downscaled copy of the frame is created, the alpha\nchannel is used to make only the bright areas stand out and two successive\nGaussian blurs are performed.\n\nAlpha Channel| Brightness Blurred  \n---|---  \n  \nThe blurred buffer is then drawn on the top of the original scene with\nadditive blending.\n\nBloom: Before\n\nBloom: After\n\n### User Interface\n\nWe\u2019re done concerning the main scene. The UI is finally rendered, and it is\nbeautifully optimized: a single draw call to render the entire interface. 1158\ntriangles are pushed at once to the GPU.\n\nUI\n\nUI (Wireframe Highlight)\n\nThe pixel shader reads from a single 1024x1024 texture which acts like a\ntexture atlas. When another unit is selected, the UI is modified, the texture\natlas is regenerated on-the-fly to pack a new set of sprites.\n\nAnd we\u2019re done for the frame!\n\n# Additional Notes\n\n### Level of Detail\n\nSince SupCom supports huge variations in the zoom level, it relies heavily on\nlevel of detail or LOD. If the player zooms out from the map, the number of\nvisible units quickly increases, to keep up with the increase in GPU load it\nbecomes necessary to render simpler geometry and smaller textures. Since the\nunits are very far away, the engine can get away with it: models are replaced\nwith low-poly versions, with fewer details but they\u2019re rendered so small on\nthe screen that the player can hardly see the difference with high-poly\nmodels.\n\nLOD High\n\nLOD Low\n\nLOD Low - Wireframe\n\nLOD High - Wireframe\n\nLOD does not only concern units: shadows, decals and props stop being rendered\nbeyond a certain distance.\n\n### Fog of War\n\nBecause of the fog of war, each unit has a line of sight and only the area\nclose to the units is completely visible. Areas where no units are present are\neither gray (previously visited) or black (still unexplored). The game stores\nthe fog information in a 128x128 mono-channel texture which defines the\nintensity of the fog: 1 means no visibility whereas 0 means full visibility.\n\n### Normal Compression\n\nAs promised, here is a short explanation about the trick used in SupCom to\ncompress normals. A normal is usually a 3-component vector, however in tangent\nspace, the vector is expressed relatively to the surface tangent: X and Y are\nwithin the tangent plane while the Z component always points away from the\nsurface. By default the normal is (0, 0, 1) which is why most normal maps\nappear bluish when the normal is not perturbed.\n\nSo assuming the normal is a unit-vector, its length is one: X2 + Y2 + Z2 = 1.\nIf you know the values of X and Y, then Z can only have two possible values: Z\n= \u00b1\u221a(1 - X2 - Y2). But since Z always points away from the surface, it has to\nbe positive and so we have Z = \u221a(1 - X2 - Y2). That\u2019s why only storing X and Y\nin the Red and Green channels is enough, Z can be derived from them. A more\ndetailed (and better) explanation can be found in this article.\n\n### Normal Blending\n\nSince we are talking about normals, SupCom performs some kind of lerp between\nnormal maps, using the splatmaps as factors. Actually there are several ways\nof blending two normal maps, with different results, it is not a\nstraightforward problem like this article explains.\n\n# More Links\n\n  * The blog of Jonathan Mavor has a lot of technical insights and a very nice post about the TA Graphics Engine.\n  * The story behind TA development. Very interesting read from 1998, archived on the Wayback Machine.\n  * Details about SupCom map editing and modding.\n\nMore discussion on this very topic: Slashdot, Hacker News, Reddit. Also, a\nprint copy of this article has been made available by Hacker Monthly.\n\nPosted by Adrian Courr\u00e8ges Jun 23rd, 2015\n\n\u00ab Introducing Linux Visual Novel Reader Exp3D Goes Open-Source \u00bb\n\n# Comments\n\n# About\n\nI'm Adrian, a software engineer who enjoys playing with game-dev, mobile, web\nand security. More...\n\nTip\n\n# Recent Posts\n\n  * Graphics Studies Compilation\n  * UE4 Optimized Post-Effects\n  * Metal Gear Solid V - Graphics Study\n  * Beware of Transparent Pixels\n  * DOOM (2016) - Graphics Study\n  * GTA V - Graphics Study - Part 3\n  * GTA V - Graphics Study - Part 2\n  * GTA V - Graphics Study\n\n# Archives\n\n  * All Blog Posts List\n\n  * 2020 (1)\n  * 2018 (1)\n  * 2017 (2)\n  * 2016 (1)\n  * 2015 (11)\n  * 2014 (2)\n  * 2013 (1)\n  * 2008 (1)\n  * 2007 (5)\n\n# Supreme Commander Graphics Study\n\n  1. Terrain Structure\n  2. Frame Breakdown\n\n    1. Frustum Culling\n    2. Normal Map\n    3. Shadow Map\n    4. Shadowed Terrain\n    5. Decals\n    6. Water Reflection\n    7. Mesh Rendering\n    8. Mesh Structure\n    9. Particles\n    10. Bloom\n    11. User Interface\n  3. Additional Notes\n\n    1. Level of Detail\n    2. Fog of War\n    3. Normal Compression\n    4. Normal Blending\n  4. More Links\n\n", "frontpage": true}
