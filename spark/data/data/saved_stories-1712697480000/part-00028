{"aid": "39979122", "title": "Bypassing anti-reversing defences in iOS applications (2023)", "url": "https://twelvesec.com/2023/10/10/bypassing-anti-reversing-defences-in-ios-applications/", "domain": "twelvesec.com", "votes": 1, "user": "giuliomagnifico", "posted_at": "2024-04-09 13:16:33", "comments": 0, "source_title": "Bypassing anti-reversing defences in iOS applications", "source_text": "Bypassing anti-reversing defences in iOS applications - Twelvesec\n\n  * Follow\n  * Follow\n  * Follow\n  * Follow\n  * Follow\n\nBLOG\n\n#### Explore our trek through time\n\nLearn about TwelveSec, our history, our philosophy, our people, and our\nbusiness endeavours. And if you want to learn more feel free to drop us a\nline, we are always happy to answer.\n\n  * TWELVESEC\n  * CLIENTS\n  * CAREERS\n  * NEWS\n  * CONTACT\n\n#### Explore what can we offer you for your specific sector\n\nTake advantage of our experience in your own industry, explore how TwelveSec\ncan help you with industry specific problems.\n\n  * AEROSPACE\n  * AUTOMOTIVE\n  * DEFENCE\n  * FINANCE\n  * HEALTHCARE\n  * LAW ENFORCEMENT & SECURITY AGENCIES\n  * MANUFACTURING\n\n  * MARITIME\n  * PUBLIC SECTOR\n  * RAIL\n  * RETAIL\n  * SOFTWARE DEVELOPMENT\n  * TELECOMMUNICATIONS\n  * TOURISM\n\n## SECURITY ASSURANCE\n\nBe pro-active\n\nFIND OUT MORE\n\n## SECURITY MANAGEMENT\n\nSecurity is not just technical stuff\n\nFIND OUT MORE\n\n## SECURITY TRAINING\n\nWe share our know-how\n\nFIND OUT MORE\n\n# Bypassing anti-reversing defences in iOS applications\n\nby Xenofon Vassilakopoulos | Oct 10, 2023 | 0 comments\n\n## Introduction\n\nThis blog post provides a walktrough on dynamically bypassing anti-debugging\nand anti-reversing defences in iOS applications. Furthermore, this blog post\nis using resources from OWASP MASTG and provides a comprehensive guide that\ndiscusses about mobile applications security testing and reverse engineering.\n\nFor the purpose of this blog post the ios-challenge-2 application is used to\nshowcase the identification of the anti-debugging and anti-reversing\ntechniques and also to present specific ways to bypass these security\nmeasures.\n\nAll the exercises in this blog post are accomplished using the radare2 tool in\norder to perform static analysis as well as the r2frida and r2ghidra plugins\nthat used to perform dynamic analysis and runtime hooking on the target\nappication.\n\nFurther details about defense-in-depth measures such as code obfuscation,\nanti-debugging, anti-tampering, etc. can also be found at OWASP MASVS-\nRESILIENCE article.\n\nMoreover, this blog post focuses on methods to bypass the following anti-\ndebugging and anti-reversing techniques presented on the latest article\nTesting Resiliency Against Reverse Engineering provided by OWASP Mobile\nApplication Security Testing Guide (MASTG)\n\n  *     * ptrace\n    * sysctl\n    * getppid\n    * dynamic RE protections\n    * Jailbreak detection\n\nAfter installing the application on the iOS device, we run frida in order to\nidentify the name of the installed application.\n\nAt this point we run the ios-challenge-2 application in order to have an\noverview of the application\u2019s behaviour.\n\nAs seen at the image above, after installing and running the application it\nexits immediately. Using r2frida, the following command spawns the\napplication, and after it exits, the detach reason eventually appears on the\noutput. The detach reason indicates that the application performs anti-\ndebugging checks that prevent it from running.\n\n## Bypassing ptrace syscall anti-debugging defence\n\nThis section discusses about the ptrace syscall that is used as a defence in\norder to prevent iOS mobile applications from entering into a debugging state.\nFurthermore, it showcsases a way to bypass such security measure.\n\nThe ptrace syscall can be found in several *nix operating systems. It is\ngenerally used for debugging breakpoints and tracing system calls. It is used\nfrom native debuggers to keep track. Also, this blog post covers only one\nfeature of the ptrace syscall, the 'PT_DENY_ATTACH'.\n\n> PT_DENY_ATTACH: This request is the other operation used by the traced\n> process; it allows a process that is not currently being traced to deny\n> future traces by its parent. All other arguments are ignored. If the process\n> is currently being traced, it will exit with the exit status of ENOTSUP;\n> otherwise, it sets a flag that denies future traces. An attempt by the\n> parent to trace a process which has set this flag will result in a\n> segmentation violation in the parent.\n\nFor further reading about ptrace check out this link\n\nNow that we already runnning r2frida, lets spawn the application again but\nthis time using the :dtf command which used to trace the address of the ptrace\nsyscall.\n\nAs we see above, the application terminated again and from the args value (31)\nwe are able to determine that the feature of the ptrace syscall is the\n'PT_DENY_ATTACH'.\n\nAccording with OWASP-MASTG and iOS Anti-Reversing Defenses, the ptrace syscall\nis not part of the public iOS API. Non-public APIs are prohibited, and the App\nStore may reject apps that include them. Because of this, ptrace is not\ndirectly called in the code; it\u2019s called when a ptrace function pointer is\nobtained via dlsym. The following code snippet represents the above logic.\n\nNow that we know that the application immediately exits after running it with\nr2frida, we are in position to further check about anti-debugging / anti-\nreversing tecniques using static analysis. For this reason, we run the\napplication using radare2 in order to perform static analysis to the revrersed\ncode.\n\nAs seen previously, the ptrace syscall is generally invoked via dlsym so we\nsearch for it as follows.\n\nAt this point we continue using radare2 in order to visualize the execution\nflow and to examine some assembly instructions in order to have insights of\nthe validation checks in a lower level.\n\nAs we see at the screenshot below we have obtained a lot of information\nregarding the ptrace implementation. Specifically we see that the ptrace is\ncalled by Challenge1.viewDidLoad and also we are able to determine the feature\nof the ptrace from the 0xf1 hex value which is 31 in decimal indicating the\n'PT_DENY_ATTACH' feature.\n\nAt this point we are able to examine the viewDidLoad method as we know it\nimplements the ptrace syscall.\n\nWe can see that the viewDidLoad method is located at 0x100008a4c address as\nseen above, so lets further check the validations on radare2\n\nIf we type ob which refers to sym.func.100008864 at radare2 we can then step\ninside the viewDidLoad low level assembly code block and from there we can use\nthe r2ghidra plugin to decompile the code and have a higher level view of the\nviewDidLoad implementation.\n\nFrom the decompiled code above, the first check is implemented using the\nptrace ( sym.func.100008864 ) syscall. At this point we can bypass ptrace\nsyscall using r2frida\n\nAs we saw earlier the argument passed to ptrace is 0xf1 in hex which indicates\nthe ptrace feature. In order to disable ptrace syscall we can change this\nvalue to a non existing identifier, for example passing the value -1. The\nfollowing code snippet can be used to dynamically manipulate the argument\npassed to ptrace\n\nThe following output indicates that the ptrace syscall has been disabled\n\nUnfortunately if we run the application again it will exit immediately showing\nthe same detach reason as before indicating that other defences might be\nenabled that should also be bypassed.\n\n## Bypassing getppid() anti-debugging defence\n\nThis section discusses about the getppid() method that is commonly used as a\ndefence technique in order to prevent iOS mobile applications from entering\ninto a debugging state. In detail by checking the parent PID using getppid(),\niOS applications can detect if they have been started by a debugger. In\ncircumnstances where the iOS application has been started by a debugger, the\ngetppid() returns a PID different than 1. If the PID=1 indicates that the\napplication has been started from launchd process which is the first process\nrunning in user mode. Furthermore, this blog post will also showcsase a way to\nbypass such security measure. For further reading about getppid() refer to iOS\nManual Pages\n\nAt this point we are in position to perform further analysis in order to check\nfor getppid() and then try to bypass it. As seen in the previous section we\nhave accomplished to bypass the ptrace defence and now we should be able to\ncontinue with the second defence which is getppid().\n\nIf we look closely at the program flow at radare2 we see that after the\nsym.func.100008864 which indicates the call of the ptrace function, the\nsym.func.100008a30 is also called that indicates the call of the getppid()\nmethod\n\nWe can also see this in the following high level view of the decompiled code\nsnippet using r2ghidra.\n\nIf we type oc which refers to sym.func.100008a30 at radare2 we can then step\ninside the low level assembly code block of viewDidLoad as seen at the\nscreenshot below.\n\nFrom there we can use the r2ghidra plugin to decompile the code and have a\nhigher level view of the viewDidLoad implementation\n\nAs seen from the decompiled function above it evaluates the expression iVar1\n!= 1. If the iVar1 is 1 it indicates that the the application has started from\nthe launchd process. On the contrary, if the iVar1 is not 1 the function\nreturns true which indicates the presence of a debugger.\n\nIn order to bypass getppid() defence we should intercept the getppid() module\nand focre the return value to be 0x01 which indicates that the application has\nbeen launched using the launchd process.\n\nThe following .js code snippet can be used in r2frida to dynamically\nmanipulate the getppid() return value.\n\nAt this point we add the above snippet to a file named bypasses.js along with\nthe previous snippet that bypasses the ptrace syscall technique as seen blow.\n\nIf we run the application again using r2frida we see that the application\nexits again but the :dtf command shows that the return value of the getppid()\nis 0x1 which indicates the successful bypass.\n\nNevertheless, the sudden application termination depicts that there are still\ndefences that need to be bypassed.\n\n## Bypassing sysctl syscall anti-debugging defence\n\nThis section discusses about a technique that is commonly used to detect the\npresence of a debugger. It should be noted that unlike the ptrace technique,\nthis method doesn\u2019t prevent a debugger from attaching to a process. Instead,\nit uses the sysctl function to retrieve information about the process and\ndetermine whether it is being debugged. Further information about the sysctl\ncan be found in the sysctl man page. As for the sysctl bypass technique,\nfurther information can be found in iOS Anti-Debugging Protections #2\n\nAt this point we are in position to perform further analysis in order to check\nfor the sysctl syscall and then try to bypass it. As seen in the previous\nsection we have accomplished to bypass the ptrace and the getppid() defences\nand now we should be able to continue with the third defence which is the\nsysctl syscall.\n\nIf we look closely at the program flow at radare2 we see that after the\nsym.func.100008864 which indicates the call of the ptrace syscall, the\nsym.func.100008a30 is also called that indicates the call of the getppid()\nmethod, and after these validations, we see that the sym.func.10000898c is\ncalled that indicates the call of the sysctl syscall\n\nIf we now step into the sym.func.10000898c we see the call of the sysctl\nsyscall as seen at the decompiled code snippet below.\n\nAccording with Apple documentation archive, a code example is provided which\nchecks the info.kp_proc.p_flag flag returned by the call to sysctl with the\nappropriate parameters. In case the sysctl syscall returns -1 it suppose to\nhave detect that the application is being debugged, otherwise if any other\nvalue returned such as 0x0, the application is not being debugged.\n\nIn order to bypass the use of the sysctl syscall defence we should intercept\nthe sysctl module and focre the return value to be 0x00 which indicates that\nthe application has not been debugged.\n\nThe following .js code snippet can be used in r2frida to dynamically\nmanipulate the return value of the sysctl syscall.\n\nAt this point we add the above snippet to the previous created file\nbypasses.js along with the previous snippets that bypass the ptrace syscall\nand the getppid techniques as seen blow.\n\nwe see again that the application terminates immediately even after these\nbypasses with the same detach reason as previously seen.\n\nThe immediate termination can also be seen at the following screenshot.\n\n## Bypassing dynamic RE protections\n\nMobile applications can be analyzed by dynamic instrumentation tools\ninspecting application\u2019s behaviour at runtime. In terms of iOS application\nsecurity there are tools such as Cydia Substrate, Cycript and Frida that used\nfor such purpose. Other tools such as SSLKillSwitch2 and SSLKillSwitch might\nalso be used in order to disable SSL/TLS certificate validation including\ncertificate pinning.\n\nAs also seen at the disassembled code below, there is a validation refering to\nthe function sym.func.1000088b4\n\nIf we move further and step into the sym.func.1000088b4 we see a call to the\n_dyld_image_count() function which is used to get the number of loaded dylibs.\n\nMoreover, we can also see that there are further checks regarding several\ninstrumentation tools.\n\nAs seen from the decompiled code below, we have a clear view about the logic\nof the decompiled code where as also mentioned the _dyld_image_count() is\nfirst called to get the number of loaded dylibs. Then, for each index the\n_dyld_get_image_name()called to retrieve the name that will be verified. The\nverification is performed against several instrumentation tools and other\ntools that are used for TLS/SSL bypass as mentioned before. The application\ntries to detect the following list of tools\n\n  * Substrate\n  * cycript\n  * SSLKillSwitch\n  * SSLKillSwitch2\n  * frida\n\nFor further reading about the dylibs visit the iOS Manual Pages.\n\nOne way to bypass all the checks is to use a quick and dirty technique which\nintercepts the _dyld_get_image_name() function and manipulates the return\nvalue of the function, pointing to a non-existent string e.g. \u201cnull\u201d.\n\nAt this point we add the code snippet above to the bypasses.js script as seen\nbelow.\n\nIf we run the bypasses.js script all the anti-debugging and anti-reversing\ntechniques will be defeated. Although this is quick workarround to bypass RE\nchecks, a drawback with this technique is that it causes errors as it actually\nbreaks the functionality of the detected tool and eventually leads to\nexceptions.\n\nA more elegant solution is to hook to the strstr() functions and manipulate\nthe return value in order to disable all the checks. According with the iOS\nManual Pages regarding the strstr(), the following code will be used.\n\nAs seen at the code above we initially use a const array with all the names of\nthe intrumentation tools of our interest. Then after hooking to the strstr()\nfunction we give as input the names of the instrumentation tools one by one\nand then if the tool is detected the return value will be replaced to 0x00\nthus the check will be disabled.\n\nThe modified bypasses.js script will be as follows.\n\nAfter running the above script with r2frida we see the following output\n\n## Bypassing Jailbreak detection\n\nAt this point we have disabled all the anti-debugging checks at the target\napplication. There is one more validation that we have to bypass, and this is\nthe jailbreak detection. Jailbreak detection is any technique implemented by\ndevelopers to identify whether the application is running on a jailbroken\ndevice. It is crucial for applications to be able to detect if they are\nrunning in a Jailbroken device as the absent of this security mechanism could\nleave the application susceptible to security issues. Jailbreaking in iOS and\nRooting in Android devices involves running a privilege escalation on the\ndevice. Also, the process of Jailbreaking gives the ability to alter or\nreplace system applications, files, and settings, removing pre-installed\napplications, and running applications that require administrator-level\npermissions.\n\nMoreover to ensure security of corporate data, it is recommended that\njailbroken devices must not be used in organizations. Mobile Device Managment\n(MDM) solutions allow organizations to detect jailbroken devices in the\nnetwork and also remove these devices once they are detected. After detection\nthese devices cannot be enrolled into Moble Device Managment (MDM) and thus\nlose access to corporate data.\n\nChecking at the Challenge1 class we identify two methods as seen at the\nsnippet below\n\nUsing the above knowledge we are able to further examine the\njailbreakTest1Tapped method to see the arguments it accepts\n\nAt the following screenshot we see the implementation of the\njailbreakTest1Tapped method which gets the return value from isJailbroken\nmethod and raises the messages \u201cDevice is NOT Jailbroken\u201d or \u201cDevice is\nJailbroken\u201d accordingly.\n\nIf we examine the code further we see the NSFileManager which is an interface\nto the contents of the file system and shares methods that can be called by\nmultiple threads. As we see at the code, there are multiple checks that have\nto be exemined further. We should try to search for all possible strings in\nthe target application in order to have all the paths and URLs that we try\nfurther to bypass. For further reading about the NSFileManager and its\nmethods, refer to this link\n\nWe shall also get a closer look to isJailbroken method to see the arguments it\naccepts.\n\nFurthermore we do a more comprehensive search to find all possible\nimplementations regarding the methods that might perform Jailbroken checks.\n\nAt a first glance, we see that at address 0x10000c140 at isJailbroken method,\nthe URL cstr.cydia:__r2con_re.murphy.jailbreak used. Furtermore we need to\nsearch for more strings in order to find possible URLs and suspicious system\npaths.\n\nJailbreak detection works by looking for differences between a non-Jailbroken\nand a Jailbroken device. Some common techniques are to search for some\nevidences that prove the existence of a Jailbroken system including the\nfollowing searches:\n\n  * Search for Jailbreak-related applications like Cydia\n  * Search for .dylib files related to popular jailbreak tools and tweaks\n  * Search for .plist files related to popular jailbreak tools and tweaks\n  * Search for Read/write access to directories not normally accessible\n  * Search for SSH service on the device\n\nChecking at the disassembled code below we see a reference to fileExistsAtPath\nwhich we know that it is a method shared from the NSFileManager interface. We\nalso see the instruction addr x2, str.cstr._Applications_Cydia.app which\nrefers to the String \"/Applications/Cydia.app\".\n\nReversing this code portion until now, allows us to understand that\napplication checks exist. Also this code portion lead us to understand that\nspecific application checks exist regarding the Jailbreak detection. if the\nCydia application is installed on the operating system is one method to\nindicate that the device is Jailbroken. We should also try to search for all\npossible strings in the target application in order to have all the paths and\nURLs that we further try to examine if they are used to identify if the\ndeviced is Jailbroken.\n\nIsolating the lines regarding the method Challenge1.isJailbroken we see all\nthe possible paths used to identify if the device is Jailbroken. The following\npaths have been identified\n\n  * \u201c/Applications/Cydia.app\u201d\n  * \u201c/bin/bash\u201d\n  * \u201c/Library/MobileSubstrate/MobileSubstrate.dylib\u201d\n  * \u201c/usr/sbin/sshd\u201d\n  * \u201c/etc/apt\u201d\n  * \u201c/private/etc/apt/sources.list.d_electra.list\u201d\n\nNow we are able to write a frida script to hook to the\nNSFileManager.fileExistsAtPath in order to manipulate the return values when\nchecking the above list of paths.\n\nApart from the previous paths mentioned before if we dig deeper we see that at\n0x100008dcc the NSURL class is referenced which performs further checks using\nthe URLWithString method that creates and returns an NSURL object initialized\nwith a provided URL string. At this point we have identified the URL string\ncydia:__r2con_re.murphy.jailbreak which allows us to understand that the\ndevice is Jailbroken\n\nThe following code snippet used to bypass this check.\n\nAdding the previous scripts used to bypass Jailbreak detection to the\nbypasses.js script, we are able to bypass all the checks regarding the\ndetected anti-debugging and anti-reversing techniques\n\n### Submit a Comment Cancel reply\n\n#### LATEST POSTS\n\n  * LedgerSMB \u2013 CVE-2024-23831: Privilege escalation through CSRF attack on \u201csetup.pl\u201d February 2, 2024\n  * The Current State of Phishing Attacks November 22, 2023\n  * Bypassing anti-reversing defences in iOS applications October 10, 2023\n  * iOS Instrumentation using Corellium, frida and r2frida September 27, 2023\n  * Basic knowledge to get started with Penetration Testing November 18, 2022\n  * Free Application Security Assessment for Start \u2013 Ups September 30, 2022\n  * War is Never the Answer February 22, 2022\n\n#### TAGS\n\nMobile Security reversing self-isolation Cyber Defense tool mobile\npartnerships Burp Extender social responsibility pentesting android Ransomware\nattacks Reverse Engineering cybersecurity Misconfigurations social distancing\nTwelveSec IT security capture the flag Web Application Penetration Testing\nApplication Penetration Test GDPR compliance Coronavirus Phising Information\nLeakage infosec event Web Security community Privacy GDPR vulnerabilities ctf\nPenetration Testing pen-test penetration test teleworking security\ncollaborations Covid-19 CCPA cyber security ICT security Corelan pentest\ncomputer security\n\n#### \u039d\u039f\u03a4\u0395\n\n* Opinions hosted on this blog do not necessarily represent TwelveSec, nor encourage the purchase of specific products or services. Any trademarks mentioned remain the property of the respective trademark holders. Tips provided are only provided as informative in nature and should not be relied on as advice or counsel.\n\n#### STAY CONNECTED\n\nhello@twelvesec.com\n\n+30 211 182 21 58\n\n#### LEGAL\n\n  * DATA PROTECTION POLICY\n  * TERMS & CONDITIONS\n\n#### NAVIGATE\n\n  * CONTACT\n  * BLOG\n  * CAREERS\n\nCopyright 2023 Twelvesec | Created by Amiad\n\nThis website uses cookies to improve your experience. We'll assume you're ok\nwith this, but you can opt-out if you wish. REJECTCookie settingsACCEPT\n\nPrivacy & Cookies Policy\n\n#### Privacy Overview\n\nThis website uses cookies to improve your experience while you navigate\nthrough the website. Out of these cookies, the cookies that are categorized as\nnecessary are stored on your browser as they are as essential for the working\nof basic functionalit...\n\nNecessary\n\nAlways Enabled\n\nNecessary cookies are absolutely essential for the website to function\nproperly. This category only includes cookies that ensures basic\nfunctionalities and security features of the website. These cookies do not\nstore any personal information.\n\nSAVE & ACCEPT\n\n### Share This\n\nShare this post with your friends!\n\n  * Facebook\n\n  * Twitter\n\n  * LinkedIn\n\n", "frontpage": false}
