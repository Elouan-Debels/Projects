{"aid": "39979031", "title": "Building files-to-prompt using Claude 3 Opus", "url": "https://simonwillison.net/2024/Apr/8/files-to-prompt/", "domain": "simonwillison.net", "votes": 3, "user": "chedar", "posted_at": "2024-04-09 13:07:49", "comments": 0, "source_title": "Building files-to-prompt entirely using Claude 3 Opus", "source_text": "Building files-to-prompt entirely using Claude 3 Opus\n\n# Simon Willison\u2019s Weblog\n\nSubscribe\n\n## Building files-to-prompt entirely using Claude 3 Opus\n\n8th April 2024\n\nfiles-to-prompt is a new tool I built to help me pipe several files at once\ninto prompts to LLMs such as Claude and GPT-4.\n\nWhen combined with my LLM command-line tool it lets you do things like this:\n\n    \n    \n    files-to-prompt README.md files_to_prompt | llm -m opus \\ --system 'Update this README to reflect this functionality'\n\nI wrote files-to-prompt almost entirely using Claude 3 Opus, llm-claude-3 and\nfiles-to-prompt itself, once it was functional enough to be useful.\n\n#### Building the initial tool #\n\nI started with my click-app cookiecutter template. This can quickly spin up a\nskeleton of a new Python command-line tool using the Click library:\n\n    \n    \n    cookiecutter gh:simonw/click-app [1/6] app_name (): files-to-prompt [2/6] description (): Concatenate a directory full of files into a single prompt for use with LLMs [3/6] hyphenated (files-to-prompt): [4/6] underscored (files_to_prompt): [5/6] github_username (): simonw [6/6] author_name (): Simon Willison\n\nI opened the files_to_prompt/cli.py file it created for me and used it to spec\nout how the initial version should work:\n\n    \n    \n    import click @click.command() @click.argument( \"path\", type=click.Path ) @click.option( \"--include-hidden\", is_flag=True, help=\"Include files and folders starting with .\", ) @click.version_option() def cli(path, include_hidden): \"\"\" Takes a path to a folder and outputs every file in that folder, recursively, each one preceeded with its filename like this: path/to/file.py ---- Contents of file.py goes here --- path/to/file2.py --- ... \"\"\"\n\nThis code defines a tool that takes a positional path argument and an optional\n--include-hidden flag, along with a Python docstring describing what it should\ndo which will be displayed as the --help output.\n\nI\u2019d originally intended to actually build the tool... but once I got to this\npoint I realized that this might be enough information for Claude 3 Opus to do\nthe rest of the work for me.\n\nSo I ran this command:\n\n    \n    \n    cat files_to_prompt/cli.py | llm -m opus \\ --system 'finish this code for me'\n\nYou can see the full transcript here, but from this single prompt Claude 3\nOpus produced the exact implementation I needed:\n\n    \n    \n    for root, dirs, files in os.walk(path): if not include_hidden: dirs[:] = [d for d in dirs if not d.startswith(\".\")] files = [f for f in files if not f.startswith(\".\")] for file in files: file_path = os.path.join(root, file) with open(file_path, \"r\") as f: file_contents = f.read() click.echo(file_path) click.echo(\"---\") click.echo(file_contents) click.echo() click.echo(\"---\")\n\nI pasted that into by cli.py module and tried running it... and it worked\nfirst time.\n\nI tried a more challenging prompt next:\n\n    \n    \n    cat files_to_prompt/cli.py | llm -m opus ' modify this code to add a --ignore-gitignore flag which defaults toFalse. Without this flag the code should read any .gitignore files and filter content based on the rules within them. With the flag it should not do that.'\n\nI forgot to use the --system option here, so the argument prompt I passed to\nllm was concatenated directly onto the end of the code rather than being\ntreated as a system/instruction prompt. This turned out not to matter.\n\n.gitignore is a tricky format to handle. Claude 3 Opus didn\u2019t do a\ncomprehensive implementation, but it did support the subset that I cared about\nfor this step of the development process.\n\nHere\u2019s what it gave me (full transcript here):\n\n    \n    \n    import os import click from pathlib import Path from fnmatch import fnmatch def should_ignore(path, gitignore_rules): for rule in gitignore_rules: if fnmatch(path, rule): return True return False def read_gitignore(path): gitignore_path = os.path.join(path, \".gitignore\") if os.path.isfile(gitignore_path): with open(gitignore_path, \"r\") as f: return [line.strip() for line in f if line.strip() and not line.startswith(\"#\")] return [] @click.command() @click.argument( \"path\", type=click.Path(exists=True, file_okay=False, dir_okay=True, readable=True), ) @click.option( \"--include-hidden\", is_flag=True, help=\"Include files and folders starting with .\", ) @click.option( \"--ignore-gitignore\", is_flag=True, help=\"Ignore .gitignore files and include all files\", ) @click.version_option() def cli(path, include_hidden, ignore_gitignore): \"\"\" Takes a path to a folder and outputs every file in that folder, recursively, each one preceded with its filename like this: path/to/file.py ---- Contents of file.py goes here --- path/to/file2.py --- ... \"\"\" gitignore_rules = [] if ignore_gitignore else read_gitignore(path) for root, dirs, files in os.walk(path): if not include_hidden: dirs[:] = [d for d in dirs if not d.startswith(\".\")] files = [f for f in files if not f.startswith(\".\")] if not ignore_gitignore: gitignore_rules.extend(read_gitignore(root)) dirs[:] = [d for d in dirs if not should_ignore(os.path.join(root, d), gitignore_rules)] files = [f for f in files if not should_ignore(os.path.join(root, f), gitignore_rules)] for file in files: file_path = os.path.join(root, file) with open(file_path, \"r\") as f: file_contents = f.read() click.echo(file_path) click.echo(\"---\") click.echo(file_contents) click.echo() click.echo(\"---\")\n\nFrom that point on I was hooked: could I use the new files-to-prompt tool to\nbuild the rest of itself?\n\nSince I\u2019d already bootstrapped it to a point where I could use it, I ran it\nfor real for the first time:\n\n    \n    \n    files-to-prompt . | llm -m opus --system ' fill out the test_files_to_prompt.py with tests, use tmpdir fixture to create example directories to run the command against - tests should cover both of the optional flags'\n\nHere I\u2019m sending it quite a bit of code\u2014the implementation, the README and the\nApache 2 License are all included in that prompt.\n\nIt wrote me these tests:\n\n    \n    \n    import os from click.testing import CliRunner from files_to_prompt.cli import cli def test_basic_functionality(tmpdir): runner = CliRunner() with tmpdir.as_cwd(): os.makedirs(\"test_dir\") with open(\"test_dir/file1.txt\", \"w\") as f: f.write(\"Contents of file1\") with open(\"test_dir/file2.txt\", \"w\") as f: f.write(\"Contents of file2\") result = runner.invoke(cli, [\"test_dir\"]) assert result.exit_code == 0 assert \"test_dir/file1.txt\" in result.output assert \"Contents of file1\" in result.output assert \"test_dir/file2.txt\" in result.output assert \"Contents of file2\" in result.output def test_include_hidden(tmpdir): runner = CliRunner() with tmpdir.as_cwd(): os.makedirs(\"test_dir\") with open(\"test_dir/.hidden.txt\", \"w\") as f: f.write(\"Contents of hidden file\") result = runner.invoke(cli, [\"test_dir\"]) assert result.exit_code == 0 assert \"test_dir/.hidden.txt\" not in result.output result = runner.invoke(cli, [\"test_dir\", \"--include-hidden\"]) assert result.exit_code == 0 assert \"test_dir/.hidden.txt\" in result.output assert \"Contents of hidden file\" in result.output def test_ignore_gitignore(tmpdir): runner = CliRunner() with tmpdir.as_cwd(): os.makedirs(\"test_dir\") with open(\"test_dir/.gitignore\", \"w\") as f: f.write(\"ignored.txt\") with open(\"test_dir/ignored.txt\", \"w\") as f: f.write(\"This file should be ignored\") with open(\"test_dir/included.txt\", \"w\") as f: f.write(\"This file should be included\") result = runner.invoke(cli, [\"test_dir\"]) assert result.exit_code == 0 assert \"test_dir/ignored.txt\" not in result.output assert \"test_dir/included.txt\" in result.output result = runner.invoke(cli, [\"test_dir\", \"--ignore-gitignore\"]) assert result.exit_code == 0 assert \"test_dir/ignored.txt\" in result.output assert \"This file should be ignored\" in result.output assert \"test_dir/included.txt\" in result.output\n\nThen I ran them... and they failed. Here\u2019s the error message:\n\n    \n    \n    def test_ignore_gitignore(tmpdir): runner = CliRunner() with tmpdir.as_cwd(): os.makedirs(\"test_dir\") with open(\"test_dir/.gitignore\", \"w\") as f: f.write(\"ignored.txt\") with open(\"test_dir/ignored.txt\", \"w\") as f: f.write(\"This file should be ignored\") with open(\"test_dir/included.txt\", \"w\") as f: f.write(\"This file should be included\") result = runner.invoke(cli, [\"test_dir\"]) assert result.exit_code == 0 > assert \"test_dir/ignored.txt\" not in result.output E AssertionError: assert 'test_dir/ignored.txt' not in 'test_dir/in...red\\n\\n---\\n' E E 'test_dir/ignored.txt' is contained here: E uded E E --- E test_dir/ignored.txt E ---... E E ...Full output truncated (3 lines hidden), use '-vv' to show\n\nI saved that message to `error.txt and ran this command to send it back to\nClaude 3 Opus:\n\n    \n    \n    cat error.txt | llm -c\n\nThe llm -c command stands for \u201ccontinue\u201d\u2014it will take any input or prompt and\npass that back to the model along with the previous logged prompts and\nresponses, equivalent to asking a follow-up question in an interface like\nChatGPT.\n\nClaude gave me back a corrected version of the should_ignore() function:\n\n    \n    \n    def should_ignore(path, gitignore_rules): for rule in gitignore_rules: if fnmatch(os.path.basename(path), rule): return True if os.path.isdir(path) and fnmatch(os.path.basename(path) + \"/\", rule): return True return False\n\nSending follow-on prompts with llm -c seemed to be working well, so I ran\nthis:\n\n    \n    \n    llm -c 'Fill out the Usage section of the README for this project - just return that section as markdown'\n\nAnd it gave me back a pretty decent README:\n\n> ## Usage\n>\n> To use files-to-prompt, simply provide the path to the directory you want to\n> process:\n>  \n>  \n>     files-to-prompt path/to/directory\n>\n> This will output the contents of every file in the directory and its\n> subdirectories, with each file preceded by its relative path and separated\n> by ---.\n>\n> ### Options\n>\n>   * \\--include-hidden: Include files and folders starting with . (hidden\n> files and directories).\n>  \n>     >     files-to-prompt path/to/directory --include-hidden\n>\n>   * \\--ignore-gitignore: Ignore .gitignore files and include all files.\n>  \n>     >     files-to-prompt path/to/directory --ignore-gitignore\n>\n>\n\n>\n> ### Example\n>\n> Suppose you have a directory structure like this:\n>  \n>  \n>     my_directory/ \u251c\u2500\u2500 file1.txt \u251c\u2500\u2500 file2.txt \u251c\u2500\u2500 .hidden_file.txt \u2514\u2500\u2500\n> subdirectory/ \u2514\u2500\u2500 file3.txt\n>\n> Running files-to-prompt my_directory will output:\n>  \n>  \n>     my_directory/file1.txt --- Contents of file1.txt ---\n> my_directory/file2.txt --- Contents of file2.txt ---\n> my_directory/subdirectory/file3.txt --- Contents of file3.txt ---\n>\n> If you run files-to-prompt my_directory --include-hidden, the output will\n> also include .hidden_file.txt:\n>  \n>  \n>     my_directory/.hidden_file.txt --- Contents of .hidden_file.txt --- ...\n\nI particularly liked the directory structure diagram.\n\nHere\u2019s the full transcript including my follow-ups.\n\nI committed and pushed everything I had so far to GitHub.\n\nAfter one last review of the README I noticed it had used the phrase \u201csimply\nprovide the path to the directory\u201d. I don\u2019t like using words like simply in\ndocumentation, so I fixed that.\n\nAnd I shipped version 0.1 of the software! Almost every line of code, tests\nand documentation written by Claude 3 Opus.\n\n#### Iterating on the project #\n\nI\u2019ve added several features since that initial implementation, almost all of\nwhich were primarily written by prompting Claude 3 Opus.\n\nIssue #2: Take multiple arguments for files and directories to include changed\nthe tool such that files-to-prompt README.md tests/ would include both the\nREADME.md file and all files in the tests/ directory.\n\nThe sequence of prompts to get there was as follows:\n\n    \n    \n    cat files_to_prompt/cli.py | llm -m opus --system ' Modify this file. It should take multiple arguments in a variable called paths. Each of those argumets might be a path to a file or it might be a path to a directory - if any of the arguments do not correspoind to a file or directory it should raise a click error. It should then do what it does already but for all files files-recursively-contained-within-folders that are passed to it. It should still obey the gitignore logic.'\n\nThen these to update the tests:\n\n    \n    \n    files-to-prompt files_to_prompt tests | llm -m opus --system ' rewrite the tests to cover the ability to pass multiple files and folders to the tool' files-to-prompt files_to_prompt tests | llm -m opus --system ' add one last test which tests .gitignore and include_hidden against an example that mixes single files and directories of files together in one invocation'\n\nI didn\u2019t like the filenames it was using in that last test, so I used symbex\nto extract just the implementation of that test and told it to rewrite it:\n\n    \n    \n    symbex test_mixed_paths_with_options | llm -m opus --system ' rewrite this test so the filenames are more obvious, thinks like ignored_in_gitignore.txt'\n\nAnd this to add one last test that combined all of the options:\n\n    \n    \n    llm -c 'add a last bit to that test for [\"test_dir\", \"single_file.txt\", \"--ignore-gitignore\", \"--include-hidden\"]'\n\nThe issue includes links to the full transcripts for the above.\n\n#### Updating a diff from a pull request #\n\nI quietly released files-to-prompt two weeks ago. Dipam Vasani had spotted it\nand opened a pull request adding the ability to ignore specific files, by\npassing --ignore-patterns '*.md' as an option.\n\nThe problem was... I\u2019d landed some of my own changes before I got around to\nreviewing his PR\u2014so it would no longer cleanly apply.\n\nIt turns out I could resolve that problem using Claude 3 Opus as well, by\nasking it to figure out the change from Dipam\u2019s diff.\n\nI pulled a copy of his PR as a diff like this:\n\n    \n    \n    wget 'https://github.com/simonw/files-to-prompt/pull/4.diff'\n\nThen I fed both the diff and the relevant files from the project into Claude:\n\n    \n    \n    files-to-prompt 4.diff files_to_prompt/cli.py tests/test_files_to_prompt.py | \\ llm -m opus --system \\ 'Apply the change described in the diff to the project - return updated cli.py and tests'\n\nIt didn\u2019t quite work\u2014it reverted one of my earlier changes. So I prompted:\n\n    \n    \n    llm -c 'you undid the change where it could handle multiple paths - I want to keep that, I only want to add the new --ignore-patterns option'\n\nAnd that time it worked! Transcript here.\n\nI merged Claude\u2019s work into the existing PR to ensure Dipam got credit for his\nwork, then landed it and pushed it out in a release.\n\n#### Was this worthwhile? #\n\nAs an exercise in testing the limits of what\u2019s possible with command-line LLM\naccess and the current most powerful available LLM, this was absolutely\nworthwhile. I got working software with comprehensive tests and documentation,\nand had a lot of fun experimenting with prompts along the way.\n\nIt\u2019s worth noting that this project was incredibly low stakes. files-to-prompt\nis a tiny tool that does something very simple. Any bugs or design flaws\nreally don\u2019t matter. It\u2019s perfect for trying out this alternative approach to\ndevelopment.\n\nI also got the software built a whole lot faster than if I\u2019d written it\nmyself, and with features like .gitignore support (albeit rudimentary) that I\nmay not have bothered with working alone. That\u2019s a good example of a feature\nthat\u2019s just fiddly enough that I might decide not to invest the time needed to\nget it to work.\n\nIs this the best possible version of this software? Definitely not. But with\ncomprehensive documentation and automated tests it\u2019s high enough quality that\nI\u2019m not ashamed to release it with my name on it.\n\nA year ago I might have felt guilty about using LLMs to write code for me in\nthis way. I\u2019m over that now: I\u2019m still doing the work, but I now have a\npowerful tool that can help accelerate the process.\n\n#### Using this pattern for real work #\n\nI\u2019ve since used the same pattern for some smaller modifications to some of my\nmore significant projects. This morning I used it to upgrade my datasette-cors\nplugin to add support for new features I had added to the underlying asgi-cors\nlibrary. Here\u2019s the prompt sequence I used:\n\n    \n    \n    files-to-prompt ../asgi-cors/asgi_cors.py datasette_cors.py | llm -m opus -s \\ 'Output a new datasette_cors.py plugin that adds headers and methods and max_age config options' files-to-prompt test_datasette_cors.py | llm -c \\ 'Update these tests to exercise the new options as well' cat README.md | llm -c \\ 'Update the README to document the new config options'\n\nAnd the full transcript.\n\nI reviewed this code very carefully before landing it. It\u2019s absolutely what I\nwould have written myself without assistance from Claude.\n\nTime elapsed for this change? The first prompt was logged at 16:42:11 and the\nlast at 16:44:24, so just over two minutes followed by a couple more minutes\nfor the review. The associated issue was open for five minutes total.\n\nPosted 8th April 2024 at 8:40 pm \u00b7 Follow me on Mastodon or Twitter or\nsubscribe to my newsletter\n\n## More recent articles\n\n  * Running OCR against PDFs and images directly in your browser - 30th March 2024\n  * llm cmd undo last git commit - a new plugin for LLM - 26th March 2024\n  * Building and testing C extensions for SQLite with ChatGPT Code Interpreter - 23rd March 2024\n  * Claude and ChatGPT for ad-hoc sidequests - 22nd March 2024\n  * Weeknotes: the aftermath of NICAR - 16th March 2024\n  * The GPT-4 barrier has finally been broken - 8th March 2024\n  * Prompt injection and jailbreaking are not the same thing - 5th March 2024\n  * Interesting ideas in Observable Framework - 3rd March 2024\n  * Weeknotes: Getting ready for NICAR - 27th February 2024\n\nThis is Building files-to-prompt entirely using Claude 3 Opus by Simon\nWillison, posted on 8th April 2024.\n\nPart of series How I use LLMs and ChatGPT\n\n  9. Claude and ChatGPT for ad-hoc sidequests - March 22, 2024, 7:44 p.m.\n  10. Building and testing C extensions for SQLite with ChatGPT Code Interpreter - March 23, 2024, 5:50 p.m.\n  11. llm cmd undo last git commit - a new plugin for LLM - March 26, 2024, 3:37 p.m.\n  12. Building files-to-prompt entirely using Claude 3 Opus - April 8, 2024, 8:40 p.m.\n\nprojects 364 ai 498 promptengineering 63 generativeai 432 llms 408 llm 44\nanthropic 23 claude 25\n\nPrevious: Running OCR against PDFs and images directly in your browser\n\n  * Source code\n  * \u00a9\n  * 2002\n  * 2003\n  * 2004\n  * 2005\n  * 2006\n  * 2007\n  * 2008\n  * 2009\n  * 2010\n  * 2011\n  * 2012\n  * 2013\n  * 2014\n  * 2015\n  * 2016\n  * 2017\n  * 2018\n  * 2019\n  * 2020\n  * 2021\n  * 2022\n  * 2023\n  * 2024\n\n", "frontpage": false}
