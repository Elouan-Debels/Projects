{"aid": "39981422", "title": "Neco: Concurrency Library for C (Coroutines)", "url": "https://github.com/tidwall/neco", "domain": "github.com/tidwall", "votes": 2, "user": "mpweiher", "posted_at": "2024-04-09 16:59:14", "comments": 0, "source_title": "GitHub - tidwall/neco: Concurrency library for C (coroutines)", "source_text": "GitHub - tidwall/neco: Concurrency library for C (coroutines)\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\ntidwall / neco Public\n\n  * Notifications\n  * Fork 2\n  * Star 150\n\nConcurrency library for C (coroutines)\n\n### License\n\nMIT license\n\n150 stars 2 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# tidwall/neco\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n1 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\ntidwallUpdate README.md8258e56 \u00b7\n\n## History\n\n2 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| first commit  \n  \n### deps\n\n|\n\n### deps\n\n| first commit  \n  \n### docs\n\n|\n\n### docs\n\n| first commit  \n  \n### examples\n\n|\n\n### examples\n\n| first commit  \n  \n### tests\n\n|\n\n### tests\n\n| first commit  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| first commit  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| first commit  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update README.md  \n  \n### neco.c\n\n|\n\n### neco.c\n\n| first commit  \n  \n### neco.h\n\n|\n\n### neco.h\n\n| first commit  \n  \n## Repository files navigation\n\nNeco is a C library that provides concurrency using coroutines. It's small &\nfast, and intended to make concurrent I/O & network programming easy.\n\n## Features\n\n  * Coroutines: starting, sleeping, suspending, resuming, yielding, and joining.\n  * Synchronization: channels, generators, mutexes, condition variables, and waitgroups.\n  * Support for deadlines and cancelation.\n  * Posix friendly interface using file descriptors.\n  * Addtional APIs for networking, signals, random data, streams, and buffered I/O.\n  * Lightweight runtime with a fair and deterministic scheduler.\n  * Fast user-space context switching. Uses assembly in most cases.\n  * Stackful coroutines that are nestable, with their life times fully managed by the scheduler.\n  * Cross-platform. Linux, Mac, FreeBSD. (Also WebAssembly and Windows with some limitations).\n  * Single file amalgamation. No dependencies.\n  * Test suite with 100% coverage using sanitizers and Valgrind.\n\nFor a deeper dive, check out the API reference.\n\nIt may also be worthwhile to see the Bluebox project for a more complete\nexample of using Neco, including benchmarks.\n\n## Goals\n\n  * Give C programs fast single-threaded concurrency.\n  * To use a concurrency model that resembles the simplicity of pthreads or Go.\n  * Provide an API for concurrent networking and I/O.\n  * Make it easy to interop with existing Posix functions.\n\nIt's a non-goal for Neco to provide a scalable multithreaded runtime, where\nthe coroutine scheduler is shared among multiple cpu cores. Or to use other\nconcurrency models like async/await.\n\n## Using\n\nJust drop the \"neco.c\" and \"neco.h\" files into your project. Uses standard C11\nso most modern C compilers should work.\n\n    \n    \n    cc -c neco.c\n\n## Example 1 (Start a coroutine)\n\nA coroutine is started with the neco_start() function.\n\nWhen neco_start() is called for the first time it will initialize a Neco\nruntime and scheduler for the current thread, and then blocks until the\ncoroutine and all child coroutines have terminated.\n\n    \n    \n    #include <stdio.h> #include \"neco.h\" void coroutine(int argc, void *argv[]) { printf(\"main coroutine started\\n\"); } int main(int argc, char *argv[]) { neco_start(coroutine, 0); return 0; }\n\n## Example 2 (Use neco_main instead of main)\n\nOptionally, neco_main() can be used in place of the standard main(). This is\nfor when the entirety of your program is intended to be run from only\ncoroutines. It adjusts the behavior of the program slightly to make\ndevelopment and error checking easier.\n\n    \n    \n    #include <stdio.h> #include \"neco.h\" int neco_main(int argc, char *argv[]) { printf(\"main coroutine started\\n\"); return 0; }\n\n## Example 3 (Multiple coroutines)\n\nHere we'll start two coroutines that continuously prints \"tick\" every one\nsecond and \"tock\" every two.\n\n    \n    \n    #include <stdio.h> #include \"neco.h\" void ticker(int argc, void *argv[]) { while (1) { neco_sleep(NECO_SECOND); printf(\"tick\\n\"); } } void tocker(int argc, void *argv[]) { while (1) { neco_sleep(NECO_SECOND*2); printf(\"tock\\n\"); } } int neco_main(int argc, char *argv[]) { neco_start(ticker, 0); neco_start(tocker, 0); // Keep the program alive for an hour. neco_sleep(NECO_HOUR); return 0; }\n\n## Example 4 (Coroutine arguments)\n\nA coroutine is like its own little program that accepts any number of\narguments.\n\n    \n    \n    void coroutine(int argc, void *argv[])\n\nThe arguments are a series of pointers passed to the coroutine. All arguments\nare guaranteed to be in scope when the coroutine starts and until the first\nneco_ function is called. This allows you an opportunity to validate and/or\ncopy them.\n\n    \n    \n    #include <stdlib.h> #include <assert.h> #include <unistd.h> #include \"neco.h\" void coroutine(int argc, void *argv[]) { // All arguments are currently in scope and should be copied before first // neco_*() function is called in this coroutine. int arg0 = *(int*)argv[0]; int arg1 = *(int*)argv[1]; int arg2 = *(int*)argv[2]; char *arg3 = argv[3]; char *arg4 = argv[4]; printf(\"arg0=%d, arg1=%d, arg2=%d, arg3=%s, arg4=%s\\n\", arg0, arg1, arg2, arg3, arg4); neco_sleep(NECO_SECOND/2); // The arguments are no longer in scope and it's unsafe to use the argv // variable any further. printf(\"second done\\n\"); } int neco_main(int argc, char *argv[]) { int arg0 = 0; int *arg1 = malloc(sizeof(int)); *arg1 = 1; neco_start(coroutine, 5, &arg0, arg1, &(int){2}, NULL, \"hello world\"); free(arg2); neco_sleep(NECO_SECOND); printf(\"first done\\n\"); return 0; }\n\n## Example 5 (Channels)\n\nA channel is a mechanism for communicating between two or more coroutines.\n\nHere we'll create a second coroutine that sends the message 'ping' to the\nfirst coroutine.\n\n    \n    \n    #include <stdlib.h> #include <unistd.h> #include \"neco.h\" void coroutine(int argc, void *argv[]) { neco_chan *messages = argv[0]; // Send a message of the 'messages' channel. char *msg = \"ping\"; neco_chan_send(messages, &msg); // This coroutine no longer needs the channel. neco_chan_release(messages); } int neco_main(int argc, char *argv[]) { // Create a new channel that is used to send 'char*' string messages. neco_chan *messages; neco_chan_make(&messages, sizeof(char*), 0); // Start a coroutine that sends messages over the channel. // It's a good idea to use neco_chan_retain on a channel before using it // in a new coroutine. This will avoid potential use-after-free bugs. neco_chan_retain(messages); neco_start(coroutine, 1, messages); // Receive the next incoming message. Here we\u2019ll receive the \"ping\" // message we sent above and print it out. char *msg = NULL; neco_chan_recv(messages, &msg); printf(\"%s\\n\", msg); // This coroutine no longer needs the channel. neco_chan_release(messages); return 0; }\n\n## Example 6 (Generators)\n\nA generator is like channel but is stricly bound to a coroutine and is\nintended to treat the coroutine like an iterator.\n\n    \n    \n    #include <stdio.h> #include <unistd.h> #include \"neco.h\" void coroutine(int argc, void *argv[]) { // Yield each int to the caller, one at a time. for (int i = 0; i < 10; i++) { neco_gen_yield(&i); } } int neco_main(int argc, char *argv[]) { // Create a new generator coroutine that is used to send ints. neco_gen *gen; neco_gen_start(&gen, sizeof(int), coroutine, 0); // Iterate over each int until the generator is closed. int i; while (neco_gen_next(gen, &i) != NECO_CLOSED) { printf(\"%d\\n\", i); } // This coroutine no longer needs the generator. neco_gen_release(gen); return 0; }\n\n## Example 7 (Connect to server)\n\nNeco provides neco_dial() for easily connecting to server.\n\nHere we'll performing a (very simple) HTTP request which prints the homepage\nof the http://example.com website.\n\n    \n    \n    #include <stdio.h> #include <unistd.h> #include \"neco.h\" int neco_main(int argc, char *argv[]) { int fd = neco_dial(\"tcp\", \"example.com:80\"); if (fd < 0) { printf(\"neco_dial: %s\\n\", neco_strerror(fd)); return 0; } char req[] = \"GET / HTTP/1.1\\r\\n\" \"Host: example.com\\r\\n\" \"Connection: close\\r\\n\" \"\\r\\n\"; neco_write(fd, req, sizeof(req)); while (1) { char buf[256]; int n = neco_read(fd, buf, sizeof(buf)); if (n <= 0) { break; } printf(\"%.*s\", n, buf); } close(fd); return 0; }\n\n## Example 8 (Create a server)\n\nUse neco_serve() to quickly bind and listen on an address.\n\nHere we'll run a tiny webserver at http://127.0.0.1:8080\n\n    \n    \n    #include <stdio.h> #include <unistd.h> #include \"../neco.h\" void request(int argc, void *argv[]) { int fd = *(int*)argv[0]; char req[256]; int n = neco_read(fd, req, sizeof(req)); if (n > 0) { char res[] = \"HTTP/1.0 200 OK\\r\\n\" \"Content-Type: text/html\\r\\n\" \"Content-Length: 21\\r\\n\" \"\\r\\n\" \"<h1>Hello Neco!</h1>\\n\"; neco_write(fd, res, sizeof(res)); } close(fd); } int neco_main(int argc, char *argv[]) { int servfd = neco_serve(\"tcp\", \"127.0.0.1:8080\"); if (servfd < 0) { printf(\"neco_serve: %s\\n\", neco_strerror(servfd)); return 0; } printf(\"Serving at http://127.0.0.1:8080\\n\"); while (1) { int fd = neco_accept(servfd, 0, 0); if (servfd < 0) { printf(\"neco_accept: %s\\n\", neco_strerror(fd)); continue; } neco_start(request, 1, &fd); } return 0; }\n\n## Example 9 (Echo server and client)\n\nRun server with:\n\n    \n    \n    cc neco.c echo-server.c && ./a.out\n\nRun client with:\n\n    \n    \n    cc neco.c echo-client.c && ./a.out\n\necho-server.c\n\n    \n    \n    #include <stdlib.h> #include <unistd.h> #include \"neco.h\" void client(int argc, void *argv[]) { int conn = *(int*)argv[0]; printf(\"client connected\\n\"); char buf[64]; while (1) { ssize_t n = neco_read(conn, buf, sizeof(buf)); if (n <= 0) { break; } printf(\"%.*s\", (int)n, buf); } printf(\"client disconnected\\n\"); close(conn); } int neco_main(int argc, char *argv[]) { int ln = neco_serve(\"tcp\", \"localhost:19203\"); if (ln == -1) { perror(\"neco_serve\"); exit(1); } printf(\"listening at localhost:19203\\n\"); while (1) { int conn = neco_accept(ln, 0, 0); if (conn > 0) { neco_start(client, 1, &conn); } } close(ln); return 0; }\n\necho-client.c\n\n    \n    \n    #include <stdlib.h> #include <unistd.h> #include \"neco.h\" int neco_main(int argc, char *argv[]) { int fd = neco_dial(\"tcp\", \"localhost:19203\"); if (fd == -1) { perror(\"neco_listen\"); exit(1); } printf(\"connected\\n\"); char buf[64]; while (1) { printf(\"> \"); fflush(stdout); ssize_t nbytes = neco_read(STDIN_FILENO, buf, sizeof(buf)); if (nbytes < 0) { break; } ssize_t ret = neco_write(fd, buf, nbytes); if (ret < 0) { break; } } printf(\"disconnected\\n\"); close(fd); return 0; }\n\n## Example 10 (Suspending and resuming a coroutine)\n\nAny coroutines can suspended itself indefinetly and then be resumed by other\ncoroutines by using neco_suspend() and neco_resume().\n\n    \n    \n    #include <stdio.h> #include <unistd.h> #include \"neco.h\" void coroutine(int argc, void *argv[]) { printf(\"Suspending coroutine\\n\"); neco_suspend(); printf(\"Coroutine resumed\\n\"); } int neco_main(int argc, char *argv[]) { neco_start(coroutine, 0); for (int i = 0; i < 3; i++) { printf(\"%d\\n\", i+1); neco_sleep(NECO_SECOND); } // Resume the suspended. The neco_lastid() returns the identifier for the // last coroutine started by the current coroutine. neco_resume(neco_lastid()); return 0; } // Output: // Suspending coroutine // 1 // 2 // 3 // Coroutine resumed\n\n### More examples\n\nYou can find more examples here.\n\n## Platform notes\n\nLinux, Mac, and FreeBSD supports all features.\n\nWindows and WebAssembly support the core coroutine features, but have some key\nlimitiations, mostly with working with file descriptors and networking. This\nis primarly because the Neco event queue works with epoll and kqueue, which\nare only available on Linux and Mac/BSD respectively. This means that the\nneco_wait() (which allows for a coroutine to wait for a file descriptor to be\nreadable or writeable) is not currently available on those platforms.\n\nOther limitations include:\n\n  * Windows only supports amd64.\n  * Windows and WebAssembly use smaller default stacks of 1MB.\n  * Windows and WebAssembly do not support guards or gaps.\n  * Windows and WebAssembly do not support NECO_CSPRNG (Cryptographically secure pseudorandom number generator)\n  * Windows does not support stack unwinding.\n\nOther than that, Neco works great on those platforms.\n\nAny contributions towards making Windows and WebAssembly feature complete are\nwelcome.\n\n## The scheduler\n\nNeco uses sco, which is a fair and deterministic scheduler. This means that no\ncoroutine takes priority over another and that all concurrent operations will\nreproduce in an expected order.\n\n### Fast context switching\n\nThe coroutine context switching is powered by llco and uses assembly code in\nmost cases. On my lab machine (AMD Ryzen 9 5950X) a context switch takes about\n11 nanoseconds.\n\n### Thread local runtime\n\nThere can be no more than one scheduler per thread.\n\nWhen the first coroutine is started using neco_start(), a new Neco runtime is\ninitialized in the current thread, and each runtime has its own scheduler.\n\nCommunicating between coroutines that are running in different threads will\nrequire I/O mechanisms that do not block the current schedulers, such as\npipe(), eventfd() or atomics.\n\nPthread utilties such as pthread_mutex_t and pthread_cond_t do not work very\nwell in coroutines.\n\nFor example, here we'll create two threads, running their own Neco schedulers.\nEach using pipes to communicate with the other.\n\n    \n    \n    #include <stdio.h> #include <unistd.h> #include <pthread.h> #include \"neco.h\" void coro1(int argc, void *argv[]) { // This coroutine is running in a different scheduler than coro2. int rd = *(int*)argv[0]; int wr = *(int*)argv[1]; int val; neco_read(rd, &val, sizeof(int)); printf(\"coro1: %d\\n\", val); neco_write(wr, &(int){ 2 }, sizeof(int)); } void coro2(int argc, void *argv[]) { // This coroutine is running in a different scheduler than coro1. int rd = *(int*)argv[0]; int wr = *(int*)argv[1]; int val; neco_write(wr, &(int){ 1 }, sizeof(int)); neco_read(rd, &val, sizeof(int)); printf(\"coro2: %d\\n\", val); } void *runtime1(void *arg) { int *pipefds = arg; neco_start(coro1, 2, &pipefds[0], &pipefds[3]); return 0; } void *runtime2(void *arg) { int *pipefds = arg; neco_start(coro2, 2, &pipefds[2], &pipefds[1]); return 0; } int main() { int pipefds[4]; pipe(&pipefds[0]); pipe(&pipefds[2]); pthread_t th1, th2; pthread_create(&th1, 0, runtime1, pipefds); pthread_create(&th2, 0, runtime2, pipefds); pthread_join(th1, 0); pthread_join(th2, 0); return 0; }\n\n## License\n\nSource code is available under the MIT License.\n\n## About\n\nConcurrency library for C (coroutines)\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n150 stars\n\n### Watchers\n\n4 watching\n\n### Forks\n\n2 forks\n\nReport repository\n\n## Releases\n\n1 tags\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * C 98.2%\n  * Shell 1.8%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
