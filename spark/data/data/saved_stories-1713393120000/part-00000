{"aid": "40066970", "title": "Show HN: How to program an Arduino using Rust (on macOS)", "url": "https://rybicki.io/blog/2024/04/16/program-arduino-using-rust.html", "domain": "rybicki.io", "votes": 6, "user": "nathan_tarbert", "posted_at": "2024-04-17 16:29:57", "comments": 0, "source_title": "How to program an Arduino using Rust (on macOS)", "source_text": "How to program an Arduino using Rust (on macOS) | functional fascinations\n\nfunctional fascinations\n\n# How to program an Arduino using Rust (on macOS)\n\nApr 16, 2024\n\nI have a confession to make \u2013 in all honesty, I\u2019m not much of a hardware\nhacker. In my teens, whenever I got home from school, I gravitated more often\nto coding (or video games) than soldering or robotics.\n\nBut I spent a lot of my childhood playing with Snap Circuits and redstone\ncircuits in Minecraft, so I can appreciate the charm. You\u2019re automating things\n- taking small atoms and combining them into something bigger. Just like code\ncan be written to do whatever you want, so can hardware \u2013 and there\u2019s\nsomething more visceral to it since your creations takes up space in the real\nworld. I dig that.\n\nIn an effort to challenge myself (and have a bit of fun), I recently picked up\nan Arduino, and it\u2019s sparked a lot of the same joy I had when I first started\nbuilding with LEGOs as a kid or programming as a teen. The Arduino is pretty\naccessible to newbies - so once I got my board working, it felt natural that\nas my first task, I\u2019d write a program for it in Rust, since Rust is a pretty\nhot language for embedded systems programming these days.\n\nThe process for getting this working hasn\u2019t been too complicated, but there\u2019s\nsome setup required to get it working on macOS, so I thought I\u2019d take some\nnotes and share my learning process in case it helps anyone else.\n\nOnwards!\n\n> Note: This isn\u2019t an introduction to Arduino. If it\u2019s your first time using\n> one, I recommend following the official tutorials that will guide you on\n> setting yours up and uploading simple programs using the Arduino IDE. Once\n> you feel comfortable with that, feel free to come back here!\n\n> Note: This also isn\u2019t an introduction to Rust. For that, I recommend\n> checking out the Rust book.\n\n## Preparation\n\nThe \u201cHello World\u201d of the embedded programming world is to get an LED blinking\n- so that\u2019s what our first Rust-based Arduino program will do.\n\nArduino chips are based on a family of microcontrollers called AVR. To compile\nRust programs to work on these chips, we\u2019ll need to install some build tools\nspecifically for compiling to the chips\u2019 instruction sets.\n\nFirst, you\u2019ll need a nightly Rust compiler for compiling Rust code for AVR.\nAfter rustup is installed (if you don\u2019t have it already), you can install the\nnightly compiler with:\n\n    \n    \n    rustup toolchain install nightly\n\nYou\u2019ll also want to have XCode tools set up, if you haven\u2019t already:\n\n    \n    \n    xcode-select --install\n\nNext we\u2019ll install some AVR-related tools using homebrew:\n\n    \n    \n    brew tap osx-cross/avr brew install avr-gcc avrdude\n\navr-gcc is a compiler that can take C code and create a binary source that can\nbe uploaded to an AVR microcontroller. avrdude is a program for uploading\nprograms to AVR microcontrollers (a process often called \u201cflashing\u201d).\n\nWe\u2019ll also install a CLI called ravedude which makes it possible to flash to\nyour board as part of your usual cargo workflow:\n\n    \n    \n    cargo +stable install ravedude\n\n## Writing Rust\n\n(spoiler: there won\u2019t actually be much actual coding in this section)\n\nThe most well supported crate for programming Arduino embedded devices is a\ncrate named arduino-hal, located in this repo. You can create a starter\nproject by running:\n\n    \n    \n    cargo install cargo-generate cargo generate --git https://github.com/Rahix/avr-hal-template.git\n\nYou\u2019ll be prompted to answer a few questions, and then it\u2019ll create a project\nfor you.\n\nOnce you\u2019ve opened it, all you should need to do is cargo run to build and\nflash the application to your board. ravedude automatically figures out the\nserial port your device is connected to which is pretty convenient.\n\nCongrats - if your starter code was the same as mine, then your device should\nnow be blinking:\n\nExternal LED optional.\n\nAt this point, we can probably say we\u2019re done - but we haven\u2019t really peaked\nat the Rust code, so the rest of the post will go into some more depth about\nwhat\u2019s happening in the starter program.\n\n## Understanding the code\n\nThe started program created by the template should look something like this:\n\n    \n    \n    #![no_std] #![no_main] use panic_halt as _; #[arduino_hal::entry] fn main() -> ! { let dp = arduino_hal::Peripherals::take().unwrap(); let pins = arduino_hal::pins!(dp); let mut led = pins.d13.into_output(); loop { led.toggle(); arduino_hal::delay_ms(1000); } }\n\nThere\u2019s a good chunk of boilerplate here, but for educational purposes it\u2019s\ninteresting to understand what each line is doing to contribute to the overall\nprogram since many parts of it will be common to a lot of embedded Rust code.\n\n### no_std\n\nLet\u2019s start with the first line:\n\n    \n    \n    #![no_std]\n\nThis tells the Rust that we want to compile our program without all of the\nstandard library\u2019s built-in APIs (like file system functions, collection\ntypes, and so on) available by default. Instead only the types and functions\nfrom core (a subset of std) will be available.\n\nIn embedded programming, we want our compiled code to be as tiny as possible,\nso this mode makes it easier to ensure our program only includes the bare\nessentials. For example, no_std programs disallow heap allocation by default.\nThis means if your program doesn\u2019t need to dynamically allocate any memory\n(common in embedded programming), then a memory allocator won\u2019t be included in\nthe final program.\n\n> If you try using a third party crate that relies on the standard library,\n> then the compiler will typically give you compiler errors indicating the\n> faulty use of std.\n>  \n>  \n>     error[E0463]: can't find crate for `std` --> /Users/rybickic/.cargo/registry/src/index.crates.io-6f17d22bba15001f/num-traits-0.2.18/src/lib.rs:23:1 | 23 | extern crate std; | ^^^^^^^^^^^^^^^^^ can't find crate | = note: the `avr-atmega328p` target may not support the standard library = help: consider building the standard library from source with `cargo build -Zbuild-std`\n>\n> Fortunately, many crates in the Rust ecosystem work with no_std either out-\n> of-the-box or through dedicated crate features, so it seems like this style\n> of programming is decently well supported.\n\n### no_main\n\nMoving on. The next line is:\n\n    \n    \n    #![no_main]\n\nThis is a directive telling the compiler that the program will be compiled\nwithout a main function, so we don\u2019t want Rust to yell at us about it. This\nmight be confusing at first since the program does appear to have a function\nnamed main, but it turns out this function gets replaced by the\n#[arduino_hal::entry] macro coming before it.\n\nSince we\u2019re using arduino_hal as a framework, it\u2019s not that important to for\nus to understand its internals. But since I was curious, I used cargo-expand\nto see what the code was transformed into to after Rust expanded all of the\nmacros. Running cargo expand on the initial program yields:\n\n    \n    \n    #![feature(prelude_import)] #![no_std] #![no_main] #[prelude_import] use core::prelude::rust_2021::*; #[macro_use] extern crate core; extern crate compiler_builtins as _; use panic_halt as _; #[doc(hidden)] #[export_name = \"main\"] pub unsafe extern \"C\" fn __avr_device_rt_main_trampoline() { __avr_device_rt_main() } #[doc(hidden)] fn __avr_device_rt_main() -> ! { let dp = arduino_hal::Peripherals::take().unwrap(); let pins = ::arduino_hal::Pins::with_mcu_pins(::atmega_hal::Pins::new(dp.PORTB, dp.PORTC, dp.PORTD)); let mut led = pins.d13.into_output(); loop { led.toggle(); arduino_hal::delay_ms(1000); } }\n\nIf we squint our eyes a bit we can see the function is rewritten to another\nname, and an extern function is created, presumably so that another program\ncan run or link to our code. (If you know more about how this works, I\u2019d be\nmore than curious to know.)\n\n### Panic handler\n\nThe following line, use panic_halt as _; defines a panic handler which tells\nRust that if any code panics, we just want the program to busy-loop.\n\nThe reason we need this that when a no_std or embedded program panics, there\noften isn\u2019t a standard output to raise a message or print a stack trace to, so\nRust requires us to specify how to handle the these situations.\n\n### Entrypoint\n\nFinally, we have our program\u2019s entrypoint:\n\n    \n    \n    #[arduino_hal::entry] fn main() -> ! { // snip }\n\nWe already explained in a previous section how the #[arduino_hal] macro gets\nexpanded and transforms the main function \u2013 but what\u2019s the deal with the\nreturn type?\n\n!, also called never, is a special type in Rust that represents the type of\nany value that never resolves. When ! is used as a return type, this means the\nfunction never returns (it loops forever).\n\nArduino programs are expected to run forever - they run as long as your chip\nis powered on. Since the Rust program only has a single function named main,\nusing ! as a return type allows the compiler to enforce this contract, and\nraise any errors to us if it detects that our function might exits\nprematurely. (Neat!)\n\n### Function body\n\nFinally, we have the guts of our actual program.\n\n    \n    \n    let dp = arduino_hal::Peripherals::take().unwrap(); let pins = arduino_hal::pins!(dp); let mut led = pins.d13.into_output(); loop { led.toggle(); arduino_hal::delay_ms(1000); }\n\nHere we\u2019re using a HAL, or Hardware Abstraction Layer, to interact with all of\nthe device features of our chip. Specifically, we\u2019re using arduino-hal (docs).\nThese are high level APIs that reduce the extent to which we have to read and\nunderstand the 300+ page datasheets associated with our chips.\n\n> Datasheets are what have all of the technical goodies about a chip\u2019s\n> features, pin configurations, CPU and memory behavior, electrical\n> characteristics, and more. They make for fun reading on the beach.\n>\n> Here are the data sheets for the Arduino UNO R3, and its microcontroller,\n> the ATmega328P:\n>\n>   * Arduino UNO R3 datasheet\n>   * ATmega328P\n>\n\nIn the program\u2019s body, we call Peripherals::take to obtain unique access to\nthe device\u2019s peripherals, and then use arduino_hal::pins! to obtain the\ndevice\u2019s pins from the peripherals.\n\nAfterwards, we set one of the pins as an output (some pins can be configured\nas either inputs or outputs), and start a loop that toggles the pin\u2019s state\nand sleeps for a second within a loop.\n\nThe code here is pretty simple, but it\u2019s worth highlighting what we didn\u2019t\nhave to do. We didn\u2019t have to poke and set individual memory addresses, we\ndidn\u2019t have to worry about incorrect initialization state, and we didn\u2019t have\nto worry about peripherals getting configured out of order. All of these kinds\nof sharp edges were smoothed out by the zero-cost abstractions provided by the\nHAL.\n\n## Closing\n\nI hope these notes were useful. If you discover any glaring errors, please\ndon\u2019t hesitate to reach out and let me know.\n\nHappy hacking!\n\n## Further resources\n\n  * avr-hal examples - The avr-hal repo has dozens (hundreds?) of examples of various sample programs for programming arduino devices.\n  * An Overview of the Embedded Rust Ecosystem - This video provides an great introduction to Rust\u2019s embedded programming ecosystems, explaining how microcontrollers are controlled at the lowest level (by setting various bytes in memory) and how different kinds of Rust crates solve different development issues by shifting responsibilities from runtime to compile time or by making embedded device code more interoperable.\n  * The Embedded Rust Book - An introductory book about using Rust on embedded systems.\n  * USART, UART, RS232, USB, SPI, I2C, TTL, etc. what are all of these and how do they relate to each other? - A helpful StackOverflow thread covering some terminology thrown around in the embedded programming space that I didn\u2019t know about as a newbie.\n\n## functional fascinations\n\n  * Chris Rybicki\n\n  * Chriscbr\n  * christopher-rybicki\n  * rybickic\n  * rss\n\n", "frontpage": true}
