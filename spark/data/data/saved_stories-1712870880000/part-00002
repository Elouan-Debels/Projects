{"aid": "40003214", "title": "Book Review: Practical Julia", "url": "https://lwn.net/SubscriberLink/966684/9989f841b3f174d5/", "domain": "lwn.net", "votes": 2, "user": "signa11", "posted_at": "2024-04-11 15:26:33", "comments": 0, "source_title": "Book review: Practical Julia [LWN.net]", "source_text": "Book review: Practical Julia [LWN.net]\n\nLWN .net News from the source\n\n  * Content\n\n    * Weekly Edition\n    * Archives\n    * Search\n    * Kernel\n    * Security\n    * Events calendar\n    * Unread comments\n    * LWN FAQ\n    * Write for us\n  * Edition\n\n    * Return to the Front page\n\n| |\n\nSubscribe / Log in / New account\n\n# Book review: Practical Julia\n\n## [LWN subscriber-only content]\n\n### Welcome to LWN.net\n\nThe following subscription-only content has been made available to you by an LWN subscriber. Thousands of subscribers depend on LWN for the best news from the Linux and free software communities. If you enjoy this article, please consider accepting the trial offer on the right. Thank you for visiting LWN.net!| | \n\n### Free trial subscription\n\nTry LWN for free for 1 month: no payment or credit card required. Activate\nyour trial subscription now and see why thousands of readers subscribe to\nLWN.net.  \n---  \n  \nBy Jake Edge April 10, 2024\n\nA recent book by LWN guest author Lee Phillips provides a nice introduction to\nthe Julia programming language. Practical Julia does more than that, however.\nAs its subtitle (\"A Hands-On Introduction for Scientific Minds\") implies, the\nbook focuses on bringing Julia to scientists, rather than programmers, which\ngives it something of a different feel from most other books of this sort.\n\nThe book begins with the preliminaries, as one might guess. It gives\ninformation on how and where to get Julia. There is also a description of\nJulia's read-eval-print loop (REPL) that can be used for interacting with the\nlanguage, along with other options of that sort (e.g. computational notebooks,\nsuch as the Julia-specific Pluto or the multi-lingual Jupyter). The book also\nshows some of the more \"modern\" features adopted by Julia, like its use of\ncolors in the REPL and its embrace of Unicode for identifiers, including\nallowing (some) emojis as variable names.\n\n#### Language intro\n\nPart one of the book (\"Learning Julia\") provides an introduction to Julia,\nwhich starts with numbers\u2014Julia has a whole slew of numeric types, including\ninteger and floating-point types of different widths (e.g. Int32, Float64).\nComplex values can be created using im for i, so \"3 + 4im\" is a Complex{Int64}\ntype (at least on a 64-bit system), while 3.14 + 7.2im is a Complex{Float64}.\nJulia has three different types of division, spelled \"\u00f7\", \"/\", and \"//\", which\nresult in integer, floating-point, or rational-number (i.e. fractional)\nvalues.\n\nEntering \"\u00f7\" is a bit cumbersome, perhaps, though the REPL has a form of\ncompletion that can be used instead of compose-key sequences (or other\nUnicode-input mechanisms). Typing \"\\div\" followed by the TAB key will insert\nthe division sign\u2014whether that is easier or not probably depends on the user.\nThat also works for various other Unicode symbols that might be used as\nvariables to make the calculations in a program look more like the underlying\nmathematical formulas. To me, it all seems a bit clunky to work with, however.\n\nNumeric types are followed up with a whirlwind tour of some types of\nexpressions, including expression blocks, leading into simple while loops and\nif statements. After that are aggregate types. Julia has arrays, naturally,\nincluding one-dimensional vectors and multi-dimensional matrices. Since array\nelements can contain any other objects, you can have vectors of vectors (or\nmatrices, etc.). All of that is pretty standard stuff for a programming\nlanguage these days.\n\nBut Julia has a number of quirks with using arrays that the book describes\nnicely\u2014and at some length. Arrays can be accessed, constructed, and operated\non in an almost dizzying number of ways, some of which make more sense (to me)\nthan others, but Phillips goes through them in some detail. Given that Julia\nis often used in scientific computing\u2014which the book focuses on\u2014having a wide\nvariety of array-manipulation tools is to be expected. The Fortran roots of\nscientific computing also make a somewhat surprising appearance in Julia:\narrays are indexed starting at one and matrices are stored in column-major\norder.\n\nNext up are characters and strings, with strings being \"\"similar in some ways\nto a Vector, but with some complications\"\"\u2014arising from the differing widths\nof UTF-8 characters. Those difficulties lead smoothly into the presentation of\nfor loops, which can be used to step through strings without falling into\nstring-indexing holes, among other uses, of course. Unlike vectors, though,\nstrings in Julia are immutable.\n\nThe initial \"Language Basics\" chapter wraps up with functions, scoping, and\nmutability. The book carefully describes how to define simple functions and\ndefers one of Julia's signature features, multiple dispatch, to later. As with\nvarious other small features and conveniences, Phillips often mentions them in\npassing, such as using \"2x\" where other languages require \"2*x\" or that truly\nsimple functions can be defined on a single line:\n\n    \n    \n    function double(x) 2x end # or: double(x) = 2x\n\nIt is kind of a casual, almost meandering at times, introduction to the core\nof the language. That is a bit surprising, because, in less than 40 pages, it\ngives enough information to start writing simple programs. The introduction is\nnot aimed at complete novices, however; a technical, math-oriented background\nwill be needed to come up to speed. The scientists targeted by the book should\ngenerally do just fine.\n\nIn the first part, there are additional chapters on different facets of the\nlanguage and its ecosystem. \"Modules and Packages\" heads that list. The\nchapter covers both sides of the coin: developing and using modules and\npackages in projects, as well as picking up new packages and adding them to\nthe local installation. Julia's package system uses the Pkg package manager,\nwhich downloads from the official Julia package registry by default.\n\nOne of Julia's signature features, graphical output, is the subject of two\nseparate chapters in the first part of the book. The plotting chapter looks at\nmultiple options for both two- and three-dimensional plots. Some choices for\ndifferent plotting backends beyond GR, which is the default for the Plots\npackage that is the go-to tool for data visualization in Julia, are mentioned\nas well. Another chapter, perhaps a little oddly separated by two intervening\nchapters, looks at creating diagrams and animations using Julia.\n\nThe two chapters in between add more language features, including collections\n(such as dictionaries, sets, and named tuples), more operations on arrays,\nmore information on functions, metaprogramming, macros, and so on. The final\nchapter of the language-introduction is on the type system and how it can be\nused for multiple dispatch. Those reading the book this far\u2014generally with the\nREPL open for trying things out\u2014should come out of it having learned the\nfundamentals of Julia. Up next is the second half, which puts the language to\nwork on a variety of real-world scientific-computing problems.\n\n#### Application\n\nIt seems clear that Phillips sees the first part mostly as an entree to his\nexamples of how to apply Julia to different problem domains. There are seven\nseparate chapters covering problems from areas such as physics, biology, and\nmachine learning. A chapter on parallel processing has some echoes with his\n2021 article on Julia concurrency, which is no surprise. Each of the chapters\nlooks at a few problems from the topic area and presents solutions that use\npackages from the wide array of choices that the Julia ecosystem provides.\n\nWhile I could pretty easily follow the code in these chapters, some of the\nunderlying math and science went sailing smoothly overhead\u2014my calculus has\nsadly bitrotted over the years. One that (mostly) did not was the chapter on\nstatistics, which looked at random numbers, complete with a plot of their\n(lack of) distribution. It also had an interesting treatment of the Monty Hall\nproblem, which is surprisingly still non-intuitive even after having seen it\nmultiple times. \"Playing\" the game thousands of times shows which door choice\nmakes the most sense\u2014in graphic form, as is true throughout part two.\n\nThe pandemic-modeling example in the statistics chapter was also interesting.\nFrom there, Phillips looked at using real-world data as a way to describe\nusing CSV files, handling missing data, and introducing the DataFrames package\nin the context of doing statistical analysis of COVID-19 data. DataFrames\nprovides a tabular data structure similar to that of Python's pandas module.\nUsing those, he creates several different types of graphs that compare\ninfection rates of many countries and over various time scales. It is\nabundantly clear how versatile Julia is in manipulating and displaying data,\nwhich goes hand-in-hand with its visualization focus.\n\nExamples from other chapters range from evolutionary modeling to signal\nanalysis of the call of the endangered Cactus Ferruginous Pygmy Owl. The\nsubject matter of the examples is diverse enough that there are likely at\nleast a few problems in a subject area of interest to each reader. But, even\nif evolution or bird calls are not particularly compelling, the techniques\nused can be applied more widely\u2014and there are dozens of other examples.\n\nAs in the first part, Phillips sprinkles in relevant tidbits of Julia\nprogramming techniques in the examples, so there are multiple things to be\nlearned from them. Each chapter has a \"Further Reading\" section at the end\nwith references to places to go for more information as well. Overall, the\nbook has well-chosen examples that give plenty of opportunity to\ndemonstrate\u2014show off\u2014all that can be done with the language.\n\nOf course, no book is perfect, so I have some minor complaints. The example\nchosen to explain the continue statement seemed contrived, for example. And I\nfound the description of the interaction between column-major order and the\nfill() and repeat() matrix operations confusing, which may be a personal\nfailing. There are others, but the only one of note is that the book may make\nthe reader lament that their math skills have slowly dribbled away\u2014at least it\ndid for me.\n\nOne thing that seems clear, though, is that the sprawling nature of the Julia\nlanguage\u2014a kitchen sink is in there somewhere, I'm sure\u2014makes it hard to\ncontain in a book. Phillips generally does an admirable job; it seems likely\nthat his intended audience will find much to like\u2014and use\u2014in the book.\nInterested non-scientists will too.\n\n> Did you like this article? Please accept our trial subscription offer to be\n> able to see more content like it and to participate in the discussion.  \n> ---  \n  \n(Log in to post comments)\n\nCopyright \u00a9 2024, Eklektix, Inc. Comments and public postings are copyrighted\nby their creators. Linux is a registered trademark of Linus Torvalds\n\n", "frontpage": false}
