{"aid": "40002761", "title": "Better string formatting in Java with MessageFormat class", "url": "https://igorstechnoclub.com/string-formatting-in-java-with-messageformat/", "domain": "igorstechnoclub.com", "votes": 2, "user": "Igor_Wiwi", "posted_at": "2024-04-11 14:44:15", "comments": 0, "source_title": "Better string formatting in Java with MessageFormat", "source_text": "Better string formatting in Java with MessageFormat | Igor's Techno Club\n\n# Igor's Techno Club\n\n# Better string formatting in Java with MessageFormat\n\n10 Apr, 2024\n\nWhen it comes to string formatting in Java, developers typically opt for\neither straightforward string concatenation or the String.format method. I\nusually recommend using String.format, because it's less error prone than\nstring concatenation, but today I want to explore another option that is often\noverlooked by developers.\n\nThe main difference between MessageFormat.format and String.format lies in how\narguments are passed to the string: String.format utilizes specific placement\nmarkers (e.g., %s, %d), whereas MessageFormat.format uses indexed\nplaceholders, with each index corresponding to a value from the argument\narray.\n\n    \n    \n    String message = \"Hello, {0}! Welcome to {1}.\"; String formattedMessage = MessageFormat.format(message, \"John\", \"our website\"); System.out.println(formattedMessage);\n\nOutput:\n\n    \n    \n    Hello, John! Welcome to our website.\n\nBut there are more differences to consider. Let's delve deeper into what\nMessageFormat.format offers:\n\n### Handling Pluralization:\n\n    \n    \n    String pattern = \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files} on your desktop.\"; for (int count : new int[]{0, 1, 5}) { System.out.println(MessageFormat.format(pattern, count)); }\n\nOutput:\n\n    \n    \n    There are no files on your desktop. There is one file on your desktop. There are 5 files on your desktop.\n\nHere, MessageFormat utilizes the choice format to select the appropriate\nmessage based on the number.\n\n### Localization and Internationalization:\n\n    \n    \n    double payment = 1234.56; Object[] args = {payment}; MessageFormat usFormatted = new MessageFormat(\"The payment due is {0,number,currency}.\", Locale.US); MessageFormat itFormatted = new MessageFormat(\"The payment due is {0,number,currency}.\", Locale.ITALY); System.out.println(usFormatted.format(args)); System.out.println(itFormatted.format(args));\n\nOutput:\n\n    \n    \n    The payment due is $1,234.56. The payment due is \u20ac 1.234,56.\n\nMessageFormat.format supports localization by allowing the specification of a\nLocale object. In this example, the payment amount is formatted differently\nbased on the locale.\n\n### Handling Date and Time Formatting:\n\n    \n    \n    String message = \"The meeting is scheduled for {0, date, long} at {0, time, short}.\"; Date meetingDate = new Date(); String formattedMessage = MessageFormat.format(message, meetingDate); System.out.println(formattedMessage);\n\nOutput:\n\n    \n    \n    The meeting is scheduled for May 18, 2023 at 10:30 AM.\n\nMessageFormat.format can also handle date and time formatting based on\nspecified format styles. In this example, the meeting date is formatted using\nthe long date style and short time style. This method also allows for more\nsophisticated date formatting, such as:\n\n    \n    \n    Date now = new Date(); String formattedFilename = MessageFormat.format(\"file{0,date,yyyy-MM-dd-HH-mm-ss}.json\", now); System.out.println(formattedFilename);\n\nThis exploration of MessageFormat.format demonstrates its flexibility and\npower, particularly in applications requiring localization, conditional\nformatting, and the management of complex string patterns.\n\n#codequality #java #til\n\nPowered by Bear \u0295\u2022\u1d25\u2022\u0294\n\n", "frontpage": false}
