{"aid": "40000689", "title": "Puzzles to convince you you don't understand dependence. (2022)", "url": "https://www.pathsensitive.com/2022/09/bet-you-cant-solve-these-9-dependency.html", "domain": "pathsensitive.com", "votes": 1, "user": "fanf2", "posted_at": "2024-04-11 10:42:04", "comments": 0, "source_title": "How an Ancient Philosophy Problem Explains Software Dependence", "source_text": "How an Ancient Philosophy Problem Explains Software Dependence | Path-Sensitive\n\n# Path-Sensitive\n\n## Friday, September 30, 2022\n\n# How an Ancient Philosophy Problem Explains Software Dependence\n\nresearchytechnical September 30, 2022\n\nUpdate Oct 30, 2022: Professor Daniel Jackson wrote a response to some of the\ncriticism this post experienced on Hacker News.\n\nThis post is based on a research paper at Onward! 2020 and loosely follows the\ntalk I gave at that conference.\n\nHave you tried to remove a dependency from a project and been unsure if you\nhave successfully done so?\n\nTo \u201cinvert a dependency?\u201d\n\nTo keep the core of a codebase from depending on something specific?\n\nOr to \u201cdepend on interfaces, not implementation?\u201d\n\nIf you\u2019re a programmer, you probably have. If you\u2019ve been doing this for a\nwhile, there\u2019s a good chance you\u2019ve gotten into a disagreement about whether\nyou\u2019ve successfully done so. Dependence is one of those words where everyone\nthinks they know what it means (Clean Code uses the word over 100 times\nwithout defining it). But as easy as it is to speak broadly about limiting\ndependencies, uncertainty about what it means leads into uncertainty in actual\njobs.\n\nBy the end of this post, you will learn an objective definition of dependence\nfor software engineering. This definition encompasses all places where\nengineers talk about dependence, from package management to performance\nengineering and even usability, and it\u2019s sufficiently rigorous to be\nmechanically checkable.\n\nBy \u201cmechanical,\u201d I do not mean automated, nor even easy. It\u2019s relatively easy\nto write a function where deciding whether it can interact with another\nfunction requires solving a famous unsolved math problem. But with this new\nunderstanding in hand, and some amount of thinking, next time you have to\nensure that customer privacy does not depend on a third-party library, you\nshould be able to explain exactly what that means and what must be done.\n\n## Background\n\nA dependence question raised in \"Oracle v. Google\"\n\nWe programmers talk about dependence all the time. Like, \u201cmy package has\nPostgres as a dependency but it doesn't depend on it until it's used, except\nthen it still never depends on it because I'm database-agnostic.\u201d If you\nponder that sentence, you may realize that every use of the word \u201cdepend\u201d has\na different meaning. We know that limiting dependence is a good thing, but\nwithout really understanding what it means, it's advice doomed to break down \u2014\ncitrus advice.\n\nA few years ago, Daniel Jackson and I set out to figure out what \u201cdependence\u201d\nreally means in software. I daresay we were extremely successful. We have a\ngeneral definition that specializes to each of the varieties of dependence\nhinted at in the previous paragraph, and then some. With it, you can\ndefinitively (though not always feasibly) answer whether you've managed to\nremove a dependence. Trying to apply the definitions raises a lot of subtlety,\nbut we found we can address them by stealing algorithms from a certain\nsubfield of (wait for it) computational philosophy. We first published our\nfindings in a paper at the Onward! 2020 conference, where it was greeted\nenthusiastically by peer reviewers, becoming the only paper that year accepted\nwithout revision.\n\nImage by DALL-E 2, \u201ccomplex clock mechanism hidden in mist\u201d\n\nThis blog post is loosely based on my previous effort to distill our findings,\nmy Onward! 2020 talk. Loosely. The words here may occasionally match what is\nsaid in the video, and the numbers next to the slides illustrations below will\nusually go up. The Onward! conference is a funny place, full of people who fly\naround the world to learn about the latest in static analysis and type\nsystems, but then ditch that go hear about pie-in-the-sky ideas that don't\nwork. (Though it's also the home of some of my favorite software-engineering\nessays ever.) I will make no assumption in this blog post that you've ever had\nreason to care about \u201cstatic and dynamic semantics.\u201d On the other hand, you\nmight follow the example better than the original audience if you've been\nexposed to an \u201canalytics framework\u201d by means other than through the window of\nan ivory tower.\n\nAnyway, let's go learn about dependence. First: why it's hard?\n\n## Depending on Analytics\n\nAs a running example, I have an iPhone app. It uses an analytics framework,\nbut it doesn't use it directly. I've interposed an analytics abstraction\nlayer, putting some kind of delegator between them. Now my question is, does\nthe app depend on the analytics framework?\n\nI'm trying to argue that the world didn't previously understand dependence, so\nI'd like to find some contradictory statements about dependence in well-known\nbooks. Problem is, these books mention dependence all the time, but rarely say\nanything concrete enough to find a contradiction. Still, I found this:\n\nLooking at the quotes in the slide, Martin Fowler seems to think that having\nthis interposed delegator removes the dependence. I believe Robert Martin is\nsaying that if something important depends on my choice of analytics\nframework, then it should be referred to directly in the program text. But my\nfirst reading suggests something in tension: one saying that the analytics\nabstraction layer removes the dependence and hinting that's a good thing, and\nthe other stating that it's bad. This is a pretty interesting contradiction\nfrom Robert Martin Fowler, who are quite close as far as software engineering\ngurus go. Of course, I'm not sure what they're actually advocating, which is\npart of the problem with existing terminology.\n\nBranching out a bit, I'll let you make your own judgment on the following\nquote.\n\n> In the old Web site with the background specified separately on each page,\n> all of the Web pages were dependent on each other. \u2014John Ousterhout, A\n> Philosophy of Software Design\n\n(Ousterhout did remove one misuse of \u201cdependence\u201d in the newer versions after\nI pointed it out. But I found more. Note that I still consider it a good book,\neven though I've criticized it a lot.)\n\nTo really draw out the confusion and mist around the idea of dependence, we\nprepared nine dependency puzzles.\n\n## The 9 Dependency Puzzles\n\n  1. The Framework Puzzle: We usually think that, if A calls B, then A depends on B.\n\nBut consider a round-robin scheduler: it invokes every task to be scheduled.\nDoes it depend on each of the tasks?\n\n  2. The Shared Format Puzzle: If A writes a file and B reads it, they are clearly coupled because of the shared format. But which depends on which?\n\nYou also see this when a client sends messages to a server; if either end\nchanges, the other will break. Do they both depend on each other?\n\n  3. The Frame^1 Puzzle: We like to think that, if A does not depend on B, then a change to B cannot affect A.\n\nBut what if you change B in a way that introduces a new dependence, like\nmodifying a global variable used by A?\n\n  4. The Crash Puzzle: As a more extreme version of the previous: A change to any module can affect a change to any other module, namely by crashing the program. So, by the \u201cA does not depend on B if a change to B cannot affect A\u201d rule, everything depends on everything else.\n\n  5. The Fallback Puzzle: A website loads a resource from a CDN but hits a server if unavailable; an app uses a cheap-but-flaky payment processor when it can but switches to a more established one when it's down; an analytics service tries to connect to multiple servers until it finds one that works; a media player that uses hardware video-decoding when available but software when not \u2014 these all have the structure \u201cA uses B but falls back to C.\u201d\n\nWith fallback, the failure of B does not imply the failure of A. Does this\nmean that A does not depend on B?\n\n  6. The Inversion Puzzle: Dependency inversion is touted for removing dependencies: instead of A statically invoking module B, the program passes A a reference to B at runtime. But A will still fail if B fails. So is there no change in the dependence structure?\n\n  7. The Self-Cycle Puzzle: We usually think of dependence as transitive: A cannot function without B, B cannot function without C, therefore A cannot function without C.\n\nWe also complain about dependency cycles: A depending on B and B depending on\nA is bad, but it can happen.\n\nNow, putting these together: What does it mean for A to depend on A?\n\n  8. The Higher-Order Puzzle: Libraries should not depend on application code. But, from one perspective, they clearly do: a hash table implementation will give incorrect output if keys have inconsistent implementations of equals() and hashcode() methods (that is, if equal values have different hashcodes). Do hash tables and other library classes depend on their callers?\n\n  9. The Majority Puzzle: There was a fad a few decades ago called \u201cn-version-programming.\u201d The idea of N-version programming: if 5 people write the same program, then there's no way they'll exhibit any of the same bugs, right? So you can have 5 people implement the same (very detailed) spec for a robot controller, and have the programs vote what to do at each timestep; so long as no 3 people have the same bug, it should always function according to spec, right?\n\nOf course, Nancy Leveson showed empirically that this doesn't work and the fad\ndied, but it presents an interesting hypothetical: Suppose all 5 controllers\nimplement the spec perfectly, and thence all 5 always vote for the same\naction. Then no change to any single implementation can alter the robot. Does\nthis mean that the robot does not depend on any of the controllers?\n\nWe'll be answering all these puzzles at the end. But, coming up next:\nunderstanding why the sentence \u201cDoes A depend on B?\u201d can actually stand for\none of many, many different questions.\n\n## Types of Dependence\n\nLet's revisit the analytics example and ask \u201cdoes the app depend on the\nanalytics framework?\u201d There are several questions here.\n\nWell, not quite. There's a tradition in the Jewish holiday of Passover that\nthe youngest always chants a Hebrew verse titled \u201cThe Four Questions.\u201d The\njoke is that it's actually one question (\u201cWhy is this night different from all\nother nights?\u201d) with four answers. Likewise, \u201cDoes it depend\u201d is just one\nquestion, but here's five answers, as seen in the image:\n\n  1. No, I can build them separately.\n  2. Yes, a crash in the framework will be a crash in the app.\n  3. No, because I can just use a different framework that changed the code and I will still have working analytics.\n  4. And no because I'll get the same resul-.....actually, no I won't. It's an open secret that no two analytics frameworks give the exact same numbers. Ideally they'll be close enough for all purposes other than choosing what to say when boasting about number of users. But maybe one will give more statistical accuracy, so, realistically, yes.\n  5. Oh my god yes, because any security vulnerabilities in the framework will be security vulnerabilities of the app as well.\n\nBut yeah, these are definitely answering different questions.\n\n## Dimensions of Dependence\n\nTo make a question about dependence concrete, you must specify three\nparameters: the semantics or execution model in question, the property of\ninterest, and the space of permitted changes.\n\n### Dimension 1: Semantics\n\nLet's go back to that agonizing sentence from the intro. \u201cMy package has\nPostgres as a dependency but it doesn't depend on it until it's used, except\nthen it still never depends on it because I'm database-agnostic.\u201d Change a\ncouple words, and it fits the analytics example as well. So I said before that\nthis sentence uses \u201cdepend\u201d in three different ways^2. It's not just that\nthey're answering different questions. These are actually different models of\nexecution.\n\n  1. When talking about importing a dependency, the \u201cexecution\u201d engine of interest is the compiler or build system: is the program even well-formed, or is there a build error? This roughly maps onto the more theoretical term \u201cstatic semantics\u201d or \u201ctype system.\u201d\n\n  2. When saying that actually invoking a package is what gives a dependence, the execution engine in question is an interpreter, or the combination of the compiler + a CPU. The focus is now on whether the code actually runs and contributes to the overall program output. \u201cDynamic semantics\u201d is a general theoretical term for what actually happens when running.\n\n  3. When saying that a program would work even after switching to a different library, the \u201cexecution engine\u201d in question is actually the reasoning used to convince yourself or someone else that it's correct / achieves its goal, based only on the guaranteed properties of the analytics abstraction layer. If you buy that that human reasoning is analogous to automated reasoning, then the theoretical term that captures this is the \u201cprogram logic,\u201d the proof system used to show the program achieves its intention.\n\nThis lists just 3 possible execution models, but there are infinitely many\nmore, a few of which are discussed in the paper. For example, the property of\nwhether text is readable could be phrased in Visual Logic.\n\nWe can already start to categorize the answers about the analytics framework\naccordingly. Inability to build separately refers to the well-formedness /\nstatic semantics. When a crash in one is a crash in the other, that's the\ninterpreter / dynamic semantics. The ability to swap it out and still have\n\u201cworking analytics,\u201d that's the correctness argument / program logic.\n\nOf course, the last two answers, about accuracy and security, also sound like\ncorrectness arguments. So it's not enough.\n\n### Dimension 2: Properties\n\nYou might notice from the last answers about whether it's secure and whether\nit has working analytics: those are actually different properties.\n\nYou should never ask, does module A depend on the module B? But rather ask,\ndoes some property P of A depend on B?\n\nWe can now classify the answers better by looking at the property. It does\ndepend in the well-formedness property, does depend on runtime behavior, does\nnot depend on correctness, does depend on statistical performance, and does\ndepend on security.\n\nBut there's a tension here. I'm saying that there's no dependence in whether\nit works, except that I can hack into some versions and not others and make\nthem not work. So maybe correctness does depend? We'll address that soon.\n\nIn the meantime, we're on our way to resolving some of the dependency puzzles\npuzzles. Back to the Framework Puzzle: Does a round-robin scheduler depend on\nthe individual tasks? It clearly does for many runtime properties. But for the\ncorrectness of the scheduler, it shouldn't....\n\n...unless it's a non-preemptive scheduler and a task doesn't terminate and\nhogs all the scheduler time. So yeah, maybe.\n\nWe've now seen two examples where we want to say that there's no dependence on\na component, except that component can \u201cbreak out of the box\u201d and mess up the\nrest of the system. That's where the third dimension comes in.\n\n### Dimension 3: Permitted Changes\n\nA property of dependence we'd like to have: if A does not depend on B, then no\nchange to B can affect A. Actually, this sounds like it would make a nice\ndefinition. When Dale Carnegie says \u201chappiness doesn't depend upon who you are\nor what you have; it depends solely upon what you think,\u201d he seems to be\nsaying that merely changing whether one owns a Lamborghini would not alter\nwhether they have the property of being happy; they must also change their\nbelief about whether they own a Lamborghini. But we've seen this apparently\nviolated in the Crash Puzzle described earlier, which can be instantiated to\nthis scenario quite literally: owning a Lamborghini but believing otherwise\nmight get you in a fatal crash, which is detrimental to happiness. More\ngenerally: how can we say \u201cno change to B can affect A\u201d when one can \u201cchange\nB\u201d by replacing it with a program that destroys A.\n\nSo we're left with this tautological definition: if A does not depend on B,\nthen no change to B can affect A, unless that change introduces a dependence.\nIt's easy to say \u201cwe should just exclude these kinds of changes. Like, Signal\nshould be able to say they don't specifically depend on Twilio to work, as\nopposed to anything else they could use for sending SMS. But they announced a\nTwilio-based security incident while I was writing this, so sometimes these\nkinds of changes really matter.\n\nSo, here's an idea: how about sometimes we exclude these kinds of changes, and\nsometimes we don't?\n\nOr, in other words: every conversation about dependence implicitly carries a\nreference frame about which kinds of changes of reasonable to consider. When\nyou're asking about whether your app's stability depends on an analytics\nframework, you should get a different answer based on whether you're\ninterested in whether an API change can cause your code to raise an exception\nversus whether you're wondering whether someone can exploit a vulnerability to\nbrick your customer's phone.\n\nAfter the execution model and the property of interest, this \u201cspace of\nreasonable changes\u201d is the third parameter determining a dependence question.\nSometimes this is a spec: the mantra \u201cdepend on interfaces, not\nimplementations\u201d seems to mean that, if your program uses a function, then any\nchange to that function's implementation within the space of \u201cchanges that\ndon't alter the spec\u201d should not change your function's correctness. So you\ncould call the \u201cspace of reasonable changes\u201d a spec. But that would be\nmisleading, because if you want to ask \u201cCould the library authors mess me up\nby removing this guarantee,\u201d you are actually asking about possible changes to\nthe library's already-existent spec. In that case, the space of permitted\nchanges is actually a spec on the spec, and so the best name we came up for\nthis is \u201csuper-spec.\u201d\n\nNow we can totally resolve the Framework Puzzle: Forbid tasks that don't\nterminate, and there's clearly no dependence. And the Crash Puzzle: Forbid\nchanges that make the component crash, and there's no dependence.\n\nBut there's still the Fallback Puzzle. Based on what we've said so far, we\nreally have no clue. Intuitively, I'd want to say that my payment succeeding\ndepends on the payment processor that was actually used. But if the only thing\nthat a change to that processor can do is bring it down, then no change to it\ncan stop my payment from going through, because the system would just use the\nother processor. So now it sounds like, if your system has a fallback\ncomponent for everything, then it has no dependencies!\n\nMore abstractly, we're asking questions like \u201cI used it, but I had another\none, so did I really need it?\u201d If you're thinking that this sounds like\nsomething philosophers ask, then you're right.\n\n## Dependence is Causation\n\nSo I foreshadowed this one by suddenly talking about happiness and\nLamborghinis: everything I've been talking about can also apply to everyday\nthings in the physical world. In fact, all of the dependency puzzles are\nisomorphic to a physical causality question.\n\nThe Framework Puzzle with the round-robin scheduler and how long tasks take?\nThat's a lot like stacking boxes; the contents of the box don't matter unless\nthey're really heavy. The Crash Puzzle, where everything depends on every\nother component because they can crash? That's a lot like saying that your\nability to read this right now depends on what every single one of your\nneighbors is doing, which is, apparently, not cutting your electricity. And\nthe Fallback Puzzle? That's a lot like asking if the grass being wet right now\nis caused by it just having rained when the sprinkler was programmed to come\non if it didn't.\n\nMore specifically, there are actually two categories of causality. There's\n\u201ctype causality\" or \u201cgeneral causality,\u201d which deals with general statements\nabout categories such as \u201cA stray spark causes fire.\" And then there's \u201cactual\ncausality\" or \u201ctoken causality,\u201d which deals with statements about specific\nevents, such as \u201cA stray spark in Thomas Farriner's bakery on Pudding Lane\ncaused the Great Fire of London on September 2nd, 1666.\" As dependence deals\nwith questions about specific programs and specific scenarios, actual\ncausation is the one relevant here.\n\nThere have been several proposed formal definitions of actual cause, and there\nis no standard for determining whether a definition is correct\u2014only arguments\nthat it is is useful and produces answers that match intuition. The basic one\nis the \u201cnaive but-for\u201d definition: A causes B if, but for A having been true,\nB would not be true. This is the definition used by lawyers, and is the reason\nyou can be charged with murder if a cop falls to their death while chasing\nyou, because you \u201ccaused\u201d their death. But when applied to the rain and\nsprinkler, it tells you that the rain cannot be a cause of the wet grass,\nwhich is counter to intuition.\n\nBut maybe that intuition is because rain and sprinklers are actually pretty\ndifferent. There are isomorphic questions, such as \u201cIs my apartment cool\nbecause I turned on the AC at 6:58 when it was scheduled to turn on at 7:00,\u201d\nfor which the intuitive answer is no. Similarly, my intuition says that my\ncredit card succeeding did depend on which payment processor was actually\nused. But I can't be so moved to care which of many redundant servers my\nbrowser is connected to when writing this. So while much of the literature on\nactual causation examines the shortcomings of the \u201cnaive\u201d but-for definition\nand focuses on examples like the sprinkler, we've decided that the but-for\ndefinition is actually pretty good, and the problems mostly come up when\ntheorists play with models of rain and sprinklers that ignore their\ndifferences.\n\nThis means that I get to spare you the debate about the definitions of actual\ncausation. If you really want it, you can have a look at our paper for a brief\nintro. For more, well, Joseph Halpern has an entire book on this subject.\n\nAnyway, this leads to the finale, a general definition of dependence:\n\n> A property P definable in some execution model of a program depends on\n> component A if and only if A is an actual cause of P, with respect to a\n> space of permitted changes to A.\n\nUsing the but-for definition of causation, this becomes:\n\n> A property P definable in some execution model of a program depends on\n> component A if and only if there is a permissible change to A which alters\n> whether P holds.\n\n## Puzzling No More!\n\nAnd now, final definition in hand, we can go back and definitively answer all\nof the dependency puzzles. And by aping the causality literature, we get some\nnew concepts for free. For some questions, we get the answer \u201cit's not a\ndependence, but is part of the dependence,\u201d stealing the concept of \u201cpart of a\ncause.\u201d\n\n  * The Framework Puzzle: Asking about dependence of a specific property resolves the confusion. It is true that the runtime behavior of a round-robin scheduler, particularly timing, does depend on the tasks being scheduled. But its correctness does not.\n  * The Shared Format Puzzle: There are actually two resolutions to this puzzle. For the first, we again look to a specific property.\n\nThe serializer/deserializer should satisfy a round-trip property, that\nserializing a value and then deserializing it results in the original value.\nThis round-trip property clearly depends on both. Through another lens, we can\ndefine correctness of each end separately, in terms of an abstract description\nof the format. Then the correctness of each depends on the shared format, but\nnot on the other end.\n\nIn both cases, the serializer and deserializer do not depend on each other,\nthough they are coupled.\n\n  * The Frame Puzzle: Super-specs resolve this puzzle! If it is reasonable for B to modify a variable used by A, then A already depends on B, and a programmer would indeed need to read the source code of A to check that it does not interfere with B.\n\nBut if one imposes a super-spec on B forbidding it from modifying such\nextraneous state \u2014 in mundane terms, if your tech lead would yell at you for\nchanging it to do such mutation \u2014 then the dependence, and with it the need to\nread, disappears.\n\n  * The Crash Puzzle: This one's just an extension of the previous. Super-specs again come to the rescue. If you consider crashing changes to any module, then indeed the runtime behavior of every module depends on every other module. But if crashing changes are out of consideration, then this is not so.\n  * The Fallback Puzzle: These fallback scenarios are isomorphic to examples from physical causality, such as \u201cIf it doesn't rain, the sprinkler will turn on [ergo, the grass-watering procedure falls back to a sprinkler].\u201d And so, concepts from causality dissolve the confusion. There are two resolutions.\n\nThe first: a dependence doesn't have to be a single module! We can say that\nthe only reasonable change to the CDN (i.e.: its superspec) is to knock it\noffline. Because of fallback, that can't prevent an image to loading, so the\nimage loading indeed does not depend on the CDN. But simultaneously knocking\nthe CDN and the fallback server offline can! So, the dependence is actually on\nthe set {CDN, fallback server}, and the CDN itself is part of a dependence.\n\nBut another resolution is to ask: is it really the same to use B vs. falling\nback to C? In the case of loading an image from a CDN, perhaps not, and it's\nintuitive to say that you loading a website just now did not depend on its\nCDN. But for receiving a payment through SketchyCheapProcessor vs.\nStodgyOldProcessor, it would be an expensive mistake to treat them as the\nsame!\n\n  * The Inversion Puzzle: Thinking about the lens of multiple tools resolves this one. To the interpreter, even after doing dependency inversion, there is a dependence (i.e.: runtime behavior does depend). But to a compiler or typechecker, the dependence has been removed (i.e.: well-formedness does not depend).\n  * The Self-Cycle Puzzle:\n\nInsights from the causal-inference literature resolve this one as well.\nSurprisingly to many, causality is not transitive, and hence dependence is not\neither. Simple, if facetious example: Seeing an advertisement for pizza causes\nme to press buttons on my phone. Me pressing buttons on my phone causes your\nphone to ring. Me seeing an advertisement for pizza does not cause your phone\nto ring (as it causes me to press the wrong buttons). Discussing exactly when\nand why causality is not transitive can get pretty technical, and is sensitive\nto exactly how one translates a statement into formal language. (Indeed, you\nmay have already prepared a valid reason why my pizza example should not\ncount.) If you're interested, I'll refer you to Halpern's \u201cSufficient\nConditions for Causality to Be Transitive.\u201d\n\nOf course, many kinds of dependence are transitive, such as build dependence.\nBut this does mean that you don't need to bend your brain around self-\ndependences; just use the definition in this article.\n\n  * The Higher-Order Puzzle: Actually stating the property of interest resolves this one. Every function's correctness is defined with a precondition: if the inputs are valid, then the outputs are as desired. In the case of a hash table, the input includes the keys' equals() and hashcode() functions, and these are only valid if their implementations are consistent. If you build a hash table on keys whose equality is determined by coin-flipping, then getting bad output is not the hash table's fault. So the hash table's correctness does not depend on any specific implementation of equals() and hashcode(), but its runtime behavior sure does.\n  * The Majority Puzzle: This is another puzzle ripped straight out of the causality literature, taken from examples on (wait for it) majority vote! The idea of being \u201cpart of a dependence\u201d returns to resolve this one. Indeed, the robot's behavior does not depend on any single one of the 5 controllers, but it does depend on each \u201cwinning coalition\u201d of voting programs; that is, each subset of size 3.\n\nAnd now we can go back and un-confuse the Fowler and Martin quotes from the\nbeginning. Fowler is talking only about static/build dependence. Martin Fowler\nis talking about how inserting your abstract delegate factory removes the\nbuild dependence. Robert Martin seems to be saying that if the correctness\nproperty depends on which analytics framework you're using, then you shouldn't\nbe using this abstract delegate factory. You should actually have direct\nreference textually to make the well-formedness depend. Now we can see this\npiece of advice are actually not in contradiction, that it can still be good\nto insert this analytics subtraction framework when the choice of analytics\nframework does not matter, when the correctness property is not affected by\nthe choice. But when you are relying on a single choice, then: not such a good\nidea.\n\n### Coupling vs. dependence\n\nI mentioned coupling briefly above. Where does coupling fit in? I think this\nstory about the connection between causation and dependence also explains\ncoupling: dependence is to causality as coupling is to correlation.\n\nA common view in causality is that the connection between causality and\ncorrelation is given by Reichenbach's principle: that if A and B are\ncorrelated (i.e.: knowing one gives some information about the other), then\neither A causes B, B causes A, or there is some common cause C. As an\naddendum, correlations can also be observed if one limits observations to\nsituations where some common effect of A and B occurs. For example, if you\nhave a bookshelf, you'll likely find that the more useful books tend to be\nless interesting \u2014 not because of some intrinsic trait, but because you\nprobably don't buy books which are neither interesting nor useful. This is\nBerkson's paradox.\n\nI propose that there is a software analogue to Reichenbach's principle: that\nif A and B are coupled (which I take to mean: tend to change together), then\neither A depends on B, B depends on A, or they have some common dependency.\nAnd there is a software analogue of Berkson's paradox too: if one is trying to\npreserve some property that depends on both A and B, then a change to A will\nbe accompanied by a change to B, as in the case of changing a serializer while\ntrying to preserve the round-trip property.\n\n## Conclusion\n\nDependence is something everyone assumes they know, but that understanding\nbreaks down quickly. It may be pretty cool to connect dependence and\ncausality, but what does learning this mean for actual programming? I say\nthere are three benefits, although they can be said to all be part of the same\nbenefit.\n\nThe first benefit: it ends debates and clarifies confusing discussions. See\nour alteration to the Martin Fowler and Robert Martin quotes above.\n\nThe second: it paints a target. When I started the Thiel Fellowship in 2012, I\nhad to write a letter from my future self in 2014 explaining my\naccomplishments. I stated that I would have a tool that could globally chase\ndown every place in the code that depends on some assumption and remove that\nassumption. It's 2022 and I still don't have one, but at least the problem is\ndefined now, so I know where to begin.\n\nAnd, of course: knowing what dependencies are helps you remove them. For\nexample, Parnas teaches us to not let general things depend on specific\nthings. Just as there are ways to trick yourself into thinking you've removed\nan if-statement without really doing so, there are ways to trick yourself into\nthinking you've removed a dependence \u2014 say you only removed a static\ndependence, but you actually wanted to remove the dependence of some\ncorrectness property.\n\nAnd there's one dependency I especially want to remove: the dependency of the\nability to produce quality code on indescribable experience and pattern-\nmatching.\n\nI'm thinking of a story from a recent student of my Advanced Software Design\nCourse, whom I'll call Karl. Karl is the lead software engineer of a startup\nin Northern Europe. He noticed some design flaws in some code from one of his\njunior engineers, and started to refactor it, changing 1800 lines across 10\nPRs. Hoping to make it a learning experience, Karl walked the engineer through\nit until Karl thought the engineer understood, so that he could finish it\nhimself. Karl assigned the rest of it to the engineer, and then came back to\nfind...\n\n...the code had been un-refactored into the original form.\n\nWhat happened is that Karl built understanding of what was wrong with the\noriginal code and good about the refactoring via a mechanism whose\neffectiveness depends on building an intuition from a lot of experience.\nAlthough it served Karl well as an engineer, it failed him as a lead; it was\nnot transmittable. That motivated him to come to me.\n\nWhen a concept teaches you how to identify the best design decision and\nexplain it, it's obviously useful. But I think there's a subtler benefit that\ncomes from understanding your actions, like going from following recipes to\nbeing a chef. I hope this understanding helps your subjective experience of\nprogramming move from climbing a mountain to enjoying the view at the top.\n\n1 \u201cFrame\u201d is a term used in program analysis to mean \u201cthe set of values a code\nsnippet may modify,\u201d and more generally in AI and philosophy to mean \u201cthe set\nof beliefs that may have to be updated in response to an action.\u201d See\nWikipedia or Daniel Dennett\u2019s delightful essay.\n\n2 If you've read The Three Levels of Software: The dynamic semantics here\ncorrespond to both the runtime and code levels in that blog post, depending on\nwhether you're considering one execution vs. all possible executions. The\nlevel of modular reasoning maps perfectly onto the \u201cprogram logic\u201d model here.\nThe static semantics here was not discussed at all in that blog post, because\nthere's no need for new terminology to discuss build errors.\n\nThanks to Nils Eriksson for comments on earlier drafts of this blog posts.\nThanks to Daniel Jackson for being a great coauthor helping me create the\noriginal content, and to the anonymous reviewers at Onward! 2020 for their\nfeedback helping us to refine it.\n\nTags: researchytechnical\n\n## Liked this post?\n\n#### Related Articles\n\n### The 11 Aspects of Good Code\n\n### 'Modules Matter Most' for the Masse...\n\n### Solving the Dog-Bunny Puzzle with P...\n\n#### 3 comments:\n\n  1. MumuOctober 8, 2022 at 1:19 PM\n\nThank you for insightful article. I have two questions on this interpretation\nof dependency.\n\nIs there a way to explain traditional \"Dependency Inversion Principle\" and\n\"Dependency Injection Techniques\" more intuitive in terms of causality, rather\nthan just saying \"They are kinds of static/build property\"?\n\nReplyDelete\n\nReplies\n\n    1. James KoppelOctober 8, 2022 at 7:05 PM\n\nInjecting a dependency means that its removal at compile time cannot cause a\nbuild failure.\n\nInterposing an abstract interface (dependency inversion) means that no within-\nspec alteration of an implementation of an interface can affect the\ncorrectness of the interface's user.\n\nDelete\n\nReplies\n\nReply\n\n    2. MumuOctober 9, 2022 at 7:26 AM\n\nThank you for your comments!\n\nDelete\n\nReplies\n\nReply\n\nReply\n\nAdd comment\n\nLoad more...\n\n\u2190 Newer Post Older Post \u2192 Home\n\n## About me\n\n##### Jimmy Koppel\n\nHello world! I'm Jimmy, and I help software engineers learn to write better\ncode. Previously, I did my Ph. D. at MIT on ways to make program\ntransformation and synthesis tools easier to build, a.k.a. \"meta-\nmetaprogramming.\" I blog mainly about improving code quality, and occasionally\nabout life quality.\n\nPersonal website\n\n## Labels\n\ntechnical life-optimization book-review researchy startups talks fun personal\ntools\n\nCopyright \u00a9 2015-18 James Koppel. All rights reserved.\n\nTop\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
