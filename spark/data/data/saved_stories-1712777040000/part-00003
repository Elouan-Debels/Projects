{"aid": "39990426", "title": "Cloudflare's Durable Multiplayer Moat", "url": "https://digest.browsertech.com/archive/browsertech-digest-cloudflares-durable/", "domain": "browsertech.com", "votes": 2, "user": "paulgb", "posted_at": "2024-04-10 13:22:11", "comments": 0, "source_title": "Browsertech Digest: Cloudflare's durable multiplayer moat", "source_text": "Browsertech Digest: Cloudflare's durable multiplayer moat\n\n### April 10, 2024, 9:20 a.m.\n\n# Browsertech Digest: Cloudflare's durable multiplayer moat\n\n## Browsertech Digest\n\nIf you'd rather listen to this post, it was also published as a podcast\nepisode.\n\nCloudflare\u2019s Workers product is probably best known among developers as a\ncompetitor to Amazon Lambda that runs on Cloudflare\u2019s edge, but Workers has a\ntrick up its sleeve that has also quietly made it a formidable platform for\nrealtime multiplayer apps.\n\nI say quietly because many developers building on Workers might not even know\nthat they are building on it, as Cloudflare Workers power a number of popular\nmultiplayer infrastructure products:\n\n  * PartyKit (acquired last week by Cloudflare)\n  * Replicache Reflect\n  * Liveblocks\n  * Y-Sweet (disclosure: I work on Y-Sweet)\n\nCloudflare's dominance in this niche comes from a feature called Durable\nObjects, which implements an abstraction that is both unique among cloud\nproviders, and incredibly useful for real-time apps.\n\n## The Durable Object abstraction\n\nAnalogous to the way that function-as-a-service (FaaS) platforms like Amazon\nLambda run a developer-provided function in the cloud, Durable Objects run a\ndeveloper-provided class.\n\nThese Durable Object classes implement a method for handling requests. This\nmethod is akin to the handler function provided to other FaaS platforms, but\nit differs in two ways that are important for multiplayer apps:\n\n  1. it supports WebSocket connections, not just regular HTTP requests\n  2. it allows you to retain in-memory values (as class fields) across invocations (the infrastructure is technically allowed to evict an object from memory at any time, so a durable key/value store is also provided by the runtime)\n\nThe other important difference from a traditional FaaS is this: Durable\nObjects provide a way to reliably connect two clients to the same object. Each\nobject has a (string) name that is used when connecting to it, which typically\ncorresponds to a \u201croom\u201d or \u201cdocument ID\u201d in the application itself.\n\nIn practice, this means that two clients can establish WebSocket connections\nusing the same document ID, and the infrastructure will guarantee that they\nare connected to the same Durable Object instance. This object will then be\nthe authority for the state of that document, and can directly send changes to\nevery client.\n\nThis is the difference that makes Durable Objects so compelling for\nmultiplayer use cases, but it's also the reason that the Durable Object\nabstraction hasn't been slapped on top of other FaaS platforms \u2013 it is a\nradical departure from core assumptions made by their scheduling and routing\nsystems.\n\n## Lambda does WebSockets, but badly\n\nThe best way to understand how much the Durable Object model simplifies\nmultiplayer apps might be to compare it with Amazon's own preferred approach\nto using WebSockets on Lambda.\n\nLambda can't directly speak WebSocket. Instead, it needs to be paired with an\nAPI Gateway, which translates WebSocket messages and events into Lambda\ninvocations. In other words, every single WebSocket message independently\ninvokes a Lambda function.\n\nThese functions are stateless, but even something as simple as a broadcast\nchannel needs state (to know which listeners to pass along the message to).\nAmazon resolves this by persisting handles to active connections in DynamoDB.\n\nThis means that every single message to a broadcast channel results in a\nDynamoDB query for a list of current clients, which it then iterates over to\nsend messages to each.\n\nThis works, I guess. But I would need to make a spreadsheet model over three\ndifferent AWS services to tell you what it cost, and it involves managing a\nbunch more AWS resources and writing a bunch of glue code to basically\nimplement a context switch in userspace.\n\nBut there's a more subtle reason why this architecture doesn't work well for\nmultiplayer: it lacks an authority. A bunch of multiplayer stuff gets way\neasier if, when processing a document change, a server is allowed to assume\nthat it is the only server currently allowed to process changes for that\ndocument.\n\nThe desired abstraction, from the application programmer's point of view, is a\nsingle thread that can process all changes to one document in the order they\nare received. This is essentially what Durable Objects gives you.\n\nFor more depth, Sunil Pai of PartyKit wrote a great post explaining Durable\nObjects in the context of traditional FaaS.\n\n## Limitations of Durable Objects\n\nBack in 2020, I wrote about the need for serverless infrastructure for\nWebSockets (wishing for \u201cwebsocketd meets Lambda\u201d). While Durable Objects has\nsince partially filled that void, it comes with some caveats to my ideal:\n\n  * It only supports JavaScript and Wasm.\n  * It has a 128mb memory limit.\n  * It only runs on Cloudflare's infrastructure (the core workerd runtime is open source, but the scheduling/routing pieces that would be needed to run a multi-node system are proprietary).\n\nOne way to think about Jamsocket (the company I co-founded and the publisher\nof Browsertech) is as combining the scheduling/routing/one-instance-per-\ndocument functionality of Durable Objects with the universality of running a\nfull Linux process (optionally on your own metal) instead of a V8 isolate.\n\nHaving seen the apps that can be built on stateful, scalable WebSocket tech, I\nexpect to see a lot more apps take advantage of this architecture, whether on\nDurable Objects, Jamsocket, or something else. I'm biased, but it's pretty\nneat.\n\nUntil next time,\n\n\\-- Paul\n\nYou just read issue #34 of Browsertech Digest. You can also browse the full\narchives of this newsletter.\n\nSubscribe\n\nFind Browsertech Digest elsewhere:\n\n", "frontpage": false}
