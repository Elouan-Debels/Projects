{"aid": "40043915", "title": "Message Templates: Capturing Structured Logs in a Human-Friendly Way", "url": "https://messagetemplates.org/", "domain": "messagetemplates.org", "votes": 2, "user": "goranmoomin", "posted_at": "2024-04-15 18:18:58", "comments": 0, "source_title": "Message Templates", "source_text": "Message Templates\n\n# Message Templates\n\nA language-neutral specification for 1) capturing, and 2) rendering,\nstructured log events in a format that\u2019s both human-friendly and machine-\nreadable.\n\nThis document explains the reasons message templates are used, and provides a\nspecification of their syntax, capturing behavior, and rendering behavior, to\nassist in creating implementations for various programming languages and\nlogging interfaces.\n\n## A brief history of structured logging APIs\n\nEarly application logging, or printf debugging, produced a stream of text\ndescribing the events taking place within an application.\n\n    \n    \n    log(\"User %s logged in from %s\", username, ipAddress); // -> 2016-05-27T13:02:11.888 User alice logged in from 123.45.67.89\n\nThis worked well for simple applications running on a single computer, and\nover the years many tools evolved to help support this format in ever-more-\ncomplex, and ever-more-distributed applications. Log parsing can extract most\nof the relevant information from the event above, but considerable effort is\nrequired for non-trivial diagnostic scenarios.\n\nAt various times, alternatives to text logs have been proposed under the\nbanner of structured logging, which considers log data to be a stream of\nfully-structured events with key/value properties. Structured log events are\nmuch easier to work with in large, complex and distributed applications,\nbecause relevant events can be identified using queries over their properties,\nrather than by regular expressions over a text payload.\n\nThe obvious method of recording structured log events, found particularly in\nlanguages with terse key/value property syntax, is to encode the event\ndirectly as a map of key/value pairs:\n\n    \n    \n    log({eventId: \"user_logged_in\", username: username, ip_address: ipAddress }); // -> {\"time\": \"2016-05-27T13:02:11.888\", \"eventId\": \"user_logged_in\", // \"username\": \"alice\", \"ip_address\": \"123.45.67.89\"}\n\nJSON is used as an example rendering here, but the concept is not tied to a\nparticular representation.\n\nThis greatly improves machine-readability, enabling queries like username =\n'alice' on the raw log stream, but the event itself is not human-friendly. Log\nevents recorded in prose make full use of our language processing and pattern\nrecognition abilities to ease cognition. A long stream of key/value pairs is\npainful to visually process. Compare the representative output of the two\nexamples above to experience this effect - what\u2019s happening in the second\nevent?\n\nAnother approach employs convention to identify properties within a printf-\nstyle message:\n\n    \n    \n    log(\"User username=%s logged in from ip_address=%s\", username, ipAddress); // -> 2016-05-27T13:02:11.888 User username=alice logged in from ip_address=123.45.67.89\n\nIn principle, this technique benefits from greater readability, but in\npractice the looseness of the format causes ambiguities when parsing, and\ninconsistent usage within development teams. Ambiguities arise when a property\ninserted into the event contains embedded spaces and/or = characters. The lack\nof a defined grammar (and lack of awareness of the grammar in the logging\ntool) means developers have no opportunity to validate their use of the syntax\n\u2013 breaking the convention is easy and goes unnoticed.\n\nFinally, niche logging systems like Event Tracing for Windows have taken a\nmiddle ground, combining event ids in the log event with a manifest of format\nspecifiers describing how a particular event can be rendered as text. Despite\nthe near-perfect balance of performance, human-friendliness and machine-\nreadability, the effort associated with assigning event ids and managing\nmanifests have an impact on development-time ergonomics that limit the appeal\nof this system.\n\nAll of these issues and shortcomings have kept fully-structured logging from\nreaching widespread adoption, but the need for it has continued to grow.\n\n## Message templates overview\n\nMessage templates take the best of all these approaches to provide optimal\nhuman-friendliness, perfect machine-readability and excellent development-time\nergonomics.\n\nA message template is a format specifier with named holes for event data:\n\n    \n    \n    User {username} logged in from {ip_address}\n\nMessage templates are unique in that they provide a means of capturing the\nevent, as well as a means of rendering it into human-friendly text.\n\nLogging APIs capture log events by positionally matching arguments with the\nnamed holes:\n\n    \n    \n    log(\"User {username} logged in from {ip_address}\", username, ipAddress) // -> { // \"time\": \"2016-05-27T13:02:11.888\", // \"template\": \"User {username} logged in from {ip_address}\", // \"username\": \"alice\", // \"ip_address\": \"123.45.67.89\" // }\n\nAn event captured using a message template is not immediately rendered into\ntext unless it is being displayed directly to a user. Instead, the template\nitself is captured, along with property values for each argument. This is\nstored in an intermediate representation like JSON for processing.\n\nBecause the template remains constant regardless of the actual property values\nsubstituted, it is possible to treat the template as an event type that\nidentifies all events from the same template. In this example, log-ins from\nvarious users will carry the different username values, but the consistent\nmessage template shared by all of them means they can be retrieved as a group.\n\nWhen the event is displayed to a human user, or searched for text, it is\nrendered by replacing each of the named holes with the corresponding property:\n\n    \n    \n    // -> User alice logged in from 123.45.67.89\n\n## Syntax\n\nA message template is a block of text with embedded holes that name a property\nto be captured and inserted into the text.\n\n  * Property names are written between { and } brackets\n  * Brackets can be escaped by doubling them, e.g. {{ will be rendered as {\n  * Property names may be prefixed with an optional operator, @ or $, to control how a property is captured\n  * Property names may be suffixed with an optional format, e.g. :000, to control how the property is rendered; the formatting semantics are application-dependent, and thus require the formatted value to be captured alongside the raw property if rendering is to take place in a different environment\n\nThe grammar below is maintained in the messagetemplates/grammar repository;\nimages generated by Railroad Diagram Generator.\n\n### Template\n\n    \n    \n    Template ::= ( Text | Hole )*\n\n### Text\n\n    \n    \n    Text ::= ( [^\\{] | '{{' | '}}' )+\n\n### Hole\n\n    \n    \n    Hole ::= '{' ( '@' | '$' )? ( Name | Index ) ( ',' Alignment )? ( ':' Format )? '}'\n\n### Name\n\n    \n    \n    Name ::= [0-9a-zA-Z_]+\n\n### Index\n\n    \n    \n    Index ::= [0-9]+\n\n### Format\n\n    \n    \n    Format ::= [^\\}]+\n\n### Alignment\n\n    \n    \n    Alignment ::= '-'? [0-9]+\n\n## Capturing rules\n\nA message template may be used to capture properties when provided a list of\nargument values.\n\n### Matching template properties with argument values\n\nEach property in the message template is associated with exactly one value in\nthe argument list.\n\n  * Templates that use numeric property names like {0} and {1} exclusively imply that arguments to the template are captured by numeric index\n  * If any of the property names are non-numeric, then all arguments are captured by matching left-to-right with holes in the order in which they appear\n  * Repeated names are not allowed\n\nBehavior in the presence of invalid/repeated names is implementation-\ndependent.\n\n### Operators\n\nPrefixing a property name with the @ structure capturing operator is a hint\nthat the the structure of the corresponding argument should be preserved, for\nexample, by serialization.\n\nThe $ stringification operator hints that the corresponding argument should be\nconverted into a string represenation for capturing.\n\nIf no operator is present, capturing behavior is implementation-dependent.\n\n## Rendering semantics\n\nGiven a set of property values, and a message template, implementations should\nrender the template by substituting property values into the locations of the\ncorresponding named holes.\n\nMessage template rendering should optimize for legibility and the conventions,\nculture, and context into which the message is being rendered:\n\n  * Named holes without corresponding property values may be rendered as the original {...} token, or a blank/empty/sentinel value may be substituted\n  * Numeric values, dates, times and similar data may be rendered in culture-specific format\n  * Complex data may be presented in a format most familiar to the user\n\n## Implementations\n\nThe following logging libraries have support for message templates.\n\n  * Emit (Rust*)\n  * FsMessageTemplates (F#)\n  * Klogging (Kotlin)\n  * LibLog (C#)\n  * Logary (F#)\n  * LogMagic (C#)\n  * MessageTemplates (C#)\n  * Microsoft.Extensions.Logging (C#)\n  * NLog (NLog 4.5+) (C#)\n  * Semlogr (Ruby)\n  * Seqlog (Python)\n  * Serilog (C#)\n  * serilogger (TypeScript/JavaScript)\n  * serilogj (Java)\n  * structlog (Go)\n  * structured-log (JavaScript)\n  * WaterLogged (C#)\n\n* Converts a custom capturing syntax to message templates for rendering and storage\n\nLibrary missing from this list? Let us know so that we can add it.\n\n", "frontpage": false}
