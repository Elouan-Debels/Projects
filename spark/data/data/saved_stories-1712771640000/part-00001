{"aid": "39989668", "title": "Rr: Lightweight Recording and Deterministic Debugging", "url": "https://rr-project.org/", "domain": "rr-project.org", "votes": 1, "user": "Jakob", "posted_at": "2024-04-10 11:53:51", "comments": 0, "source_title": "rr: lightweight recording & deterministic debugging", "source_text": "rr: lightweight recording & deterministic debugging\n\nWELCOME TO RR\n\nWELCOME TO RR\n\nWELCOME TO RR\n\nWELCOME TO RR\n\nWELCOME TO RR\n\nLast updated Fri Oct 18 17:19\n\n# rr\n\n  * github\n  * mailing list\n  * news\n  * #rr on chat.mozilla.org\n\nDevelopment sponsored by Pernosco\n\n## what rr does\n\n### rr aspires to be your primary C/C++ debugging tool for Linux, replacing \u2014\nwell, enhancing \u2014 gdb. You record a failure once, then debug the recording,\ndeterministically, as many times as you want. The same execution is replayed\nevery time.\n\n### rr also provides efficient reverse execution under gdb. Set breakpoints\nand data watchpoints and quickly reverse-execute to where they were hit.\n\n### rr works on real applications and is used by many developers to fix real\nbugs. It makes debugging hard bugs much easier, but also speeds up debugging\nof easy bugs.\n\n###\n\nrr features:\n\n  * Low overhead compared to other similar tools, especially on mostly-single-threaded workloads\n  * Supports recording and replay of all kinds of applications: Firefox, Chrome, QEMU, LibreOffice, Go programs, ...\n  * Record, replay and debug multiple-process workloads, including entire containers\n  * Works with gdb scripting and IDE integration\n  * Durable, compact traces that can be ported between machines\n  * Chaos mode to make intermittent bugs more reproducible\n\n## the rr debugging experience\n\nStart by using rr to record your application:\n\n    \n    \n    $ rr record /your/application --args ... FAIL: oh no!\n\nThe entire execution, including the failure, was saved to disk. That recording\ncan now be debugged.\n\n    \n    \n    $ rr replay GNU gdb (GDB) ... ... 0x4cee2050 in _start () from /lib/ld-linux.so.2 (gdb)\n\nRemember, you're debugging the recorded trace deterministically; not a live,\nnondeterministic execution. The replayed execution's address spaces, register\ncontents, syscall data etc are exactly the same in every run.\n\nMost of the common gdb commands can be used.\n\n    \n    \n    (gdb) break mozilla::dom::HTMLMediaElement::HTMLMediaElement ... (gdb) continue Continuing. ... Breakpoint 1, mozilla::dom::HTMLMediaElement::HTMLMediaElement (this=0x61362f70, aNodeInfo=...) ...\n\nIf you need to restart the debugging session, for example because you missed\nbreaking on some critical execution point, no problem. Just use gdb's run\ncommand to restart replay.\n\n    \n    \n    (gdb) run The program being debugged has been started already. Start it from the beginning? (y or n) y ... Breakpoint 1, mozilla::dom::HTMLMediaElement::HTMLMediaElement (this=0x61362f70, aNodeInfo=...) ... (gdb)\n\nThe run command started another replay run of your recording from the\nbeginning. But after the session restarted, the same execution was replayed\nagain. And all your debugging state was preserved across the restart.\n\nNote that the this pointer of the dynamically-allocated object was the same in\nboth replay sessions. Memory allocations are exactly the same in each replay,\nmeaning you can hard-code addresses you want to watch.\n\nEven more powerful is reverse execution. Suppose we're debugging Firefox\nlayout:\n\n    \n    \n    Breakpoint 1, nsCanvasFrame::BuildDisplayList (this=0x2aaadd7dbeb0, aBuilder=0x7fffffffaaa0, aDirtyRect=..., aLists=...) at /home/roc/mozilla-inbound/layout/generic/nsCanvasFrame.cpp:460 460 if (GetPrevInFlow()) { (gdp) p mRect.width 12000\n\nWe happen to know that that value is wrong. We want to find out where it was\nset. rr makes that quick and easy.\n\n    \n    \n    (gdb) watch -l mRect.width (gdb) reverse-cont Continuing. Hardware watchpoint 2: -location mRect.width Old value = 12000 New value = 11220 0x00002aaab100c0fd in nsIFrame::SetRect (this=0x2aaadd7dbeb0, aRect=...) at /home/roc/mozilla-inbound/layout/base/../generic/nsIFrame.h:718 718 mRect = aRect;\n\nThis combination of hardware data watchpoints with reverse execution is\nextremely powerful!\n\n## video\n\nThis video shows a quick demo of rr recording and replaying Firefox.\n\nThis video demonstrates rr's basic capabilities in a bit more detail.\n\nThis video is a high-level technical talk by Robert O'Callahan about rr.\n\n## getting started\n\n### Build from source\n\nFollow these instructions. Recommended if the packages don't work for you ---\nkernel changes and OS updates sometimes require rr changes.\n\n### Or in Fedora:\n\n    \n    \n    cd /tmp wget https://github.com/rr-debugger/rr/releases/download/5.7.0/rr-5.7.0-Linux-$(uname -m).rpm sudo dnf install rr-5.7.0-Linux-$(uname -m).rpm\n\n### Or in Ubuntu:\n\n    \n    \n    cd /tmp wget https://github.com/rr-debugger/rr/releases/download/5.7.0/rr-5.7.0-Linux-$(uname -m).deb sudo dpkg -i rr-5.7.0-Linux-$(uname -m).deb\n\n### Running rr\n\nFollow the usage instructions to learn how to use rr.\n\nIf you're using rr to debug Firefox, you may find these setup instructions\nhelpful. They cover how to use rr to record Firefox test suites.\n\n## background and motivation\n\nrr's original motivation was to make debugging of intermittent failures\neasier. These failures are hard to debug because any given program run may not\nshow the failure. We wanted to create a tool that would record program\nexecutions with low overhead, so you can record test executions until you see\na failure, and then replay the failing execution repeatedly under a debugger\nuntil it has been completely understood.\n\nWe also hoped that deterministic replay would make debugging of any kind of\nbug easier. With normal debuggers, information you learn during the debugging\nsession (e.g. the addresses of objects of interest, and the ordering of\nimportant events) often becomes obsolete when you have to rerun the testcase.\nWith deterministic replay, that never needs to happen: your knowledge of what\nhappens during the failing run increases monotonically.\n\nFurthermore, since debugging is the process of tracing effects to their\ncauses, it's much easier if your debugger can execute backwards in time. It's\nwell-known that given a record/replay system which provides restartable\ncheckpoints during replay, you can simulate reverse execution to a particular\npoint in time by restoring the previous checkpoint and executing forwards to\nthe desired point. So we hoped that if we built a low-overhead record-and-\nreplay system that works well on the applications we care about (Firefox), we\ncould build a really usable backend for gdb's reverse execution commands.\n\nThese goals have all been met. rr is not only a working tool, but it's being\nused regularly by developers on many large and small projects.\n\nrr records a group of Linux user-space processes and captures all inputs to\nthose processes from the kernel, plus any nondeterministic CPU effects\nperformed by those processes (of which there are very few). rr replay\nguarantees that execution preserves instruction-level control flow and memory\nand register contents. The memory layout is always the same, the addresses of\nobjects don't change, register values are identical, syscalls return the same\ndata, etc.\n\nTools like fuzzers and randomized fault injectors become even more powerful\nwhen used with rr. Those tools are very good at triggering some intermittent\nfailure, but it's often hard to reproduce that same failure again to debug it.\nWith rr, the randomized execution can simply be recorded. If the execution\nfailed, then the saved recording can be used to deterministically debug the\nproblem.\n\nrr lowers the cost of fixing bugs. rr helps produce higher-quality software\nfor the same cost. rr also makes debugging more fun.\n\n## rr in context\n\nRecord-and-replay debugging is an old idea; many systems preceded rr. What\nmakes rr different are the design goals:\n\n  * Initial focus on Firefox. Many record and replay techniques require specific programming languages or don't scale well and thus can't handle Firefox --- or were just experimental and were never fleshed out. Firefox is a complex application, so given rr is useful for debugging Firefox, it is likely to be generally useful.\n  * Deployability. rr runs on stock Linux kernels, on commodity hardware, and requires no system configuration changes. Many record and replay techniques require kernel changes. Many rely on running the OS in a virtual machine.\n  * Low run-time overload. We want rr to replace gdb in your workflow. That means you need to start getting results with rr about as quickly as you would if you were using gdb. Low overhead also means less perturbation of tests.\n  * Simplicity of design. We didn't have a lot of resources to develop rr, so we avoided approaches that rely on complex techniques such as dynamic binary instrumentation. This simplicity has also made rr more robust and lower overhead.\n\nThe overhead of rr depends on your application's workload. On Firefox test\nsuites, rr's recording performance is quite usable. We see slowdowns down to \u2264\n1.2x. A 1.2x slowdown means that if the suite takes 10 minutes to run by\nitself, it will take around 12 minutes to be recorded by rr. However, overhead\ncan vary dramatically depending on the workload. For mostly-single-threaded\nprograms, rr has much lower overhead than any competing record-and-replay\nsystem we know of.\n\n## limitations\n\nrr ...\n\n  * emulates a single-core machine. So, parallel programs incur the slowdown of running on a single core. This is an inherent feature of the design.\n  * cannot record processes that share memory with processes outside the recording tree. This is an inherent feature of the design. rr automatically disables features such as X shared memory for recorded processes to avoid this problem.\n  * requires a reasonably modern x86 CPU or certain ARM CPUs (Apple M1+).\n  * requires knowledge of every system call executed by the recorded processes. It already supports a wide range of syscalls \u2014 those needed by Firefox and other applications people have tackled with rr \u2014 but support isn't complete, so running rr on your application may uncover a syscall that needs to be implemented. Please file github issues for unsupported system calls.\n  * sometimes needs to be updated in response to kernel changes, updates to system libraries, or new CPU families. If rr isn't working for you (and the above caveats do not apply), please file an issue.\n\n## further reference\n\nThe Extended Technical Report is our best overview of how rr works and\nperforms.\n\nThe rr wiki contains pages that cover technical topics related to rr.\n\nAsk on the mailing list or on #rr on chat.mozilla.org if you have questions\nabout rr.\n\n", "frontpage": false}
