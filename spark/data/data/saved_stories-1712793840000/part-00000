{"aid": "39993840", "title": "Python Library: Tenacity", "url": "https://new.pythonforengineers.com/blog/awesome-python-library-tenacity/", "domain": "pythonforengineers.com", "votes": 1, "user": "shantnutiwari", "posted_at": "2024-04-10 18:02:33", "comments": 0, "source_title": "Awesome Python Library: Tenacity", "source_text": "Awesome Python Library: Tenacity\n\n# Awesome Python Library: Tenacity\n\n#### Shantnu Tiwari\n\nApr 10, 2024 \u2022 2 min read\n\nLink: https://tenacity.readthedocs.io/en/latest/\n\nWhen writing code or tests in Python, one issue I had was when the code would\nfail due to random things like network issues or external peripherals not\nresponding in time. Just rerunning the tests would make them pass. The\nunreliability wasn't in the code but in things out of my control, like network\nissues.\n\nSo I had to add extra code to retry the code, but this added unnecessary\ncomplexity.\n\nThats when I discovered the Tenacity library and it saved me hours and a lot\nof useless boilerplate code.\n\n### Some unreliable code\n\nLet's try some dummy unreliable code.\n\n    \n    \n    import time import random FAIL_PERCENT= 0.7 # 70% of time def unreliable_function(): print(\"In unreliable function:\") if random.random() < FAIL_PERCENT: raise Exception(\"Operation failed randomly\") else: # Successful operation return \"Success\"\n\nThe code uses the random function to throw an exception 70% of the time. Try\nrunning it, it will fail more often than not.\n\nNormally, I would add some code to retry the code on failure:\n\n    \n    \n    for i in range(10): try: unreliable_function() print(\"passed, yay!\") break except Exception as e: print(\"Function returned error, sleeping\") time.sleep(1)\n\nRunning it, I get output like:\n\n    \n    \n    In unreliable function: Function returned error, sleeping In unreliable function: Function returned error, sleeping In unreliable function: Function returned error, sleeping In unreliable function: passed, yay!\n\nSo the code works, but I have to manually add try excepts and a sleep. And\nthen I have to maintain the code.\n\n### Tenacity: Retry on failure\n\nLet's see how we can retry the buggy code with Tenacity:\n\n    \n    \n    @retry # <-- This is the only NEW code def unreliable_function(): print(\"In unreliable function:\") if random.random() < FAIL_PERCENT: raise Exception(\"Operation failed randomly\") else: # Successful operation return \"Success\" unreliable_function()\n\nThe simplest thing is to just add the @retry decorator to the code. It will\nkeep running the code if it passes.\n\nThe fact you have no extra code, just a decorator, means the code is really\neasy to follow when someone else picks up your code a few months/years from\nnow.\n\nBut what if we want to only try X times, and sleep in between tries?\n\n    \n    \n    @retry(wait = wait_fixed(1), stop = stop_after_attempt(8)) def unreliable_function(): print(\"In unreliable function:\") if random.random() < FAIL_PERCENT: raise Exception(\"Operation failed randomly\") else: # Successful operation return \"Success\" unreliable_function()\n    \n    \n    In unreliable function: In unreliable function: In unreliable function: 'Success'\n\nThe wait = wait_fixed(1) will wait 1 second between runs. Instead of\nwait_fixed we can also wait a random time, or wait_exponential() which will\nincrease the time exponentially.\n\nstop = stop_after_attempt(8) will stop after 8 tries. You can also set a\nmaximum timeout\u2013 like the code must fail after 30 seconds.\n\nAdding multiple conditions\n\nWe can also chain conditions. So for example, you want to wait between\nretries, but you don't want to spend hours on it as you have other things to\ndo (or you might have other tests to run, and want to fail early).\n\n    \n    \n    @retry(stop=(stop_after_attempt(10) | stop_after_delay(30) ) )\n\nThe above will retry the code 10 times, but for a maximum of 30 seconds. If\nafter 30 seconds, the code is still failing, it will return with the error\nmessage.\n\nAnother cool function if Custom Callbacks, where you can have your own test to\ncheck if the code failed.\n\nSay you are reading a webpage and it returns a 500 server error HTTP code.\nWhile there has been no exception, the code still failed.\n\nIn this case, you can write your own custom code to check the HTTP code is\n200.\n\n### In conclusion\n\nI wasted a lot of time writing my own code to retry functions in various\ncases, and it became complex and unmanageable soon. Tenacity is so simple to\nuse, I recommend just using it.\n\n## Sign up to know when the next post is out, and get exclusive content\n\nEnter your email\n\nSubscribe\n\n## So Google's Gemini Doesn't Like Python Programming and Sanskrit?\n\nI have been playing around with Googles Gemini Pro. Recently, I wanted to\nwrite a blog on Python's decorators and wanted to get some ideas for practical\nprojects I could build with them. Tried GPT4 first, it gave me the standard\n\"log analyser\" that all blogs\n\nShantnu Tiwari Feb 25, 2024 \u2022 4 min read\n\n## LinkedIn Has Become a Pile of Garbage (even more than usual)\n\nOnline forums, especially Hacker News and Reddit, are very hostile to\nLinkedIn. Everyone makes fun of the self-promotion and silliness that goes\nthere. There are complaints the site is unusable, which I didn't agree with\nuntil now. I've had an account there for a few years.\n\nShantnu Tiwari Jan 29, 2024 \u2022 4 min read\n\n## The Tech Bro's Hypocrisy about AI and IP Theft is Incredible\n\nSome time ago there was a post that Github(owned by Microsoft) was training\nits data on public code repos. And there was predictable outrage about code\nbeing \"stolen\" by a greedy corporation. The key thing is: Most of the\nprogrammers had willingly put their code on GitHub\n\nShantnu Tiwari Jan 19, 2024 \u2022 3 min read\n\nPython for Engineers \u00a9 2024\n\nPowered by Ghost\n\n", "frontpage": false}
