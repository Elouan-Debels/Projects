{"aid": "39990642", "title": "The undocumented Microsoft \"Rich\" PECOFF header. (2021)", "url": "http://bytepointer.com/articles/the_microsoft_rich_header.htm", "domain": "bytepointer.com", "votes": 1, "user": "fanf2", "posted_at": "2024-04-10 13:42:04", "comments": 0, "source_title": "BYTE* / The Undocumented Microsoft \"Rich\" Header", "source_text": "BYTE* / The Undocumented Microsoft \"Rich\" Header\n\n| | <\\-- Articles Index / The Undocumented Microsoft \"Rich\" Header  \n---  \n| 1  \n---  \n| | | The Undocumented Microsoft \"Rich\" HeaderDate: Mar 12, 2017Last-Modified: Feb 28, 2018SUMMARY: There is a bizarre undocumented structure that exists only in Microsoft-produced executables. You may have never noticed the structure even if you've scanned past it a thousand times in a hex dump. This linker-generated structure is present in millions of EXE, DLL and driver modules across the globe built after the late 90's. This was when proprietary features were introduced into both Microsoft compilers and the Microsoft Linker to facilitate its generation. If you view the first 256 bytes of almost any module built with Microsoft development tools (such as Visual C++) or those that ship with the Windows operating system, such as KERNEL32.DLL from Windows XP SP3 (shown below), you can easily spot the signature in a hex viewer. Just look for the word \"Rich\" after the sequence \"This program cannot be run in DOS mode\":\n    \n    \n    00000000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 MZ.............. <--DOS header 00000010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@....... 00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030 00 00 00 00 00 00 00 00 00 00 00 00 f0 00 00 00 ................ 00000040 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 ........!..L.!Th <--DOS STUB 00000050 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f is program canno 00000060 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 t be run in DOS 00000070 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00 mode....$....... 00000080 17 86 20 aa 53 e7 4e f9 53 e7 4e f9 53 e7 4e f9 .. .S.N.S.N.S.N. <--Start of \"Rich\" Header 00000090 53 e7 4f f9 d9 e6 4e f9 90 e8 13 f9 50 e7 4e f9 S.O...N.....P.N. 000000A0 90 e8 12 f9 52 e7 4e f9 90 e8 10 f9 52 e7 4e f9 ....R.N.....R.N. 000000B0 90 e8 41 f9 56 e7 4e f9 90 e8 11 f9 8e e7 4e f9 ..A.V.N.......N. 000000C0 90 e8 2e f9 57 e7 4e f9 90 e8 14 f9 52 e7 4e f9 ....W.N.....R.N. 000000D0 52 69 63 68 53 e7 4e f9 00 00 00 00 00 00 00 00 RichS.N......... <--End of \"Rich\" header 000000E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000F0 50 45 00 00 4c 01 04 00 2c a1 02 48 00 00 00 00 PE..L...,..H.... <--PE header\n\nWhen present, the \"Rich\" signature (DWORD value 0x68636952) can be found\nsandwiched (maybe \"camouflaged\" is a better word) between the DOS and PE\nheaders of a Windows PE (portable executable) image. I say camouflaged,\nbecause it appears, perhaps by Microsoft's original design, to be part of the\n16-bit DOS stub code, which it is not. Since many programmer probably weren't\nversed with 16-bit assembly even when Microsoft introduced this structure, you\ncould argue the decision to embed something at this particular location in\nevery executable was certainly a strategic one to help it hide in plain\nsight.In Microsoft-linked executables, not only does the DOS mode string begin\nat predictable offset 0x4E, but the \"Rich\" structure always seems to appear at\noffset 0x80; this makes sense as the DOS header has probably been hardcoded\nfor quite some time. Oddly enough, the \"Rich\" signature actually marks the end\nof the structure's data, whose size varies. Therefore the position of the\nsignature as well as the total size of the structure changes from module to\nmodule. The 32-bit value that follows the signature not only marks the end of\nthe structure itself, it happens to be the key that is used to decrypt the\nstructure's data. Following this structure is the PE header, with a handful of\nzero-padded bytes in between.Since this is an undocumented \"feature\" of the\nMicrosoft linker, it is not surprising that there is no known option to\ndisable it, short of patching (discussed below). At the time of discovery, all\nexecutables built using Microsoft language tools contained this structure\n(e.g. Visual C++, Visual Basic 6.x and below, MASM, etc.) causing many\ndevelopers to fear the worst. Two \"seemingly\" identical installations of\nVisual Studio building the same source code appeared to produce executables\nwith differing \"Rich\" headers. This combined with the fact that the structure\nwas encrypted led many to the assumption that Microsoft was embedding\npersonally identifiable information, ultimately allowing any given executable\nto be traced back to the machine it was built with. An old 2007 post on the\nSysinternals forum refers to this structure the \"Devil's Mark\". Also of\ninterest is a 2008 report on Donationcoder that Microsoft utilized the\ninformation from this structure as \"evidence against several high-profile\nvirus writers\". A post from Garage4Hackers said \"Microsoft uses compiler ids\nto prove that a virus is made on a particular machine with a particular\ncompiler. Proving that the person owning the computer is the virus\nwriter\".Note that while this structure is present in some .NET executables, it\nis not present in those that do not make use of the Microsoft linker. For\nexample, an application composed purely of .NET Intermediate Language such as\nC# does not contain this structure. For any given executable module, you can\ncheck for the existence of the \"Rich\" header (in addition to viewing the\ndecoded fields) using the pelook tool tool with the -rh option.Before jumping\nto any conclusions, lets see what Microsoft is hiding here.AN ARRAY OF NUMERIC\nVALUES: First off, the \"Rich\" header really isn't a header at all. It is a\nself-contained chunk of data that doesn't reference anything else in the\nexecutable and nothing else in the executable references it. The structure was\nunofficially referred to as a header because it happens to reside in PE header\narea.The structure happens to be little more than an array of 32-bit (DWORD)\nvalues between two markers. If one so chooses, the structure can even be\nsafely zeroed-out from the executable without affecting any functionality.\nJust ensure you update the PE OptionalHeader's checksum if you alter any bytes\nin the file; although this is not necessary if the checksum field is zero\n(disabled).Automated removal is possible through the peupdate tool. More\nrecently, I found that Microsoft's editbin (in version 7.x and up) will also\nzero-out the \"Rich\" structure using the undocumented /nostub switch however\nthis also removes the PE header offset from the DOS header effectively\nbreaking the executable. Using editbin is therefore not recommended. Other\nremoval options are discussed in the section, Patching the Microsoft Linker\nbelow.In the KERNEL32.DLL sample above, the DWORD following the \"Rich\"\nsequence happens to have the value 0xF94EE753. This is the XOR key stored by\nand calculated by the linker. It is actually a checksum of the DOS header with\nthe e_lfanew (PE header offset) zeroed out, and additionally includes the\nvalues of the unencrypted \"Rich\" array. Using a checksum with encryption will\nnot only obfuscate the values, but it also serves as a rudimentary digital\nsignature. If the checksum is calculated from scratch once the values have\nbeen decrypted, but doesn't match the stored key, it can be assumed the\nstructure had been tampered with. For those that go the extra step to\nrecalculate the checksum/key, this simple protection mechanism can be\nbypassed.To decrypt the array, start with the DWORD just prior to the \"Rich\"\nsequence and XOR it with the key. Continue the loop backwards, 4 bytes at a\ntime, until the sequence \"DanS\" (0x536E6144) is decrypted. This value marks\nthe start of the structure, and in practice always seems to reside at offset\n0x80. I think a lot of tools that parse the \"Rich\" structure rely on it\nstarting at offset 0x80. I'd personally recommend against relying on this fact\nand parsing backwards from the \"Rich\" signature as described above to handle\nsituations where this may not be the case. Since this is an undocumented\nstructure, I think its best to avoid any assumptions such as hardcoded\noffsets, especially since you must search for the signature \"Rich\" anyway.\nWith that said, I have yet to encounter an executable where offset 0x80 is not\nthe start; that is, if the structure is present at all.Following the decoding\nprocedure using the KERNEL32.DLL sample shown above, we end up with following\n\"Rich\" structure where all values have been decrypted, and the array is listed\nbeginning at offset 0x80 in ascending order:\n\n    \n    \n    OFFSET DATA ------ ---------- 0080 0x536E6144 //\"DanS\" signature (decrypted) / START MARKER 0084 0x00000000 //padding 0088 0x00000000 //padding 008C 0x00000000 //padding 0090 0x00010000 //1st id/value pair entry #1 0094 0x0000018A //1st use count id1=0,uses=394 0098 0x005D0FC3 //2nd id/value pair entry #2 009C 0x00000003 //2nd use count id93=4035,uses=3 00A0 0x005C0FC3 //3rd id/value pair entry #3 00A4 0x00000001 //3rd use count id92=4035,uses=1 00A8 0x005E0FC3 //4th id/value pair entry #4 00AC 0x00000001 //4th use count id94=4035,uses=1 00B0 0x000F0FC3 //5th id/value pair entry #5 00B4 0x00000005 //5th use count id15=4035,uses=5 00B8 0x005F0FC3 //6th id/value pair entry #6 00BC 0x000000DD //6th use count id95=4035,uses=221 00C0 0x00600FC3 //7th id/value pair entry #7 00C4 0x00000004 //7th use count id96=4035,uses=4 00C8 0x005A0FC3 //8th id/value pair entry #8 00CC 0x00000001 //8th use count id90=4035,uses=1 00D0 0x68636952 //\"Rich\" signature END MARKER 00D4 0xF94EE753 //XOR key\n\nThe array stores entries that are 8-bytes each, broken into 3 members. Each\nentry represents either a tool that was employed as part of building the\nexecutable or a statistic. You'll notice there are some zero-padded DWORDs\nadjacent to the \"DanS\" start marker. In practice, Microsoft seems to have\nwanted the entries to begin on a 16-byte (paragraph) boundary, so the 3\nleading padding DWORDs can be safely skipped as not belonging to the data.Each\n8-byte entry consists of two 16-bit WORD values followed by a 32-bit DWORD.\nThe HIGH order WORD is an id which indicates the entry type. The LOW order\nWORD contains the build number of the tool being represented (when\napplicable), or it may be set to zero. The next DWORD is a full 32-bit \"use\"\nor \"occurrence\" count.THE ID VALUE: The id value indicates the type of the\nlist entry. For example, a specific id will represent OBJ files generated as a\nresult of the use of a specific version of the C compiler. Different ids\nrepresent other tools that were also employed as part of building the final\nexecutable, such as the linker. Daniel Pistelli's article, Microsoft's Rich\nSignature (undocumented), found that the id values are a private enumeration\nthat change between releases of Visual Studio. I have also found this to be\nthe case, which unfortunately makes them a bit of a moving target to\ndecipher.Besides a couple exceptions which I'll explain below, the id is\nemitted by each compiler (or assembler) and is stored within each OBJ (and\nthus LIB) files linked against in the form of the \"@comp.id\" symbol. The\n\"@comp.id\" symbol happens to be short for \"compiler build number\" and \"id\". In\nfact, the DWORD value stored as the \"@comp.id\" symbol is the same DWORD being\nstored in the first half of applicable \"Rich\" list entries. I say applicable\nbecause not all list entries represent OBJ files.Some ids can appear more than\nonce in the list, while others do not. The id typically represents the\nfollowing statistics:\n\n  * OBJ count for specific C compiler (cl.exe)\n  * OBJ count for specific C++ compiler (cl.exe)\n  * OBJ count for specific assembler (ml.exe)\n  * specific linker that built module (link.exe)\n  * specific resource compiler (rc.exe), when RES file linked\n  * imported functions count\n  * MSIL modules\n  * PGO Instrumented modules\n  * and so on...\n\nMost of the entries above have an associated build number of the tool being\nrepresented, such as the compiler, assembler and linker. One exception to this\nis the imported functions count, which happens to be the total number of\nimported functions referenced in all DLLs. This is usually the only entry with\na build number of zero. Note that the \"Rich\" structure does not store\ninformation on the number of static/private functions within each OBJ/source\nfile.The linker entry is always last in the list and represents the linker\nthat built the module. The resource compiler, when present, is almost always\n2nd to last in the list; next to the linker. Both the linker and resource\ncompiler are represented by a hardcoded id and build values for each linker\nrelease. For example, when a resource script is employed, the linker uses the\nsame id/build pair even if the RES is built from a resource compiler from\nanother version of Visual Studio! Another oddity is the build value of the\nresource compiler entry typically does not match the build reported by the\nrc.exe command line. The correlation of unique build values to specific\nversions of Visual Studio tools is discussed in more detail below.The linker\nseems to build most \"Rich\" structures in the following order, though not\nnecessarily in the order appearing on the command line:\n\n  * Entries representing LIB files\n  * Entries representing individual OBJ files\n  * Resource Compiler\n  * Linker\n\nAt first glance you might guess that each referenced LIB file would represent\none entry in the list, but this is not the case. The linker may may generate\none or more entries for each LIB file depending on the number of unique\n\"@comp.id\" values found within. Since a LIB file is not much more than a\nconcatenation of OBJ files, the resulting \"count\" member of these entries are\nthe number of OBJ files referenced in the final executable that contain that\nexact \"@comp.id\" value. For example, statically linking to the Standard C\nLibrary usually generates assembler and C OBJ entries because that is what\nconstitutes the source files internally used by Microsoft to build LIBCMT.LIB.\nWhen you link against this library, the unique \"@comp.id\" value-pairs are\ntallied together and the resulting counts are written to the list.With that in\nmind, the \"Rich\" structure in KERNEL32.DLL can be annotated as follows:|\nid1=0,uses=394| id93=4035,uses=3| id92=4035,uses=1| id94=4035,uses=1|\nid15=4035,uses=5| id95=4035,uses=221| id96=4035,uses=4| id90=4035,uses=1  \n---|---|---|---|---|---|---|---  \n394 imports| ???| ???| 1 rc script| 5 asm sources| 221 C sources| 4 C++\nsources| Linker  \n  \nHere's another annotated example derived from a minimal C++ application linked\nwith a resource script and the Standard C Library built from Visual C++ 7.1:\n\nid15=6030,uses=20| id95=6030,uses=68| id93=2067,uses=2| id93=2179,uses=3|\nid1=0,uses=3;| id96=6030,uses=1| id94=3052,uses=1| id90=6030,uses=1  \n---|---|---|---|---|---|---|---  \n20 asm sources| 68 C sources| ???| ???| 3 imports| 1 C++ source| 1 rc script|\nLinker  \n  \nBelow is my attempt at a partial list of decoded ids from the version 6 and 7\nVisual Studio toolsets based on a little trial and error. Note that many of\nthe ids originate from the LIB files bundled with with the associated Visual\nC++ SDK versions, as the linker only hardcodes a few of the entries at the end\nof the list. It is also common to see a reference to MASM even when MASM is\nnot utilized directly by a project as these references are pulled in\nautomatically by the linker or SDK LIB files.\n\nMicrosoft Visual Studio 6.0 SP6\n\nID| MEANING  \n---|---  \n1| total count of imported DLL functions referenced; build number is always\nzero  \n4| seems to be associated when linking against Standard C Library DLL  \n19| seems to be associated when statically linking against Standard C Library  \n6| resource compiler; almost always last in list (when RES file used) and use-\ncount always 1  \n9| count of OBJ files for Visual Basic 6.0 forms  \n13| count of OBJ files for Visual Basic 6.0 code  \n10| count of C OBJ files from specific cl.exe compiler  \n11| count of C++ OBJ files from specific cl.exe compiler  \n14| count of assembler OBJ files originating from MASM 6.13  \n18| count of assembler OBJ files originating from MASM 6.14  \n42| count of assembler OBJ files originating from MASM 6.15  \n  \nMicrosoft Visual Studio 7.1 SP1\n\nID| MEANING  \n---|---  \n1| total count of imported DLL functions referenced; build number is always\nzero; same as in Linker versions 5.0 SP3 and 6.x  \n15| count of assembler OBJ files originating from MASM 7.x  \n90| linker; always present and always at end of list; use-count always 1  \n93| Always seems to be present no matter how the executable was built, but\ndoesn't appear to originate from @comp.id symbols (???)  \n94| resource compiler; almost always 2nd to last in list (when RES file used)\nand use-count always 1  \n95| count of C OBJ files from specific cl.exe compiler  \n96| count of C++ OBJ files from specific cl.exe compiler  \n  \nNot only do the ids change with each major linker release (sometimes with\nservice packs too), but newer versions of the SDK's LIB files use different\nand higher id numbers for the same thing, such as the C and C++ compiler. So\nnot only do the build numbers change with each SDK, but the id identifying the\ntype of entry also changes. Unless the idea is to make the header difficult to\ninterpret, the id may be meant to be combined with the build number to provide\na unique compiler-that-built-SDK instance statistic which could be used to\ntrace leaked or BETA versions of tools or SDKs. The whole system might also\ndouble as another check system, where if the tool ids and reported build\nversions don't match known publicly released pairs, this would be another\nindication the entries in the list were tampered with. Without any official\nword from Microsoft, some of this is pure speculation.\n\nThe good news is that if you are only interested in detecting modern versions\nof Visual Studio (7.x and up), the id member can be completely ignored! More\ninformation about detection is presented below.\n\nWHEN DID MICROSOFT INTRODUCE THE \"RICH\"-ENABLED LINKER? The short answer is in\n1998, with Visual Studio 6.0 (LINK 6.x). The long answer is the final Service\nPack for Visual Studio 5.0; that is, the version 5.10.7303 linker introduced\nwith SP3 in 1997 was the first \"Rich\" capable linker. The catch was that the\nlist this linker produced was practically empty because the compilers at the\ntime (e.g. Visual C++ 5.x, MASM 6.12) did not yet emit the \"@comp.id\" symbol\nto the OBJ files. Not surprisingly, the LIB files that shipped with the\nproduct's SDK were also missing the \"@comp.id\" symbol. The result was a \"Rich\"\nstructure with either a single entry for the imports, or with an additional\nentry to represent a compiled resource script.\n\nIf you however link a Visual C++ 6.0 OBJ file with the older 5.0 SP3\n(5.10.7303) linker, you will get a proper \"Rich\" structure because the 6.0 OBJ\nfile contained the \"@comp.id\" symbol with build information. The 6.0 OBJ files\nwere however incompatible the 5.0 SP2 and earlier linkers; if you attempted to\nlink-in any of these modules using the older linkers, you would run in to\nerror: LNK1106: \"invalid file or disk full: cannot seek to 0xXXXXXXXX\". This\nis an indication that in 1997, Microsoft changed the OBJ file format.\n\nIn summary, the Visual C++ 5.0 SP3 linker and the linker that would be\nreleased next with Visual C++ 6.0, both supported a new type of OBJ file.\nSpecifically, the OBJ files that would facilitate the generation of the this\nnew \"Rich\" structure.\n\nCHANGELIST:\n\nPRODUCT VERSION| YEAR| CHANGE  \n---|---|---  \nVisual Studio 97 (5.0) SP3| 1997| First linker capable of producing \"Rich\"\nheader and supporting new OBJ format to be released with the not-yet-public\nVC++ 6.0 compiler (cl.exe 12.x); however compiler's at the time did not yet\nsupport writing \"@comp.id\" to OBJ files so the list had minimal information  \nVisual Studio 6.x| 1998| Microsoft compilers, including Visual Basic now\nsupport writing \"@comp.id\" symbol to OBJ files; bundled SDK LIB files now\ncontain \"@comp.id\" build information; as a result, executables built using the\nVisual C++ 6.0 compiler and linker now get the first \"proper\" \"Rich\" headers.  \nVisual Studio 7.0 .NET (2002)| 2002| Linker now appends its own entry to the\nlist and is always last; fortunately we now have a predictable entry that is\nretained in future versions  \n  \nBUILD NUMBERS FOR DETECTION: Before continuing further, I want to stress an\nimportant point. There is little preventing someone from either tampering with\nor completely falsifying the \"Rich\" header. While this structure may provide\nuseful information for the majority of executables, other signature methods\nshould be utilized in conjunction where accuracy is paramount. Some of these\nmethods may include searching for specific patterns in the headers and/or\nanalysis of the entry-point code. For example the Borland and Watcom linkers\ncan be identified by specific patterns unique to each from their DOS stubs.\nThe presence of a \"Rich\" header, or lack thereof, doesn't mean Microsoft's\nlinker cannot be detected by other clues.\n\nA typical version number for a Microsoft product consists of major and minor\nnumbers (one byte each) followed by a 16-bit build number and sometimes\nanother 16-bit sub-version number. Since we primarily have the build number\nfor each \"Rich\" entry to go by, how might we distinguish a specific version of\nVisual Studio from this information? There are at least 3 ways:\n\n  * The MajorLinkerVersion and MinorLinkerVersion members of the PE's OptionalHeader can be combined with the last entry in the \"Rich\" list (if MajorLinkerVerion >= 7) to construct the full version of the linker. Once the linker is known, one can assume the version of Visual Studio including that linker was responsible for building the executable even if not all inputs came from this version.\n  * The build numbers for each release of Visual Studio are almost completely unique which allow build numbers to identify a specific version of the toolset used; that is for id's besides the linker. The one exception I'm aware of is build number 50727. This build number was issued to public releases of both Visual Studio 2005 and 2012. As mentioned above, you might make the distinction by checking the PE MajorLinkerVersion and testing it for 8 and 11 respectively to at least determine the full version of the linker.\n  * Because the entry type ids change between releases of Visual Studio, the id in combination with the build number can be used to uniquely identify a version of Visual Studio.\n\nBased on the information above, if you want to detect versions of Visual\nStudio 7.0 and up, things couldn't be easier. If the MajorLinkerVersion in the\nPE's OptionalHeader is 7 or greater, indicating Visual Studio .NET 7.0 (2002)\nand up, the last entry in the list always represents the linker that built the\nmodule. If that build number corresponds to a known version of Visual Studio,\nyou might consider it safe to assume the compiler is also from the same\ntoolset.\n\nAs for versions of Visual Studio supporting the \"Rich\" structure prior to 7.0,\nthe detection rules were a little different because no linker entry was\nwritten to the end of the \"Rich\" list. Perhaps Microsoft figured it was enough\nthat the PE header contained the Major and Minor version for the linker and\nthe build number was not important enough to include.\n\nIt is interesting to note that the id and build versions embedded within the\npublicly shipped SDK LIB files are those of non-public releases of Microsoft\ncompilers; this makes sense because Microsoft builds its SDKs internally, but\nthis happens to be a good thing for detection. This allows us to distinguish\nthe SDK's compiler id/build pairs from those pairs that represent the\ncompilers responsible for building the executable. In other words, if you know\nwhere the linker entry is and the entries that represent the SDK LIB files\nbecause they are not recognized public versions (see table below), the only\nthing left are the compiler entries we want to use for detection! You will\nthen be able to determine the language used to build an executable, whether it\nbe C, C++, MASM or all in combination in addition to the toolset version of\neach. All of this is assuming you want to use the build numbers alone for\ndetection rather than hardcoding the differing tool ids per version of Visual\nStudio to combine with the build numbers.\n\nGoing back to the KERNEL32.DLL example above, we can see the last entry's\nbuild number is 4035 which corresponds to one of the known public Microsoft\n7.1 linkers. Using a lookup table, such as that shown below, applications can\nuse this information to correlate [mostly] unique build numbers to known\nMicrosoft Visual Studio toolsets.\n\nMASM 6.x BUILDS\n\nBUILD| PRODUCT VERSION  \n---|---  \n7299| 6.13.7299  \n8444| 6.14.8444  \n8803| 6.15.8803  \n9030| 6.15.9030 (VS.NET 7.0 BETA 1)  \n  \nVisual Basic 6.0 BUILDS\n\nBUILD| PRODUCT VERSION  \n---|---  \n8169| 6.0 (also reported with SP1 and SP2)  \n8495| 6.0 SP3  \n8877| 6.0 SP4  \n8964| 6.0 SP5  \n9782| 6.0 SP6 (same as reported by VC++ but different id)  \n  \nVISUAL STUDIO BUILDS\n\nBUILD| PRODUCT VERSION| CL VERSION| LINK VERSION  \n---|---|---|---  \n8168| 6.0 (RTM, SP1 or SP2)| 12.00.8168| 6.00.8168  \n8447| 6.0 SP3| 12.00.8168| 6.00.8447  \n8799| 6.0 SP4| 12.00.8804| 6.00.8447  \n8966| 6.0 SP5| 12.00.8804| 6.00.8447  \n9044| 6.0 SP5 Processor Pack| 12.00.8804| 6.00.8447  \n9782| 6.0 SP6| 12.00.8804| 6.00.8447  \n9030| 7.0 2000 (BETA 1)| 13.00.9030| 7.00.9030  \n9254| 7.0 2001 (BETA 2)| 13.00.9254| 7.00.9254  \n9466| 7.0 2002| 13.00.9466| 7.00.9466  \n9955| 7.0 2002 SP1| 13.00.9466| 7.00.9955  \n3077| 7.1 2003| 13.10.3077| 7.10.3077  \n3052| 7.1 2003 Free Toolkit| 13.10.3052| 7.10.3052  \n4035| 7.1 2003| 13.10.4035 (SDK/DDK?)  \n6030| 7.1 2003 SP1| 13.10.6030| 7.10.6030  \n50327| 8.0 2005 (Beta)| ?| ?  \n50727 (linkver 8.x)| 8.0 2005| 14.00.50727.42 14.00.50727.762 SP1?  \n21022| 9.0 2008| 15.00.21022  \n30729| 9.0 2008 SP1| 15.00.30729.01  \n30319| 10.0 2010| 16.00.30319  \n40219| 10.0 2010 SP1| 16.00.40219  \n50727 (linkver 11.x)| 11.0 2012| 17.00.50727  \n51025| 11.0 2012| 17.00.51025  \n51106| 11.0 2012 update 1| 17.00.51106  \n60315| 11.0 2012 update 2| 17.00.60315  \n60610| 11.0 2012 update 3| 17.00.60610  \n61030| 11.0 2012 update 4| 17.00.61030  \n21005| 12.0 2013| 18.00.21005  \n30501| 12.0 2013 update 2| 18.00.30501  \n31101| 12.0 2013 update 4| 18.00.31101.0  \n40629| 12.0 2013 SP5| 18.00.40629 SP5  \n22215| 14.0 2015| 19.00.22215 Preview  \n23026| 14.0 2015| 19.00.23026.0  \n23506| 14.0 2015 SP1| 19.00.23506 SP1  \n23824| 14.0 2015 update 2| (unverified)  \n24215| 14.0 2015| 19.00.24215.1 (unverified)  \n24218| 14.0 2015| 19.00.24218.2  \n25019| 14.1 2017| 19.10.25019.0  \n  \nNOTE: The table above was compiled from various sources; it is not an\nexhaustive list.\n\nBUILD NUMBERS DON'T ALWAYS MATCH REPORTED COMMAND LINE/ VERSION RESOURCE\nVALUES! As you can see, the build numbers don't always correspond to what is\nreported from the command line. For example cl.exe for Visual C++ 6.0 reports\nversion 12.00.8804 for Service Packs 4 thru 6, however the \"@comp.id\" value\nwritten to OBJ files is different for each service pack, such as\n8799,8966,9044, and 9782 for SP4, SP5, SP5 (Processor Pack) and SP6\nrespectively. You can see the same pattern in Visual C++ 7.x. This allows for\nunique detection for each Service Pack.\n\nPATCHING THE MICROSOFT LINKER: Rather than using a tool (such as peupdate) to\nremove the \"Rich\" header on a per-executable basis, it is possible to \"fix\"\nthe linker so that the \"Rich\" header is never written in the first place.\n\nIt wasn't long between the \"Rich\" header's discovery gone public and the\nappearance of a linker patch to prevent the structure from being written to\nthe executable. This is a cleaner solution than manually zeroing-out each\nexecutable produced, however a new patch is needed for each version of the\nlinker. As an added bonus, patching reclaims the area originally occupied by\nthe \"Rich\" header (usually offset 0x80) as the spot where the PE header will\ninstead be placed. This can reduce the size of the executable depending on the\nfile alignment value passed to the linker.\n\nIn August of 2005, there was a PE tutorial written by Goppit that briefly\ndescribes using a tool called Signature Finder to patch the Linker. This is a\nsimple GUI tool that when supplied the path to LINK.EXE, locates the RVA\naddress of the CALL instruction for the routine which generates the \"Rich\"\nHeader.\n\nKnowing where the \"Rich\" routine is invoked by the linker is the first step;\nhow to patch is up to you. However the traditional patch method is to NOP-out\nthe ADD instruction following the CALL.\n\nTo do this, load LINK.EXE in a disassembler or debugger and navigate to the\nlocation reported by the tool (adding a 0x400000 base address to the reported\nRVA). If you have symbols loaded, you'll see disassembly similar to the\nfollowing within the IMAGE::BuildImage() function:\n\n0045F0A5 E8 56 45 FC FF call ?UpdateCORPcons@@YGXXZ ; UpdateCORPcons(void)\n0045F0AA 55 push ebp ; struct IMAGE * 0045F0AB E8 30 D2 01 00 call\n?UpdateSXdata@@YGXPAVIMAGE@@@Z ; UpdateSXdata(IMAGE *) 0045F0B0 8D 54 24 14\nlea edx, [esp+448h+lpMem] 0045F0B4 52 push edx 0045F0B5 55 push ebp 0045F0B6\nE8 45 A6 FF FF call ?CbBuildProdidBlock@IMAGE@@AAEKPAPAX@Z ;\nIMAGE::CbBuildProdidBlock(void**) <\\--- BUILDS the \"Rich\" Header 0045F0BB 8B\n8D 3C 02 00 00 mov ecx, [ebp+23Ch] 0045F0C1 03 C8 add ecx, eax ; <\\--- NOP\nthis out! 0045F0C3 89 44 24 2C mov [esp+448h+var_41C], eax 0045F0C7 89 8D 40\n02 00 00 mov [ebp+240h], ecx 0045F0CD FF 15 BC 12 40 00 call ds:__imp___tzset  \n---  \n  \nThe \"Rich\" Header routine identified by the tool is named\nCbBuildProdidBlock(); we can now assume Microsoft internally refers to the\n\"Rich\" structure as the \"Product ID Block\". If the ADD instruction below it\n(address 0x45F0C1) is changed from bytes \"03 C8\" to \"90 90\" (NOPs), the linker\nstill internally generates the structure, but because we've removed the\ninstruction that advances the current file position, the PE header (which\ncomes next in the image) overwrites the \"Rich\" structure. Problem solved, no\ninformation leak.\n\nIf you don't want to run the Signature Finder tool, below is a table with\npatch address information for all of the publicly-released 6.xx and 7.xx\nMicrosoft linkers. The location is for the \"ADD ECX,EAX\" instruction (bytes\n\"03 C8\"). To perform the patch, replace the ADD instruction with two NOP bytes\n(\"90 90\"). This can be done with the bytepatch tool using the following\ncommand line:\n\n    \n    \n    bytepatch -pa <address> link.exe 90 90 //using address column below  \n  \n---  \n  \n*OR*\n    \n    \n    bytepatch -a <offset> link.exe 90 90 //using offset column below  \n  \n---  \n  \nReplace <address> or <offset> values with those corresponding in the ADDRESS\nand OFFSET columns below for the linker you are using:\n\nVERSION| SHIPPED WITH| MD5| FILE SIZE| ADDRESS| OFFSET  \n---|---|---|---|---|---  \nLINK.EXE 6.00.8168| MSVC 6.0 RTM,SP1,SP2| 7b3d59dc25226ad2183b5fb3a0249540|\n462901| 0x44551A| 0x4551A  \nLINK.EXE 6.00.8447| MSVC 6.0 SP3,SP4,SP5,SP6|\n24323f3eb0d1afa112ee63b100288547| 462901| 0x445826| 0x45826  \nLINK.EXE 7.00.9466| MSVC .NET 7.0 (2002) RTM|\ndbb5bf0ce85516c96a5cbdcc3d42a97e| 643072| 0x45CD82| 0x5CD82  \nLINK.EXE 7.00.9955| MSVC .NET 7.0 (2002) SP1|\n2042a0f45768bc359a5c912d67ad0031| 643072| 0x45CD32| 0x5CD32  \nLINK.EXE 7.10.3052| MSVC .NET Free Toolkit| 8d7a69e96e4cc9c67a4a3bca1b678385|\n647168| 0x45EA0F| 0x5EA0F  \nLINK.EXE 7.10.3077| MSVC .NET 7.1 (2003)| 4677d4806cd3566c24615dd4334a2d4e|\n647168| 0x45EA0F| 0x5EA0F  \nLINK.EXE 7.10.6030| MSVC .NET 7.1 (2003) SP1|\n59572e90b9fe958e51ed59a589f1e275| 647168| 0x45F0C1| 0x5F0C1  \nLINK.EXE 10.00.30319.01| MSVC .NET 10 (2010) RTM|\nd358960cb06c16476e89bd808a5e67fa| 852296| 0x476DBD| 0x761BD  \nLINK.EXE 10.00.40219.01| MSVC .NET 10 (2010) SP1|\n60f3d6c30c1bbfb4da62df454a4be470| 851272| 0x476CAD| 0x760AD  \n  \nUnfortunately, the Signature Finder tool only works with Microsoft linkers\nprior to and including Visual Studio .NET 7.1 (2003). RE Analysis of the tool\nindicates that it searches up to 4 possible linker signatures (all known\nlinkers available at the time of the tool's release in 2004), so trying to\npatch a newer linker such as the one that shipped with MSVC .NET 8.0 (2005),\nresults in an error. However, manually finding the location using a\ndisassembler is not difficult. I received an e-mail from icestudent with a\nmethod he uses to manually patch each Microsoft linker release from 8.0 and\nup. Here is a break-down of this method:\n\n  * Ensure your symbol path is set correctly; then download symbols for the linker you want to patch; e.g.: symchk /v LINK.EXE\n  * open LINK.EXE with IDA Pro\n  * Open the imports window, locate \"_tzset\", and go to it\n  * Open the references for \"_tzset\" (CTRL-X) and go to the \"IMAGE::BuildImage\" reference (or the \"IMAGE::GenerateWinMDFile\" for CLR executables).\n  * Around the \"CALL _tzset\" instruction, locate the \"CALL IMAGE::CbBuildProdidBlock\" instruction. In older versions of the linker it was closer and above \"_tzset\", in modern versions it is below and quite far.\n  * If you don't have symbols, check for all CALL instructions around \"_tzset\" and find the one where the referenced function begins with a call to \"HeapAlloc\"; this will be the \"IMAGE::CbBuildProdidBlock()\" function.\n  * After the \"CALL IMAGE::CbBuildProdidBlock\", you will see some code like \"MOV reg, ...\", \"ADD reg, reg2\", \"MOV [mem], reg\". NOP-out the second ADD instruction (or sometimes LEA) which is responsible for adjusting the PE offset in memory past the Rich signature.\n\nIf you don't use the method above, the table below contains the patch offsets\nfor some post MSVC 7.x linkers. Thanks goes to icestudent for this\ninformation!\n\n32-BIT LINK.EXE| x86 VERSION| OFFSET| ORIGINAL BYTES| PATCH BYTES  \n---|---|---|---  \n8 SP1| 0x6A382| 03 D0| 90 90  \n9 RTM| 0x6A20F| 03 C8| 90 90  \n9 SP1| 0x6BE7F| 03 C8| 90 90  \n10 B1| 0x6CF50| 03 C8| 90 90  \n10 B2| 0x75EED| 03 D0| 90 90  \n10 CTP| 0x6C26D| 03 C8| 90 90  \n10 RTM| 0x761BD| 03 D0| 90 90  \n10 SP1| 0x760AD| 03 D0| 90 90  \n11 RTM U1| 0x235BF| 03 CE| 90 90  \n11 RTM| 0x17AEF| 03 CE| 90 90  \nvc18 CTP2| 0x31920| 03 CB| 90 90  \nvc18 PREVIEW| 0x1B3D8| 03 CF| 90 90  \nvc18 RC1| 0x27B43| 03 CF| 90 90  \nvc18 RTM| 0x31168| 03 CB| 90 90  \n64-BIT LINK.EXE| x64 VERSION| OFFSET| ORIGINAL BYTES| PATCH BYTES  \n---|---|---|---  \n8 RTM| 0x8157A| 93| 8B  \n8 SP1| 0x80DAC| 93| 8B  \n9 RTM| 0x78205| 93| 8B  \n9 SP1 KB| 0x78CE1| 8D 14 0E| 90 90 90  \n9 SP1| 0x78CE5| 93| 8B  \n10 B1| 0x7A01F| 93| 8B  \n10 B2| 0x7A09D| 93| 8B  \n10 SP1| 0x7A06D| 93| 8B  \n11 RTM U1| 0x136B5| 03 D0| 90 90  \n11 RTM| 0x136B5| 03 D0| 90 90  \nvc18 CTP2| 0xE22A| 03 D0| 90 90  \nvc18 PREVIEW| 0x853D| 03 D0| 90 90  \nvc18 RC1| 0xE684| 03 D0| 90 90  \nvc18 RTM| 0xEF3A| 03 D0| 90 90  \n  \nTo patch using the offsets in the table above, use the following bytepatch\ncommand line, replacing <file-offset> and <patch-bytes> with the appropriate\nentry:\n\n    \n    \n    bytepatch -a <file-offset> link.exe <patch-bytes>  \n  \n---  \n  \nCONSPIRACY THEORIES: When the public first became aware of the \"Rich\" header,\nthe obvious encryption of this structure of unknown information made a lot of\npeople nervous and suspicious. Because Microsoft never officially confirmed\nthe existence of this structure, their lack of transparency made a lot of\ndevelopers assume the worst. Here you can have an identical-source program\nbuilt on two different machines and end up with a slightly different\nexecutable because the information contained within the \"Rich\" header was\ndifferent. It is not surprising that people assumed Microsoft was embedding\nmachine or otherwise personally identifiable information within the structure.\nThese might include a NIC/MAC address, a CPU identifier, Windows registration\ninformation or even a unique GUID representing a particular installed instance\nof a Microsoft product or operating system.\n\nIn reality, the only thing stored here are the build numbers for the\nMicrosoft-specific tools responsible for a specific component in an executable\nmodule. The slightest difference in Visual Studio version, SDK version or 3rd\nparty libraries used will cause an alteration of the \"Rich\" header.\n\nThe PE/COFF specification defines a minimum file alignment of 512 bytes. Since\nthis value leaves more than enough room for an executable's header section to\nfully contain the DOS and PE headers, there will always be leftover wasted\nspace between the headers section and the subsequent section. Microsoft\ncapitalized on this fact by inserting the \"Rich\" header in the padding space,\nsince it wouldn't generally affect the final executable size one way or the\nother.\n\nTo Microsoft's credit, the \"Rich\" header offers invaluable debugging\nstatistics about how a given executable was built. Because the Visual C/C++\ncompiler and linker command lines are probably among the most complex command\nlines of any of Microsoft products to date, not to mention the different\nversions of those tools available and combinations of SDKs that can be used, a\nstructure such as the \"Rich\" header being embedded within every executable\ncould certainly save countless man hours in debugging complex build\nenvironment problems. Did I mention Microsoft's internal build environment is\namong the most complex in the world?\n\nIf Microsoft's case against the author of a virus hinged on the virus being\ncreated by a particular version of Visual Studio that matched the version on a\nconfiscated machine, I guess the \"Rich\" header could be used as evidence to\nprove this fact but probably not much more. There are other useful reasons\nMicrosoft might want to bury such a secret \"fingerprint\" within executables.\nIf Microsoft could prove which versions of certain libraries were employed,\nthis would help them to assert intellectual property rights or even a\nredistribution license violation as they could distinguish between public,\nbeta and pre-release versions. If companies used beta versions of Microsoft\ntools or libraries to release executables to the public outside of a specific\ntime period, Microsoft would now have a way to find out. The \"Rich\" header\ncould also help ensure publicly released benchmark tests were done fairly on\nproperly built, Microsoft-sanctioned executables. These reasons could have\nbeen a bigger deal at the time the \"Rich\" header was invented than they are\ntoday.\n\nThe problem was that Microsoft intentionally hid and encrypted this\ninformation. Since the structure doesn't officially exist, there isn't going\nto be an official way to disable it. Anyone who develops with Microsoft tools\ngets this structure crammed in their executable whether or they like it or\nnot. Failing to document this fact can be considered a questionable practice.\n\nHowever, once people realized Microsoft wasn't embedding personally\nidentifiable information in their executables, the \"Rich\" header was no longer\nthe hot topic it once was.\n\nORIGINS OF \"RICH\" AND \"DANS\" SEQUENCES: According to a 2012 post on Daniel\nPistelli's RCE Cafe blog, information from two people who claimed to have\nworked on the Microsoft Visual C++ team said the word \"Rich\" likely originated\nfrom \"Richard Shupak\", a Microsoft employee who worked in the research\ndepartment and had a hand in the Visual C++ linker/library code base. NOTE:\nRichard Shupak is listed as the author at the top of the file PSAPI.H in the\nPlatform SDK. The PSAPI library (The NT \"Process Status Helper\" APIs)\nretrieves information about processes, modules and drivers.\n\n\"DanS\" was likely attributed to employee \"Dan Spalding\" who presumably ran the\nlinker team. I can vouch for the fact that there was a \"Dan Spalding\" employee\nworking on the Visual C++ team around the turn of the century. Apparently\ntheir initials also show up in the MSF/PDB format!\n\nCONCLUSION AND REFERENCES: The first known public information about this\nstructure goes back to at least July 7th, 2004 from the article, Things They\nDidn't Tell You About MS LINK and the PE Header, a loose specification\nauthored by \"lifewire\". I've archived the article here, because it is no\nlonger available at one of the original links. While the article was brief, it\nwas densely packed with useful details, such as the layout of the \"Rich\"\nstructure and how the checksum key is calculated. It is not mentioned how the\nauthor came to know such information, but information like this is usually\nleaked or derived from reverse engineering. At the end of the article, he\nattributes the \"Dan^\" sequence as being a reference to Microsoft employee \"Dan\nRuder\", but the sequence was actually and has always been \"DanS\", so I think\nthis conclusion is incorrect.\n\nWhen I was writing the pelook tool and was looking to add minimal compiler\nsignature detection, I initially stumbled upon Daniel Pistelli's excellent\n2008 article, titled Microsoft's Rich Signature (undocumented). This article\ndescribes what he discovered while reverse engineering Microsoft's linker.\nPistelli's research was independent of lifewire's 2004 article which was\nunknown to him at the time. Despite this, he arrived at the same conclusion.\n\nPistelli's article was the first I'd heard of such a structure. I was\nsurprised to learn of its existence and that it had been right under my nose\nall of those years. I was even more surprised that further information\n(official or unofficial) was not available. My goal in writing this article\nwas to fill in some of the gaps of information not previously available, such\nas how far back Microsoft's linker had support for the \"Rich\" structure and\nhow it changed between different versions of Visual Studio.\n\nOther links I found useful:\n\n  * A tutorial from 2010 that was based off of the original \"lifewire\" article.\n  * A posting on asmcommunity\n  * A posting on trendystephen\n\n<END OF ARTICLE>\n\nQuestions or Comments?\n\nChangelist for this document\n\n    \n    \n    2018-08-27 * added VS.NET 7.0 BETA 1 and BETA 2 entries to MASM 6.x and Visual Studio tables * added several missing 14.x and 12.0 builds to Visual Studio table 2018-08-26 * added patch info for link.exe 10.00.30319.01 (MSVC 2010 RTM); courtesy Vernon Brooks * added patch info for link.exe 10.00.40219.01 (MSVC 2010 SP1) * added patch cmdline variation for offset column 2018-02-28 * typos fixed and minor rewording for clarification 2017-11-22 * added information about editbin 7.x (and up) undocumented /nostub switch to remove the \"Rich\" header 2017-11-12 * added links to peupdate tool (for \"Rich\" header removal) 2017-06-22 * added section \"Patching the Microsoft Linker\"; added 8.0 2005 Beta to MSVC BUILDS 2017-04-10 * added NOTE that Richard Shupak is listed as the author at the top of PSAPI.H (from the Platform SDK) 2017-03-28 * added table for VB6 build numbers and filled in their ids for the Visual Studio 6.0 table * changed VS6/VS7 id table references from \"linker\" to \"Visual Studio toolset\" as the linker is not responsible for all of the id values; added that it is common to see MASM references when MASM not used directly in a project.  \n  \nWas this site useful? Bitcoin donations appreciated :)\n131KmThzNqeBtEciLhMJrQqfbvm1xcVHyp  \n| | 1:1  \n---\n\n", "frontpage": false}
