{"aid": "39990302", "title": "Layered Toggles: Optional CSS Mixins", "url": "https://kizu.dev/layered-toggles/", "domain": "kizu.dev", "votes": 2, "user": "speckx", "posted_at": "2024-04-10 13:10:20", "comments": 0, "source_title": "Layered Toggles: Optional CSS Mixins", "source_text": "Layered Toggles: Optional CSS Mixins\n\n# Layered Toggles: Optional CSS Mixins\n\nIn this article, I am sharing the next evolution of space & cyclic toggles,\nwhich allows us to create and apply optional mixins in CSS with the help of\ncustom cascade layers, available today in every browser that supports them.\n\nI am no stranger to looking for various ways to apply some CSS conditionally,\nand through the years, went from using math as a way to achieve conditions for\nCSS variables back in 2016, to cyclic dependency space toggles that I came up\nwith last year.\n\nThis was one of the reasons why I found another missing piece for this puzzle\nof having conditions in CSS, as an experiment in reply to Heydon Pickering\u2019s\nquestion in Mastodon, which I could\u2019ve potentially missed if not for Nathan\nKnowler mentioning my cyclic toggles article.\n\nWhile the technique I discovered did not help Heydon with his case, I found\nthis discovery to be important enough to share as fast as I could. So here we\nare.\n\n## The Technique\n\nThis technique, which I named \u201clayered toggles\u201d, essentially allows us to\napply any number of CSS mixins on any element!\n\nLet me show you a minimal example^Go to a sidenote, and afterward, I will\nexplain what\u2019s going on.\n\nSide note: All the examples in the article are just quick demonstrations of\nthe technique, maybe with time I will add a few more practical ones. Jump to\nthis sidenote\u2019s context.\n\nDefault\n\nHover or focus me\n\nAs if hovered\n\n    \n    \n    @layer default { .item { padding: 1em; border-radius: 0.5em; background: var(--PINK); } } @layer mixins { * { --hover: var(--hover--off); --hover--off: var(--hover,); --hover--on: var(--hover,); background-color: var(--hover--off, revert-layer) var(--hover--on, var(--GREEN)); } } /* Applying mixin */ .can-be-hovered:is(:hover, :focus-visible), .pseudo-hovered { --hover: var(--hover--on); }\n\nThe first thing you might notice: we\u2019re using custom cascade layers. This is\nthe main requirement^Go to a sidenote for the technique to work, specifically\nthe revert-layer CSS-wide keyword.\n\nSide note: Thankfully, every major desktop browser supports cascade layers\nfrom March 2022, but I will recommend against using this technique in\nproduction as something foundational and not as a progressive enhancement.\nJump to this sidenote\u2019s context.\n\nI started playing with it after reading Nathan\u2019s \u201cSo, You Want to Encapsulate\nYour Styles?\u201d article, as well as Mayank\u2019s \u201cSome use cases for revert-layer\u201d\none, specifically \u201cthe self-reset\u201d section, but, until now, I did not think of\ncombining layers with the space or cyclic toggles.\n\nBut, this time, I tried to use^Go to a sidenote the revert-layer as one of the\ncyclic toggle\u2019s values \u2014 and it did work!\n\nSide note: Something needs to be said about how we can only use CSS-wide\nkeywords like revert-layer or inherit with CSS variables only as an immediate\nfallback value, but that\u2019s probably a topic out of scope for this article.\nJump to this sidenote\u2019s context.\n\nSo, here is what is going on:\n\n  1. We need to separate our styles into two layers: the lower one will contain the \u201cdefault\u201d styles, and the higher layer will contain our \u201cmixins\u201d. This allows mixins to override the default styles when they are applied.\n\n  2. In our mixins, we are using \u201cCyclic Dependency Space Toggles\u201d to define our styles, with the important part being revert-layer applied as the default value. Due to how it works, this allows us to \u201creturn control\u201d over the property to the lower layers unless our \u201ccondition\u201d (enabling some mixin) will happen.\n\n  3. Finally, our set-up is complete, and we can \u201cuse\u201d our mixin by switching the value of our cyclic toggle anywhere in CSS. As soon as it is enabled \u2014 based on some selector, media query, inline styles, or anything else \u2014 the mixin\u2019s styles will override the default styles.\n\nAnd here we are \u2014 with the ability to apply some styles conditionally based on\na single CSS variable on any element, but without messing up our default\nstyles.\n\nI wanted to have this as a feature for years, probably since I first saw Lea\nVerou define pseudo-mixins using the universal selector in one of her CSS\nVariables talks. But when the styles were inside just a rule with a universal\nselector, that led to any later rules that touched this property to override\nour mixin\u2019s styles. And if we do anything with this, our mixin could become\ntoo powerful and go over everything. Layered toggles don\u2019t have this problem.\n\n## Limitations\n\nOf course, this technique is not without its limitations:\n\n  1. All mixins live in a shared space. This means: that if multiple mixins need to toggle the same CSS property, we will need to define how this should be handled. In the next section, I will show two ways to do it.\n\n  2. As we\u2019re applying our styles through a universal selector^Go to a sidenote (*), we could use the mixin to only style the element itself, not its children. However, it will be possible to work around this with style queries, I\u2019ll describe how later in the article. This might also be a blessing in some cases, as we don\u2019t want to apply mixin to the nested elements, so the disabled inheritance here can be welcome.\n\n  3. We cannot toggle other cyclic toggles with this. Or, at least, I did not find a way to do so yet.\n\n  4. Obviously, it requires the CSS layers to be supported, and all main styles to be handled by CSS layers. This means that you might wait to apply this technique unless you are certain that you can use custom cascade layers with the browser support your website requires.\n\n  5. It is unknown how bad this technique could be for performance with many mixins. Browsers will attempt to apply the mixins for every element, going through multiple layers until encountering the one that has its variables enabled. Proper performance evaluation should be done.\n\nSide note: Note that it is not necessary to apply these as mixins, via a\nuniversal selector. The same method could be used to provide optional\ncomponent API to some specific selector. This could be better than regular\ncyclic toggles as we won\u2019t always override some of the properties, making it\neasier to mix different styles, and separate the defaults from the mixins.\nJump to this sidenote\u2019s context.\n\nBecause this technique is so new, there is a big chance I\u2019m missing some other\nlimitations or potential problems \u2014 if you encounter any, please let me know,\nand I will include them in this article.\n\n## Advanced Cases\n\n### Multiple Mixins\n\nWhat if we want to have two mixins, and both of them would like to apply some\nbackground? Which should win? How do we define this?\n\nThankfully, as we\u2019re already using custom cascade layers, we can continue\ndoing just that and rely on their cascading nature!\n\nNothing stops us from separating every mixin into its sub-layer, making it\npossible for every mixin to handle its list of properties, and revert any of\nits layered values to either some other previously defined mixin or to the\ndefault values on the element.\n\nRegular\n\nWith alpha (hover me)\n\nWith all mixins\n\nHere is the CSS for this example:\n\n    \n    \n    @layer mixins.alpha { * { --mix-alpha: var(--mix-alpha--off); --mix-alpha--off: var(--mix-alpha,); --mix-alpha--on: var(--mix-alpha,); --mix-alpha-color: currentColor; --mix-alpha-value: 75%; color: var(--mix-alpha--off, revert-layer) var(--mix-alpha--on, color-mix( in srgb, var(--mix-alpha-color) var(--mix-alpha-value), transparent ) ); } } @layer mixins.red { * { --mix-red: var(--mix-red--off); --mix-red--off: var(--mix-red,); --mix-red--on: var(--mix-red,); background: var(--mix-red--off, revert-layer) var(--mix-red--on, var(--RED)); color: var(--mix-red--off, revert-layer) var(--mix-red--on, #FFF); text-shadow: var(--mix-red--off, revert-layer) var(--mix-red--on, none); } } /* Applying mixins */ .with-alpha { --mix-alpha: var(--mix-alpha--on); &:is(:hover, :focus-visible) { --mix-alpha-value: 90%; } } .is-red { --mix-red: var(--mix-red--on); }\n\nA few notes:\n\n  1. For the third element, both with-alpha and is-red classes are applied. But because the mixins.red layer comes after the mixins.alpha, its properties \u201cwin\u201d.\n\n  2. The mixins are completely separate and both can override the color, but either can apply only based on its custom property!\n\n  3. Nothing stops us from using additional variables that we can pass to the mixin\u2019s code. I did not guard them against other mixins, but it is also possible to wrap them with the cyclic toggles conditions if necessary.\n\n### Merging Mixins\n\nYou could\u2019ve noticed that right now, either mixin does not know about the\nother, making it so the red one completely overrides the alpha. Can we somehow\nmake them work together?\n\nThere are many ways to handle this, but the one I find the best is to modify\nthe usage of the later mixin to fall back to the earlier if it detects its\nstate. This way, it is possible to conditional revert-layer to get the values\nfrom the earlier mixin in place:\n\nRegular\n\nWith alpha (hover me)\n\nWith all mixins\n\nHere is what is different:\n\n    \n    \n    @layer mixins.red { * { color: var(--mix-red--off, revert-layer) var(--mix-red--on, var(--mix-alpha--off, #FFF) var(--mix-alpha--on, revert-layer) ); --mix-alpha-color: var(--mix-red--off, revert-layer) var(--mix-red--on, #FFF); } }\n\n  1. When our red mixin is on, we also check the other mixin: if it is enabled, then we know that we can rely on it.\n\n  2. But how do we change the color to white? Easy: the other mixin provides a --mix-alpha-color variable that we can use!\n\nNote how here either mixin knows about what the other is doing: the alpha gets\nthe value of --mix-alpha-color that the red defines, and the red knows that\nthe alpha is active, and reverts to its handling of color!\n\nAlso, when testing all the examples in Safari, I found a bug in WebKit with\nthe revert-layer when used in a nested variable fallback, which leads to hover\nin the above example not working in it. I\u2019ll fill a big about this at a later\npoint and will update this paragraph to include a link to it.\n\n### Using With Style Queries\n\nYou could\u2019ve asked: why are we not using container style queries for this?\nThere are two main answers:\n\n  * Style queries are not supported everywhere: when I write this, they\u2019re only available in stable Chromium-based browsers, and in Safari Technology Preview.\n\n  * Even if they were available everywhere, it is not possible to style the element with a CSS variable itself with them \u2014 only the descendants.\n\nHowever, when we get style queries everywhere, could we use them in tandem\nwith this technique:\n\nDefault\n\nRed\n\nRed\n\nDefault\n\nDefault\n\nRed\n\nDefault\n\nRed\n\nHovering or focusing over any element highlights a direct child nested inside.\n\nHovering on any element, Here is the CSS for this example:\n\n    \n    \n    @layer mixins.child-hover { * { --mix-child-hover: var(--mix-child-hover--off); --mix-child-hover--off: var(--mix-child-hover,); --mix-child-hover--on: var(--mix-child-hover,); /* Applies only to the direct children of the element */ @container style(--mix-child-hover--off: ) { background: var(--GREEN); color: CanvasText; } } } /* Applying mixin */ .child-hover:is(:hover, :focus-visible):not(:has(.child-hover:is(:hover, :focus-visible))) { --mix-child-hover: var(--mix-child-hover--on); }\n\nWe can hook into the value of either --mix-child-hover--on or --mix-child-\nhover--off, and style this element\u2019s direct child based on its parent\u2019s cyclic\ntoggle value, as it will be either an empty value or initial.\n\nNote that in Safari Technology Preview there is a bug with the initial inside\nthe style queries, so in the example above we\u2019re checking for style (--mix-\nchild-hover--off:); in Chrome the style (--mix-child-hover--on: initial) will\nwork as well.\n\n## Use Cases\n\nThe examples above are very basic, mostly because I wanted to share them as\nsoon as possible. I could probably spend a few weeks coming up with many\nexamples, but I feel that there might be too many of them. Almost anything\nthat you could want a native CSS mixin could be implemented with layered\ntoggles, I believe.\n\nThat might be your homework: think of anything reusable in your CSS \u2014 could it\nbe separated into a mixin like that? I will be happy to look at what all of\nyou will do with this.\n\nThere are many articles on the internet which you could use as an inspiration,\nwith small snippets of code that can be converted into mixins like that. I can\nrecommend starting with SmolCSS by Stephanie Eckles, and CSS Tip by Temani\nAfif. There are many, many other resources, so don\u2019t stop at these!\n\n### Update from 2024-04-10\n\n  * I did create a CodePen that combines Stephanie\u2019s flex and grid layouts into one mixin.\n\nThe flex one requires style queries to work, but the grid one will work\neverywhere where @layer is supported! We can see how the code is hardly\nreadable, but it works! One interesting moment to note is that if we\u2019d want to\nuse some variables on the children that are defined on the parent, we\u2019d need\nto explicitly inherit these variables, as otherwise they will be reset on\nevery element due to the universal selector.\n\n  * And another example: a CodePen for visually-hidden mixin, based on the code from the \u201cThe Web Needs a Native .visually-hidden\u201d article by \u201cBen Myers\u201d, inspired by a \u201cNative visually hidden\u201d post by Matthias Z\u00f6chling.\n\nThis one should work everywhere where we have @layer.\n\n## Future of Mixins\n\nWhile I\u2019m happy this technique is possible, it can still look rather hacky,\nand cyclic toggles are not very fun to debug right now. Good news: there is a\nCustom CSS Functions & Mixins proposal by Miriam Suzanne which was accepted by\nCSSWG as something to pursue. However, it is yet unknown which exact form it\nwill take, and it can take years until we could use whatever will get into the\nspecifications and later into browsers. CSS Layers are already here, and style\nqueries will be sooner rather than later too, and the best thing we could do\nfor the future of mixins \u2014 is prototype them with what we can today. This\ncould allow us to gather common use cases, uncover potential issues, work out\nhow they could interact with other CSS features, and so on.\n\n## Final Words\n\nI wrote this article very soon after discovering the technique. I want to re-\niterate that you probably don\u2019t want to use it in production right away, both\ndue to still not perfect browser support, and the overall novelty: we don\u2019t\nknow which issues we can uncover with it.\n\nOn the other hand, this technique is so new, that we don\u2019t know what it\nunlocks next. In the same way, space toggles^Go to a sidenote did unlock\ncyclic toggles, and cyclic toggles now unlocked layered toggles, something\nelse could be on the horizon, and we just need to continue trying to go beyond\nwhat, we think, is possible.\n\nSide note: Discovered independently by many people over many years, including\nAna Tudor, Jane Ori, David Khourshid, and Lea Verou. Jump to this sidenote\u2019s\ncontext.\n\nLet me know what you think about this article on Mastodon!\n\nPublished on April 9, 2024 with tags: #CSS Layers #CSS Variables #CSS Logic\n#Style Queries #Experiment #Practical #CSS\n\n", "frontpage": false}
