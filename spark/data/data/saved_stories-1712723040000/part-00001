{"aid": "39984964", "title": "Building your own WordPress staging with Tempesta FW", "url": "https://tempesta-tech.com/blog/building-your-own-wordpress-staging-with-tempesta-fw/", "domain": "tempesta-tech.com", "votes": 1, "user": "krizhanovsky", "posted_at": "2024-04-09 22:23:03", "comments": 0, "source_title": "Building your own WordPress staging with Tempesta FW", "source_text": "Building your own WordPress staging with Tempesta FW - Tempesta Technologies\n\n# Building your own WordPress staging with Tempesta FW\n\nPosted on April 9, 2024\n\nWebsite staging is mostly about handling 2 or more copies of your website,\ntypically one production and one testing (staging) instances. While your\nproduction instance services your clients, you can safely do any enhancements,\namendments and testing on your staging instance.\n\nIn this article we\u2019re not going to describe what is staging and when it\u2019s\nrequired. For this information you can read a detailed article from WPEngine.\nInstead, in this article we\u2019ll discuss how to build your own WordPress\nstaging. Note that neither of us is a professional web developer and\nespecially a WordPress developer.\n\n## Why to build your own staging?\n\nWe use this website as dogfooding to test Tempesta FW, so we wanted to test\nTempesta against the most used web platform, which is apparently WordPress.\nThere are many WordPress hostings providing website staging, e.g. WPEngine is\none of them. So why to build our own staging instead of going with a ready to\nuse hosting? Well, there are at least two reasons:\n\n  * the Tempesta FW wiki is generated automatically from the github repository. There is a Python daemon, which fetches all the new changes in the wiki pages, produced by all our developers, converts them from Markdown to HTML and pushes directly into the WordPress database. This custom logic could be hard to implement on a WordPress hosting.\n  * Tempest FW emphasizes advanced web caching techniques, so it implements unique features like purging content with immediate and light-weight population of a new content to the web cache, so we need to customize our WordPress setup to make it aware about the Tempesta FW features.\n\n## DIY staging\n\nThis is what we have at the moment. Further in the article we\u2019ll discover the\nthings from the image more, but we should start from our environment. We store\nthe WordPress database as SQL dump, all the WordPress files and other website\nresources in a GitHub repository (so you see git on the scheme). Next, we\ndeploy a website in LXC containers.\n\nThis not only about staging, but also our dogfooding: any our developer can\neasily deploy our website on their working computers, e.g. to debug some\nTempesta FW issue, which was caught in production.\n\nBy the way, such a local website installation and be amended in any way (e.g.\nI write this blog post using this approach), pushed to git and deployed to a\nproduction website. This is a local staging.\n\nDeploying containers and manual pushing changes to git aren\u2019t for everyone, so\nwe need a very simple staging installation on our webiste, so a web developer\nworking with WordPress code, styles and so on don\u2019t need need to bother with\nall the things. They just need to login to the WordPress admin console and do\nall necessary things. So we need a remote staging, hosting on the same\nphysical server with the production website.\n\nBeing a web accelerator, Tempesta FW distributes client requests between the\nstaging and production instances. There are 2 basic ways to deploy a staging\ninstances and let\u2019s have a look how to setup both the scenarios with Tempesta\nFW.\n\n## 3rd-level domain\n\nTraditional way to deploy a staging instance for tempesta-tech.com is to use a\n3rd-level domain like staging.tempesta-tech.com. This approach is taken by the\nmost public WordPress hostings, so we started from this approach. From the\nTempesta FW configuration point of view we need to write configuration like:\n\n    \n    \n    srv_group default { server 192.168.100.4:8001; } srv_group staging { server 192.168.100.4:8002; } vhost tempesta-tech.com { proxy_pass default; } vhost staging.tempesta-tech.com { proxy_pass staging; } http_chain { host == staging.tempesta-tech.com -> staging.tempesta-tech.com; -> tempesta-tech.com; }\n\nI.e. all the requests having staging.tempesta-tech.com in the Host or\n:authority HTTP headers are routed to the staging instance. Here we use\nseparate containers accepting requests on 8001 and 8002 ports. So we deployed\nthis installation (hopefully, firstly on our workstations hopefully), but we\nforgot about a simple, but important thing, which turned us to another staging\nscenario...\n\nA web browser requests staging.mywebsite.com and Tempesta FW forward the\nrequest to WordPress container as is, i.e. having staging.tempesta-tech.com in\nthe Host or :authority HTTP header. Obviously, WordPress is confused with the\nrequest and the website staging doesn\u2019t work. OK, then let\u2019s rewrite the HTTP\nheader for staging, so for the same configuration we just have updated:\n\n    \n    \n    vhost staging.tempesta-tech.com { req_hdr_set host \"tempesta-tech.com\"; proxy_pass staging; }\n\nSo now Tempesta FW routes client requests to the staging container as\ntempesta-tech.com and WordPress answers to this request. We ran the instance\nand it looked fine at the first glance. However, later we realized that ALL\nthe website links (e.g. images, CSS, JavaScript code \u2013 everything!) are\nrequested by a browser from the production website! No any change (maybe\nexcept an HTML page firstly requested by a browser) on the staging actually\ncould be observed.\n\nThe whole website database or even probably static files must be updated from\ntempesta-tech.com to staging.tempesta-tech.com. But this not the only problem:\nwe need to update all the resources back, when we deploy the changes on\nstaging website to the production. How to update all links in all the\nresources for a website? The first thought was just to run some SQL statements\nrewriting all text sames from tempesta-tech.com to staging.tempesta-tech.com.\nHowever, the website has many articles (like this one) with URLs, which must\nnot be rewritten. Moreover, WordPress (or its plugins) store some data in\nserialized arrays in the database, which require more sophisticated processing\nusing real programming languages like Python. We\u2019ll back to this problem bit\nlater, at much smaller scale though. Now we moved to another approach for\nstaging.\n\n## Different IP addresses\n\nThe idea is very simple: both the staging and production containers work from\nthe name of tempesta-tech.com, but both of them have separate IP addresses and\nTempesta FW distributes client requests among the container based on the\ndestination IP address. This approach doesn\u2019t require URL rewrites. However,\nthe approach has a couple of drawbacks. The first one is that a staging user\nneeds to update their local DNS resolver configuration that it points\ntempesta-tech.com to the new IP address. Another drawback of the approach is\nthat we need the additional IP address (hopefully our hoster sells even 5 IPv4\naddresses for a very modest price). The good news even for massive hostings\ncould be that we don\u2019t need a separate IP for the each of hosted website \u2013 we\ncan just put all the staging instances on the same IP as we put all production\nwebsites on the original IP. In this case Tempesta FW is configured as:\n\n    \n    \n    srv_group default { server 192.168.100.4:8001; } srv_group staging { server 192.168.100.4:8002; } vhost mywebsite.com { proxy_pass default; } vhost staging.mywebsite.com { proxy_pass staging; } http_chain { mark == 1 -> staging.mywebsite.com; -> mywebsite.com; }\n\nThe difference from the previous example is just that now in http_chain we\nroute requests based on mark value received from the Linux Netfilter instead\nof HTTP headers. Now we only need to set the mark value based on the IP\naddress for a client connection and we did this with:\n\n    \n    \n    iptables -t mangle -A PREROUTING -p tcp -d x.x.x.x -j MARK --set-mark 1\n\nIs everything done and can we launch? Unfortunately, not.\n\n## Still need database rewriting\n\nWhile staging and production instances must be as similar as possible, then\nmust not be exactly the same. The most obvious is an administrator passoword:\nif you provide your staging instance access to a third-party web development\nteam, then probably you don\u2019t want to use the same passwords for the\nproduction and staging instances. Another example could be Google Analytics \u2013\nwe don\u2019t want to have all the requests, produced by a web development team, or\neven worse, our own stress tools, in the analytics statistics. Thus, we\ndecided to store in our GitHub repository the staging version and update the\ndatabase for production.\n\nThese database changes are localized and can be easily made by making\nappropriate changes in the WordPress admin console, dumping the database with\nmysqldump (we use MySQL) and use the diff utility to compare the dumped\ndatabase with the original one. Administrator password is stored in wp_users\ntable and can be trivially updated with one SQL statement (we just get the\ncalculated and encoded hash of the password from the database dump).\n\nOur website uses a plugin to send email, so we also needed to change the SMTP\npassword. This is more tricky since this plugin stores the all SMTP settings\nas a single PHP serialized array like\n'a:11:{s:4:\"mail\";a:6:{s:10:\"from_email\";s:20:\"info@tempesta-tech.com\";...'.\nNot so big deal though and only about 20 lines of Python code with\nphpserialize deserializes the string to a Python dictionary, updates the\npassword hash, serializes back and updates the database.\n\n## Switching between production instances\n\nOn the image above you saw to production containers. Once all amendments on a\nstaging instance are done, the WordPress database and static files are dumped\nto the git project directory and pushed to GitHub. Next a new production\ncontainer is deployed, which takes time, but during this time the previous\nproduction container services client requests. The new container occupies a\nnew port on local machine, so with the next step we need to make Tempesta FW\nto use the new container.\n\nActually, we store the production and staging container addresses in Tempesta\nFW config as a template like:\n\n    \n    \n    srv_group production { server $PRODUCTION_IP:$PRODUCTION_PORT; } srv_group staging { server $STAGING_IP:$STAGING_PORT; }\n\nThese template variables can be easily rewritten with Python. Server groups\ncan be dynamically updated for Tempesta FW, so no live HTTP client connections\nare terminated, but the new one will go to the new container. We can reload\nthe updated configuration with:\n\n    \n    \n    tempesta.sh --reload\n\n## Going live\n\nI didn\u2019t actually need staging to write this post (WordPress is a powerful CMS\nafter all). But instead of conclusion, I just make an exercise and deploy this\nblog post from my local staging to the production website using the new\napproach.\n\nShare the article\n\n  * Facebook\n  * Twitter\n  * LinkedIn\n\n### Recent Posts\n\n### Building your own WordPress staging with Tempesta FW\n\nApril 9, 2024\n\n### Tempesta FW 0.7: WordPress, HTTP/2 and the fastest TLS\n\nOctober 1, 2023\n\n### Understanding Nginx tail latencies\n\nFebruary 23, 2022\n\n### Lean video conferencing billing \u2013 keep it simple, make it fast!\n\nJuly 23, 2021\n\n### Performance of ORDER BY over text columns in MariaDB and MySQL\n\nJuly 5, 2021\n\n### Other Careers\n\n### Sales development representative\n\nWe\u2019re looking for a business person, who still loves technologies. ...\n\n### Python QA & release engineer\n\nWe develop our own open source product Tempesta FW along...\n\n### C/C++ Linux developer\n\nWe\u2019re looking for talented and experienced C/C++ Linux developers, who...\n\n### Leave a Reply (Cancel reply)\n\nPowered by Tempesta FW\n\nStay up to date with our latest developments\n\nUseful Links\n\nHome Blog\n\nTempesta\u00ae FW\n\nFeatures Performance Deployment Support Knowledge Base\n\nServices\n\nSoftware Development Performance analysis Network Security\n\nSolutions\n\nCDN\n\nCompany\n\nResearch Careers Contact\n\nBy clicking \"Accept\", you agree to the storing of cookies on your device to\nenhance your experience whilst using this website.\n\nAccept\n\n", "frontpage": false}
