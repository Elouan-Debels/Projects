{"aid": "39983623", "title": "Show HN: Subscription Wall for MDX Blog Using Clerk and ContentLayer", "url": "https://www.felixvemmer.com/en/blog/mdx-blog-subscription-wall-with-clerk", "domain": "felixvemmer.com", "votes": 1, "user": "cryptoneur", "posted_at": "2024-04-09 20:01:18", "comments": 0, "source_title": "Build a Subscription Wall with Clerk for Your MDX Blog", "source_text": "Build a Subscription Wall with Clerk for Your MDX Blog\n\nFelix Vemmer\n\nResources\n\nFeatured\n\n# How to Build a Blog Subscription Wall with Clerk and ContentLayer for Your\nMDX Blog\n\nIn this article, we will build a subscription wall for your MDX blog using\nClerk, an easy-to-use auth provider, and integrate it into our blog using MDX\nand ContentLayer.\n\nFelix Vemmer\n\nApril 9, 2024\n\nI began this blog on Ghost, a popular blogging platform. A standout feature of\nGhost that I appreciated is the option to share some content publicly and keep\nother content private for subscribers.\n\nAfter moving to my custom blog using Next.js and MDX through ContentLayer, I\naimed to include a subscription wall to begin growing my audience.\n\n## The Rise of Next.js: Why It's the Full-Stack Framework of Choice for Modern\nWebsites\n\nWhen selecting a frontend framework, reliability is paramount for my clients.\nDespite exploring options like SvelteKit, \"Why Next.js?\" remains a frequent\nquery. In this article, I unpack why Next.js stands out as a dependable choice\nand its promising future.\n\nNovember 1, 2023\n\nAfter announcing the launch in a tweet, here is the complete guide on creating\na subscription wall for your MDX blog using Clerk.\n\n## Setting Up Clerk\n\nTo secure access to my blog, I chose Clerk because it's a simple and intuitive\nauthentication provider that works very well with Next.js. Below, you'll find\na post where I compared Clerk to Supabase Auth and delved a bit more into\ndetail on why I prefer Clerk.\n\n## Supabase vs. Clerk.dev: Comparative Analysis of Auth Tools\n\nDive into the Supabase vs Clerk.dev debate. Uncover insights about their\nperformance, custom tokens, user impersonation, cost dynamics, and more. Which\ntool will reign supreme for you?\n\nJune 14, 2023\n\nThe easiest way to get started with Clerk is to use their Next.js integration.\n\nSince their tutorial is well done, I will not delve into detail on how to set\nup Clerk. I'll just provide a step-by-step guide on creating a subscription\nwall.\n\nBy the end of following the quickstart, you should have set up Clerk in your\nNext.js app with the following files:\n\n  * /sign-in/[[...sign-in]]/page.tsx\n  * /sign-up/[[...sign-up]]/page.tsx\n  * /middleware.ts\n\n## Paywall Card Component\n\nThe next step is to create a card component that will be shown to the user if\nthey are not logged in.\n\nGoogle should be able to index this.\n\n### Subscription Form Zod Schema\n\nAs you can see from the component above, the component is a simple form\nwrapped in a Card using the amazing shadcnUI library.\n\nBy using react-hook-form, we can create a type-safe subscription form with the\nfollowing fields:\n\n    \n    \n    import { z } from 'zod' const SSubscribe = z.object({ email: z.string().email({ message: 'Please enter a valid email address', }), pendingVerification: z.boolean().optional(), code: z.string().optional(), mode: z.literal('sign-up').or(z.literal('sign-in')).default('sign-up'), }) export type TSubscribe = z.infer<typeof SSubscribe>\n\n  * email: The user's email address\n  * pendingVerification: State used for Clerk sign-up/sign-in flow\n  * code: The verification code sent to the user's email address\n  * mode: The mode of the subscription form, either 'sign-up' or 'sign-in'\n\nWe can then instantiate the form and build out the form fields inside the\ncard.\n\n    \n    \n    const form = useForm<TSubscribe>({ resolver: zodResolver(SSubscribe), defaultValues: { email: '', pendingVerification: false, code: '', mode: 'sign-up', newsletter: true, }, })\n\n### Subscription Form UI\n\nFor the UI, depending on the mode and sign-up/sign-in state, we render either\na sign-up, sign-in, or verification code form.\n\nIf the user has signed up or signed in, we display a verification code form\nwhere the user can enter the verification code that was sent to their email\naddress.\n\n    \n    \n    if (form.watch('pendingVerification')) { return ( <> <Card className=\"my-12 flex flex-col items-center\"> <CardHeader> <CardTitle>Enter verification code</CardTitle> </CardHeader> <CardContent>Enter the verification code which was sent to your email.</CardContent> <CardFooter className=\"gap-0\"> <Form {...form}> <form onSubmit={form.handleSubmit(onVerify)} className=\"flex flex-col sm:flex-row gap-2\" > <FormField control={form.control} name=\"code\" render={({ field }) => ( <FormControl> <InputOTP {...field} maxLength={6}> <InputOTPGroup> <InputOTPSlot index={0} /> <InputOTPSlot index={1} /> <InputOTPSlot index={2} /> </InputOTPGroup> <InputOTPSeparator /> <InputOTPGroup> <InputOTPSlot index={3} /> <InputOTPSlot index={4} /> <InputOTPSlot index={5} /> </InputOTPGroup> </InputOTP> </FormControl> )} /> <Button type=\"submit\"> {form.formState.isSubmitting ? ( <Loader2Icon className=\"animate-spin mr-2 size-4\" /> ) : null} Verify </Button> </form> </Form> </CardFooter> </Card> </> ) }\n\nOtherwise we render a sign-up or sign-in form, depending on the mode state.\n\n    \n    \n    return ( <> <Card className=\"my-12 flex flex-col items-center\"> <CardHeader> <CardTitle> {form.watch('mode') === 'sign-up' ? 'Subscribe to continue reading.' : 'Sign in to continue reading.'} </CardTitle> </CardHeader> <CardContent> {form.watch('mode') === 'sign-up' ? 'Become a free member to get access to all subscriber-only content.' : 'Enter your email to sign in and continue reading.'} </CardContent> <CardFooter> <Form {...form}> <div className=\"flex flex-col items-center\"> <form onSubmit={form.handleSubmit(onSubmit)}> <div className=\"flex flex-col sm:flex-row gap-2\"> <FormField control={form.control} name=\"email\" render={({ field }) => ( <FormItem> <FormControl> <Input className=\"w-60\" placeholder=\"\" type=\"email\" {...field} /> </FormControl> <FormMessage /> </FormItem> )} /> <Button type=\"submit\"> {form.formState.isSubmitting ? ( <Loader2Icon className=\"animate-spin mr-2 size-4\" /> ) : null} {form.watch('mode') === 'sign-up' ? 'Subscribe' : 'Sign in'} </Button> </div> </form> <FormDescription className=\"pt-2\"> Already a reader?{' '} <Button className=\"p-0\" onClick={(e) => { e.preventDefault() const value = form.watch('mode') === 'sign-in' ? 'sign-up' : 'sign-in' form.setValue('mode', value) }} variant={'link'} > {form.watch('mode') === 'sign-in' ? 'Sign up' : 'Sign in'} </Button> </FormDescription> </div> </Form> </CardFooter> </Card> </> )\n\n### Subscription Form Handlers\n\nFinally, we need to handle the form submission when a user tries to sign\nup/sign in or enters the verification code. For each route, I created two\nseparate functions onSubmit and onVerify.\n\n#### Sign Up/In Handler\n\n  1. First, we check if the sign-up or sign-in API is loaded.\n\n  2. If it is, we check if the mode is sign up or sign in and handle the sign-up or sign-in flow accordingly.\n\n  3. After the sign-up or sign-in flow is complete, we set the pendingVerification state to true and show the verification code form.\n\n    \n    \n    async function onSubmit(values: TSubscribe) { if (!isLoadedSignUp) { return } if (values.mode === 'sign-up') { try { await signUp.create({ emailAddress: values.email, }) await signUp.prepareEmailAddressVerification({ strategy: 'email_code' }) form.setValue('pendingVerification', true) toast.success('Please enter the verification code which was sent to your email.') } catch (err: any) { const message = err?.errors[0]?.message || 'There was an error subscribing.' toast.error(message) console.error(JSON.stringify(err, null, 2)) } } else { if (!signIn) return try { const si = await signIn.create({ identifier: values.email }) const firstFactor = si.supportedFirstFactors.find( (ff) => ff.strategy === 'email_code' && ff.safeIdentifier === values.email, ) as EmailCodeFactor await si.prepareFirstFactor({ emailAddressId: firstFactor.emailAddressId, strategy: firstFactor.strategy, }) form.setValue('pendingVerification', true) } catch (err: any) { const message = err?.errors[0]?.message || 'There was an error signing in.' toast.error(message) console.error(JSON.stringify(err, null, 2)) } } }\n\n### Verify Handler\n\n  1. First, we check if the sign-up or sign-in API is loaded.\n  2. If it is, we check if the mode is sign-up or sign-in and handle the sign-up or sign-in flow accordingly.\n  3. If the completeSignUp.status === 'complete', we set an active session for the user.\n\n    \n    \n    const onVerify = async (values: TSubscribe) => { if (!isLoadedSignUp) { return } if (!values.code) { toast.error('Please enter the verification code sent to your email.') return } if (form.watch('mode') === 'sign-up') { try { const completeSignUp = await signUp.attemptEmailAddressVerification({ code: values.code, }) if (completeSignUp.status !== 'complete') { /* investigate the response, to see if there was an error or if the user needs to complete more steps.*/ console.log(JSON.stringify(completeSignUp, null, 2)) } if (completeSignUp.status === 'complete') { await setActive({ session: completeSignUp.createdSessionId }) return } } catch (err: any) { const message = err?.errors[0]?.message || 'There was an error verifying your email code.' toast.error(message) console.error(JSON.stringify(err, null, 2)) return } } else { if (!signIn) return if (!values.code) { form.setError('code', { message: 'Please enter the verification code sent to your email.', }) return } try { // Use the code provided by the user and attempt verification const completeSignIn = await signIn.attemptFirstFactor({ strategy: 'email_code', code: values.code, }) // This mainly for debuggin while developing. // Once your Instance is setup this should not be required. if (completeSignIn.status !== 'complete') { console.error(JSON.stringify(completeSignIn, null, 2)) return } // If verification was completed, create a session for the user if (completeSignIn.status === 'complete') { await setActive({ session: completeSignIn.createdSessionId }) return } } catch (err: any) { const message = err?.errors[0]?.message || 'There was an error verifying your email code.' toast.error(message) console.error(JSON.stringify(err, null, 2)) return } } }\n\n### Protected Content Component\n\nThe ProtectedContent component is a simple component that allows us to wrap\ncontent that should only be accessible to authenticated users.\n\n    \n    \n    import { useContentTeaser } from '@/hooks/use-content-teaser' import { FC } from 'react' import ContentTeaser from './content-teaser' export interface ProtectedContentProps { children: React.ReactNode } export const ProtectedContent: FC<ProtectedContentProps> = ({ children }) => { const [showContentTeaser, setShowContentTeaser] = useContentTeaser() if (showContentTeaser) return <ContentTeaser /> return <div>{children}</div> }\n\nDepending on the showContentTeaser state, we either render a ContentTeaser or\nthe protected content, such as the children.\n\n### useContentTeaser Hook\n\nSince we want to show a teaser of the content to the user before they are\nauthenticated, we need a way to modify the showContentTeaser state. For\nContentLayer, I did not manage to easily pass props to the ProtectedContent\ncomponent, so I created a custom hook using Jotai:\n\nuse-content-teaser.ts\n\n    \n    \n    import { atom, useAtom } from 'jotai' const showContentTeaser = atom(false) export function useContentTeaser() { return useAtom(showContentTeaser) }\n\n### ContentLayer Integration\n\nNow that we have the useContentTeaser hook and ProtectedContent component\nready, we can include them in our mdx-components.tsx:\n\n  1. Import the useContentTeaser hook and ProtectedContent component.\n  2. Add the ProtectedContent component to the components object.\n  3. Implement a side effect to check if the user is authenticated or a bot and if not, set the showContentTeaser state to true.\n\n    \n    \n    const components = { // Other components.... ProtectedContent: ({ ...props }: React.ComponentProps<typeof ProtectedContent>) => ( <ProtectedContent {...props} /> ), } export function Mdx({ code, isBot }: MdxProps) { const [config] = useConfig() const { isLoaded, isSignedIn } = useAuth() const Component = useMDXComponent(code, { style: config.style, }) const [_, setShowContentTeaser] = useContentTeaser() useEffect(() => { if (isBot) { setShowContentTeaser(false) return } if (isLoaded && isSignedIn) { setShowContentTeaser(false) return } setShowContentTeaser(true) }, [isLoaded, isSignedIn, isBot]) return ( <> <div className=\"mdx\"> {/* @ts-ignore */} <Component components={components} /> </div> </> ) }\n\n### Protecting Content\n\nNow that we have the ProtectedContent component ready, we can use it to\nprotect our content in any MDX file by simply wrapping the content in the\nProtectedContent component.\n\n    \n    \n    # Protected Content Dummy Example Public Content <ProtectedContent> Subscriber Only Content </ProtectedContent>\n\n## SEO Considerations\n\nAs you might have noticed from the code above, the ProtectedContent component\nis not rendered when the request is coming from a bot.\n\nThis is important for SEO, as search engines need to be able to see the\ncontent of your website so that they can properly index it.\n\nLet's understand how we can check if a request is coming from a bot.\n\n### User Agent Check\n\nWell, Next.js makes it super easy to check if a request is coming from a bot.\n\nSimply use the userAgent function in your page.tsx or any other server\ncomponent, and you will know if a request is coming from a bot.\n\n    \n    \n    const { isBot } = userAgent({ headers: headers(), })\n\nTo ensure that this works for Google, you can utilize the Rich Results Test at\nhttps://search.google.com/test/rich-results to determine if Google can\nsuccessfully access your 'ProtectedContent' component.\n\nTesting it on this blog post reveals that I could view the protected content:\n\n> Google ought to index this.\n\nwithin this ProtectedContent component.\n\n    \n    \n    The subsequent step involves crafting a card component that will display to users who are not logged in. <ProtectedContent> Google should be able to index this. </ProtectedContent>\n\n## Wrapping Up\n\nThis concludes the guide on how to create a subscription wall for your MDX\nblog using Clerk.\n\nI hope this guide has been helpful to you. I'm eager to hear your feedback or\nsee you as a new subscriber in my Clerk dashboard. For those interested in\nadding a guest book to their website, Brian has written an excellent post on\nintegrating a guestbook using Clerk, Neon, and Netlify Functions.\n\nIf you're curious about how my blog subscribers are growing, follow me on X so\nyou don't miss out.\n\nSee all posts\n\nBuilt by Felix Vemmer. The source code is available on GitHub.\n\n", "frontpage": false}
