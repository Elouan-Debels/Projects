{"aid": "39980673", "title": "Yeti Programming Language", "url": "https://mth.github.io/yeti/", "domain": "mth.github.io", "votes": 2, "user": "evacchi", "posted_at": "2024-04-09 15:44:58", "comments": 0, "source_title": "YETI programming language", "source_text": "YETI programming language\n\nYETI Releases ... and the slime became the worm and the worm the serpent, the\nserpent became the yeti of the mountain forests and the yeti became man.\n\nYeti is ML style functional programming language, that runs on the JVM.\n\n    \n    \n    message = \"Hello world\"; println message;\n\n  * Library documentation: std, io, json, xml\n  * Read the tutorial (also available as PDF)\n  * Language reference manual (PDF)\n  * Source is available through git (ant is needed for building): git clone git://github.com/mth/yeti.git (BSD licensed)\n  * Yeti code evaluator in web\n  * Chrisichris has some interesting posts about Yeti.\n  * YetiScript is a JavaScript targeting dialect of the Yeti language.\n  * boot-yeti, a Boot build task for Yeti development.\n\nYeti was created to have a clean and minimal expressive language on the JVM\nthat allows functional style programming, has static type inference and\ninterfaces well with Java code.\n\n### Some features\n\n  * Type inference using the Hindley-Milner algorithm. The types are statically inferred at compile time without a need for explicit type declarations.\n  * Polymorphic structure and variant types. Using those resembles duck typing from the dynamic languages - for example, when a value is used as a structure having a field foo, which gives string value, then any structure with string field foo will be good enough.\n  * Property fields in structures (access goes through function calls).\n  * Lazy lists\n  * Pattern matching on values\n  * Comfortable string regex support\n  * Easy to call existing Java code\n  * Interactive REPL environment for experimenting\n  * Compiles directly to Java bytecode\n  * Fast compilation and quite fast execution\n\n### Future\n\nUsing Yeti feels like scripting language due row types, and the error messages\nare usually easy to read (which wasn't trivial to achieve in the compiler).\nCompiling to JVM bytecode made implementation much easier (JVM has very good\nJIT), but unfortunately has tied it to the JVM. The JVM is a big and often\nunwanted dependency, doesn't start very fast, and is today mostly used in\nenvironments, where Java is mandated. This leaves little room to non-Java JVM\nlanguages outside Android. Therefore the current implementation is for me an\nexperiment that has successfully reached some goals, but a dead end otherwise.\nAs it is occasionally useful tool, a maintanance (mostly bugfixes) will\ncontinue, but active development is not planned. It is also open source and\nanyone is free to fork it.\n\nGiven this, OCaml and Nim are better options, if you are seeking a productive\nand easy to use modern language outwith JVM. Those planning to create a new\nprogramming language might find some ideas from Yeti (read reference manual\nfor type system details). It is also useful for having REPL and testing things\non Java platform.\n\n### Editor syntax highlighting\n\n  * Vim syntax hilighting and filetype plugin. Save these files as ~/.vim/syntax/yeti.vim and ~/.vim/ftplugin/yeti.vim accordingly, and add au BufNewFile,BufRead *.yeti setlocal filetype=yeti ts=8 sw=4 sts=4 expandtab into your ~/.vimrc.\n  * Netbeans and Notepad++ support.\n  * Emacs mode for Yeti.\n  * jEdit mode for Yeti.\n\n(put yeti into subject)\n\n", "frontpage": false}
