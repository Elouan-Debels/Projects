{"aid": "39980680", "title": "Rerun 0.15 \u2013 Layout from Code", "url": "https://www.rerun.io/blog/blueprint-part-one", "domain": "rerun.io", "votes": 8, "user": "Tycho87", "posted_at": "2024-04-09 15:45:44", "comments": 0, "source_title": "Introducing the Rerun Blueprint APIs", "source_text": "Introducing the Rerun Blueprint APIs \u2014 Rerun\n\n# Rerun\n\n# Introducing the Rerun Blueprint APIs\n\nDevelopers in fields like robotics, spatial computing, and finance use Rerun\nto understand their systems by visualizing the multimodal data they process\nand produce over time. The details of how that data is displayed are just as\nimportant as the data itself, but have mainly been controllable through the UI\nuntil now.\n\nIn Rerun, the specification of which parts of the data to show, where to show\nthem, and how, is called Blueprint. With the new Blueprint APIs in Rerun 0.15\nyou can define the layout and contents of views directly from code. You can\nalso save and load Blueprints to and from (.rbl) files. This unlocks new\nworkflows and makes it easier to share repeatable visualizations.\n\nFor example, this video shows live coding of how the output of a face tracking\nalgorithm is shown, as the algorithm is running.\n\nThe ability to seamlessly control the blueprint both from the UI and from code\nhas been in the works for close to a year, and was a motivating factor behind\nthe API overhaul we did back in 0.9. Over the last 6 releases, we have been\nreplacing the core of the visualizer with structured blueprint types to make\nthis release possible.\n\nIf you want to start playing around with controlling blueprints from code\nright away, check out the blueprint tutorial. If you want to read up a bit\nmore let\u2019s dive in.\n\n## Rerun Viewer = Data recording x Blueprint\n\nIn Rerun there are two separate pieces that combine to produce what you see:\nthe \"recording\" and the \"blueprint\". The recording is constructed by logging\nmultimodal data with rr.log(), and provides the actual data you are\nvisualizing. The blueprint is the configuration that determines how the data\nfrom the recording is displayed and defines things like the grouping and\nlayout of containers, and what data is included in which view.\n\nUntil now, the default blueprint for any recording has been created by a\nheuristics engine that looks at the data in the recording and tries to guess a\ngood blueprint. If you wanted anything other than that, you would have to\nconfigure the viewer to your liking in the UI manually. There was no way to\nshare blueprints, and making edits by hand was a lengthy and error-prone\nprocess.\n\n## The declarative Python blueprint APIs\n\nThe 0.15 release introduces blueprint APIs to the Python SDK. Let's dive into\nsome code to see how it works.\n\nDefining a blueprint is as simple as instantiating a collection of containers\nand space-views.\n\n    \n    \n    import rerun.blueprint as rrb my_blueprint = rrb.Blueprint( rrb.Horizontal( rrb.Spatial3DView(origin=\"reconstruction\"), rrb.Spatial2DView(origin=\"video\") ), collapse_panels=True, )\n\nAbove, rrb.Spatial3DView(origin=\"reconstruction\") defines a 3D view with its\nspatial origin at the entity path reconstruction. What's important but hidden\nhere is the default argument content=$origin/**, which means the view will\nquery for any visualizable data under its origin. These queries can become\nmuch more specific and fine grained so you can control exactly what data is\nshown where.\n\nrrb.Horizontal unsurprisingly defines a container that lays out its contents\nhorizontally, and rrb.Blueprint is the base blueprint, that e.g. allows you to\nindicate that you want all panels collapsed.\n\nYou can use this blueprint to spawn a new Rerun viewer with it as the default\nblueprint instead of one generated by the heuristics engine.\n\n    \n    \n    my_blueprint.spawn(\"my_application\")\n\nYou can also send the blueprint directly to a viewer you have connected to.\n\n    \n    \n    rr.send_blueprint(my_blueprint)\n\n## Programmatic layout of blueprints\n\nBecause blueprints can be constructed directly via the API, it\u2019s possible to\nconstruct blueprints dynamically to better suit the needs of your application.\n\nThis example creates a grid of views by iterating over dates and stock symbols\nin a dataset:\n\n    \n    \n    blueprint = rrb.Blueprint( rrb.Vertical( contents=[ rrb.Horizontal( contents=[ rrb.TextDocumentView( name=f\"{symbol}\", origin=f\"/stocks/{symbol}/info\", ), ] + [ rrb.TimeSeriesView( name=f\"{day}\", origin=f\"/stocks/{symbol}/{day}\", ) for day in dates ], name=symbol, ) for symbol in symbols ] ), ) rr.send_blueprint(blueprint)\n\nIf you want to learn more about how to use the new APIs, check out this guide.\n\n## Blueprints can be saved and shared\n\nWriting Python code isn\u2019t the only way to work with blueprints. If you have\ncreated a layout that\u2019s valuable to you or your team, you can now save it\nthrough the Rerun file menu as an .rbl file.\n\nNow when you open it again whilst running your recording it restores your\nlayout.\n\n## You can swap out either blueprint or recording\n\nThe blueprint and the recording are loosely coupled. This means that either\ncan be changed independently of the other as long as the share the same\napplication_id. Keeping the blueprint constant while changing the recording\nwill allow you to compare different datasets using a consistent set of views.\nOn the other hand, changing the blueprint while keeping a recording constant\nwill allow you to view the same data in different ways.\n\n## More coming soon\n\nThis is just the beginning of our expanded support for blueprints.\n\nAlthough we started with Python to prove out the concepts and get users access\nto these features quickly, we plan to implement comparable APIs in C++ and\nRust.\n\nAdditionally, there are still many aspects of space-view configuration such as\nvisible-time-range configuration, styling, and property overrides that are not\nyet exposed via the blueprint APIs. In future releases we will be working to\nensure that any change you can make through the viewer UI can also be defined\nthrough a corresponding API.\n\nWe\u2019re extremely excited for all the new use-cases this functionality will\nunlock and can\u2019t wait to see what you will build with it! Join us on Github or\nDiscord and let us know what you've built or are would hope to see from us\nnext!\n\n  * GitHub\n  * Discord\n  * LinkedIn\n  * Twitter\n\nPrivacy policy\n\n", "frontpage": false}
