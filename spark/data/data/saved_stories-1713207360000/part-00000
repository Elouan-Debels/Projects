{"aid": "40039927", "title": "Publish testable code not pseudo code", "url": "https://fizzbee.io/posts/pseudocode-modelchecking/", "domain": "fizzbee.io", "votes": 1, "user": "jayaprabhakar", "posted_at": "2024-04-15 12:52:56", "comments": 0, "source_title": "Publish algorithms with testable code", "source_text": "Publish algorithms with testable code | FizzBee\n\nFizzBee\n\n# Publish algorithms with testable code\n\nApr 12, 2024 6 minutes to read pseudocode python\n\nIn March 2023, Andrew Helwer wrote a thought-provoking article comparing\nPython with PlusCal & TLA+, while implementing a 45-year-old algorithm.\n\nReflecting on his insights, I find myself resonating with much of what he\nshared. Indeed, when it comes to publishing algorithms, opting for an\nexecutable language over arbitrary pseudocode stands out as a superior choice.\n\nA quick recap from his article:\n\n> Python made a very compelling case for itself here. The final algorithm,\n> naive algorithm, and property-based testing code combined took up only 35\n> very readable lines!\n\nOn PlusCal,\n\n> It [PlusCal] ran around 275 lines (100 of those generated) split across four\n> source files just to match Python\u2019s 35-line execution & test functionality.\n> Also, it took more effort to write: probably an entire day of work for the\n> basics plus another day for polish, vs. less than an hour for the Python\n> version.\n\nOf course, he did highlight,\n\n> To be fair, sequential string algorithms are not PlusCal\u2019s strength. It\n> really shines in concurrent & distributed algorithms, where the model\n> checker explores all possible interleavings of instructions.\n\nAndrew\u2019s post was one of the inspirations for FizzBee (He was also among the\nfirst who looked at FizzBee code when all I had were a few slides).\n\nvia Imgflip\n\n  * Python\u2019s ease of use\n  * PlusCal\u2019s model checking capabilities\n\nWhy not both?\n\nThat thought led to FizzBee - a formal specification language and model\nchecker that seamlessly merges Python\u2019s ease of use with PlusCal\u2019s powerful\nmodel checking capabilities.\n\nAs much as possible, I tried to keep the syntax similar to Python.\n\nLet me show the same algorithm in FizzBee.\n\nI am literally copying the Python code from Andrew\u2019s post and pasting it here.\nThe only change needed here is, the func definition, and mark the function as\natomic.\n\nFirst the buggy algorithm:\n\n    \n    \n    # Replace 'def lcs(b):' with 'atomic func lcs(b):' atomic func lcs(b): n = len(b) f = [-1] * (2 * n) k = 0 for j in range(1, 2 * n): if j - k >= n: return k i = f[j - k - 1] while b[j % n] != b[(k + i + 1) % n] and i != -1: if b[j % n] < b[(k + i + 1) % n]: k = j - i - 1 i = f[i] if b[j % n] != b[(k + i + 1) % n] and i == -1: if b[j % n] < b[(k + i + 1) % n]: k = j f[j - k] = -1 else: f[j - k] = i + 1 return k\n\nAssertion:\n\n    \n    \n    always assertion LcsMatchNaiveLcs: expected = naive_lcs(input) actual = lcs(input) return actual == expected atomic func naive_lcs(s): n = len(s) if n == 0: return 0 rotations = [s[i:] + s[:i] for i in range(n)] least_rotation = min(rotations) return rotations.index(least_rotation)\n\nDriver code: We just need to initialize the input to all possible strings.\n\n    \n    \n    action Init: CHARSET = [0, 1] input = \"\" atomic action Next: any c in CHARSET: input += str(c)\n\nIn the fizz.yaml file, you can specify the max depth we want to go.\n\n    \n    \n    deadlock_detection:true options: max_actions: 5\n\nNote: At this moment, the online playground does not have this setting. You\ncan run this on your local machine by installing from\nhttps://github.com/fizzbee-io/fizzbee/.\n\nTo run in the online playground, just set the MAX_LENGTH and an\n\n    \n    \n    action Init: CHARSET = [0, 1] MAX_LENGTH = 5 input = \"\" atomic action Next: # To limit the max depth if len(input) > MAX_LENGTH: return any c in CHARSET: input += str(c) action NoOp: # To avoid deadlock errors pass\n\nComplete code:\n\nRun in playground\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48\n\n|\n\n    \n    \n    always assertion LcsMatchNaiveLcs: expected = naive_lcs(input) actual = lcs(input) return actual == expected action Init: CHARSET = [0, 1] MAX_LENGTH = 3 input = \"\" atomic action Next: if len(input) > MAX_LENGTH: return any c in CHARSET: input += str(c) action NoOp: pass atomic func lcs(b): n = len(b) f = [-1] * (2 * n) k = 0 for j in range(1, 2 * n): if j - k >= n: return k i = f[j - k - 1] while b[j % n] != b[(k + i + 1) % n] and i != -1: if b[j % n] < b[(k + i + 1) % n]: k = j - i - 1 i = f[i] if b[j % n] != b[(k + i + 1) % n] and i == -1: if b[j % n] < b[(k + i + 1) % n]: k = j f[j - k] = -1 else: f[j - k] = i + 1 return k atomic func naive_lcs(s): n = len(s) if n == 0: return 0 rotations = [s[i:] + s[:i] for i in range(n)] least_rotation = min(rotations) return rotations.index(least_rotation)  \n  \n---|---  \n  \nRun the model checker, you can see the algorithm fails for the input 010\n\nThe fix proposed in the errata, change the condition.\n\n    \n    \n    f = [-1] * (2 * n) k = 0 for j in range(1, 2 * n): - if j - k >= n: + if j - k > n: return k i = f[j - k - 1] while b[j % n] != b[(k + i + 1) % n] and i != -1:\n\nThe model checker will now pass for the input 010 but fail for 0010.\n\nFinal solution: Remove the early return altogether.\n\n    \n    \n    f = [-1] * (2 * n) k = 0 for j in range(1, 2 * n): - if j - k > n: - return k i = f[j - k - 1] while b[j % n] != b[(k + i + 1) % n] and i != -1: if b[j % n] < b[(k + i + 1) % n]:\n\nThe model checker should pass now.\n\nAs an exercise, play changing the CHARSET to [0, 1, 2] and MAX_LENGTH to 6.\nSee how quick the state space grows.\n\nUnlike traditional testing where you generally test for a few inputs, with\nformal methods, we could test for all possible inputs.\n\nfrom Imgflip Meme Generator\n\n## Parting thoughts\n\nAs Andrew mentioned, pseudocode is not a good way to publish algorithms; any\nexecutable language is better. If you compare the Python/FizzBee code with the\npublished pseudo code, you\u2019ll notice they are almost the same lines of code.\nWith FizzBee\u2019s model checker, you can also verify the correctness of the\nalgorithm. (At present, there is no proof language like PlusCal/TLA+ in\nFizzBee.) And all this with almost negligible extra work.\n\nAs Andrew noted, simple Python worked well in this case because this algorithm\nis single-threaded. However, if you\u2019re working on a concurrent or distributed\nalgorithm, raw Python is insufficient, but FizzBee or PlusCal would be the\nonly option to verify correctness. Among these, FizzBee is orders of magnitude\nsimpler than PlusCal/TLA+.\n\n## References\n\n  * Andrew Helwer\u2019s Pseudocode Showdown Python vs. PlusCal & TLA+\n  * PlusCal and Python code\n  * A. Jesse Jiryu Davis\u2019s Pseudocode Is Not Durable\n  * FizzBee\n\n", "frontpage": false}
