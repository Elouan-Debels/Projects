{"aid": "39990993", "title": "Deploy SOPS Secrets with Nix", "url": "https://www.maxdaten.io/2023-12-11-deploy-sops-secrets-with-nix", "domain": "maxdaten.io", "votes": 1, "user": "maxdaten", "posted_at": "2024-04-10 14:17:38", "comments": 0, "source_title": "Deploy SOPS Secrets with Nix - Jan-Philip Loos | maxdaten.io", "source_text": "Deploy SOPS Secrets with Nix - Jan-Philip Loos | maxdaten.io\n\n# Deploy SOPS Secrets with Nix\n\nPublished on 11 December 2023\n\n6 min read\n\nnix\n\nsops\n\nsecrets\n\ngoogle cloud\n\ndevops\n\n> How to manage secrets like private ssh keys or database access in a cloud\n> environment via nix and sops.\n\nOne of my most productive endeavors with Nix recently has been setting up\nreproducible workspaces for team members and CI via flakes and direnv.\nBroadening my DevOps skills, I\u2019ve delved into NixOS this year, leveraging it\nto deploy and configure machines.\n\nMy use-case: Deploy and manage our own Hydra cluster in Google Cloud (GC) for\nour internal CI/CD.\n\nA critical aspect in this scenario is secret management, such as SSH keys or\ndatabase credentials. Nix, while excellent for configuration, isn\u2019t ideal for\nplaintext secrets, leading to security risks.\n\nThis blog post is inspired by the post by Xe Iasos: \u201cEncrypted Secrets with\nNixOS\u201d (2021) which provides great insights into possible solutions using\nsecrets in a nix environment. One method is unmentioned in Xe\u2019s article: using\nsops with sops-nix. I want to spread the word and describe my approach.\n\n## #Secrets OPerationS (sops) and sops-nix\n\nSecret management is a challenge of its own. One strategy is storing encrypted\nsecrets in your version control system, like git. git-crypt is one tool\noffering encryption of secrets in git. It\u2019s based on GPG, which can be\nchallenging, and not everyone might actively using GPG/PGP.\n\nsops offers greater flexibility by supporting GPG/PGP + SSH via age, along\nwith various cloud key management backends including AWS, GCE, Azure and\nHashicorp Vault. It evolves around structured text data like JSON, YAML. While\nnot reliant on git it, also supports cleartext diffs.\n\nMy goal has been to incorporate sops support into a NixOS instance using sops-\nnix. The management of the encryption key is centralized with Google Cloud Key\nManagement System (GC KMS), offering granular access control, key rotation &\nauditing.\n\n## #Encode & Deploy secrets with sops-nix & GC KMS\n\n\u261d Prerequisite: A GCE instance with NixOS and SSH access\n\nOur goal: Use sops in combination with GC KMS to provision secrets to a NixOS\ninstance. This secret should be accessible by a service running on the\ninstance.\u00e5\n\nWe will follow these steps:\n\n  1. Setting up a KMS key ring + crypto key, allowing decryption by the instance\u2019s service account.\n  2. Configuring sops with GC KMS.\n  3. Creating and encrypting a secret.\n  4. Referencing the secret in NixOS configuration\n  5. Deploying NixOS configuration via NixOps\n\n## #Step-By-Step Guide\n\n### #Step 1: Google Cloud KMS Setup\n\nUsing terraform to create a key ring and a crypto key\n\nhcl\n\n    \n    \n    resource \"google_kms_key_ring\" \"infrastructure\" { name = \"infrastructure\" location = \"europe\" } resource \"google_kms_crypto_key\" \"example_crypto_key\" { name = \"example-crypto-key\" key_ring = google_kms_key_ring.infrastructure.id lifecycle { prevent_destroy = true } } data \"google_service_account\" \"my_instance_sa\" { account_id = \"my-instance\" } resource \"google_kms_crypto_key_iam_member\" \"my_instance_example_crypto_key\" { crypto_key_id = google_kms_crypto_key.example_crypto_key.id role = \"roles/cloudkms.cryptoKeyDecrypter\" member = data.google_service_account.my_instance_sa.member } output \"example_crypto_key_id\" { value = google_kms_crypto_key.example_crypto_key.id }\n\nThis assumes that the instance is configured with a service account named my-\ninstance, for example in an instance templates:\n\nhcl\n\n    \n    \n    resource \"google_compute_instance_template\" \"my_instance\" { ... service_account { email = google_service_account.my_instance_sa.email scopes = [\"cloud-platform\"] } }\n\n### #Step 2: sops configuration\n\nDefine creation rules in .sops.yaml\n\nyaml\n\n    \n    \n    creation_rules: - path_regex: ^(.*.yaml)$ encrypted_regex: ^(private_key)$ gcp_kms: \"projects/<projectid>/locations/europe/keyRings/infrastructure/cryptoKeys/example-crypto-key\"\n\npath_regex: to match files to be managed encoded/decoded by sops.\n\nencrypted_regex: to match keys in yaml to be encoded, others will left\nuntouched.\n\ngcp_kms: Google Cloud resource path for crypto key to use for encryption and\ndecryption.\n\n### #Step 3: Creating secret\n\nEncrypt a secret using sops\n\n\u261d Assumption: You are allowed to access the GCE crypto key via [Application\nDefault\nCredentials](https://developers.google.com/identity/protocols/application-\ndefault-credentials)\n\nbash\n\n    \n    \n    $ sops example-keypair.enc.yaml # will open $EDITOR\n\nyaml\n\n    \n    \n    ssh_keys: private_key: | -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZWQyNTUx OQAAACAmZvH7A4/vJzYZn+M6iHuMw0SKV6lvsHyisxLsOhYvowAAAIiUPTj8lD04/AAAAAtzc2gt ZWQyNTUxOQAAACAmZvH7A4/vJzYZn+M6iHuMw0SKV6lvsHyisxLsOhYvowAAAEDxeLqwYkmIHjtg NJhPn+7bt5UBQgC6LQRZ0PrPJHHw5SZm8fsDj+8nNhmf4zqIe4zDRIpXqW+wfKKzEuw6Fi+jAAAA AAECAwQF -----END OPENSSH PRIVATE KEY----- public_key: | ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICZm8fsDj+8nNhmf4zqIe4zDRIpXqW+wfKKzEuw6Fi+j\n\nwith encrypted_regex provided in .sops.yaml this will ensure only the secret\nvalue of key private_key in the yaml file will be encrypted. This file is now\nsafe to commit.\n\n### #Step 4: Consume secret in NixOS configuration.nix\n\nyaml\n\n    \n    \n    { config, ... }: { # Setting up test user for service users.users.secret-test.isSystemUser = true; users.users.secret-test.group = \"secret-test\"; users.groups.secret-test = { }; # Declare secret sops.secrets.\"ssh_keys/private_key\" = { # 1 restartUnits = [ \"secret-test.service\" ]; # 2 # Reference test user owner = config.users.users.secret-test.name; sopsFile = ./example-keypair.enc.yaml; # 3 }; systemd.services.secret-test = { wantedBy = [ \"multi-user.target\" ]; after = [ \"sops-nix.service\" ]; # 4 serviceConfig.Type = \"oneshot\"; # Reference test user serviceConfig.User = config.users.users.secret-test.name; script = '' # Reference secret by path convention stat /run/secrets/ssh_keys/private_key ''; }; }\n\n  1. sops-nix will place nested yaml keys in nested directories in /run/secrets/ . This way you are able to organize your secrets by service. But you are also free to define multiple secret files.\n  2. Reference services to restart if secret changes\n  3. Our encoded secret as a nix path. This is used as default but can also be overridden o\n  4. Ensure service starts after sops-nix service. The sops-nix service is responsible in decoding secrets and organizing them in /run/secrets/\n\n### #Step 5: Deploy NixOS configuration\n\nFinally we deploy our new NixOS configuration to the machine in question, if\nlocally via nixos-rebuild otherwise you can use any nix deployment framework\nlike deploy-rs or NixOps. In this case I will use NixOps:\n\nbash\n\n    \n    \n    $ nixops deploy --deployment <machine-name>\n\nThis will build and activates the new NixOS configuration on the instance.\nDuring the activation/boot phase secrets will be decrypted by the systemd nix-\nsops.service to the /run/secrets folder.\n\nbash\n\n    \n    \n    $ journalctl -u secret-test.service systemd[1]: Starting secret-test.service... secret-test-start[184449]: File: /run/secrets/ssh_keys/private_key secret-test-start[184449]: Size: 387 Blocks: 8 IO Block: 4096 regular file secret-test-start[184449]: Device: 0,42 Inode: 1139030 Links: 1 secret-test-start[184449]: Access: (0400/-r--------) Uid: ( 994/secret-test) Gid: ( 992/secret-test) secret-test-start[184449]: Access: 2023-12-04 17:41:48.657466504 +0000 secret-test-start[184449]: Modify: 2023-12-04 17:41:48.657466504 +0000 secret-test-start[184449]: Change: 2023-12-04 17:41:48.657466504 +0000 secret-test-start[184449]: Birth: - systemd[1]: secret-test.service: Deactivated successfully. systemd[1]: Finished secret-test.service.\n\n## #Discussion\n\nUsing sops-nix with NixOS allows us to directly encode and store our secrets\nwhere the rest of our configuration is stored. While it is debatable if\nsecrets are configuration or state, storing secrets this way brings us several\nbenefits:\n\n  * Simplified refactoring of configuration and secrets side by side.\n  * Easier integration into pipelines.\n  * Fine control of access, reducing attack surface.\n  * Auditing either by cloud service or independently by sops.\n  * Support for Multi-Factor Authorization (MFA) if supported by cloud service.\n  * Template support for interpolating secrets into configuration files via nix.\n  * Partial file encryption.\n  * Flux 2.0 support.\n\n## #Additional References\n\n  * How to effectively manage secrets\n  * Comparison of secret managing schemes - NixOS Wiki\n\nPowered by SvelteKit. Icons by Iconoir.\n\nBased on a template built by Matheus Fantinel.\n\n", "frontpage": false}
