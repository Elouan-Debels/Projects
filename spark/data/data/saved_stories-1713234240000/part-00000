{"aid": "40045121", "title": "Five Little Languages and How They Grew: Dennis Ritchie on the History of C", "url": "https://www.bell-labs.com/usr/dmr/www/hopl.html", "domain": "bell-labs.com", "votes": 1, "user": "fanf2", "posted_at": "2024-04-15 20:22:41", "comments": 0, "source_title": "HOPL C Transcript", "source_text": "HOPL C Transcript\n\n# Five Little Languages and How They Grew: Talk at HOPL*\n\n    \n\nDennis M. Ritchie Bell Labs/Lucent Technologies Murray Hill, NJ 07974 USA\n\ndmr@bell-labs.com\n\n    \n\n#### ABSTRACT\n\nA paper on the development of C was presented at the second ACM History of\nProgramming Languages conference in Cambridge, Mass. in 1993. It was printed\nin History of Programming Languages, ed. T. Bergin and R. Gibson, ACM Press\nand Addison-Wesley, New York 1996, ISBN 0-201-89502-1. The paper itself has\nbeen available for some time; here I record the transcript of the talk I gave\nat the time. Unlike the paper, it doesn't talk about C's history, but instead\nconcentrates on its relationships with other contemporary languages that are\nat heart similar to C but have some characteristic differences.\n\nAlthough I have the introductory remarks by the session chair, Brent Hailpern,\nand also the transcript of the Q&A session that followed, I've omitted these\nparts. I'll leave the parts others said for the book (which I recommend).\n\nThe transcript below is quite close to what I intended to say according to my\nnotes, though there were some on-the-fly additions (especially in the opening\n--not surprisingly, there were more than a few barbs thrown).\n\nIn cooperation with the volume's editors, particularly Tim Bergin (to whom\ngreat thanks are due), my own language glitches have been cleaned up well, but\nit still retains some informality, as well as showing some of the time\npressure on the presentation.\n\nDMR, March 2002\n\n    NOTE: *Copyright 1996 Association for Computing Machinery, Inc. This electronic reprint made available by the author as a courtesy. For further publication rights contact ACM or the author. This talk was presented at Second History of Programming Languages conference, Cambridge, Mass., April, 1993.\n    \n\nThank you. Before I begin the talk, I will put forth a little idea I thought\nof in the last day or so. It's a programming problem having to do with Graph\nTheory: you have a graph. The nodes contain a record with a language and a\nperson, and, just to make the example concrete: the nodes might be (C,\nRitchie), (ADA, Ichbiah), (Pascal, Wirth), or Brinch-Hansen perhaps. (Lisp,\nSteele), (C++, Stroustrup) might also be part of the population. There is an\nedge from X to Y, whenever X.Person will throw a barb in public at Y.Language.\nAnd the questions are: is this a complete graph? Does it have self-edges? If\nit's not complete, what cliques exist? There are all sorts of questions you\ncan ask. I guess if it were a finite state machine, you could ask about\ndiagnosability, too. Can you push at the people and get them to throw these\nbarbs?\n\n[Slide 1] The paper itself tells the history of C, so I don't want to do it\nagain. Instead, I want to do a small comparative language study, although it's\nnot really that either. I'm going to talk about a bunch of twenty-year old\nlanguages. Other people can discuss what the languages contain. These were\nthings that were around at the time, and I'm going to draw some comparisons\nbetween them just to show the way we were thinking and perhaps explain some\nthings about C. Indirectly, I want to explain why C is as it is. So the actual\ntitle of the talk, as opposed to the paper, is `Five Little Languages and How\nThey Grew.'\n\n[Slide 2] Here are the five languages: Bliss, Pascal, Algol 68, BCPL, C. All\nthese were developed in more or less the same period. I'm going to argue that\nthey're very much similar in a lot of ways. And each succeeded in various\nways, either by use or by influence. C succeeded really without politics in a\nsense that we didn't do any marketing, so there must have been a need for it.\nWhat about the rest of these? Why are these languages the same?\n\n[Slide 3] In the first place, the things that they're manipulating, their\natomic types, their ground-level objects, are essentially identical. They are\nsimply machine words interpreted in various ways. The operations that they\nallow on these are actually very similar. This is contrast to SNOBOL, for\nexample, which has strings, or Lisp, which has lists. The languages I'm\ntalking about are just cleverly-designed ways of shuffling bits around;\neverybody knows about the operations once they've learned a bit about machine\narchitecture. That's what I mean by concretely grounded. They're procedural,\nwhich is, to say, imperative. They don't have very fancy control structures,\nand they perform assignments; they're based on this old, old model of machines\nthat pick up things, do operations, and put them someplace else. They are very\nmuch influenced by Algol 60 and FORTRAN and the other languages of that were\ndiscussed in the first HOPL conference.\n\nMostly they were designed (speaking broadly) for `systems programming.'\nCertainly some of them, like BCPL and C and Bliss, are explicitly system\nprogramming languages, and Pascal has been used for that. Algol 68 didn't\nreally have that in mind, but it really can be used for the purpose; when\nSteve Bourne came to Bell Labs with the Algol 68C compiler, he made it do the\nsame things that C could do; it had Unix system call interfaces and so forth.\nThe point is, that `system' can be understood in a fairly broad sense, not\njust operating systems.\n\nLet me very briefly characterize each language. [Slide 4] Bliss is the one\nthat hasn't been mentioned before at this conference. It was done by Bill Wulf\nand his students at Carnegie-Mellon. I believe it started as a PDP-10 system\nprogramming language, and it was then later used to do system programming on\nthe PDP-11 for a variety of projects. It went somewhat beyond that--it was\npicked up in particular by Digital Equipment Corp., I suppose partly through\nthe close connections between DEC and CMU at that time. And in fact it's been\nused, maybe still is used, for parts of VMS. Bliss is word oriented, by which\nI mean, there is only one data type, which is the machine word. So that's 36\nbits in the case of the PDP-10 version; 16 bits in the case of the '11. You\naccessed individual bytes, or characters, was by having a special operator\nnotation where you mentioned the start bit and the length. So it is a special\ncase that accessed characters of a slightly more general case that accessed\nindividual rows of bits.\n\nBliss was innovative in a variety of ways. It was goto-less; it was an\nexpression language. A lot of things that are built in to other languages were\nnot built into Bliss; instead there were syntax macros used for giving meaning\nto arrays, particularly multi-dimensional arrays, and structures. An array or\nstructure was represented by the programmer as a sort of inline function to\naccess the members, instead of being built in as a data type.\n\nBut the thing that people really remember about Bliss [Slide 5] is all those\ndots. Bliss is unusual in that the value of a name appearing in an expression\nis the address at which the associated value is stored. And to retrieve the\nvalue itself, you put a dot operator in front of the name. For example, in an\nordinary assignment of a sum will be written as `C gets .A+.B'. Here you're\ntaking the value stored in A and the value stored in B, and adding them. (If\nyou left off the dots, you would be adding the addresses.) On the other hand,\nthe assignment operator wants an address on the left and a value on the right;\nthat's why there's no dot in front of the C.\n\nWhat were the problems of Bliss? Really, that it never transcended its\noriginal environments. The programs tended to be non-portable. There was a\nnotation for the bit extraction to get characters, but there were also\nnotations that created PDP-10 specific byte pointers, because they couldn't\nresist using this feature of the PDP-10. And this (and other things) made\nprograms tend to be non-portable because they were either PDP-11 dialect, or\nthe PDP-10 dialect. And perhaps equally important, the compilers were\nnonportable; in particular, the compiler never ran on the PDP-11 [Slide 6].\n\nWhatever the motivation for Bliss as a language, much of the interest in it\nactually came because of a sequence of optimizers for its compilers created by\na succession of students. In other words, its legacy is a multi-phase\noptimizing compiler that ran on the PDP-10. It was a project that could be\ndivided up phases, in which each student gets a phase and writes a thesis on\nthis particular kind of optimization. Altogether very CMU-like way of\noperating--a series of programs that collectively could be called C.PhD. A\ngood way of working, I think. [It was used as well in C.mmp and Mach, as\nwell.]\n\nLet me move on to Pascal [Slide 7]. I argue that Pascal is very similar to C;\nsome people may be surprised by this, some not. C and Pascal are approximately\ncontemporaneous. It's quite possible that there could have been mutual\ninformation flow in the design, but in fact, there wasn't. So it's interesting\nthat they're so much the same. The languages differ much in detail but at\nheart are really the same; if you look at the actual types in the languages,\nand the operators on the types, there really is a very large degree of\noverlap. Some things are said differently--in particular Pascal's sets are in\nsome ways a more interesting abstraction than unsigned integers, but they're\nstill bit fields.\n\nThis is in spite of the fact Wirth's intent in creating Pascal was very\ndifferent from ours in C. He was was creating a language for teaching, so that\nhe had a didactic purpose. And in particular, I take it both from Pascal and\nfrom his later languages that he's interested in trying to constrain\nexpression as much as possible, although no more. In general, he explores\nwhere the line should go between constraints that are there for safety, and\nexpressiveness. He's really a very parsimonious fellow, I think, and so am I.\n\nEven some of the characteristic problems of Pascal and C are very similar. In\nparticular, in treatment of arrays with varying bounds: this is worth\ndiscussing a bit.\n\nC has always provided for open-ended, that is, variable-sized, arrays (one-\ndimensional arrays, or vectors). In particular, C has been able to subsume\nstrings under the same set of general rules as integer arrays. Pascal,\ncertainly in the original form, did not allow even that. In other words, even\none-dimensional arrays had a fixed size known at compile time. There have\nbeen, in at least some of the dialects, a notion of `conformant' arrays so\nthat procedures can take arrays of different sizes. But still the issue isn't\nfully resolved; the status of this is not really clear.\n\nC's solution to this has real problems, and people who are complaining about\nsafety definitely have a point. Nevertheless, C's approach has in fact lasted,\nand actually does work. In Pascal's case, certainly in the original language,\nand perhaps even in some of the following ones, the language needs extensions\nin order to be really useful. You can't take the pure language and use it, for\nexample, as a system programming language. It needs other things.\n\nHere's an aphorism I didn't create for this conference, but several years ago.\nIt seems particularly apt, given the people present [Stu Feldman and Niklaus\nWirth]: `` `Make' is like Pascal. Everybody likes it, so they want to change\nit.'' In both cases, a very good idea wasn't quite right at the start.\n\nHere's another anecdote, based on something that happened yesterday afternoon.\nDuring the coffee break. Wirth said to me, `Sometimes you can be too\nstrict...' Interestingly, he was not talking about language design and\nimplementation, but instead about the type- and bounds-checking that was\noccurring within the conference. [That is, to the insistence on written-down\nquestions to speakers and strongly enforced time limits on speakers and\nquestioners].\n\nPascal is very elegant. It's certainly still alive. It is prolific of\nsuccessors and it has influenced language design profoundly [Slide 8].\n\n[Slide 9] Algol 68. This is definitely the odd member of the list. I wrote\n`designed by committee' on the original slide. I started to cross this out\nbased on what Charles Lindsay said earlier, but I didn't cross it out\ncompletely because, the point I want to make here is not so much that it was\ndesigned by a committee but that it was `official.' In other words, there was\na international standards organization that was actually supporting the work\nand expecting something out of the design of Algol 68. Whatever the result, it\nwas definitely not a small project. Of course, it was formally defined from\nthe very beginning. The language was designed well before there were any\ncompilers; this meant that, like most interesting languages done that way, it\nheld surprises; even Algol 60 held surprises. Algol 60's call-by-name\nmechanism looked beautiful in the report, and then people came to implement it\nand realized that it had unexpected consequences. There were a few other\nthings like this, even in Algol 60. Similarly, in Algol 68, there were things\nthat were put in because they looked natural and orthogonal, and then when\npeople came to implement the language they found that, although it was\npossible, it was difficult. It's a hard language, and big in some ways. It\ndoes have more concepts than the others, even if they're orthogonal. Things\nlike flexible arrays, slices, parallelism, the extensibility features\n(especially operator identification), and so forth. Despite the efforts of\nCharles Lindsay, I think the language really did suffer from its definition in\nterms of acceptance. Nevertheless, it was really quite practical.\n\n[Slide 10] In some ways, Algol 68 is the most elegant of the languages I've\nbeen discussing. I think in some ways, it's even the most influential,\nalthough as a language in itself, it has nearly gone away. But the number of\npeople at this conference who have said \"This was influenced by Algol 68,\" is\nsurprisingly quite large. As the accompanying paper points out, C was\ninfluenced by it in important ways. The reference on the slide to Algol 68C is\nto indicate that we had an A68C compiler on the early Unix system in the '70s,\nwhen Steve Bourne came from Cambridge and brought it with him. It didn't\nhandle the complete language, but it was certainly enough to get the flavor.\n(It was kind enough to give me warnings whenever I said the wrong thing. The\nmost common was, \"Warning! Voiding a Boolean,\" which always struck me as\namusing. Of course it meant that I had written `A=B' instead of `A:=B').\n\n[Slide 11] BCPL was the direct predecessor to C. It is very much like Bliss\nbecause it's a typeless language, and it was intended for system programming.\nUnlike Bliss, it was designed to be portable. The compiler itself was written\nto be portable, and transportable; it produced a well-described intermediate\ncode. And, in spite of the fact that the only type was the `word', it ran on\nmachines with different word sizes. It was a small language, and its style was\npragmatic. Its original purpose was to be the implementation language for CPL,\na more ambitious undertaking by Strachey and his students that never quite\nmaterialized. BCPL was used in a variety of places. It was one of the early\nlanguages used at Xerox PARC on the Alto, for example.\n\n[Slide 12] Let me compare. (This is the only technical part of the talk.) What\nis the meaning of a name, when it appears in an expression? There are three\nvery different interpretations that happen in these languages.\n\nFirst, a further example of the way Bliss works. In the first statement,\nyou've simply assigned a value 1 to A. In the second statement when you say `B\ngets A', what you have assigned is the address at which A is located. So, if\nyou print the value B at this point, you'll see a number representing some\nmemory address. However, if you do this assignment with the dot, as in the\nthird statement, then you have assigned the value 1 that came from the\nassignment on the first line. That means that `dereferencing' (a word that\ncame from Algol 68) is always explicit in Bliss, and it's necessary because in\nBliss a simple name is a reference, not a value.\n\nIn Algol 68, there is a more interesting situation. The meaning of a name, at\nheart, is often the same as in Bliss; in other words, it often denotes a\nlocation. In [Slide 13, first line of program] the declaration of A says that\nA is a reference to an integer stored in a local cell that can hold an\ninteger. The notation `int A' is a shorthand for the more explicit declaration\nshown in the comment.\n\nLater, you write, in line 4, `A gets 1'. The rules of the language see a\nreference to an int on the left, an int on the right, and do the appropriate\nmagic (called `coercion') that puts 1 into the cell referred to by A. In line\n5, because B is declared as a reference to a reference to an integer, B is\nassigned the address of A, while in line 6, C gets the value (the number 1)\nstored in A. On the last line, the same 1 is stored again, this time\nindirectly through the reference in B.\n\nSo the two A's, on lines 5 and 6, are coerced in different ways, depending on\nthe context in which they appear. `Dereferencing', or turning an address into\nthe value stored in it, happens automatically, according to explicit rules,\nwhen appropriate; even though the underlying semantics resemble those Bliss,\none doesn't have have to write the dots.\n\nThe next slide [Slide 14] shows the way things work in BCPL and its\ndescendants and also Pascal. Here we have the same kind of types, in that A\nholds an integer, B holds a reference to (or pointer to) an integer. However,\nin these languages, the value of the name (like A) that holds the integer, is\nthe integer's value, and there is an explicit operator that generates the\naddress. Similarly, if one has a variable (like B) that holds a reference to\n(pointer to) an integer, one uses an explicit operator to get to the integer.\nIn line 4 of the program, where A gets 1, there's no coercion; instead the\nrules observe that there is an integer on the left, whose expression is a\nspecial form called an `lvalue,' which can appear in this position. In line 5,\nthe explicit `&' operator produces the address (reference value) of A and\nlikewise assigns it to B; in line 7, the explicit `*' operator fetches the\nvalue from the reference (pointer) stored in B.\n\nThese languages (Bliss, Algol 68, and BCPL/B/C), show three different\napproaches to the question `What is the meaning of a name when it appears in a\nprogram?' Bliss says: `It means the location of a value; to find the value\nitself, you must be explicit.' Algol 68 says: `It means the location of a\nvalue; the language, however, supplies coercion rules such that you will\nalways get the value itself, or its location, as appropriate. Otherwise you\nhave made a error that will be diagnosed.' BCPL, B, C, and Pascal say, `A name\nmeans a value. You must be explicit if you wish to get the location in which\nthat value is stored, and also if the value happens to represent a reference\nto another value.'\n\nNaturally I prefer the approach that C has taken, but I appreciate how Algol\n68 has clarified thinking about these issues of naming and reference.\n\n[Slide 15] Let's talk about the influences of these languages. While you\nponder the slide, I'll digress to talk about characterizations of the\nlanguages along the lines of Fred Brooks's [keynote] talk, which mentioned\nempiricism versus rationalism, being pragmatic and utilitarian versus\ntheoretical and doctrinal. How do we classify these languages? Some were\ncreated more to help their creators solve their own problems, some more to\nmake a point. Algol 68 is unabashedly rationalist, even doctrinaire. Pascal is\nan interesting question--in some ways, the most interesting because it's\nclearly got the rationalistic spirit, but also some of the empiricism as well.\nBCPL and C are, in general, not pushing any `-ology,' and belong clearly in\nthe pragmatic camp. Bliss, a goto-less, expression language, with an unusual\napproach to the meaning of names, partakes heavily of the rationalist spirit,\nbut, like Pascal, was created by the same people who intended to use it.\n\nI'll make another side point, a comparison that doesn't have a slide either.\nOf these languages, only Pascal does anything interesting about numerical\nprecision control. Algol 68 really thought about static semantics of names,\nand in most cases, dynamic semantics of things. But one thing it just didn't\ntalk about at all in a meaningful sense, is: what numbers go out or go in? It\nhas `int's and `long ints's and `long long int's and so forth, but the\nlanguage doesn't tell you how big these things are; there's no control over\nthem. In B and BCPL, there is nothing but the `word'. What's a word? It\ndepends on the machine. C is similar to Algol 68, in the sense that it has\ntype modifiers like `long'. The C standard does say, `Here is the minimal size\nyou can expect for `int', for `long', for `short'. But this is still fairly\nweak. Pascal has ranges, so that you can be explicit about the range of values\nyou expect to store. Of course, you hit against limits, and you can't have\nnumbers that are too big.\n\nOther languages allow you to use very big numbers. Various predecessors of\nthese languages, like PL/1, were very explicit about numerical precision, and\nsuccessors like ADA make it possible say similar things in a different way.\nThe question: `How can you be portable if you don't know how big an integer\nis?,' is continually raised. The interesting fact, and it's one that's\nsurprising to me, is how little this actually matters. In other words, though\nyou have to do some thinking about program design, it's fairly seldom that\nthis issue turns out to be the important source of bugs, at least in my\nexperience.\n\nLet me go back to talk about influences of these languages on the world. Bliss\nhas pretty much disappeared. Its optimization ideas have remained useful, and\nsome of the companies that worked with it have survived. Digital Equipment\nCorp. still has a lot of Bliss code that they're wondering what to do with.\n\nPascal is definitely alive, and it has many direct descendants and other\nlanguages strongly influenced by it. Algol 68 and BCPL as languages are\nmoribund, but their influence continues: Algol 68 influences in a broad way,\nand BCPL rather directly through through its influence on C. C remains lively,\nobviously.\n\nC's own descendants, by which I mainly mean C++, may very well be even\nlivelier in the next few years. Aside from languages that are directly\ndescended from C, (particularly C++ but also some others), C's intellectual\ninfluence on the semantic design of new languages has been small. On the other\nhand, it has influenced notation: even pseudo-code these days tends to contain\ncurly braces.\n\n[Slide 16] Let me finish by trying to show how C succeeded in becoming so\nwidely used, much more than any of the others I talked about. I can't give a\nreal answer, because I don't know it, but I'll try.\n\nElegance and formality of definition may be necessary, according to some, but\nit's certainly not sufficient. It's important that people really be able to\nunderstand the the language. One of the problems with Algol 68, despite the\nefforts of Charles Lindsay and others, was that its definition was hard to\nread. More fundamentally, though, a language has to be able to connect with\nand facilitate what people need to do, and potential users have to be able to\nget an implementation of it.\n\nSo, you need to be able to get a compiler: the language has to be\nimplementable in the compiler technology of the day, on the systems they have\navailable to them.\n\nWhen you design a language with new ideas before implementing it, you are\ntaking a chance that you're pushing compiler technology. This may be a social\ngood, but it may not do your language any good. It has to have an\nimplementation, so that people can try it, and it needs distribution. As I've\nmentioned, the definition of both Algol 68, and Algol 60 before it, held\nsurprises for implementers.\n\nAlso, languages need to provide appropriate interaction with a real\nenvironment. Computer languages exist to perform useful things that affect the\nworld in some way, not just to express algorithms, and so their success\ndepends in part on their utility. Environments vary. The one that we created\nin the Unix System had a particular flavor, and we took full advantage of the\nability of the C language to express the software tools appropriate for the\nenvironment. As an old example, suppose you want to search many files for\nstrings described by regular expressions, in the manner of the Unix `grep'\nprogram.\n\nWhat languages could you write grep in? As an example, there are really neat\nways of expressing the regular expression search algorithm in the APL\nlanguage. However, traditional APL systems are usually set up as a closed\nenvironment, and give you no help in creating a tool for text searching in a\nmore general setting.\n\n[Lack of time prevented discussion of Slide 17].\n\n[Slide 18] Here's how to succeed: by being lucky. Grab on to something that's\nmoving pretty fast. Let yourself be carried on when you're in the right place\nat the right time.\n\nMarch 19, 2002\n\n", "frontpage": false}
