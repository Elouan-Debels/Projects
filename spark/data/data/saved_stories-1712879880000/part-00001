{"aid": "40004930", "title": "Modern Best Practices for Testing in Java (2022)", "url": "https://phauer.com/2019/modern-best-practices-testing-java/", "domain": "phauer.com", "votes": 2, "user": "Tomte", "posted_at": "2024-04-11 17:56:30", "comments": 0, "source_title": "Modern Best Practices for Testing in Java", "source_text": "Modern Best Practices for Testing in Java\n\nI save information about your visit on my blog and use cookies. This data is\nused for statistics and advertising. This way, I see what my visitors are\nexpecting and how I can improve my blog. Privacy Policy\n\nOK\n\nPhilipp Hauer's Blog\n\nEngineering Management, Java Ecosystem, Kotlin, Sociology of Software\nDevelopment\n\nYour new development career awaits. Check out the latest listings. ads via\nCarbon\n\n# Modern Best Practices for Testing in Java\n\nPosted on Sep 9, 2019. Updated on Dec 18, 2022\n\nMaintainable and readable test code is crucial to establish a good test\ncoverage which in turn enables implementing new features and performing\nrefactorings without the fear of breaking something. This post contains many\nbest practices that I collected over the years of writing unit tests and\nintegration tests in Java. It involves modern technologies like JUnit5,\nAssertJ, Testcontainers, and Kotlin. Some recommendations might be obvious to\nyou, but some might conflict with what you\u2019ve read in books about software\ndevelopment and testing.\n\n# TL;DR\n\n  * Write small and specific tests by heavily using helper functions, parameterized tests, AssertJ\u2019s powerful assertions, not overusing variables, asserting only what\u2019s relevant and avoiding one test for all corner cases.\n  * Write self-contained tests by revealing all relevant parameters, insert data right in the test and prefer composition over inheritance.\n  * Write dumb tests by avoiding the reuse of production code and focusing on comparing output values with hard-coded values.\n  * KISS > DRY\n  * Test close to production by focusing on testing a complete vertical slide and avoiding in-memory databases.\n  * JUnit5 and AssertJ are a very good choice.\n  * Invest in a testable implementation by avoiding static access, using constructor injection, using Clocks and separating business logic from asynchronous execution.\n\n# General\n\n## Given, When, Then\n\nA test should contain three blocks which are separated by one empty line. Each\nblock of code should be as short as possible. Use subfunctions to shorten\nthese blocks.\n\n  * Given (Input): Test preparation like creating data or configure mocks\n  * When (Action): Call the method or action that you like to test\n  * Then (Output): Execute assertions to verify the correct output or behavior of the action.\n\n    \n    \n    // Do @Test public void findProduct() { insertIntoDatabase(new Product(100, \"Smartphone\")); Product product = dao.findProduct(100); assertThat(product.getName()).isEqualTo(\"Smartphone\"); }\n\n## Use the Prefixes \u201cactual*\u201d and \u201cexpected*\u201d\n\n    \n    \n    // Don't ProductDTO product1 = requestProduct(1); ProductDTO product2 = new ProductDTO(\"1\", List.of(State.ACTIVE, State.REJECTED)) assertThat(product1).isEqualTo(product2);\n\nIf you are going to use variables in an equals assertion, prefix the variables\nwith \u201cactual\u201d and \u201cexpected\u201d. This increases the readability and clearifies\nthe intention of the variable. Moreover, it\u2019s harder to mix them up in the\nequals assertion.\n\n    \n    \n    // Do ProductDTO actualProduct = requestProduct(1); ProductDTO expectedProduct = new ProductDTO(\"1\", List.of(State.ACTIVE, State.REJECTED)) assertThat(actualProduct).isEqualTo(expectedProduct); // nice and clear.\n\n## Use Fixed Data Instead of Randomized Data\n\nAvoid randomized data as it can lead to toggling tests which can be hard to\ndebug and omit error messages that make tracing the error back to the code\nharder.\n\n    \n    \n    // Don't Instant ts1 = Instant.now(); // 1557582788 Instant ts2 = ts1.plusSeconds(1); // 1557582789 int randomAmount = new Random().nextInt(500); // 232 UUID uuid = UUID.randomUUID(); // d5d1f61b-0a8b-42be-b05a-bd458bb563ad\n\nInstead, use fixed values for everything. They will create highly reproducible\ntests, which are easy to debug and create error messages that can be easily\ntraced back to the relevant line of code.\n\n    \n    \n    // Do Instant ts1 = Instant.ofEpochSecond(1550000001); Instant ts2 = Instant.ofEpochSecond(1550000002); int amount = 50; UUID uuid = UUID.fromString(\"00000000-000-0000-0000-000000000001\");\n\nYou can avoid the increased typing effort by using helper functions.\n\n# Write Small and Specific Tests\n\n## Heavily Use Helper Functions\n\nExtract details or repetitive code into subfunctions and give them a\ndescriptive name. This is a powerful mean to keep the tests short and the\nessentials of the test easy to grasp at first glance.\n\n    \n    \n    // Don't @Test public void categoryQueryParameter() throws Exception { List<ProductEntity> products = List.of( new ProductEntity().setId(\"1\").setName(\"Envelope\").setCategory(\"Office\").setDescription(\"An Envelope\").setStockAmount(1), new ProductEntity().setId(\"2\").setName(\"Pen\").setCategory(\"Office\").setDescription(\"A Pen\").setStockAmount(1), new ProductEntity().setId(\"3\").setName(\"Notebook\").setCategory(\"Hardware\").setDescription(\"A Notebook\").setStockAmount(2) ); for (ProductEntity product : products) { template.execute(createSqlInsertStatement(product)); } String responseJson = client.perform(get(\"/products?category=Office\")) .andExpect(status().is(200)) .andReturn().getResponse().getContentAsString(); assertThat(toDTOs(responseJson)) .extracting(ProductDTO::getId) .containsOnly(\"1\", \"2\"); }\n    \n    \n    // Do @Test public void categoryQueryParameter2() throws Exception { insertIntoDatabase( createProductWithCategory(\"1\", \"Office\"), createProductWithCategory(\"2\", \"Office\"), createProductWithCategory(\"3\", \"Hardware\") ); String responseJson = requestProductsByCategory(\"Office\"); assertThat(toDTOs(responseJson)) .extracting(ProductDTO::getId) .containsOnly(\"1\", \"2\"); }\n\n  * Use helper functions for creating data (objects) (createProductWithCategory()) and complex assertions. Only pass those parameters to the helper functions that are relevant for your tests. Use reasonable defaults for the other values. In Kotlin, this is easy by using default arguments. In Java, you have to use method chaining and overloading to simulate default arguments.\n  * varargs can make your test code even more concise (\u00ecnsertIntoDatabase()).\n  * Helper functions can also be used to create simple values more easily. This is even nicer in Kotlin where you can use extension functions for this.\n\n    \n    \n    // Do (Java) Instant ts = toInstant(1); // Instant.ofEpochSecond(1550000001) UUID id = toUUID(1); // UUID.fromString(\"00000000-0000-0000-a000-000000000001\")\n    \n    \n    // Do (Kotlin) val ts = 1.toInstant() val id = 1.toUUID()\n\nThe helper functions could be implemented in Kotlin like this:\n\n    \n    \n    fun Int.toInstant(): Instant = Instant.ofEpochSecond(this.toLong()) fun Int.toUUID(): UUID = UUID.fromString(\"00000000-0000-0000-a000-${this.toString().padStart(11, '0')}\")\n\n## Don\u2019t Overuse Variables\n\nA usual reflex of a developer is to extract values that are used multiple\ntimes to variables.\n\n    \n    \n    // Don't @Test public void variables() throws Exception { String relevantCategory = \"Office\"; String id1 = \"4243\"; String id2 = \"1123\"; String id3 = \"9213\"; String irrelevantCategory = \"Hardware\"; insertIntoDatabase( createProductWithCategory(id1, relevantCategory), createProductWithCategory(id2, relevantCategory), createProductWithCategory(id3, irrelevantCategory) ); String responseJson = requestProductsByCategory(relevantCategory); assertThat(toDTOs(responseJson)) .extracting(ProductDTO::getId) .containsOnly(id1, id2); }\n\nUnfortunately, this significantly bloats the test code. Moreover, given a test\nfailure message, it\u2019s harder to trace the value back to the relevant line of\ncode.\n\n> KISS > DRY\n    \n    \n    // Do @Test public void variables() throws Exception { insertIntoDatabase( createProductWithCategory(\"4243\", \"Office\"), createProductWithCategory(\"1123\", \"Office\"), createProductWithCategory(\"9213\", \"Hardware\") ); String responseJson = requestProductsByCategory(\"Office\"); assertThat(toDTOs(responseJson)) .extracting(ProductDTO::getId) .containsOnly(\"4243\", \"1123\"); }\n\nIf you keep the tests short (which is highly recommended anyway), it\u2019s no\nproblem to see where the same values are used. Plus, the method is even\nshorter and therefore easier to understand. And finally, failure messages are\neasier to trace back to the code.\n\n## Don\u2019t Extend Existing Tests To \u201cJust Test One More Tiny Thing\u201d\n\n    \n    \n    // Don't public class ProductControllerTest { @Test public void happyPath() { // a lot of code comes here... } }\n\nIt\u2019s tempting to add a corner case test to an existing (happy path) test. But\nthis test becomes bigger and harder to understand. It becomes hard to grasp\nall relevant test cases that are covered by this big test. You can spot those\ntests by generic names like \u201chappy path test\u201d. If this test fails, it\u2019s hard\nto see what exactly is broken.\n\n    \n    \n    // Do public class ProductControllerTest { @Test public void multipleProductsAreReturned() {} @Test public void allProductValuesAreReturned() {} @Test public void filterByCategory() {} @Test public void filterByDateCreated() {} }\n\nInstead, create a new test method with a descriptive name that tells\neverything about the expected behavior. Yes, it\u2019s more writing effort but you\ncan create a tailored and clear test, that only test the relevant behavior.\nAgain, helper functions can reduce the typing effort. And finally, adding\ntailored tests with descriptive names is a great way of documenting the\nimplemented behavior.\n\n## Assert Only What You Want to Test\n\nThink about what you actually want to test. Avoid asserting more things just\nbecause you can do it. Moreover, keep in mind what you have already tested in\nformer tests; you usually don\u2019t have to assert that again and again in every\ntest. This keeps the tests short and states clearly and without any\ndistraction the expected behavior.\n\nLet\u2019s consider an example: We like to test an HTTP endpoint which returns\nproducts. Our tests suite should contain the following tests:\n\n  1. One bigger \u201cmapping test\u201d that assert all values from the database are correctly returned in the JSON payload and got mapped correctly to the correct format. We can do this easily by using AssertJ\u2019s isEqualTo() (for a single element) or containsOnly() (for multiple elements) if you have implemented equals() correctly.\n\n    \n    \n    String responseJson = requestProducts(); ProductDTO expectedDTO1 = new ProductDTO(\"1\", \"evelope\", new Category(\"office\"), List.of(States.ACTIVE, States.REJECTED)); ProductDTO expectedDTO2 = new ProductDTO(\"2\", \"evelope\", new Category(\"smartphone\"), List.of(States.ACTIVE)); assertThat(toDTOs(responseJson)) .containsOnly(expectedDTO1, expectedDTO2);\n\n  2. Some tests checking the correct behavior of the query parameter ?category. So we want to test the correct filtering; not if all properties are correctly set. We have already done that in the above test. Consequently, it\u2019s enough to compare only the returned product ids.\n\n    \n    \n    String responseJson = requestProductsByCategory(\"Office\"); assertThat(toDTOs(responseJson)) .extracting(ProductDTO::getId) .containsOnly(\"1\", \"2\");\n\n  3. Some tests checking corner cases or special business logic. For instance, if a certain value in the payload is calculated correctly. In this case, we may only be interested in a certain JSON field of the payload. So we should only check the relevant field to clearly state and document the scope of the logic under test. Again, there is no need to assert all fields again, because there are not relevant here.\n\n    \n    \n    assertThat(actualProduct.getPrice()).isEqualTo(100);\n\n# Self-Contained Tests\n\n## Don\u2019t Hide the Relevant Parameters (in Helper Functions)\n\n    \n    \n    // Don't insertIntoDatabase(createProduct()); List<ProductDTO> actualProducts = requestProductsByCategory(); assertThat(actualProducts).containsOnly(new ProductDTO(\"1\", \"Office\"));\n\nYes, you should use helper functions for creating data and assertions, but you\nhave to parameterize them. Define a parameter for everything that is important\nfor the test and needs to be controlled by the test. Don\u2019t force the reader to\njump to a function definition in order to understand the test. Rule of thumb:\nYou should see the essentials of a test by looking only at the test method.\n\n    \n    \n    // Do insertIntoDatabase(createProduct(\"1\", \"Office\")); List<ProductDTO> actualProducts = requestProductsByCategory(\"Office\"); assertThat(actualProducts).containsOnly(new ProductDTO(\"1\", \"Office\"));\n\n## Insert Test Data Right In The Test Method\n\nEverything needs to be right in the test method. It\u2019s tempting to move\nreusable data insertion code to the @Before method, but this would force the\nreader to jump around in order to fully understand what\u2019s going on. Again,\nhelper functions for data insertion can help to make this repetitive task a\none-liner.\n\n## Favor Composition Over Inheritance\n\nDon\u2019t build up complex inheritance hierarchies for the test classes.\n\n    \n    \n    // Don't class SimpleBaseTest {} class AdvancedBaseTest extends SimpleBaseTest {} class AllInklusiveBaseTest extends AdvancedBaseTest {} class MyTest extends AllInklusiveBaseTest {}\n\nThose hierarchies are hard to understand and you likely end up extending a\nbase test that contains a lot of stuff that the current test doesn\u2019t need.\nThis distracts the reader and can lead to bugs. Inheritance is not flexible:\nIt\u2019s not possible to use everything from AllInklusiveBaseTest but nothing from\nits superclass AdvancedBaseTest? Moreover, the reader has to jump between\nmultiple base classes to understand the big picture.\n\n> \u201cPrefer duplication over the wrong abstraction\u201d. Sandi Metz. See \u201cWall of\n> Coding Wisdom\u201d\n\nInstead, I recommend using composition. Write small code snippets and classes\nfor each specific fixture work (start the test database, create the schema,\ninsert data, start a mock web server). Reuse those parts in your tests in the\n@BeforeAll method or by assigning the created objects to fields of the test\nclass. So you assemble every new test class by reusing those parts; like lego\nbricks. This way, every test has its own tailored fixture that is easy to\ngrasp and nothing unrelated is happening. The test class is self-contained\nbecause everything relevant is right in the test class.\n\n    \n    \n    // Do public class MyTest { // composition instead of inheritance private JdbcTemplate template; private MockWebServer taxService; @BeforeAll public void setupDatabaseSchemaAndMockWebServer() throws IOException { this.template = new DatabaseFixture().startDatabaseAndCreateSchema(); this.taxService = new MockWebServer(); taxService.start(); } } // In a different File public class DatabaseFixture { public JdbcTemplate startDatabaseAndCreateSchema() throws IOException { PostgreSQLContainer db = new PostgreSQLContainer(\"postgres:11.2-alpine\"); db.start(); DataSource dataSource = DataSourceBuilder.create() .driverClassName(\"org.postgresql.Driver\") .username(db.getUsername()) .password(db.getPassword()) .url(db.getJdbcUrl()) .build(); JdbcTemplate template = new JdbcTemplate(dataSource); SchemaCreator.createSchema(template); return template; } }\n\nAgain:\n\n> KISS > DRY\n\n# Dumb Tests Are Great: Compare the Output with Hard-Coded Values\n\n## Don\u2019t Reuse Production Code\n\nTest should test the production code; not reuse it. If you reuse production\ncode in a test, you might miss a bug that is introduced in the reused code\nbecause you don\u2019t test this code anymore.\n\n    \n    \n    // Don't boolean isActive = true; boolean isRejected = true; insertIntoDatabase(new Product(1, isActive, isRejected)); ProductDTO actualDTO = requestProduct(1); // production code reuse ahead List<State> expectedStates = ProductionCode.mapBooleansToEnumList(isActive, isRejected); assertThat(actualDTO.states).isEqualTo(expectedStates);\n\nInstead, think in terms of input and output when writing tests. The test sets\nthe input and compares the actual output with hard-coded values. Most of the\ntime, code reuse is not required.\n\n    \n    \n    // Do assertThat(actualDTO.states).isEqualTo(List.of(States.ACTIVE, States.REJECTED));\n\n## Don\u2019t Rewrite Production Logic\n\nMapping code is a common example where the logic in tests is rewritten. So\nlet\u2019s assume our tests contains a method mapEntityToDto() which result is used\nto assert that a returned DTO contains the same values than the entities that\nhave been inserted at the beginning of the test. In this case, you\u2019ll most\nlikely end up rewriting the production logic in the test code, which can\ncontains bugs.\n\n    \n    \n    // Don't ProductEntity inputEntity = new ProductEntity(1, \"evelope\", \"office\", false, true, 200, 10.0); insertIntoDatabase(input); ProductDTO actualDTO = requestProduct(1); // mapEntityToDto() contains the same mapping logic as the production code ProductDTO expectedDTO = mapEntityToDto(inputEntity); assertThat(actualDTO).isEqualTo(expectedDTO);\n\nAgain, the solution is to compare the actualDTO with a manually created\nreference object with hard-coded values. That\u2019s dead-simple, easy to\nunderstand and less error-prone.\n\n    \n    \n    // Do ProductDTO expectedDTO = new ProductDTO(\"1\", \"evelope\", new Category(\"office\"), List.of(States.ACTIVE, States.REJECTED)) assertThat(actualDTO).isEqualTo(expectedDTO);\n\nIf you don\u2019t want to compare all values and you therefore don\u2019t want to create\na complete reference object, consider to only compare subobjects or just the\nrelevant values.\n\n## Don\u2019t Write Too Much Logic\n\nAgain, testing is mostly about input and output: Providing input and compare\nthe actual output with the expected values. Hence, we don\u2019t need to code much\nlogic in our tests and we shouldn\u2019t. If you implement logic with many loops\nand conditions, you make the tests harder to grasp and more error-prone.\nMoreover, in case of complex assertion logic, AssertJ\u2019s powerful assertions\ncan do the heavy lifting for you.\n\n# Test Close To The Reality\n\n## Focus on Testing A Complete Vertical Slide\n\nTesting each class in isolation by using mocks is a common testing\nrecommendation. However, it has drawbacks: You are not testing all classes in\nintegration and refactorings of the internals will break all tests, because\nthere is a test for each internal class. And finally, you have to write and\nmaintain multiple tests.\n\nUnit Testing each class in isolation and with mocks comes with drawbacks.\n\nInstead, I suggest focussing on integration tests. By \u201cintegration tests\u201d (or\n\u201ccomponent test\u201d) I mean putting all classes together (just like in\nproduction) and test a complete vertical slide going though all technical\nlayers (HTTP, business logic, database). This way, you are testing behavior\ninstead of an implementation. Those tests are accurate, close to production\nand robust against refactorings of internals. Ideally, we only have to write a\nsingle test class.\n\nI recommend to focus on integration test (= wiring real objects together and\ntest all at once)\n\nStill, unit tests are useful and there are situations where a unit test is the\nbetter choice or where it make sense to combine both approaches. However, my\nexperience is that an integration test is the better and sufficient choice\nmost of the time.\n\nThere is much more to say about this topic. Check out my blog post \u2018Focus on\nIntegration Tests Instead of Mock-Based Tests\u2019 for more details.\n\n## Don\u2019t Use In-Memory Databases For Tests\n\nWith an in-memory database, you are testing against a different database than\nin production.\n\nUsing an in-memory database (H2, HSQLDB, Fongo) for tests reduces the\nreliability and scope of your tests. The in-memory database and the database\nused in production behave differently and may return different results. So a\ngreen in-memory-database-based test is no guaranty for the correct behavior of\nyour application in production. Moreover, you can easily run into situations\nwhere you can\u2019t use (or test) a certain (database-specific) feature because\nthe in-memory database doesn\u2019t support it or act differently. For details on\nthis, check out the post \u2018Don\u2019t use In-Memory Databases for Tests\u2019.\n\nThe solution is to execute the tests against the real database. Fortunately,\nthe library Testcontainers provides an awesome Java API for managing container\ndirectly in the test code. To increase the execution speed, see here.\n\n# Java/JVM\n\n## Use -noverify -XX:TieredStopAtLevel=1\n\nAlways add the JVM options -noverify -XX:TieredStopAtLevel=1 to your run\nconfigurations. It will save 1 - 2 seconds during the start of the JVM before\nthe test got executed. This is especially useful during the initial\ndevelopment of a test where you frequently start the test via the IDE.\n\nUpdate: As of Java 13, -noverify is deprecated.\n\nTip: You can add the arguments to the \u201cJUnit\u201d run config template in IntelliJ\nIDEA so you don\u2019t have to add them for each new run configuration.\n\n## Use AssertJ\n\nAssertJ is an extremely powerful and mature assertion library with a fluent\ntype-safe API, a huge variety of assertions and descriptive failure messages.\nThere is an assertion for everything you want to do. This prevents you from\nwriting complex assertion logic with loops and conditions while keeping the\ntest code short. Here are some examples:\n\n    \n    \n    assertThat(actualProduct) .isEqualToIgnoringGivenFields(expectedProduct, \"id\"); assertThat(actualProductList).containsExactly( createProductDTO(\"1\", \"Smartphone\", 250.00), createProductDTO(\"1\", \"Smartphone\", 250.00) ); assertThat(actualProductList) .usingElementComparatorIgnoringFields(\"id\") .containsExactly(expectedProduct1, expectedProduct2); assertThat(actualProductList) .extracting(Product::getId) .containsExactly(\"1\", \"2\"); assertThat(actualProductList) .anySatisfy(product -> assertThat(product.getDateCreated()).isBetween(instant1, instant2)); assertThat(actualProductList) .filteredOn(product -> product.getCategory().equals(\"Smartphone\")) .allSatisfy(product -> assertThat(product.isLiked()).isTrue());\n\n## Avoid assertTrue() and assertFalse()\n\nAvoid simple assertTrue() or assertFalse() assertions as they produce cryptic\nfailure messages:\n\n    \n    \n    // Don't assertTrue(actualProductList.contains(expectedProduct)); assertTrue(actualProductList.size() == 5); assertTrue(actualProduct instanceof Product);\n    \n    \n    expected: <true> but was: <false>\n\nInstead, use AssertJ\u2019s assertions which produce nice failure messages out-of-\nthe-box.\n\n    \n    \n    // Do assertThat(actualProductList).contains(expectedProduct); assertThat(actualProductList).hasSize(5); assertThat(actualProduct).isInstanceOf(Product.class);\n    \n    \n    Expecting: <[Product[id=1, name='Samsung Galaxy']]> to contain: <[Product[id=2, name='iPhone']]> but could not find: <[Product[id=2, name='iPhone']]>\n\nIf you really have to check for a boolean, consider AssertJ\u2019s as() to improve\nthe failure message.\n\n## Use JUnit5\n\nJUnit5 is the state of the art for (unit) testing. It\u2019s actively developed and\nprovides many powerful features (like parameterized tests, grouping,\nconditional tests, lifecycle control).\n\n### Use Parameterized Tests\n\nParameterized Tests allow rerunning a single test multiple times with\ndifferent values. This way, you can easily test several cases without writing\nmore test code. JUnit5 provides great means to write those tests with\n@ValueSource, @EnumSource, @CsvSource, and @MethodSource.\n\n    \n    \n    // Do @ParameterizedTest @ValueSource(strings = [\"\u00a7ed2d\", \"sdf_\", \"123123\", \"\u00a7_sdf__dfww!\"]) public void rejectedInvalidTokens(String invalidToken) { client.perform(get(\"/products\").param(\"token\", invalidToken)) .andExpect(status().is(400)) } @ParameterizedTest @EnumSource(WorkflowState::class, mode = EnumSource.Mode.INCLUDE, names = [\"FAILED\", \"SUCCEEDED\"]) public void dontProcessWorkflowInCaseOfAFinalState(WorkflowState itemsInitialState) { // ... }\n\nI highly recommend to extensively use them, because you can test more cases\nwith a minimal amount of effort.\n\nFinally, I like to highlight @CsvSource and @MethodSource which can be used\nfor more advanced parameterized test scenarios where you can also control the\nexpected output with a parameter.\n\n    \n    \n    @ParameterizedTest @CsvSource({ \"1, 1, 2\", \"5, 3, 8\", \"10, -20, -10\" }) public void add(int summand1, int summand2, int expectedSum) { assertThat(calculator.add(summand1, summand2)).isEqualTo(expectedSum); }\n\n@MethodSource is powerful in conjunction with a dedicated test object\ncontaining all relevant test parameters and the expected output.\nUnfortunately, in Java, writing those data structures (POJOs) is cumbersome.\nThat\u2019s why I\u2019ll demonstrate this feature using Kotlin\u2019s data classes.\n\n    \n    \n    data class TestData( val input: String?, val expected: Token? ) @ParameterizedTest @MethodSource(\"validTokenProvider\") fun `parse valid tokens`(data: TestData) { assertThat(parse(data.input)).isEqualTo(data.expected) } private fun validTokenProvider() = Stream.of( TestData(input = \"1511443755_2\", expected = Token(1511443755, \"2\")), TestData(input = \"151175_13521\", expected = Token(151175, \"13521\")), TestData(input = \"151144375_id\", expected = Token(151144375, \"id\")), TestData(input = \"15114437599_1\", expected = Token(15114437599, \"1\")), TestData(input = null, expected = null) )\n\n### Group the Tests\n\nJUnit5\u2019s @Nested is useful to group tests methods. Reasonable groups can be\ncertain types of tests (like InputIsXY, ErrorCases) or one group for each\nmethod under test (GetDesign and UpdateDesign).\n\n    \n    \n    public class DesignControllerTest { @Nested class GetDesigns { @Test void allFieldsAreIncluded() {} @Test void limitParameter() {} @Test void filterParameter() {} } @Nested class DeleteDesign { @Test void designIsRemovedFromDb() {} @Test void return404OnInvalidIdParameter() {} @Test void return401IfNotAuthorized() {} } }\n\nGroup the test methods with JUnit5\u2019s @Nested\n\n### Readable Test Names with @DisplayName or Kotlin\u2019s Backticks\n\nIn Java, use JUnit5\u2019s @DisplayName to create readable test descriptions.\n\n    \n    \n    public class DisplayNameTest { @Test @DisplayName(\"Design is removed from database\") void designIsRemoved() {} @Test @DisplayName(\"Return 404 in case of an invalid parameter\") void return404() {} @Test @DisplayName(\"Return 401 if the request is not authorized\") void return401() {} }\n\nReadable test method names with JUnit5\u2019s @DisplayName\n\nIn Kotlin, you can put the method names in backticks which can contain spaces.\nThis ensures a good readability while avoiding redundancy.\n\n    \n    \n    @Test fun `design is removed from db`() {}\n\n## Mock Remote Service\n\nIn order to test HTTP clients we need to mock the remote service. I often use\nOkHttp\u2019s WebMockServer for this purpose. Alternatives are WireMock or\nTestcontainer\u2019s Mockserver.\n\n    \n    \n    MockWebServer serviceMock = new MockWebServer(); serviceMock.start(); HttpUrl baseUrl = serviceMock.url(\"/v1/\"); ProductClient client = new ProductClient(baseUrl.host(), baseUrl.port()); serviceMock.enqueue(new MockResponse() .addHeader(\"Content-Type\", \"application/json\") .setBody(\"{\\\"name\\\": \\\"Smartphone\\\"}\")); ProductDTO productDTO = client.retrieveProduct(\"1\"); assertThat(productDTO.getName()).isEqualTo(\"Smartphone\");\n\n## Use Awaitility for Asserting Asynchronous Code\n\nAwaitility is a library for testing asynchronous code. You can easily define\nhow often an assertion is retried until it finally fails.\n\n    \n    \n    private static final ConditionFactory WAIT = await() .atMost(Duration.ofSeconds(6)) .pollInterval(Duration.ofSeconds(1)) .pollDelay(Duration.ofSeconds(1)); @Test public void waitAndPoll(){ triggerAsyncEvent(); WAIT.untilAsserted(() -> { assertThat(findInDatabase(1).getState()).isEqualTo(State.SUCCESS); }); }\n\nThis way, you can avoid using the fragile Thread.sleep() in the tests.\n\nHowever, testing synchronous code is much easier. That\u2019s why we should try to\nseparate the synchronous and the asynchronous code in order to test them\nseparately.\n\n## No Need to Bootstrap DI (Spring)\n\nUsing Spring\u2019s capabilities for testing are suitable in many cases. However,\nbootstrapping the (Spring) DI framework takes some seconds before the test can\nstart. Especially during the initial development of a test, this can slow down\nthe feedback cycle.\n\nSo alternatively, you can write the integration tests without any DI but that\nrequires more manual fixture creation. You can instantiate the required\nobjects manually by calling new and plump them together. If you are using\nconstructor injection, this is very easy. Most of the time, you want to test\nthe business logic you have wrote. For this, you don\u2019t need DI. Check out my\npost on integration tests for an example. But if you want to also test the\nconfiguration, you should use DI in your tests.\n\nMoreover, Spring Boot 2.2 will introduce an easy way to use lazy bean\ninitialization, which should significantly speed up DI-based tests.\n\n# Make The Implementation Testable\n\n## Don\u2019t Use Static Access. Never. Ever.\n\nStatic access is an anti-pattern. First, it obfuscates dependencies and side-\neffects making the whole code harder to understand and more error-prone.\nSecond, static access harms testability. You can\u2019t exchange the objects\nanymore. But in a test, you want to use mocks or use the real objects with a\ndifferent configuration (like a DAO object pointing to a test database).\n\nSo instead of access code statically, put it into non-static methods,\ninstantiate the class and pass the object to the constructor of the object\nwhere you need it.\n\n    \n    \n    // Don't public class ProductController { public List<ProductDTO> getProducts() { List<ProductEntity> products = ProductDAO.getProducts(); return mapToDTOs(products); } }\n    \n    \n    // Do public class ProductController { private ProductDAO dao; public ProductController(ProductDAO dao) { this.dao = dao; } public List<ProductDTO> getProducts() { List<ProductEntity> products = dao.getProducts(); return mapToDTOs(products); } }\n\nFortunately, DI frameworks like Spring are providing an easy way to avoid\nstatic access because it handles the creation and wiring of all objects for\nus.\n\n## Parameterize\n\nMake all relevant parts of the class controllable by the test. This can be\ndone by making a parameter for the constructor out of this aspect.\n\nFor instance, your DAO has a fixed limit of 1000 for queries. Testing this\nlimit would require you to create 1001 database entries in the test. By using\na constructor parameter for this limit you make the limit configurable. In\nproduction, this parameter is 1000. In the test, you can use 2. This only\nrequires 3 test entries for testing the limit feature.\n\n## Use Constructor Injection\n\nField injection is evil due to poor testability. You have to bootstrap the DI\nenvironment in your tests or do hacky reflection magic. So constructor\ninjection is the preferred way because it allows you to easily control the\ndependent object in the test.\n\nIn Java, this requires a little bit of boilerplate.\n\n    \n    \n    // Do public class ProductController { private ProductDAO dao; private TaxClient client; public CustomerResource(ProductDAO dao, TaxClient client) { this.dao = dao; this.client = client; } }\n\nIn Kotlin, the same is much more concise.\n\n    \n    \n    // Do class ProductController( private val dao: ProductDAO, private val client: TaxClient ){ }\n\n## Don\u2019t Use Instant.now() or new Date()\n\nDon\u2019t get the current timestamp by calling Instant.now() or new Date() in your\nproduction code when you like to test this behavior.\n\n    \n    \n    // Don't public class ProductDAO { public void updateDateModified(String productId) { Instant now = Instant.now(); // ! Update update = Update() .set(\"dateModified\", now); Query query = Query() .addCriteria(where(\"_id\").eq(productId)); return mongoTemplate.updateOne(query, update, ProductEntity.class); } }\n\nThe problem is that the created timestamp can\u2019t be controlled by the test. You\ncan\u2019t assert the exact value because it\u2019s always different in every test\nexecution. Instead, use Java\u2019s Clock class.\n\n    \n    \n    // Do public class ProductDAO { private Clock clock; public ProductDAO(Clock clock) { this.clock = clock; } public void updateProductState(String productId, State state) { Instant now = clock.instant(); // ... } }\n\nIn the test, you can now create a mock for the clock, pass it to the\nProductDAO and configure the clock mock to return a fixed timestamp. After\ncalling updateProductState() we assert if the defined timestamp made it into\nthe database.\n\n## Separate Asynchronous Execution and Actual Logic\n\nTesting asynchronous code is tricky. Libraries like Awaitility can help, but\nit\u2019s still cumbersome and test can still toggle. If possible, it makes sense\nto separate the (often synchronous) business logic from the asynchronous\nexecution of this logic.\n\nFor instance, by putting the business logic in the ProductController, we can\ntest it synchronously which is easy. The asynchronous and parallelization\nlogic is centralized in the ProductScheduler, which can be tested in\nisolation.\n\n    \n    \n    // Do public class ProductScheduler { private ProductController controller; @Scheduled public void start() { CompletableFuture<String> usFuture = CompletableFuture.supplyAsync(() -> controller.doBusinessLogic(Locale.US)); CompletableFuture<String> germanyFuture = CompletableFuture.supplyAsync(() -> controller.doBusinessLogic(Locale.GERMANY)); String usResult = usFuture.get(); String germanyResult = germanyFuture.get(); } }\n\n# Kotlin\n\nMy post about Best Practices for Unit Testing in Kotlin contains many Kotlin-\nspecific recommendations for writing test with Kotlin.\n\nBuy me a coffee\n\nYou can follow me on Twitter, LinkedIn or Mastodon, subscribe my newsletter or\nrequest my consulting or training.\n\nRelated Posts\n\n  * Best Practices for Unit Testing in Kotlin\n\n  * Focus on Integration Tests Instead of Mock-Based Tests\n\n  * Clean Code with Kotlin\n\n  * Idiomatic Kotlin. Best Practices.\n\nThis entry was posted in Software Craftsmanship, and tagged with Java, Kotlin,\nTesting, Best Practices, AssertJ, JUnit5, Testcontainers, Clean Code,\n\nComments\n\nArman 13 months ago\n\nFor anyone interested, I maintain a library for creating test objects that\nallows you to do:\n\nProductEntity entity = Instancio.create(ProductEntity.class);\n\ninstead of:\n\nProductEntity inputEntity = new ProductEntity(1, \"evelope\", \"office\", false,\ntrue, 200, 10.0);\n\nSee: https://github.com/instancio/instancio/\n\nDude 18 months ago\n\n\"So alternatively, you can write the integration tests without any DI but that\nrequires more manual fixture creation.\"\n\nNo, you can't. Using the new operator and manually injecting dependencies is\nstill DI.\n\nNitin Potdar 2 years ago\n\nThis is crisp, explanatory too helpful, excellent Philipp!\n\nDejan 2 years ago\n\nIt is very useful! Thank you!\n\nDong 2 years ago\n\nVery nice and useful article. I got a lot. Thanks\n\nvikram singh 2 years ago\n\ni am trying to create a test suite for Unit test of android application, but\nit always fails with different kinds of configuration error, one among that is\nas follows,\n\nError: Test events were not received android FAILURE: Build failed with an\nexception.\n\nWhat went wrong: Execution failed for task\n\u2018:appModules:factList:testDebugUnitTest\u2019. No tests found for given includes:\nreprator.wipro.factlist.FactListTestSuite RepoDetails: GitHub \u2013\nTheReprator/Wipro at junit5\n\nBranch: junit5\n\nTestSuite Class: Wipro/FactListTestSuite.kt at junit5 \u00b7 TheReprator/Wipro \u00b7\nGitHub\n\nMy whole code works perfectly with junit4 in master branch. Stackoverflow:\nhttps://stackoverflow.com/questions/68750803/junit5-testsuite-with-\nselectclasses-not-working\n\nPlease assist.\n\nJayson Zanarias 3 years ago\n\nHi Philipp, nice work man! Like with other comments have some opinion on some\nof the things you said but this is great job man, great list and examples.\nVery useful to me. Thank you!\n\ntejkrishna 3 years ago\n\nI really thank you for the valuable info on this great subject and look\nforward to more great posts.\n\narun 3 years ago\n\nThanks for sharing the information about the Java and keep updating us.This\ninformation is really useful to me. https://www.iitworkforce.com/java-\ncertification/\n\nsanjay 3 years ago\n\nThanks for sharing the information about the <a\nhref=\"https://www.iitworkforce.com/java-certification/\">Java</a> and keep\nupdating us.This information is really useful to me.\n\nAntoon 3 years ago\n\nHi Philipp, Very interesting - thanks!\n\nAndre Ghigo 3 years ago\n\nExcellent article. Some of your tips I have learned the hard way. Indeed\nintegration tests are more reliable but more complex to implement. Another\nhabit which is very bad is doing \"fake tests\" with assertions like\nassertTrue(true), assertEquals(1,1) just to increase the test coverage in\norder to pass the sonar analysis.\n\nDen Tsvetkoff 3 years ago\n\nHello, my name is Denis. I work in Russia. I think I do my job very well.. But\nmy subordinates tell me that I suck at Java. What can I do? Can you give me\ncouple of free lessons, please?\n\nRobin Bygrave 3 years ago\n\n> integration tests\n\nFor myself I instead prefer to use the term \"component tests\" because the term\n\"integration test\" already has different meaning to a lot of people.\n\n> Bootstrapping the (Spring) DI framework takes some seconds\n\nNote that if you are using a DI framework that uses [source] code generation\nlike https://avaje.io/inject then DI wiring takes almost no time. Combined\nwith something like https://javalin.io and this can enable \"component tests\"\nto actually include http and controller (marshalling, exception mapping,\nresponse codes etc) if desired.\n\n> Docker containers\n\nAlso note that https://ebean.io has test docker container support similar to\ntest containers but includes checking for the docker container to be already\nrunning and setting up the database (user, roles, schema etc). This means that\n99% of the time running tests is actually a case of running drop/create ddl.\n\nCheers, Rob.\n\nClebiovieira 3 years ago\n\nNice article. Fortunately, I've already use most of your that tips.\n\nToby 3 years ago\n\nHi, Philipp Nice article, good job. Btw, here you can find additional info in\nthis article - <a href=\"https://steelkiwi.com/blog/getting-started-kotlin-\nlibraries-glide-dagger/\" rel=\"nofollow noopener\"\ntitle=\"https://steelkiwi.com/blog/getting-started-kotlin-libraries-glide-\ndagger/\">Getting started with Kotlin and third-party libraries Glide, Dagger\n2, Retrofit 2, Realm, RxJava and MVP architecture on Android</a>\n\nToby 3 years ago\n\nSorry! Getting started with Kotlin and third-party libraries Glide, Dagger 2,\nRetrofit 2, Realm, RxJava and MVP architecture on Android -\nhttps://steelkiwi.com/blog/getting-started-kotlin-libraries-glide-dagger/\n\nDirk Steins 3 years ago\n\nHey, thanks for the article, great summarization. I disagree on a view points,\nespecially on the In-Memory-Database. My take is to use In-Memory-Databases\nfor almost all tests that need a persistence but don't test the persistence.\nAnd then I have tests for the persistence itself which use the real database\nfor this. This ensures that your application runs fine using the database used\nin production but the other test can run faster by using the In-Memory DB.\n\nAnother point is the usage of Junit5. I don't have anything against it, and I\ndon't want to discourage anyone from using it, but I prefer to write tests\nusing Spock as a Framework. This gives you, because these tests are written in\nGroovy, the ability to use correct naming of tests without the use of\nannotations, and you automatically get the given:/when:/then: blocks because\nof Spock. Also Spock is excellent for mocking of objects. If you don't know\nit, take a look at it.\n\nPersonally I use WireMock for HTTP mocks, but I think there isn't such a big\ndifference between this and the WebMockServer mentioned above.\n\nRavi Gupta 3 years ago\n\nGreat article except the \"Vertical slide\" part. The vertical slide is more of\nan integration test. You can't test all code paths using integration test. (I\nmean you can, but that'd be terrible). Realistically, you would have a handful\nof integration (vertical slide) and a lot of unit tests each specific to\nindividual class where the business logic is written.\n\nBoth integration and unit tests are important. Testing all code paths using\nvertical slide would be painfully slow. Over time they end up being @Ignore\n(d).\n\nAnton Feoktistov 3 years ago\n\n> Focus on Testing A Complete Vertical Slide\n\nI strongly disagree with this point. Currently I have such system - tests run\nfor 20 minutes and are hard to maintain. Number of mocks make initial setup\ntricky. Test container with Postgres starts much slower then in-mem. And I see\nonly one solution - make test double totally the same as repo class. Without\nmocks.\n\nSuch integration/acceptance tests should exist in projects, but: 1. There\nshould be a small number of them, which tests the integration 2. Full\nacceptance tests should be wrote NOT by developers who wrote that code\n\nPhilipp Hauer 3 years ago\n\nHi Anton, thanks for your reply. Disagreeing is fine. :-)\n\nEventually, with integration tests, you trade reliability for speed. That's\nthe deal and for me, that's fine. When I would relying mostly on unit test I\nwould never have the confidence that my system also works in integration and\nwith the real database.\n\nBut I agree with you that waiting 20 min is pain. What does take so long? Do\nyou restart the Postgres multiple times? Do you start the whole application or\nthe DI framework multiple times?\n\nFor example, the integration tests of one of our service take 30 s for 700\ntests (mostly integration tests). We reuse the database container and don't\nstart the whole application but only the parts that are relevant for the\ncurrent test (no DI involved).\n\nI also agree that the setting up mock server can be tricky. For me, it's still\nworth the effort.\n\nCheers, Philipp\n\nAnton Feoktistov 3 years ago\n\nHi Philipp, thank you for reply :)\n\nI am using Postgress testcontainer and there are ~20 test files. Thus, it is\nrestarted 20 times. I was googling how to not restart container each time, but\nas I understood it is not possible to configure it once for test suite.\n\nBut the biggest pain in this story is async code. Test run perfectly on my\nmachine, but CI server has the smallest AWS nodes. So, tests are flaky because\nof timeouts. Timeouts where increased therefore to 15 seconds.\n\nThat's why I'd like to steak to unit test approach, and one or two test for\nintegration. Then, code is deployed to test env, where tests written in other\ntechnology, written by QA team are started.\n\nI still have several tests to test exactly integration. And unit test for each\ncomponent which is written during development. And I try to wrap DB code\nbehind Repo interface, and implement it as collection, without any framework.\nOne parametrized test can test two implementations: one my with in memory map,\nand other one with test container.\n\nUsing H2 doesn't work by the same reasons as you described.\n\nCheers, Anton\n\nPhilipp Hauer 3 years ago\n\nHi Anton,\n\nwe start the test container once for the whole test suite. That works for us.\nIn Java, you can use a static field for this. In Kotlin, I use a lazy-\ninitialized variable for this.\n\nYes, asynchronous code can be very hard to test without toggling tests. I try\nto leave the asynchronous parts out of my test and focus on the synchronous\npart of the code that gets tested in an integration test. But that's not\nalways possible. Without having a look at your system is hard to say, if I\nwould slice the integration tests in a different way.\n\nFor me, the database queries are one of the most crucial parts of the whole\ncode base. Therefore, I want these code to be tested intensively, with all\ncorner-cases and against the real database. That's why I never mock them in my\ntests.\n\nSystems are different, there is no silver bullet and I believe that you have\nmade tough experiences that finally led to your point of view. :-)\n\nPhilipp\n\nkerrerain 3 years ago\n\nHello Philipp,\n\nTesting against an environment very close to the production requires practice.\nIt's achievable nevertheless. We are often lazy about this choice, and might\nrun into a very unlikely bug. It's a matter of risk. I pay tribute to your\nthoroughness.\n\nIt's obvious that you put much effort in practicing automated testing, and as\nmuch care sharing the results on this blog, so, thank you.\n\nI'd like to share an opinion about the \"Focus on Testing A Complete Vertical\nSlide\" section. I think that two different concepts are mixed in this section:\n- Integration testing. - Testing against and API.\n\nAs long as other components of the system (such as a database) are involved in\nthe test, it can be qualified as an integration test, even if the SUT (system\nunder test) is a single DAO class.\n\nTesting the high-level controller is rather testing an API than doing\nintegration testing. In the example you provide, it's both: the integration\ntesting of an API against other components of the system. This API could be\ntested against a mocked database instead, without changing the logic of the\ntest itself.\n\nWhat's interesting about testing an API is, as you've noticed, that it is\nrobust against refactoring of internals. What degree of realism is involved in\nthe automated tests is rather a matter of risk.\n\nThe main reason we're designing API's is to make the usage as stable and easy\nas possible. Every element of the system that goes public involves a\nmaintenance. It starts with the tests: if the API is poorly designed, it will\nchange often, and the test will also change often. This issue is very likely\nto occur if there is little effort made on the design of the API.\n\nConclusion: IMHO, testing an API actually decreases the risk to refactor the\ntests, but only if the API is well designed. Doing integration testing\ndecreases the risk of having bugs.\n\nThe code of the automated tests reflects the usage of the API. A lot of\nattention needs to be paid to this part. The integration testing of an API can\nbe a real nightmare if the API is poorly designed and breaks often.\n\nPedro Moniz 4 years ago\n\nHello Philip,\n\nI would like to ask you if the manno lib for android to allow support for\nJUnit5 is something trustworthy and that you would recommend?\n\nCurrently there is no official support for JUnit5 so I am hesitant in using it\neven though I enjoy it.\n\nleventov 4 years ago\n\nI'd also mention somewhere (either in the section about making the\nimplementation testable, or close to the section \"Use Fixed Data Instead of\nRandomized Data\") a recommendation to use SplittableRandom instead of both\njava.util.Random and ThreadLocalRandom and, perhaps, parameterize classes\n(those than need some source of randomness internally) with it, in a manner\nsimilar to the suggested pattern for java.time.Clock.\n\nSplittableRandom is better than java.util.Random because it's not synchronized\ninternally and could be actually split to create independent sources of\nrandomness down object graph if needed. On the other hand, a test may create a\nSplittableRandom with a fixed seed and provide it to the high-level object\nconstructor or factory to parameterize the whole object graph but at the same\ntime keep the tests repeatable and problems debuggable.\n\nAvoiding randomness completely may not be a good strategy (even when it's not\nrequired strictly by the underlying algorithm (such as \"balancing\" logic of\nany sort, HyperLogLog impls, etc. which could get away without randomness)\nbecause it may not allow \"smoke\" tests. Randomness also ensures there are no\nunintended patterns emerging.\n\nleventov 4 years ago\n\nGreat post, thank you. I'd add a note in the last section \"Separate\nAsynchronous Execution and Actual Logic\" that this pattern is actually called\nHumble Object (http://xunitpatterns.com/Hu... to help to build a common\nindustry vocabulary.\n\nSuhel Khan 4 years ago\n\nWonderful article! Thanks a lot :)\n\nPhilipp Hauer\n\nI am Philipp Hauer and I work remotely as a Head of Engineering for\ncommercetools near Rostock, Germany. I strive for building happy, motivated,\nand productive teams and I\u2019m enthusiastic about Kotlin, clean code,\ndistributed systems, testing and the sociology of software development. I\u2019m\ntweeting under @philipp_hauer, giving talks and offering leadership coaching,\nconsulting and workshops.\n\nRecent Posts\n\n  * Coaching Skills for Managers II: The Thought Model\n  * Coaching Skills for Managers I: The Coaching Steering Wheel\n  * Template for Efficient One-On-One Meetings\n  * Manager's Summary of the Book 'Never Split The Difference'\n\nCategories\n\n  * Leadership (17)\n  * Build and Development Infrastructure (15)\n  * Web Development (15)\n  * Software Craftsmanship (14)\n  * Publications and Talks (11)\n  * Database (9)\n  * Software Architecture (9)\n  * Tools and Environment (2)\n  * Productivity (1)\n\nTop Tags\n\n  * Docker (11)\n  * Kotlin (11)\n  * Best Practices (9)\n  * One-on-One (8)\n  * REST (8)\n  * Build (7)\n  * Clean Code (7)\n  * Feedback (7)\n  * Maven (7)\n  * Vaadin (7)\n  * MongoDB (6)\n  * Testing (6)\n\nCopyright \u00a9 2024 by Philipp Hauer | Icon Contribution | Imprint | Privacy Policy |\n\n", "frontpage": false}
