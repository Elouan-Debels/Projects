{"aid": "40039379", "title": "What I Learned from Building a Postgres Extension in Rust", "url": "https://goodyduru.github.io//database/2024/04/15/what-i-learned-from-building-a-postgres-extension-in-rust.html", "domain": "goodyduru.github.io", "votes": 1, "user": "ingve", "posted_at": "2024-04-15 12:01:40", "comments": 0, "source_title": "What I Learned From Building A Postgres Extension In Rust", "source_text": "What I Learned From Building A Postgres Extension In Rust | Goodness\u2019s blog\n\nGoodness's blog\n\n# What I Learned From Building A Postgres Extension In Rust\n\nApr 15, 2024\n\nThis is a list of things I learned from building the Postgres-redis extension\nfor Postgres in Rust. A retrospective design and implementation article, this\nis not. It is written here.\n\nBuilding this extension opened my eyes to some of Postgres\u2019s design details\nand Rust tricks. The things I learned might be ordinary and widely known, but\nI learned about them on this project. Here\u2019s what I learned.\n\n#### 1\\. The Mundanity Of Excellence\n\nTake a look at this piece of code:\n\n    \n    \n    /* * Loop until we've processed the proper number of tuples from the plan. */ for (;;) { /* Reset the per-output-tuple exprcontext */ ResetPerTupleExprContext(estate); /* * Execute the plan and obtain a tuple */ slot = ExecProcNode(planstate); /* * if the tuple is null, then we assume there is nothing more to * process so we just end the loop... */ if (TupIsNull(slot)) break; /* * If we have a junk filter, then project a new tuple with the junk * removed. * * Store this new \"clean\" tuple in the junkfilter's resultSlot. * (Formerly, we stored it back over the \"dirty\" tuple, which is WRONG * because that tuple slot has the wrong descriptor.) */ if (estate->es_junkFilter != NULL) slot = ExecFilterJunk(estate->es_junkFilter, slot); /* * If we are supposed to send the tuple somewhere, do so. (In * practice, this is probably always the case at this point.) */ if (sendTuples) { /* * If we are not able to send the tuple, we assume the destination * has closed and no more tuples can be sent. If that's the case, * end the loop. */ if (!dest->receiveSlot(slot, dest)) break; } /* * Count tuples processed, if this is a SELECT. (For other operation * types, the ModifyTable plan node must count the appropriate * events.) */ if (operation == CMD_SELECT) (estate->es_processed)++; /* * check our tuple count.. if we've processed the proper number then * quit, else loop again and process more tuples. Zero numberTuples * means no limit. */ current_tuple_count++; if (numberTuples && numberTuples == current_tuple_count) break; }\n\nPretty ordinary, with no clever tricks, just straightforward C code. This\npiece of code taken from Postgres is responsible for\ninserting/updating/deleting/selecting tuples (rows) from a table. It\u2019s pretty\namazing how simple it is, yet almost all select/update/delete/insert queries\nyou run against your Postgres table execute this code. It wasn\u2019t just this\narea; other parts of the Postgres codebase were like this. Simple pieces of\ncode that are combined to create excellent, reliable, sophisticated, and\namazing software. It reminds me of Da Vinci\u2019s quote: Simplicity is the\nultimate sophistication.\n\n#### 2\\. So Many Kinds Of Operators\n\nTake a look at this. Postgres has lots of operators. Initially, I thought the\n= sign would only have one constant. I could not have been more mistaken.\nThere are Int4EqualOperator, TextEqualOperator, NameEqualTextOperator,\nBooleanEqualOperator, TIDEqualOperator, BpcharEqualOperator,\nByteaEqualOperator, and this is just for the equal sign. Other operators have\ndifferent subtypes, with each subtype having its own oid.\n\nIt made our where clause handler a bit more complex, but I can\u2019t complain. I\u2019m\ncurious about the reason for this, though. Please, I\u2019d love to hear from you\nif you know :-).\n\n#### 3\\. Rust Pointers\n\nWorking on this project introduced me to using pointers in Rust lots of time.\nIn an unsafe context, Rust pointers behave so much like C. While the basic\npointer stuff like referencing and dereferencing pointers are covered well by\nthe Rust book, there are two things I learned about Rust pointers when\nbuilding this extension. Here they are:\n\n  * Pointer arithmetic: Imagine you have a list of objects and the pointer to the first item in the list; how do you get to the nth item? In C, you\u2019d probably do this:\n\n    \n    \n    struct object* get_nth(struct object* list, int n) { struct object* item = list + n; return item; }\n\nI needed to do something like this when porting this function from C to Rust.\nThankfully, Rust has a handy function for that called offset. Here\u2019s how the\nabove code will look in Rust:\n\n    \n    \n    unsafe fn get_nth(list: *mut object, n: isize) -> *mut object { let item = list.offset(n); item }\n\nThat\u2019s it!!! Really straightforward and dangerous \ud83d\ude43.\n\n  * Easily cast a struct variable to another: Rust is a strict programming language. This can make learning the language a chore. One of the reasons why it\u2019s strict is because it tries to protect the programmer from the clever version of themselves. Let\u2019s say you want to convert a variable from one struct type to another. In Rust, we want to achieve something like this:\n\n    \n    \n    struct Person { firstname: String, lastname: String, } struct User { firstname: String, lastname: String, } fn convert_person_to_user(x: Person) { let u = x as User; println!(\"Firstname: {}, Lastname: {}\", u.firstname, u.lastname); }\n\nWhen you run this code, the Rust compiler will throw an error. This error will\noccur despite both structs having the same fields. This is a good thing, but\nit might be a bit inconvenient. There are other ways you could achieve this\nrather than using straight-up casting. But what if you are working with a\nlibrary or C code and need to cast? We can achieve it with pointers. Here\u2019s\nthe above function rewritten to use pointers.\n\n    \n    \n    unsafe fn convert_to_user(mut x: Person) { let p = &mut x as *mut Person; let u = p.cast::<User>(); println!(\"{}, {}\", (*u).firstname, (*u).lastname); }\n\nIt runs without any complaint. It isn\u2019t good Rust code, but sometimes you need\nsomething to just work.\n\nI won\u2019t advise anyone to use the above methods to solve problems, but you\nmight need them. It turned out that I needed them, and it was really\nworthwhile discovering and using them.\n\nSpeaking of casting...\n\n#### 4\\. Adding extra fields to a struct\n\nImagine you\u2019re using a todo library that works with only one task. When you\nadd a task, it throws away the previous one.\n\n    \n    \n    #[derive(Clone)] struct Task { content: String, is_done: bool } #[repr(C)] struct Todo { add: unsafe fn(self_: *mut Todo, task: Task), current_task: Option<Task>, } unsafe fn add_task(todo: *mut Todo, task: Task) { (*todo).current_task = Some(task); } fn add_tasks(todo: *mut Todo) { let task1 = Task{content: String::from(\"Write\"), is_done: false}; let task2 = Task{content: String::from(\"Read\"), is_done: true}; unsafe { ((*todo).add)(todo, task1); ((*todo).add)(todo, task2); } }\n\nYou\u2019d use the above library like this:\n\n    \n    \n    fn create_todo() { let mut todo = Todo {add: add_task, current_task: None}; let todo_ptr = &mut todo as *mut Todo; add_tasks(todo_ptr); }\n\nIt works well, but what if the one task at a time is too limited for you? What\nif you want to keep track of previous tasks? The library function add_tasks\ncannot be changed and expects a specific input type. Is it possible to satisfy\nthe library and satisfy your extra needs? It turns out both needs could be\nsatisfied with a bit of casting trick. Here\u2019s how?\n\n    \n    \n    #[repr(C)] struct CustomTodo { add: unsafe fn(self_: *mut Todo, task: Task), current_task: Option<Task>, previous_tasks: Vec<Task>, } unsafe fn custom_add_task(todo: *mut Todo, task: Task) { let custom_todo = todo as *mut CustomTodo; if (*custom_todo).current_task.is_some() { let prev = (*custom_todo).current_task.as_ref().unwrap().clone(); (*custom_todo).previous_tasks.push(prev); } (*custom_todo).current_task = Some(task); } fn create_todo() { let mut custom_todo = CustomTodo{add: custom_add_task, current_task: None, previous_tasks: vec![]}; let custom_todo_ptr = &mut custom_todo as *mut CustomTodo; unsafe { let custom_todo_ptr = custom_todo_ptr as *mut Todo; add_tasks(custom_todo_ptr); } for task in &(custom_todo.previous_tasks) { println!(\"Previous tasks\\tContent: {}, is_done: {}\", task.content, task.is_done); } }\n\nThe above code shows how using casting has helped achieve both needs. We still\nneeded help from the library code to pull this off, though. Notice the repr\nattribute on both Todo and CustomTodo that tells the Rust compiler to treat\nboth like a C struct. The attribute ensures that the compiler doesn\u2019t change\nthe order of the struct\u2019s fields. A segmentation fault would have occurred if\nthe library hadn\u2019t added the attribute to the Todo struct.\n\nThis struct manipulation is dangerous and shouldn\u2019t be used thoughtlessly in\nyour code. There are ways to achieve the above intent without meddling in\nunsafe territory. Dealing with C code or FFI might call for a need for it.\n\n### Conclusion\n\nThese lessons might look very ordinary, but they are special to me. Working on\nthis project has made me a better programmer.\n\nIronically, I started with praises about the simplicity of Postgres and then\nended with some clever tricks. The biggest lesson here is to strive for\nsimplicity, but you never know when a clever trick could come in handy. Where\ndo you think I found the struct casting trick?\n\n## Goodness's blog\n\n  * Goodness Duru\n  * goodyduru@gmail.com\n\n  * goodyduru\n  * goodyduru\n\nA place where I riff on my current projects.\n\n", "frontpage": false}
