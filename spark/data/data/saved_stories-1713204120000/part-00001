{"aid": "40039371", "title": "Don't lose your file (descriptors): escrow library", "url": "https://github.com/nikitadanilov/escrow", "domain": "github.com/nikitadanilov", "votes": 1, "user": "oecumena", "posted_at": "2024-04-15 12:00:48", "comments": 0, "source_title": "GitHub - nikitadanilov/escrow: File descriptor escrow library", "source_text": "GitHub - nikitadanilov/escrow: File descriptor escrow library\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nnikitadanilov / escrow Public\n\n  * Notifications\n  * Fork 0\n  * Star 0\n\nFile descriptor escrow library\n\n### License\n\nView license\n\n0 stars 0 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# nikitadanilov/escrow\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nnikitadanilovAdd tests to TODO.77dc6be \u00b7\n\n## History\n\n21 Commits  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Add README.md  \n  \n### LICENCE\n\n|\n\n### LICENCE\n\n| Add LICENCE.  \n  \n### README.md\n\n|\n\n### README.md\n\n| Add tests to TODO.  \n  \n### build\n\n|\n\n### build\n\n| Fixes for Darwin.  \n  \n### echo-client.c\n\n|\n\n### echo-client.c\n\n| Add LICENCE.  \n  \n### echo-server.c\n\n|\n\n### echo-server.c\n\n| Fixes for Darwin.  \n  \n### escrow.c\n\n|\n\n### escrow.c\n\n| Output everything to stderr.  \n  \n### escrow.h\n\n|\n\n### escrow.h\n\n| Fix a typo.  \n  \n### main.c\n\n|\n\n### main.c\n\n| Add LICENCE.  \n  \n## Repository files navigation\n\n# File descriptor escrow library\n\nby Nikita Danilov danilov@gmail.com\n\n## BUILD\n\n    \n    \n    ./build\n\nThis produces:\n\n  * escrow.o: the library object file that you can link into your binary or library\n  * escrowd: the daemon binary that can be started in advance\n  * echo-server, echo-client: a sample client and server demonstrating the use of the escrow library.\n\n## OVERVIEW\n\nThis library provides an interface to send process' file descriptors to a\nseparate process (\"escrow daemon\", \"escrowd\"). The descriptors can be\nretrieved later by the sender process or by another process.\n\nThe motivating use case for the library is zero-downtime service upgrade:\nconsider a network service that maintains socket connections from multiple\nclients. To upgrade the service to a new version:\n\n  * bring it to a \"quiescent state\" that is, pause accepting new client connections and new requests from the existing connections, and complete all ongoing requests;\n  * place all the sockets in the escrow;\n  * exit the service process;\n  * start the new version;\n  * retrieve all sockets from the escrow;\n  * resume request and connection processing.\n\nFrom the client perspective this process is transparent (save for a delay):\nthe connection to the server is not broken. Note that escrowd is single-\nthreaded and can have at most a single client at a time. Hence, the new\nservice version binary can start before the previous instance terminated: it\nwill be safely blocked in an attempt to connect to escrowd until the previous\ninstance disconnects.\n\nThe same mechanism can be used for recovery after a process crash, except in\nthis case there is no guarantee that the connections were left in some known\nstate, and the recovery code needs to figure out how to proceed.\n\nAn escrow can also be used to provide access to \"restricted\" file descriptors:\na priviledged process can open a device or establish and authenticate a\nconnection and then place the resulting file descriptor in an escrow, from\nwhich it can be retrieved by any properly authorised process.\n\nOne can imagine load-balancing by passing live client connections between\nmultiple instances of a service perhaps across container boundaries.\n\n## INTERFACE OVERVIEW\n\nAn escrow connection is established by calling escrow_init(). A parameter of\nthis function is the path to a UNIX domain socket used for the communication\nwith the escrowd. Access to the escrow is authorised by the usual access rules\nfor this pathname.\n\nAn escrowd process listening on the socket can be started explictly in\nadvance. Alternatively, when escrow_init(), called with ESCROW_CREAT flag,\ndetermines that nobody is listening on the socket or the socket does not\nexist, it starts the daemon automatically.\n\nWhen a file descriptor is placed in an escrow, the user specifies a 16-bit tag\nand a 32-bit index within the tag. Tags can be used to simplify descriptor\nrecovery. For example, in the service upgrade scenario described above, the\nservice can place all listener sockets in one tag and all accepted stream\nsockets in another. The recovery can first recover all listeners and then all\nstreams. The total number of tags is specified when the escrow is created.\n\nIn addition to the tag and the index, a file descriptor has an optional\n\"payload\" of up to 32KB. The payload is stored in and retrieved from the\nescrow together with the file descriptor. In fact, it is possible to store and\nretrieve payload only without a file descriptor, by providing (-1) as fd\nargument to escrow_add(). This makes escrowd a simple memory-only data-base. A\ntypical use of payload is to store auxiliary information about the file\ndescriptor that recovery uses to restore application-specific per-descriptor\nstate.\n\nSee escrow.h for details.\n\n  * int escrow_init(const char *path, uint32_t flags, int32_t nr_tags, struct escrow **escrow): Establishes a connection to escrowd, starting it if necessary. nr_tags is the number of tags that a newly started escrowd will have.\n\n  * void escrow_fini(struct escrow *escrow): Finalises the escrow connection.\n\n  * int escrow_tag(struct escrow *escrow, int16_t tag, int32_t *nr, int32_t *nob): Returns information about a tag. In nr the maximal used index in this tag plus one is placed. Note, that some indices less than the maximal one can be absent. In nob the sum of payload sizes of all descriptors in the tag is placed. This can be used to pre-allocate memory for payloads before the recovery.\n\n  * int escrow_get(struct escrow *escrow, int16_t tag, int32_t idx, int *fd, int32_t *nob, void *data): Retrieves the descriptor with the given index in the given tag. *nob contains the size of the payload buffer data. The retrieved descriptor is placed in *fd, the actual size of the payload is returned in *nob. The payload is copied into data, truncated at the original size in *nob if necessary. It is up to the user to close the returned file descriptor.\n\n  * int escrow_add(struct escrow *escrow, int16_t tag, int32_t idx, int fd, int32_t nob, void *data): Places the descriptor and its payload in the escrow.\n\n  * int escrow_del(struct escrow *escrow, int16_t tag, int32_t idx): Deletes the descriptor and its payload from the escrow.\n\n## RETURN VALUES\n\nAll functions return 0 on success, a negated errno value on a failure.\n\n## CONCURRENCY\n\nThe interface is neither MT nor ASYNC safe. In case of a multi-threaded user,\nexplicit serialisation is needed.\n\n## TRANSPORTABILITY\n\nThe code should compile on any reasonable UNIX. Linux-specific and Darwin-\nspecific bits (mostly setting the process name for escrowd) are compiled\nconditionally.\n\n## EXAMPLES\n\necho-client.c and echo-server.c are a simple echo client and service: the\nsingle-threaded server listens on the local port 8087, accepts connections\nthere and echoes back everything received form a client. The implementations\nare deliberately simplified, they are not supposed to represent how socket\nservices should be implemented.\n\necho-server.c demonstrates the use of an escrow. The simplified echo-server\ncode is the following:\n\n    \n    \n    int main() { int sock; struct escrow *escrow; int result = escrow_init(argv[1], ESCROW_VERBOSE | ESCROW_FORCE, 1, &escrow); /* * Retrive the socket from the escrow. * * If this is the first time the server connects to the escrow, this * returns -ENOENT and places -1 into sock. * * If the echo-server is restarted, the escrow returns the socket that * the previous instance of the echo-server placed there. */ escrow_get(escrow, 0, 0, &sock, &nob, &ch); if (sock == -1) { /* Create sock, bind, listen and accept ... */ /* Place the accepted stream socket in the escrow. */ escrow_add(escrow, 0, 0, sock, nob, &ch); } /* Loop until the client disconnects, echo back. */ while ((result = read(sock, &ch, sizeof ch)) > 0) { write(sock, &ch, result); } /* Delete from the escrow. */ escrow_del(escrow, 0, 0); escrow_fini(escrow); return 0;\n\nExecute the following commands:\n\n    \n    \n    # Run the echo-server, using \"usock\" to communicate with escrowd. # This will start an instance of escrowd. ./echo-server usock\n\nIn another shell, run the client:\n\n    \n    \n    # Start the client. It will connect to the server and loop forever, # ... verifying that the server echoes back correctly. ./echo-client\n\nKill the server:\n\n    \n    \n    pkill -9 echo-server\n\nNote that the client is still connected, because the socket descriptor is\nstored in escrow. Start the server again. It retrieves the socket from the\nescrow and continues echoing to the client.\n\n    \n    \n    ./echo-server usock\n\nYou can check (via top) that client and server are busy comminicating.\n\nAlternatively, you can start escrowd in advance as escrowd ./usock.\n\necho-server calls escrow_init() with ESCROW_VERBOSE flag, so you can see the\nmessage exchange between the echo-server and escrowd:\n\n    \n    \n    Starting escrowd (111). # escrow_init() starts new escrowd, because it got ECONNREFUSED on the socket Listening on \"usock\" # escrowd listens on the UNIX domain socket. Connected to \"usock\" # echo-server connects to the UNIX domain socket (again). send: {GET 0 0} (-1) 0 # echo-server tries to retrieve the TCP socket from the escrow recv: {GET 0 0} (-1) 0 # It's not there (yet). send: {REP -2 \"Non-existent index in a GET request.\"} (-1) 0 # ENOENT reply is sent back recv: {REP -2 \"Non-existent index in a GET request.\"} (-1) 0 # the reply is received by echo-server Received from the escrowd: -2 \"Non-existent index in a GET request.\" send: {ADD 0 0 5 0} (5) 0 # At this point, the client connects and echo-server places the accepted stream socket in escrow recv: {ADD 0 0 5 0} (6) 0 # escrowd receives the socket send: {REP 0 \"\"} (-1) 0 # Reply is sent ... recv: {REP 0 \"\"} (-1) 0 # ... and received. Killed # echo-server is killed. Connected to \"usock\" # echo-server restarts and connects to \"usock\". send: {GET 0 0} (-1) 0 # echo-server tries to retrieve the TCP socket from the escrow. recv: {GET 0 0} (-1) 0 # escrowd receives the request. send: {ADD 0 0 5 0} (6) 0 # escrowd replies with the socket descriptor that ... recv: {ADD 0 0 5 0} (4) 0 # ... the previous instance of echo-server placed.\n\n## TODO\n\n  * Add an interface to plug escrow client to select/poll/epoll\n\n  * Add tests\n\n## About\n\nFile descriptor escrow library\n\n### Topics\n\nlinux socket unix opensource process recovery lgpl\n\n### Resources\n\nReadme\n\n### License\n\nView license\n\nActivity\n\n### Stars\n\n0 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * C 99.4%\n  * Shell 0.6%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
