{"aid": "40001398", "title": "McCarthy's Ambiguous Operator (2005)", "url": "http://www.randomhacks.net/2005/10/11/amb-operator/", "domain": "randomhacks.net", "votes": 2, "user": "Tomte", "posted_at": "2024-04-11 12:28:56", "comments": 0, "source_title": "McCarthy's Ambiguous Operator", "source_text": "McCarthy's Ambiguous Operator | Random Hacks\n\nRandom Hacks\n\nRandom code snippets, projects and musings about software from Eric Kidd, a\ndeveloper and occasional entrepreneur. You're welcome to contact me!\n\n# McCarthy's Ambiguous Operator\n\nOct 11, 2005 \u2022 by Eric Kidd\n\nBack in 1961, John McCarthy (the inventor of LISP) described an interesting\nmathematical operator called amb. Essentially, amb hates to be called with no\narguments, and can look into the future to keep that from happening. Here\u2019s\nhow it might look in Ruby.\n\n    \n    \n    # amb will (appear to) choose values # for x and y that prevent future # trouble. x = amb 1, 2, 3 y = amb 4, 5, 6 # Ooops! If x*y isn't 8, amb would # get angry. You wouldn't like # amb when it's angry. amb if x*y != 8 # Sure enough, x is 2 and y is 4. puts x, y\n\nOf course, amb can\u2019t actually see the future. However, it can rewind into the\npast whenever it sees trouble, and try a different coice.\n\nSo, how could we implement this function? As it turns out, we need\ncontinuations. Here\u2019s a basic implementation in Ruby.\n\n    \n    \n    # A list of places we can \"rewind\" to # if we encounter amb with no # arguments. $backtrack_points = [] # Rewind to our most recent backtrack # point. def backtrack if $backtrack_points.empty? raise \"Can't backtrack\" else $backtrack_points.pop.call end end # Recursive implementation of the # amb operator. def amb *choices # Fail if we have no arguments. backtrack if choices.empty? callcc {|cc| # cc contains the \"current # continuation\". When called, # it will make the program # rewind to the end of this block. $backtrack_points.push cc # Return our first argument. return choices[0] } # We only get here if we backtrack # using the stored value of cc, # above. We call amb recursively # with the arguments we didn't use. amb *choices[1...choices.length] end # Backtracking beyond a call to cut # is strictly forbidden. def cut $backtrack_points = [] end\n\nIf you\u2019d like a fun, non-technical overview of continuations, see the\nexplanation at RubyGarden.\n\n### More posts\n\n  * Why Ruby is an acceptable LISP (2005)\n  * Pair programming with ChatGPT: A simple dice roller\n  * Bare Metal Rust 2: Retarget your compiler so interrupts are not evil\n  * Monads in 15 minutes: Backtracking and Maybe\n  * 13 Ways of Looking at a Ruby Symbol\n\nWant to contact me about this article? Or if you're looking for something else\nto read, here's a list of popular posts.\n\nDan Piponi wrote on Feb 22, 2006:\n\nI have an implementation of \"amb\" that can be used in C here. Thanks for\ngiving a name to this operator for me - I never knew what to call it.\n\nBen wrote on Jan 17, 2007:\n\nThats really interesting. It means that you could write a constraint DSL in\nRuby or any other language which implements continuations. I thought\nconstraint engines were hard... Cheers Ben\n\nBen wrote on Jan 17, 2007:\n\nWow, I just implemented the send+more=money solver with amb:\n\n    \n    \n    # define variables m = 1 n = amb(0, 2, 3, 4, 5, 6, 7, 8, 9) o = amb(0, 2, 3, 4, 5, 6, 7, 8, 9) r = amb(0, 2, 3, 4, 5, 6, 7, 8, 9) s = amb(2, 3, 4, 5, 6, 7, 8, 9) y = amb(0, 2, 3, 4, 5, 6, 7, 8, 9) e = amb(0, 2, 3, 4, 5, 6, 7, 8, 9) d = amb(0, 2, 3, 4, 5, 6, 7, 8, 9) # reduce the problem space amb unless(d+e == y || d+e == y+10) amb unless(s+m+1 >= 10) # The actual problem send = s*1000 + e*100 + n*10 + d more = m*1000 + o*100 + n*10 + e money = m*10000 + o*1000 + n*100 + e*10 + y amb unless(send+more == money) # p \"m=#{m}, n=#{n}, o=#{o}, r=#{r}, s=#{s}, y=#{y}, e=#{e}, d=#{d},\" # Make sure all variables are different a = [m, n, o, r, s, y, e, d] t = Array.new(10, 0) a.each { |v| amb unless (t[v]+=1)<2 } # stop cut p \"Final solution: m=#{m}, n=#{n}, o=#{o}, r=#{r}, s=#{s}, y=#{y}, e=#{e}, d=#{d},\"\n\nAmb is pretty cool! Ben\n\nEric Kidd wrote on Jan 21, 2007:\n\nWow! That's very cool. If you're into constraint languages, you might also\nenjoy Oz, which can do heavily-optimized searches of constraint problems. The\nbig advantage of Oz: Before choosing which path to investigate, it tries to\ninfer as much information as possible (aka \"propagation\"). And then it makes\nvery intelligent guesses about exactly which \"guess\" to make next (aka\n\"distribution\"). Since a backtracking search takes O(2^N) time (yikes!), it's\nworth doing a _lot_ of work before actually branching. And the most popular\nimplementation of Oz can actually spread the search over an entire cluster of\ncomputers!\n\nChristian Theil Have wrote on Jun 08, 2007:\n\n\"Since a backtracking search takes O(2^N) time (yikes!), it\u2019s worth doing a\nlot of work before actually branching.\" This really depends on the nature of\nthe problem. If you are only going to backtrack a little, it might not be\nworth spend cycles on forward-checking or ensuring arc consistency.\nPropagation can also be quite costly. But sure, in most cases, amb is not a\nvery efficient way solving constraint problems..\n\nDoug Auclair wrote on Nov 28, 2007:\n\n@Christian, you are quite right! For this particular problem\n(SEND+MORE=MONEY), eliminated selected digits narrows the search-space\nconsiderably, speeding up the calculation by a factor of ~50:\nhttp://www.cotilliongroup.com/arts/DCG.html (done with Prolog's definite\nclause grammars, which have a similar feel to Haskell's monads) And, I\nsuppose, one can use, e.g., Gwydion Dylan's matrix library\n(http://www.opendylan.org/gdref/gdlibs/libs-matrix-operations.html), along the\nlines of a gausse-jordan elimination, to solve the system of equations\nlinearly? Perhaps not apropos to this problem, but handles several kinds of\nconstraint problems.\n\nDoug Auclair wrote on Nov 29, 2007:\n\nThe Haskell version of SEND+MORE=MONEY in the amb-style:\n\n    \n    \n    > sendmory = [(s,e,n,d,m,o,r,y) | s <- pos, e <- all, n <- all, d <- all, > m <- [1], o <- all, r <- all, y <- all, > y == d + e || y == d + e - 10, > s + m + 1 >= 10, > num [s,e,n,d] + num [m,o,r,e] > == num [m,o,n,e,y], > allDiff [s,e,n,d,m,o,r,y]] > where > pos = [2..9] > all = 0:pos > num :: [Int] -> Int > num = foldl ((+).(*10)) 0 > allDiff :: [Int] -> Bool > allDiff [] = True > allDiff (x:xs) = notElem x xs && allDiff xs\n\n... note that a definition for amb is unnecessary, as list compression (as a\nMonadPlus) already makes choice. The above, as already pointed out, is not\nvery efficient, so using a state monad to narrow the selection in-place:\n\n    \n    \n    > sendmory' :: StateT [Int] [] [Int] > sendmory' = -- do [m] <- item > -- verify (m == 1) > -- the first two lines can be written 'do let m = 1' > -- iff the passed in list does not contain the number 1 > do let m = 1 > [s] <- item > verify (s + m + 1 >= 10) > [e] <- item > [d] <- item > [y] <- item > verify (y == d + e || y == d + e - 10) > [n] <- item > [o] <- item > [r] <- item > verify (num [s,e,n,d] + num [m,o,r,e] > == num [m,o,n,e,y]) > -- item obviates allDiff > return [s,e,n,d,m,o,r,y] > > -- split list into all combinations of one element and rest > splits :: [a] -> [([a],[a])] > splits l = splitAccum [] l where > splitAccum ys [] = [] > splitAccum ys (x:xs) = ([x],xs++ys) : splitAccum (x:ys) xs > choose :: StateT [a] [] [a] > choose = StateT $ \\s -> splits s > item :: StateT [Int] [] [Int] > item = choose > verify :: Bool -> StateT [Int] [] () > verify p = StateT $ \\s -> if p then [((), s)] else []\n\nsplits, choose, and verify are thanks to Dirk Thierbach on comp.lang.haskell.\nThis version is 200x faster than the amb-style one -- 10x speed up for\nredundant digit elimination and on top of that a 20x speed up from placing the\nguards as far up in the computation as possible. Although it requires some\nhelper functions to implement nondeterminism with elimination, sendmory'\nretains the declarative feel of it's amb-styled counterpart.\n\nbacktrack wrote on Sep 09, 2008:\n\nThere's also goal directed computation as implemented in the Icon language,\nthough you probably know about it.\n\nperson-b wrote on Jul 03, 2009:\n\nThis reminds me of Damian Conway's Positronic::Variables CPAN Perl module. He\nwrote it for his (hilarious - highly recommended) talk on \"Temporally\nQuaquaversal Virtual Nanomachine Programming In Multiple Topologically\nConnected Quantum-Relativistic Parallel Timespaces...Made Easy!\"\n(http://blip.tv/file/1145545/). It actually did look into the future.\n\n## Random Hacks\n\n  * Contact me\n\n  * Portfolio\n  * emk\n  * emk\n\nRandom code snippets, projects and musings about software from Eric Kidd, a\ndeveloper and occasional entrepreneur.\n\n", "frontpage": false}
