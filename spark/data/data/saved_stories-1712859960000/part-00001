{"aid": "40001370", "title": "Clojure's slow start \u2013 what's inside?", "url": "https://clojure-goes-fast.com/blog/clojures-slow-start/", "domain": "clojure-goes-fast.com", "votes": 2, "user": "goranmoomin", "posted_at": "2024-04-11 12:24:16", "comments": 0, "source_title": "Clojure's slow start \u2014 what's inside?", "source_text": "Clojure's slow start \u2014 what's inside? - Clojure Goes Fast\n\n## Clojure Goes Fast\n\n\u21b0 Back to list\n\nJan 02, 2018\n\n# Clojure's slow start \u2014 what's inside?\n\nIt is not surprising that the question of Clojure's long startup time is\nraised time and time again on forums and social media. This topic concerns\nusers who want to use Clojure as a scripting language, or who have a\nparticular workflow which requires restarting the Clojure program often.\nCompared to languages like Python, Ruby, and JavaScript all of which have less\nthan 100 millisecond startup time, Clojure's seconds or even tenth of seconds\nseem incredibly slow and wasteful.\n\nThe nature of Clojure loading is not exactly a secret. A few years ago\nNicholas Kariniemi profiled Clojure startup process and described his findings\nin the post \"Why is Clojure bootstrapping so slow?\". One of the points Nick\nbrings forward is that JVM is not to blame for Clojure's slowness \u2014 after all,\na HelloWorld in Java executes in 50 ms. This is only partly true, JVM's\nstartup time is not a problem, but the JVM as a platform makes Clojure\nstarting time worse. JVM is optimized towards running long-lived programs and\ninvests a lot of time upfront when initializing the classes. That's why\nClojure on JVM boots much slower than ClojureScript on NodeJS.\n\nThe silver lining in this situation, and the main thing that keeps Clojure\nalive even with its ludicrously long bootstrap, is the REPL, of course. So\nwhat that you have to wait seconds until the project starts \u2014 you'll get your\nrevenge later, when the results in the REPL come back instantly while others\nare busy recompiling and reloading. With some dexterity, you might not restart\nyour REPL for days. E.g., Leiningen and Boot both allow to dynamically inject\nnew dependencies into a running REPL (in Leiningen you'll need clj-refactor or\nAlembic, Boot can do that by itself). If you are worried about polluting your\nREPL state, you can adopt a workflow like Reloaded. Even when writing new\nscripts, I prefer starting a REPL, connecting to it from Emacs, and then\ninteractively produce pieces of the script as I go.\n\nSo, there aren't many reasons to restart Clojure programs as you would do with\nPython, for example. Yet the questions stand \u2014 what exactly is behind\nClojure's slow start and can we do anything about it? Today we'll try to\nanswer the first one in an exhaustive and reproducible way.\n\n### Experiment description\n\nWe are going to profile Clojure's \"time to REPL\" for three common use cases:\nbare Clojure using Clojure CLI, Leiningen, and Boot. In all three cases, we'll\nbe using the minimum possible number of dependencies (nothing besides what\ncomes with or is required by the build tool). Clojure version is 1.9.0 in all\ncases.\n\nFor profiling, we'll take async-profiler which has the ability to begin\nprofiling from the very start of JVM process. In the previous post, I\nannounced a Clojure wrapper around async-profiler \u2014 we won't need it here\nbecause it is not suited for startup profiling. The default async-profiler is\nprecisely what we need here.\n\nWe will not add any \"accelerating\" JVM flags like -XX:+TieredCompilation\n-XX:TieredStopAtLevel=1 -Xverify:none. While I use those day-to-day, the\nchoice to enable them is opinionated and has certain tradeoffs.\n\nThis post is about profiling, not benchmarking, so the parameters of my\ntesting rig are less critical. For what it's worth, I ran these experiments on\nMacBook Pro 2015 with 3.1 GHz Core i7.\n\n### Setup\n\nTo reproduce the experiments in this post do the following steps.\n\nGet async-profiler. First, clone it from Github. Then you'll have to compile\nthe native agent with make. Note that JAVA_HOME environment variable must be\nset when running make. On MacOS you can do:\n\n    \n    \n    $ JAVA_HOME=$(/usr/libexec/java_home) make\n\nIf all goes well, you'll find a directory build, with two files: jattach and\nlibasyncProfiler.so. We'll only be needing the last one. You may move this\nfile into a more convenient place or keep it here; just keep in mind that\nwhenever in the post we refer to libasyncProfiler.so, it means the valid path\nto the file.\n\nClone FlameGraph repository. We'll need it for generating flamegraphs from the\nprofiling data. We'll invoke specifically flamegraph.pl, again, substitute it\nwith a valid path when running this command.\n\nThis guide describes how to install Clojure CLI. Boot and Leiningen can be\ndownloaded from their respective websites.\n\n### Clojure\n\nCheck if you have the correct Clojure version:\n\n    \n    \n    $ clj ~ Clojure 1.9.0 user=>\n\nNow let's measure the time from start to instant exit:\n\n    \n    \n    $ time clj -e '(System/exit 0)' clj -e '(System/exit 1)' 1.80s user 0.12s system 181% cpu 1.057 total\n\nThe time is around 1 second. It is much less than dozen-of-seconds load times\nyou might have experienced with real-world projects. So, Clojure is not the\nprimary time hog after all. But it is still too long for something so\nseemingly simple. Let's find out what is happening exactly.\n\n    \n    \n    $ cd /tmp $ clj -J-agentpath:/path/to/agent/libasyncProfiler.so=start,event=cpu,file=raw-clojure.txt,collapsed -e '(System/exit 0)' $ /path/to/FlameGraph/flamegraph.pl --colors=java --minwidth 2 raw-clojure.txt > raw-clojure.svg\n\nNow, you can view the resulting flamegraph in the browser by visiting\nfile:///tmp/raw-clojure.svg. Or just see my image below.\n\nRaw Clojure startup flamegraph (View in full)\n\nNote: I trimmed my flamegraphs a little so that they fit easier on the screen.\nFrames like (require ...) are manually collapsed.\n\nIf you haven't learned yet how to read flamegraphs, now is the excellent\nopportunity to do so. The vertical axis shows stacktraces going from bottom to\ntop. On the horizontal axis, the width corresponds to how often the frame was\nseen on the stack during the execution (\u2248 time spent in the method). Relative\nposition of frames on X-axis is arbitrary and doesn't mean anything. You can\nclick the frames to zoom in/out on particular stacktraces.\n\nYou can explore the flamegraph on your own; meanwhile, I will list the main\npoints of interest, together with some explanations. If you can't find a\nstackframe I'm referring to, use Search button in the top right corner and\nenter the sought frame.\n\n  * The biggest part is clojure/lang/RT.load (73.03%) that comes into clojure/core__init.<clinit> (64.29%). That corresponds to the initialization of clojure.core namespace. The time spent there is so long because the namespace is that large, it is already ~7700 LOC and counting.\n\n    * Its largest constituent is clojure/core__init.load (59.36%). This is where Vars are assigned their values and metadata, and top-level non-defining forms are executed. We can still distinguish several big chunks.\n\n      * clojure/core$fn__8055.invoke (7.14%) corresponds to this form which loads core_instant18 namespace (actually, I couldn't tell it from the flamegraph, I had to go to decompile the generated class). I'm not sure why the namespace takes so long to load though \u2014 it seems tiny, with just a single extend-protocol call. Needs further investigation.\n      * (load ...) (11.70%) and (require ...) (5.42%) loads and initializes many medium-to-big namespaces like clojure.pprint, clojure.java.io, clojure.core.protocols, etc. Those namespaces contain many definitions and plenty of top-level execution which adds to the loading time significantly.\n      * java/lang/ClassLoader.loadClass (23.40%) is where the JVM loads the monster of a class that clojure/core__init.class is (by the way, its size is 316Kb).\n  * The tower on the right, clojure/lang/Var.invoke (18.23%), loads clojure.core.server namespace, which through clojure.main triggers loading of clojure.spec.alpha. Spec is the latest addition to the language, and while it has many useful applications, it is a big piece of machinery that takes a while to load.\n\nWe see that the most significant contributor to Clojure load time is the size\nof its base library. There are several potential ways to help that:\n\n  * Reduce the time needed to load each definition. This would be perfect, but there are no obvious ways to do so yet.\n  * Separate the namespaces more and reduce the number of definitions that need to be loaded immediately. Achievable, but does only so much \u2014 when more libraries and code are added to the project, the delayed definitions will probably get loaded, incurring the time costs anyway.\n\n### Leiningen\n\nWe are using Leiningen 2.8.1.\n\n    \n    \n    $ lein version Leiningen 2.8.1 on Java 1.8.0_102 Java HotSpot(TM) 64-Bit Server VM\n\nTo profile Leiningen startup, we need a more complicated setup. First, we'll\nhave to create a new Lein project; otherwise, there is no way to specify the\nexact Clojure version for lein repl.\n\n    \n    \n    $ lein new profile-lein $ cd profile-lein $ sed -i 's/1\\.8\\.0/1.9.0/g' project.clj $ lein repl ... Clojure 1.9.0\n\nNow we can measure the startup time with Lein:\n\n    \n    \n    $ echo '(System/exit 0)' | time lein repl ... lein repl 6.88s user 0.61s system 124% cpu 6.003 total\n\nThe elapsed time of 6 seconds is much more than Clojure's original second.\nLet's find out what exactly happens in there. There are some changes to be\nmade to project.clj, here's what it should look like:\n\n    \n    \n    (defproject profile-lein \"0.1.0-SNAPSHOT\" :jvm-opts [\"-agentpath:/path/to/agent/libasyncProfiler.so=start,event=cpu,file=lein-child.txt,collapsed\"] :dependencies [[org.clojure/clojure \"1.9.0\"]])\n\nAnd then launch the REPL like this:\n\n    \n    \n    $ echo '(System/exit 0)' | LEIN_JVM_OPTS='-agentpath:/path/to/agent/libasyncProfiler.so=start,event=cpu,file=lein-host.txt,collapsed' lein repl\n\nYou've probably noticed that we specified the async-profiler agent string\ntwice. It is not accidental. Leiningen launches two Clojure processes: one for\nitself, and one for the actual project. We need to profile both of them, so we\ndo, and we save the output to different files, lein-host.txt and lein-\nchild.txt. Then, thanks to the beautiful textual nature of collapsed\nstacktraces, we can straightforwardly merge them[1]:\n\n    \n    \n    $ cat lein-host.txt lein-child.txt > lein.txt $ /path/to/FlameGraph/flamegraph.pl --colors=java --minwidth 2 lein.txt > lein.svg\n\nLeiningen startup flamegraph (View in full)\n\nI have heavily redacted this flamegraph to make it easier to navigate. Your\nflames would be higher.\n\n  * On the left, you'll see a familiar subgraph, clojure/main.<clinit> (26.40%), where the base Clojure is loaded. One thing is different: it contains twice the sample count compared to when we profile bare Clojure. This is because Leiningen loads Clojure twice.\n  * Green java/lang/Thread.run (10.61%) on the right contains initialization of Leiningen namespaces and tools.nrepl middleware. Significant part goes to loading clojure-complete (clojure/lang/AFn.call, 6.17%).\n  * Now to the elephant in the room, clojure/main.main (62.00%).\n\n    * clojure/lang/RestFn.applyTo (18.41%) consists mostly of tools.nrepl.sever initialization.\n    * clojure/core$require.invokeStatic (13.88%) in the middle eventually comes to loading pomegranate, a library for resolving dependencies through Maven.\n    * Thin column leiningen/core/project$read.invoke (3.61%) goes through leiningen/core/project$load_plugins.invoke (3.32%) towards cemerick/.../aether$resolve_dependencies (3.18%). Looks like here Leiningen resolves plugins through Pomegranate.\n    * leiningen/core/main$task_args.invoke (5.57%) also seems to be executing nREPL-related code.\n    * What's left, leiningen/core/main$apply_task.invoke (20.51%) ultimately calls Reply, Clojure's alternative REPL client.\n\nWith this knowledge we can approximate that Leiningen's bootstrap process\nconsists of:\n\n  * Loading Clojure twice (26.40%, 1.58 s)\n  * Resolving dependencies (17.49%, 1.05 s)\n  * Initializing REPL server and client: (50.66%, 3.04 s)\n\nI think there is room for improvement here, especially on the REPL side. More\nthorough investigation of tools.nrepl and Reply might reveal potential\ncandidates for optimization.\n\n#### Boot\n\nCheck Boot version. If Clojure is not 1.9.0, change it in\n~/.boot/boot.properties.\n\n    \n    \n    $ boot -V ... BOOT_CLOJURE_VERSION=1.9.0 BOOT_VERSION=2.7.2\n\nNow measure the start time:\n\n    \n    \n    $ time boot repl -s boot repl -s 14.71s user 0.60s system 288% cpu 5.303 total\n\n5.3 seconds, almost the same as Leiningen.\n\n    \n    \n    $ BOOT_JVM_OPTIONS='-agentpath:/path/to/agent/libasyncProfiler.so=start,event=cpu,file=boot.txt,collapsed' boot repl -s $ /path/to/FlameGraph/flamegraph.pl --colors=java --minwidth 2 boot.txt > boot.svg\n\nBoot startup flamegraph (View in full)\n\n  * Left part, Boot.main (19.35%) loads Boot's own namespaces. Boot has quite a lot of features, thus plenty of code to load.\n  * Our old friend, Clojure initialization graph, is in the middle as clojure/lang/RT.<clinit> (36.89%). Unlike Leiningen, Boot doesn't start two JVM processes, but the number of samples loading Clojure is on par with Lein. Why is it so? It is due to Boot's feature called pods. Boot runs in a single JVM process, but it still loads Clojure twice, one for its own purposes (build tooling), and one for the application context.\n  * Green .../ClojureRuntimeShimImpl.require (21.00%) seems to be initializing more Boot namespaces.\n  * clojure/lang/AFn.call (19.75%) on the right resolves and adds dependencies (4.46%), initializes tools.nrepl (11.31%), and prettifies REPL exceptions with pretty (2.75%).\n\nTo summarize, Boot spends those 5.3 seconds on:\n\n  * Loading Clojure twice (36.89%, 1.96 sec)\n  * Initializing its own namespaces (43.1%, 2.28 sec)\n  * Preparing the REPL (14.06%, 0.75 sec)\n  * Resolving dependencies (4.46%, 0.24 sec)\n\nI think the easiest way to reduce Boot loading time would be to trim the\nnumber of functions that need to be loaded from the start. From there, there\nare no immediately apparent optimizations.\n\n### Conclusions\n\nAs it turns out, Clojure start time is a complicated and multi-dimensional\ntopic. Clojure projects are slow to start not only because of JVM \u2014 JVM itself\nstarts in ~50 ms \u2014 but because of JVM specifics the classes are loaded slowly.\nClojure projects are slow to start not only because of Clojure \u2014 Clojure\nitself starts in ~1 second \u2014 but because of Clojure specifics, the namespaces,\nespecially not AOT-compiled one, are loaded slowly. And so on.\n\nIn this post, we have observed three common ways to use Clojure and discovered\nwhere the initial lag comes from. We haven't even started on long loading\ntimes of big projects with huge dependency trees. But now you know how to\nprofile the startup of your application regardless of the build tool you are\nusing. And meanwhile your REPL is loading, go make yourself a cup of tea. You\nearned it.\n\n### References\n\n  * Improving Clojure Start Time\n  * Why is Clojure bootstrapping so slow?\n\n##### Footnotes\n\n  1. Notice a Useful use of cat(1)!\u2191\n\nDiscussion on Reddit Discussion on Hacker News\n\n#### 27 Comments\n\nAnonymous\u20226 years ago\n\nClojure is compiling itself each time it starts, it's simply bad design. We\nneed to idolize Rich Hickey a little less.\n\n-6 | Reply\n\nAlexander\u20226 years ago\n\nThat's not true, but it seems you've already made your mind about it. Whatever\nfloats your boat.\n\n0 | Reply\n\nGary Trakhman\u20226 years ago\n\nI think you're implying caching is a technical improvement, but I really don't\nagree. That's effectively the same as 'don't restart your REPL'.\n\n0 | Reply\n\nAlexander\u20226 years ago\n\nI mean AOT, yes. Technical or not, it's a [partial] solution to the problem.\nClojure itself is AOT compiled. Most libraries are not, for a good reason - to\nhave fewer problems with binary compatibility.\n\nSo, again, dynamic compilation is a feature with tradeoffs, not a bad design.\nIt's in the same realm as JVM compiles bytecode to native code at runtime. You\ngive away something to get something else.\n\n1 | Reply\n\nAnonymous\u20226 years ago\n\nYou show how long clojure.core takes to load. That's a base part of the\nlanguage (nobody overrides clojure.core/rest) and is recompiled every time\nclojure starts. That's what I call bad design.\n\n0 | Reply\n\nAlexander\u20226 years ago\n\n> is recompiled every time clojure starts\n\nNo, it is not. clojure.core is AOT-compiled.\n\n1 | Reply\n\n4 Hidden\n\nGary Trakhman\u20226 years ago\n\nIt is the fault of clojure's design to exacerbate jvm class loading times by\ncreating a ton of classes, the biggest culprit is one class per function\ncompilation. That choice keeps the compiler a bit simpler, and it would take a\nmajor change to fix that but also allow first class functions, as big as using\nJava lambdas. To Core's credit, lambdas weren't around at the time, but I\nthink a change like that would never get prioritized. It's really bad on\nAndroid so no surprise that Kotlin's leaner model is winning there.\n\n1 | Reply\n\nAlexander\u20226 years ago\n\nThanks for a detailed response.\n\nIndeed, some of the slowness comes from the necessity to create a new class\nfor each function. I don't think that it's a \"faulty\" design though, more of a\ntradeoff. Like you've said, Java's lambdas and invokedynamic happened after\nClojure's first release. Even then, MethodHandle is quite limited, and I don't\nthink it's possible to rewrite the Clojure compiler to use it instead of\ngeneric IFn protocol. Not to mention backward compatibility with earlier\nClojure code and with Java 6/7. So it's not only about priorities.\n\nRegarding Android, it was me, in fact, who sought opportunities to speed up\nClojure/Android boot time. I achieved reasonable success, and even though I\ndidn't continue my work, there are no fundamental deficiencies in the design\nthat prevent it.\n\n1 | Reply\n\nNathan\u20226 years ago\n\nI'm still coming to grips with how the sausage factory works but I've been\ncurious about a Class per CLJ file. In the REPL that'd get messy quickly\nperhaps.\n\n1 | Reply\n\nAlex Miller\u20226 years ago\n\nRegarding a few things...\n\n  * instant18 - is one of the few namespaces in core that are not AOT'ed (because Clojure is built with an older JDK that does not have access to Instant), which may account for longer load time.\n  * server load time - can be removed if not used, pending patch is at http://dev.clojure.org/jira/browse/CLJ-1891\n  * spec and core specs load is deferred till first macro compilation but the spec load is currently also triggered by use of spec in clojure.main. You can avoid that by AOT'ing and not using clojure.main, invoking java directly. If you go that route, you won't use clj to launch but could still use it to load the classpath.\n  * \"Reduce the time needed to load each definition\" - there is a patch for lazy vars (originally written by Rich in the Clojure fastload branch, cleaned up by me for 1.8) attached to https://dev.clojure.org/display/design/Improving+Clojure+Start+Time. In combination with AOT + direct linking, it has a significant impact on the the number of classes loaded and removes var initialization time for unused vars.\n  * there have been some experiments (in particular by Ghadi Shayban) with invokedynamic and other uses of java 7+ methods for code loading that are quite promising. While invokedynamic was a little sketchy in java 7 and was significantly overhauled in java 8, now that it's had some soak time with lambdas, I think it's something we could consider seriously. removing the old jdk support, bumping asm, etc are all prereqs for that but that's inevitable regardless. I think with some time spent in this area, several areas (including but not limited to lazy var load) can be substantially improved.\n  * some of the new java aot stuff might also be useful specifically for things like clojure core or libs. Hard to say what the tradeoffs are with dynamicity and long-running app performance without a lot more testing though.\n\n8 | Reply\n\nGary Trakhman\u20226 years ago\n\nMy worry here is as the work is substantial, there's also no language spec to\ntest new compilers against and clojure leaks implementation details that\nthings accidentally rely on (garbage in/out) along with high resistance to\nbreaking changes. I think spec can help here, but is there any thought to how\nmuch time it could take to be viable? 'Lean compiler' has been on the radar\nfor years.\n\n1 | Reply\n\nAlexander\u20226 years ago\n\nThank you, Alex! Your explanations are always helpful.\n\n0 | Reply\n\nAlex Miller\u20226 years ago\n\nI think there are relatively small changes that can have a big impact. I'm not\ntalking about \"rewriting the compiler\" or anything. I think these are very\ndoable.\n\n0 | Reply\n\nAnonymous\u20226 years ago\n\nLisp user here.\n\nI love coding in Clojure, but the startup time is ridiculous to what I'm used\nto in typical Common Lisp implementations where you can load up your code and\nall of its dependencies and then save the image to disk (like in Smalltalks)\ne.g. http://www.sbcl.org/manual/#Saving-a-Core-Image Restarting the Lisp with\nthe saved image is instantaneous. Doesn't the JVM have something like that\nfunctionality? Could it be used for Clojure?\n\n0 | Reply\n\nFrancis Avila\u20226 years ago\n\nCommercial Oracle JVM 8 has a feature called \"AppCDS\". CDS = class data\nsharing, essentially making a saved binary image of the result of class\nloading for the hotspot JVM to consume very quickly later and share between\nJVM instances. This feature helps a lot with Clojure startup but requires an\nOracle license. (It will be included in OpenJDK eventually, but I don't know\nwhen.) Java 8 also has AOT compilation (JVM bytecode->machine code), but it's\nnot as big a win with Clojure. This blog post explores the options thoroughly:\nhttps://mjg123.github.io/2017/10/04/AppCDS-and-Clojure.html\n\n1 | Reply\n\nAnonymous\u20226 years ago\n\nAwesome! Thanks for that link\n\n0 | Reply\n\nPaul Bransford\u20226 years ago\n\nIt's a bit of a sledgehammer approach, but CRIU.org could be abused to\naccomplish the task, I think. It's used under the hood by OpenVZ, Docker, LXC\nand the like, if that helps sell the idea.\n\n1 | Reply\n\nPhil\u20226 years ago\n\nI appreciate the detailed breakdown here, and I realize it's not central to\nthe main thrust of this post, but it's a bit disappointing that these kinds of\nposts don't mention how Leiningen's entire startup time penalty can easily be\nskipped with fast trampolining:\nhttps://github.com/technomancy/leiningen/wiki/Faster\n\nApart from that, great post with helpful conclusions.\n\n1 | Reply\n\nAlexander\u20226 years ago\n\nThanks for bringing this up, Phil. I don't think I've ever used fast\ntrampoline, and I don't use Leiningen much these days. But anyway, the goal\nwas to evaluate the raw unmodded startup time and investigate what can be done\nthere. Opt-in features like the fast trampoline, or certain JVM options,\nprobably involve trade-offs (otherwise they would be enabled by default).\n\nSo what I'd like to see improved is the default waiting experience since that\nis what an average user would go through.\n\n0 | Reply\n\nNathan\u20226 years ago\n\nGreat post Alexander!\n\n1 | Reply\n\nstardiviner\u20226 years ago\n\nI profiled my Clojure startup time. Here is my svg file\nhttps://gist.github.com/stardiviner/6a4d720b1617e58523ecc0aa28e065a6 Seems\nvery slow. Do you know why?\n\n0 | Reply\n\nAlexander\u20226 years ago\n\nThe subgraph on the right looks like a separate JIT thread. It seems that you\nare on Linux, you'll know more if you install debug symbols package\n(openjdk-8-dev or similar, depends on which JDK you are using).\n\nIs the start itself slow (more than a second)?\n\n-1 | Reply\n\nAnonymous\u20226 years ago\n\nWould love to see this done with ClojureScript as well, so we could compare.\n\n0 | Reply\n\n\u00a9 2017-2024 Oleksandr Yakushev. Made with Cryogen. Logo is derived from\nClojure logo, copyright by Rich Hickey. Icons from Iconmonstr.\n\n", "frontpage": false}
