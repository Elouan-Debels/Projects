{"aid": "39985197", "title": "PyMiniRacer v0.11.1", "url": "https://bpcreech.com/post/mini-racer-v0.11.1/", "domain": "bpcreech.com", "votes": 1, "user": "bpcreech", "posted_at": "2024-04-09 22:52:19", "comments": 0, "source_title": "PyMiniRacer v0.11.1", "source_text": "PyMiniRacer v0.11.1 - Disparate Treasures\n\nDisparate Treasures\n\nBen Creech's arbitrary stuff\n\n# PyMiniRacer v0.11.1\n\nPoke objects! Call functions! Await promises!\n\nPage content\n\nIn this last blog post, I discussed my revival of PyMiniRacer, a neat project\ncreated by Sqreen to embed the V8 JavaScript into Python. As of that post\n(v0.8.0), I had done a light reorganization of the C++ side of PyMiniRacer,\nbut nothing big there yet. Here we talk about some extensions to PyMiniRacer,\nrolling up the changes up to v0.11.1: JS Object and Array manipulation,\ndirectly calling JS functions from Python, async support, and a discussion of\nthe C++ changes needed to make all that work.\n\nNote: As of this writing on 2024-04-09, v0.11.0 is up on PyPI and I\u2019m building\nthe v0.11.1 release, which has a bug fix for long-running microtasks, and a\nlot of the C++ revamp explained below. Official PyMiniRacer builds take a few\ndays because we build on aarch64 using emulation, so v0.11.1 should be ready\non PyPI approximately 2024-04-11. Check out the full docs for PyMiniRacer\nhere.\n\nSome new PyMiniRacer features:\n\n    \n    \n    from py_mini_racer import MiniRacer mr = MiniRacer() # Direct object and array access! >>> obj = mr.eval('let obj = {\"foo\": \"bar\"}; obj') >>> obj[\"foo\"] 'bar' >>> obj[\"baz\"] = mr.eval('[]') >>> obj[\"baz\"].append(42) >>> mr.eval('JSON.stringify(obj)') '{\"foo\":\"bar\",\"baz\":[42]}' # Call JS functions directly! >>> func = mr.eval('(a) => a*7') >>> func(6) 42 # Promise await support, so you can wait in two languages at once! >>> async def will_you_wait_just_one_second_please(): ... promise = mr.eval('new Promise((res, rej) => setTimeout(res, 1000))') ... await promise ... >>> import asyncio >>> asyncio.run(will_you_wait_just_one_second_please()) # does exactly as requested! >>>\n\nOther new features can be found on the relnotes page, where v0.8.0 was the\nsubject of the last blog post.\n\n## New feature rundown\n\nFirst, I\u2019ll discuss new features for PyMiniRacer. These require an incremental\noverhaul of the C++ side of PyMiniRacer, which is discussed below.\n\n### Manipulating objects and arrays\n\nAs of v0.8.0 and earlier, PyMiniRacer could create and manipulate objects and\narrays only at a distance. Sure, you could easily create objects in the JS\ncontext via MiniRacer.eval statements. However, getting to their contents was\nhard!\n\nMiniRacer.eval could convert primitives like numbers and strings directly to\nPython objects, but to get a property of an object, you had to run an\nevaluation of some JS code which would extract that property, like\nmr.eval(my_obj[\"my_property\"]) instead of simply writing my_obj[\"my_property\"]\nin Python. Or you could give up and JSON.stringify the whole object, and\njson.loads the serialized object on the Python side.\n\nThe more you do it, the more it feels like programming with waldos:\n\nWorking with Objects and Arrays in PyMiniRacer v0.8.0. source\n\nWell, now you can directly mess with objects and arrays from Python! I added a\nMutableMapping (dict-like) interface for all derivatives of JS Objects, and a\nMutableSequence (list-like) interface for JS Arrays. You can now use Pythonic\nidioms to read and write Object properties and Array elements in Python,\nincluding recursively (i.e., you can read Objects embedded in other Objects,\nand embed your own).\n\nThis required tracking v8 object handles within Python (instead of reading and\ndisposing them at the end of every MiniRacer.eval call), which in turn\nrequired revamping the C++ memory management model. More on that below.\n\n### Direct function calls\n\nAs of v0.8.0 and earlier, PyMiniRacer couldn\u2019t directly call a function. You\ncould only evaluate some JS code which would call your function. Passing in\nfunction parameters was likewise awkward; you had to serialize them into JS\ncode. So instead of doing foo(my_str, my_int) in Python, you had to do\nsomething like mr.eval(f'foo(\"{my_str}\", {my_int})'). The MiniRacer.call\nmethod helped with this by JSON-serializing your data for you, but the wrapper\nit puts around your code isn\u2019t always quite right (as reported on the original\nsqreen/PyMiniRacer GitHub issue tracker).\n\nWell, now you can retrieve a function from JS, and then... just call it:\n\n    \n    \n    >>> reverseString = mr.eval(\"\"\" function reverseString(str) { return str.split(\"\").reverse().join(\"\"); } reverseString // return the function \"\"\") >>> reverseString <py_mini_racer.py_mini_racer.JSFunction object at 0x7bb3dc5739a0> >>> reverseString(\"reviled diaper\") 'repaid deliver'\n\nYou can also specify this as a keyword argument, because JavaScript:\n\n    \n    \n    >>> get_whatever = mr.eval(\"\"\" function get_whatever(str) { return this.whatever; } get_whatever // return the function \"\"\") >>> obj = mr.eval(\"let obj = {whatever: 42}; obj\") >>> get_whatever(this=obj) 42\n\nAs with direct Object and Array manipulation, aside from a straightforward\nexposure of C++ APIs to Python, to make this work we have to revamp the C++\nobject lifecyle model; more below.\n\n### Async and timeouts\n\nIt seemed like a big gap that PyMiniRacer, as of v0.8.0 and earlier, could\ncreate JS Promises, but couldn\u2019t do anything to asynchronously await them. I\nwasn\u2019t the only one with this feeling. One of the PyMiniRacer tests did work\nwith promises, but only by polling for completion.\n\nBoth Python and JavaScript have a concept of async code. Can we hook them up?\nYes!\n\nNow you can create a Promise on the JS side and await it either using asyncio\nor using a blocking .get call:\n\n    \n    \n    >>> promise = mr.eval('new Promise((res, rej) => setTimeout(() => res(42), 1000))') >>> await promise # only works within Python \"async def\" functions 42 >>> promise.get() # works outside of python \"async def\" functions and not recommended 42 # within async functions (because it would block up the asyncio loop)\n\nTo make this demo work, I actually also had to write a setTimeout function,\nwhich is funny because it\u2019s so ubiquitous you might forget that it\u2019s not part\nof the ECMA standard, and thus not part of V8\u2019s standard library. (setTimeout\nis a web standard, and also exists in NodeJS. E.g., in browser scripts,\nsetTimeout lives on the window object, but PyMiniRacer has no window object.)\nTurns out we can write a pure-JS setTimeout using only the ECMA standard\nlibraries using a somewhat hacky wrapper of Atomics.waitAsync. I stole this\ninsight from the PyMiniRacer unit tests and spun it into a glorified\nsettTimeout / clearTimeout wrapper in what felt like one of those silly\nimprobable interview questions (\u201cPlease build thing A using only half-broken\ntools B and C!\u201d).\n\nMoreover, this required making PyMiniRacer better at running code indefinitely\nso it would actually process the async work reliably\u2014more on that below.\n\n## Changes to the PyMiniRacer C++ backend\n\nSo, the above features involve overhauling PyMiniRacer. Let\u2019s talk about how I\ndid that!\n\n### clang-tidy\n\nFirst, before getting into C++ changes, I wanted to inherit the best of\nautomated wisdom about how to write C++. I personally have been writing C++\nfor over two decades, but having taken a break from it for 5 years, I missed\nout on the fun of both C++17 and C++20!\n\nSo I added a clang-tidy pre-commit. As well as a clang-format pre-commit,\nbecause duh. Some observations:\n\n  1. clang-tidy has taught me lots of things I didn\u2019t know, e.g., when to std::move stuff and when to rely on guaranteed copy elision, and how to annoy others by using trailing return types everywhere, absolutely everywhere.\n  2. It continually catches my mistakes, like extra copies, extra lambda parameters, and whatnot!\n  3. There is unfortunately no good set of recommended clang-tidy checks everyone should enable (as compared to ESLint for JavaScript, Ruff for Python, etc, which work pretty well out of the box). Some bundled checks are broadly useful for most everyone, and some are are clearly only intended for a limited audience. E.g., the llvm checks are doomed to fail if you\u2019re not writing llvm itself. The altera checks are intended for people writing code for FGPAs. The fuschia checks have some very unusual opinions that I\u2019m sure make sense for the Fuschia project but I cannot imagine there is consenus that, e.g., defaults in function parameters are bad. So everyone using clang-tidy has to figure out, by trial and error, which checks have weird non-applicable opinions and thus have to be disabled.\n  4. The memory management checks seem unhelpful in that I, like most C++ programmers, use smart pointers everywhere, so when the checks fail it\u2019s just noise 100% of the time so far. It seems like these complicated memory-tracking checks could almost be simplified into \u201cuh you used new or delete without a shared pointer\u201d, and then would only usefully trigger for novice C++ programmers.\n  5. clang-tidy is slow; something like 100 times slower than clang itself. It takes about 20 minutes on my old laptop to run over PyMiniRacer, which is only 29 small files.\n\nAnyway, clang-tidy is super useful; would recommend!\n\n### Inverting PyMiniRacer\u2019s threading model\n\nSo, to start off, for async code to work correctly in PyMiniRacer (and also,\nto run code off the Python thread, thus enabling KeyboardInterrupt of\nPyMiniRacer JS code), we need V8 to execute code continually, e.g., to process\ndelayed callbacks from setTimeout. In other words, if want to be able to use\nsetTimeout to schedule work for N seconds from now, and have it actually, you\nknow, run that delayed work, we need to convince V8 to actually run,\ncontinually, until explicitly shut down.\n\nHowever, PyMiniRacer was set up like both of V8\u2019s extensive list of two\nsamples. It ran a thing once, and pumped the V8 message loop a bit, and quit,\nnever to call V8 again (until the next user input). This seems odd: how do you\nknow there is no delayed work? I guess you just assume there\u2019s no delayed\nwork. But at the same time, programs like Chrome, which a few people use, and\nNodeJS, likewise, obviously use V8 in continually-operating form. How do we do\nit?\n\nA couple facts make \u201chow do we do it\u201d tricky to answer:\n\n  1. The v8::Isolate, the environment in which all your JS code runs, is not inherently thread-safe. You need to grab a v8::Locker first to use it safely.\n  2. v8::platform::PumpMessageLoop, the thing that powers all work beyond an initial code evaluation in V8, needs the v8::Isolate lock. However, it does not actually ask for the lock. It does not release the lock either, apparently. And yet we need it to run, continually and without returning control to us. We have to use its wait-for-work mode, (unless we want to use a lot of electricity), which means the message pump is doomed to sit around a lot, doing nothing but hogging the v8::Isolate lock.\n\nSo you need to get the lock to use the Isolate, but you also need to spend a\nlot of time calling this thing (PumpMessageLoop) hogs that lock. How do you\nreconcile these?\n\nMy solution was inspired by the d8 tool, which ships with V8: all code which\ninteracts with the Isolate is \u201cposted\u201d as a \u201ctask\u201d on the Isolate\u2019s\nTaskRunner. Then it will run under the PumpMessageLoop call, where it already\nhas that Isolate lock which PumpMessageLoop has been hogging. Nobody needs to\ngrab the Isolate lock, because they already have it, having been sequenced\ninto the PumpMessageLoop thread as tasks.\n\nThis seems to work, but involved reorganizing all of PyMiniRacer, inverting\ncontrol such that a thread running PumpMessageLoop is the center of the\nuniverse, and everything else just asks it to do work. Even things like \u201chey\nI\u2019d like to delete this object handle\u201d need to be put onto the v8::Isolate\u2019s\ntask queue.\n\nThe resulting setup looks roughly like this:\n\nReading that diagram in order:\n\n  1. The MiniRacer::IsolateMessagePump runs a thread which creates a v8::Isolate,\n  2. ... exposes it to the MiniRacer::IsolateManager,\n  3. ... and loops on v8::platform::PumpMessageLoop until shutdown.\n  4. Then, any code which wants to use the Isolate, such as MiniRacer::CodeEvaluator (the class which implements the MiniRacer.eval function to run arbitrary JS code) can package up tasks into MiniRacer::AdHocTask and\n  5. ... throw them onto the Isolate work queue to actually run, on the message-pumping thread.\n\n#### std::shared_ptr all the things!\n\nOur control inversion to an event-driven design (explained above) is\ncomplicated to pull off safely in C++, where object lifecycle is up to the\ndeveloper. Since everything is event-driven, we have to be very careful to\ncontrol the lifecycle of every object, ensuring objects outlive all the tasks\nwhich reference them. After trying to explicitly control everything, I gave up\nand settled on basically using std::shared_ptr to manage lifecycle for just\nabout everything (regressing to \u201cC++ developer phase 1\u201d as described here). If\na task has a std::shared_ptr pointing to all the objects it needs to run, the\nobjects are guaranteed to still be around when the task runs. This in turn\ninvolves some refactoring of classes, to ensure there are no references cycles\nwhen we implement this strategy. Reference cycles and std::shared_ptr do not\nget along.\n\n#### Threading, in summary\n\nThe above story seems like it should be common to most use of V8, yet all\nseems underdocumented in V8. The solution I landed on involved some educated\nguesses about thread safety of V8 components (like, can you safely add a task\nto the Isolate\u2019s foreground task runner without the Isolate lock? The\nimplementation seems to say so, but the docs... don\u2019t exist! Does\nv8::platform::PumpMessageLoop need the lock? It seems to crash when I don\u2019t\nhave it; core files are a form of library documentation I guess, but maybe I\nwas simply holding it wrong when it crashed?) I have put a question to the\nv8-users group to see if I can get any confirmation of my assumptions here.\n\n### Relieving Python of the duty of managing C++ memory\n\nThere are 5 places where Python and C++ need to talk about objects in memory:\n\n  1. The overall MiniRacer context object which creates and owns everything (including the v8::Isolate discussed above).\n\n  2. JS values created by MiniRacer and passed back to Python (and, when we start doing mutable objects or function calls, JS values created in Python and passed into JS!).\n\n  3. Callback function addresses from C++ to Python.\n\n  4. Callback context to go along with the above, so that when Python receives a callback it understands what the callback is about. (E.g., we typically use a Python-side Future as the callback context here; the callback sends both data and context. The callback function just has to take the data, i.e., a result value, and stuff it into a Future, which it conveniently can find given the callback\u2019s context.)\n\n  5. Task handles for long-running eval tasks, so we can cancel them.\n\nWhile Python\u2019s garbage collector tracks references and automatically deletes\nunreachable Python objects, if you\u2019re extending Python with C (or C++) code,\nyou have to explicitly delete the C/C++ objects. There are kinda two\napproaches for systematically ensuring deletion happens:\n\n  1. with statements:\n\nYou can treat C++ objects as external resources and use `with statements and\ncontext managers to explicitly manage object lifecycle, in user code. There is\nan absolutist view (previously held by me after being burned by finalizers\nbefore; see below) that this is the only way proper way to manage external\nresources (but are in-process C++ objects really \u201cexternal resources\u201d?). Code\nusing context managers to explicitly deallocate all allocated objects would\nlook like, in absolutist form:\n\n    \n        with MiniRacer() as mr: with mr.eval(\"[]\") as array: array.append(42) with mr.eval('JSON.stringify') as stringify_function: with stringify_function(array) as stringified: print(stringified) # prints '[42]' # at this point, the value behind \"stringified\" is freed by calling a C API. # at this point, the value behind \"stringify_function\" is freed by calling a C API. # at this point, the value behind \"array\" is freed by calling a C API. # at this point, the MiniRacer context is freed by calling a C API.\n\n(Astute Pythonistas may note that two of those with statements could be\ncollapsed into one to make it \u201csimpler\u201d. Yay.)\n\nThis is nicely explicit, but extremely annoying to use. (I actually\nimplemented this, but undid it when I started updating the PyMiniRacer README\nand saw how annoying it is.)\n\n  2. Finalizers, aka the __del__ method:\n\nYou can create a Python-native wrapper class whose __del__ method frees the\nunderlying C++ resource. This looks like, e.g.:\n\n    \n        class _Context: def __init__(self, dll): self.dll = dll # (\"dll\" here comes from the ctypes API) self._c_object = self.dll.mr_init_context() def __del__(self): self.dll.mr_free_context(self._c_object) ...\n\nThen user code doesn\u2019t have to remember to free things at all! What could go\npossibly wrong?\n\n#### The trouble with finalizers\n\nWhat could possibly go wrong is that finalizers are called somewhat lazily by\nPython, and in kind of unpredictable order. This problem is shared by Java, C#\nand I assume every other garbage-collected language which supports finalizers:\nif you have two objects A and B which refer to each other (aka a reference\ncycle), but which are obviously otherwise unreachable, obviously you should\ngarbage-collect them.\n\nBut if both A and B have finalizers, which do you call first? If you call A\u2019s\nfinalizer, great, but later B\u2019s finalizer might try and reach out to A, which\nhas already been finalized! Likewise, if you finalize B first, then A\u2019s\nfinalizer might try and reach out to B which is already gone. You can\u2019t win!\nSo if you\u2019re the Python garbage collector, you just call the finalizers for\nboth objects, in whatever order you like, and you declare it to be programmer\nerror if these objects refer to each other in their finalizers, and you\ngenerally declare that finalization order doesn\u2019t matter.\n\nUnfortunately, order sometimes matters. Let\u2019s say those objects A and B are\neach managing C++ objects, C and D, respectively, as depicted above.\nObviously, in the above picture, we should tear down C before D so we don\u2019t\nleave a dangling reference from C to D. The best teardown order here is: A, C,\nB, then D. But Python doesn\u2019t know that! It has no idea about the link between\nC++ objects C and D. It is likely to call B\u2019s finalizer first, tearing down D\nbefore C, thus leaving a dangling reference on the C++ side.\n\nThis happens in practice in MiniRacer: a Python _Context wraps a\nMiniRacer::Context, and a Python _ValueHandle wraps a MiniRacer::BinaryValue.\nBut within C++ land, that MiniRacer::Context is what created those\nMiniRacer::BinaryValue objects, and they each know have pointers into the\nv8::Isolate object which the Context owns. If you free the MiniRacer::Context\nbefore you free the values pointing into its v8::Isolate, things get very\ncrashy, fast. We want Python to free all the _ValueHandle objects before the\n_Context, but there\u2019s no way to tell it that, and worse, the garbage\ncollection ordering is nondeterministic, so it will get it wrong, and crash,\nrandomly.\n\nThe same situation arises for task handles (MiniRacer::CancelableTaskHandle in\nC++), and we have other more mundane risky use of pointers and Python-owned\nmemory with callback function pointers and callback context data.\n\nWhen I started work on it, MiniRacer tracked raw C++ pointers for the\nMiniRacer context only, using __del__ to clean it up. It only used values\nephemerally, converting and cleaning them up immediately (except for\nmemoryview objects into JS ArrayBuffers but that was a rare case). If you\u2019re\nonly using finalizers with one type of object, and instances of that object\ndon\u2019t interact, the reference cycle problem explained above doesn\u2019t exist.\n\nThis worked fine until... I introduced more object types (async tasks,\ncallback functions, callback contexts, and persistent values to track Objects\nand Arrays). More object types means more opportunities for Python to call\nfinalizers in the wrong order.\n\n#### Making finalizers safe\n\nSo the principle I derive from the above: we must refactor things so that\nfinalizer order doesn\u2019t matter. But how do we do it? And otherwise make our\nPython/C++ boundary safe from memory management bugs?\n\nI developed the following strategy:\n\n  1. Avoid passing pointers at all. Instead, pass integer identifiers (specifically uint64_t) between C++ and Python. The identifiers are all created and registered in maps on the C++ side. The map lets the C++ side safely validate, then convert from the identifier to actual object pointers.\n\n     * Two exceptions:\n\n       1. For JS values, for performance reasons, we pass a special BinaryValueHandle which doubles as an identifier and an address which can peek into data for primitive types. (In that case, the map key is the BinaryValueHandle pointer instead of an ID. The mapped value is the full BinaryValue object pointer, which is not directly accessible to Python.) Note that the C++ side still validates any BinaryValueHandle values passed in from Python.\n\n       2. For callback addresses from C++ to Python, we have to use a pointer. Which then means we are at risk of bugs wherein PyMiniRacer accidentally disposes the callback before the C++ side is totally done with it. C\u2019est la vie.)\n\n  2. Thus the C++ side can check for validity of any references it receives from Python, eliminating any bugs related to use-after-free or Python freeing things in the wrong order (i.e., freeing a whole v8::Isolate and only then freeing a JS value which lived in that isolate).\n\n  3. ... And the C++ side can also avoid memory leaks, in that when an \u201cowning container\u201d (like the context object) is torn down, the container (on the C++ side) has a holistic view of all objects created within that container, and can free any stragglers itself, on the spot.\n\nIn this way, we still use __del__ on the Python side, but only as an\nopportunistic memory-usage-reducer. The C++ side is actually tracking all\nmemory usage deterministically and doesn\u2019t rely on Python to get it\nright\u2014especially not the order of operations when freeing things.\n\nAs a cute bonus trick, since we\u2019re tracking all living objects on the C++\nside, can expose methods which count them, for use in our unit tests, to\nensure we don\u2019t have any designed memory leaks! (I caught one pre-existing\nleak this way!)\n\nThe resulting setup, just looking at Contexts and JS Values, sort of looks\nlike the following diagram (and similar goes for async task handles):\n\nWith this new setup, if Python finalizes (\u201ccalls __del__ on\u201d) the _Context\nbefore a _ValueHandle that belonged to that context, aka \u201cthe wrong order\u201d,\nwhat happens now is:\n\n  1. _Context.__del__ calls MiniRacer::ContextFactory to destroy its MiniRacer::Context. MiniRacer::Context destroys the MiniRacer::BinaryValueFactory, which in turn notices some C++ MiniRacer::BinaryValue objects were left alive (before this change, the BinaryValueFactory wasn\u2019t tracking them and thus didn\u2019t even know they still existed). BinaryValueFactory goes ahead and tears all those leftover BinaryValue objects down. This avoids a memory leak, and avoids dangling pointers on the C++ side.\n\n  2. When Python later calls _ValueHandle.__del__, it passes both a context ID and the value handle to MiniRacer::ContextFactory. MiniRacer::ContextFactory notices that the whole context ID is no longer valid because the context was torn down already. The context and its values are already gone. Thus, this call can be safely ignored.\n\nI think the design strategy is generalizable to most Python/C++ integrations,\nand potentially likewise Java/C++ and C#/C++ integrations. (TL;DR: use integer\nidentifiers instead of passing pointers, track object lifecycle in maps on the\nC++ side, validate all incoming identifiers from Python, and refactor so that\nout-of-order finalization doesn\u2019t hurt anything). I wonder if it\u2019s written\ndown anywhere.\n\n## Contribute!\n\nThat wraps up this overly detailed changelog for now!\n\nIf you\u2019re reading this and want to contribute, go for it! See the contribution\nguide.\n\nOne thing I wish PyMiniRacer really had, and don\u2019t have time to build right\nnow, is extension via user-supplied Python callback functions. A more detailed\ndescrition and implementation ideas can be found here.\n\n  * javascript\n  * typescript\n  * python\n\nAbout Ben Creech\n\nBen Creech is definitely a real person and insisting on this fact is not at\nall suspicious.\n\n\u00a9 2024 Ben Creech. Generated with Hugo and Mainroad theme.\n\n", "frontpage": false}
