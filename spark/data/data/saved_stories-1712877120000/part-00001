{"aid": "40004458", "title": "Moc Myths Debunked (2016)", "url": "https://woboq.com/blog/moc-myths.html", "domain": "woboq.com", "votes": 1, "user": "Tomte", "posted_at": "2024-04-11 17:10:44", "comments": 0, "source_title": "Moc myths debunked", "source_text": "Moc myths debunked\n\nEst. 2011\n\n  * Services\n  * Products\n  * Videos\n  * Blog\n\n# Moc myths debunked\n\nI have often read, on various places, criticisms about Qt because of its use\nof moc. As the maintainer of moc I thought it would be good to write an\narticle debunking some of the myths.\n\n## Introduction\n\nmoc is a developer tool and is part of the Qt library. Its role is to handle\nQt's extension within the C++ code to offer introspection and enable\nreflection for Qt Signals and Slots, and for QML. For a more detailed\nexplanation, read my previous article How Qt Signals and Slots work.\n\nThe use of moc is often one of the criticisms given to Qt. It even led to\nforks of Qt, such as CopperSpice. However, most of the so-called drawbacks are\nnot completely founded.\n\n## Myths\n\n### Moc rewrites your code before passing it to the compiler\n\nThis is often misunderstood, moc does not modify or rewrite your code. It\nsimply parses part of your code to generate additional C++ files which are\nthen usually compiled independently. This does not make a big difference\noverall, but is still a technical misconception.\n\nThe moc is just generating some boilerplate code that would be fastidious to\nwrite otherwise. If you were masochist, you would write all the introspection\ntables and implementation of signals by hand. It is so much more convenient to\nhave this auto generated.\n\n### When writing Qt code, you are not writing real C++ 1\n\nI have read this many times, but this is simply false. The macros understood\nby moc to annotate the code are simply standard C++ macros defined in a\nheader. They should be understood by any tool that can understand C++. When\nyou write Q_OBJECT, it is a standard C++ macro that expands to some function\ndeclarations. When you write signals: it is just a macro that expands to\npublic:. Many other Qt macros expand to nothing. The moc will then locate\nthese macros and generate the code of the signal emitter functions, together\nwith some additional introspection tables.\n\nThe fact that your code is also read by another tool than the compiler does\nnot make it less C++. I've never heard that you are not using vanilla C++ if\nyou use tools like gettext or doxygen, which will also parse your code to\nextract some information.\n\n### Moc makes the build process much more complicated 2\n\nIf you are using any mainstream build system, such as CMake or qmake, they\nwill have a native integration of Qt. Even with a custom build system, we are\njust talking about invoking one additional command onto your header files. All\nthe build systems allow this because many projects have some sort of generated\ncode as part of the build. (Things like yacc/bison, gperf, llvm has TableGen)\n\n### It makes the debugging experience harder\n\nSince the moc generated code is pure C++, debuggers or other tools have no\nproblems with it. We try to keep the generated code without warnings or any\nissues that would trigger static or dynamic code analyzers. You will sometimes\nsee backtraces containing frames within the moc generated code. In some rare\ncase you can have errors within the moc generated code, but it is usually\nstraightforward to find their cause. The moc generated code is human readable\nfor most part. It will also probably be easier to debug than the infamous\ncompiler error messages you can get while using advanced template code.\n\n### Removing moc improves run time performance 3\n\nThis is a quote from the CopperSpice home page, and is probably their biggest\nlie. The moc generated code is carefully crafted to avoid dynamic allocation\nand reduce relocations. All the moc generated tables go in const arrays that\nare stored in the shareable read-only data segment. CopperSpice, on the other\nhand, registers the QMetaObject data (information about signals, slots and\nproperties) at run time.\n\nMilian Wolff did some measurements to compare Qt and CopperSpice for his\nCppCon2015 talk. Here is a screenshot from one of his slides (smaller is\nbetter):\n\nIt is also worth mentioning that Qt code with moc compiles faster than\nCopperSpice code.\n\n## Outdated Myths\n\nSome criticisms used to be true, but are long outdated.\n\n### A macro cannot be used to declare a signal, a slot, the base class of an\nobject, or ... 4\n\nBefore Qt5, moc did not expand macros. But since Qt 5.0 moc fully expands\nmacros, and this is no longer an issue at all.\n\n### Enums and typedefs must be fully qualified for signal and slot parameters\n\nThis is only an issue if you want to use the string-based connection syntax\n(as this is implemented with a string comparison). With the Qt5 function\npointer syntax, this is not an issue.\n\n### Q_PROPERTY does not allow commas in its type 5\n\nQ_PROPERTY is a macro with one argument that expands to nothing and is only\nunderstood by moc. But since it is a macro, the comma in QMap<Foo, Bar>\nseparating macro arguments is causing a compilation error. When I saw that\nCopperSpice used this as an argument against Qt, I spent five minutes to fix\nit using C++11 variadic macros.\n\n## Other criticisms\n\n### Template, nested, or multiple inherited classes cannot be QObjects\n\nWhile true, those are just missing features of QObject, which could be\nimplemented in moc if we wanted them. The Qt project does not think these\nfeatures are important.\n\nFor example, I implemented support for templated QObjects in moc, but this was\nnot merged because it did not raise enough interest within the Qt project.\n\nAs a side note, moc-ng supports template and nested classes.\n\nMultiple inheritance is also something that is in itself controversial. Often\nconsidered bad design, it has been left out of many languages. You can have\nmultiple inheritance with Qt as long as QObject comes first as base class.\nThis small restriction allows us to make useful optimization. Ever wondered\nwhy qobject_cast is so much faster than dynamic_cast?\n\n## Conclusion\n\nI believe moc is not a problem. The API and usability of the Qt meta object\nmacro helps. Compare them to CopperSpice's to see the excessive boilerplate\nand user unfriendly macros (not even talking about the loss in performance).\nThe Qt signals and slots syntax which exists since the 90s is among the things\nthat made Qt so successful.\n\nYou might also be interested to learn about some research projects around moc,\nlike moc-ng: a re-implementation of moc using the clang libraries; or this\nblog research if moc can be replaced by C++ reflection. Update: And also\nVerdigris, a library with macros to create a QMetaObject without moc.\n\n#### Footnotes\n\n1 StackOverflow question 2 StackOverflow answer 3 CopperSpice home page 4\nCopperSpice documentation 5 CopperSpice documentation\n\nWoboq is a software company that specializes in development and consulting\naround Qt and C++. Hire us!\n\nIf you like this blog and want to read similar articles, consider subscribing\nvia our RSS feed (Via Google Feedburner, Privacy Policy), by e-mail (Via\nGoogle Feedburner, Privacy Policy) or follow us on twitter or add us on G+.\n\n### Article posted by Olivier Goffart on 22 February 2016\n\n\u00ab Previous: How Qt Signals and Slots Work - Part 3 - Queued and Inter Thread Connections | Next: Verdigris: Qt without moc \u00bb\n\nLoad Comments... Loading comments embeds an external widget from disqus.com.\nCheck disqus privacy policy for more information.\n\nGet notified when we post a new interesting article!\n\nClick to subscribe via RSS or e-mail on Google Feedburner. (external service).\n\nClick for the privacy policy of Google Feedburner.\n\n#### Woboq\n\n  * About Us\n  * References\n\n#### Services\n\n  * Development\n  * Support\n  * Training\n\n#### Products\n\n  * C++ Code Browser\n  * Verdigris (Qt without moc)\n  * ocsmount (WebDAV mapping for macOS)\n  * Slint by SixtyFPS GmbH\n\n#### Knowledge\n\n  * Videos\n  * Blog\n\n#### Misc\n\n  * Contact\n  * Imprint\n  * Privacy Policy\n\n\u00a9 2011-2023 Woboq GmbH Google Analytics Tracking Opt-Out\n\n", "frontpage": false}
