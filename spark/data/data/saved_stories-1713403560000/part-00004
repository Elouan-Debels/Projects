{"aid": "40069060", "title": "Building an interactive 3D event badge with React Three Fiber", "url": "https://vercel.com/blog/building-an-interactive-3d-event-badge-with-react-three-fiber", "domain": "vercel.com", "votes": 2, "user": "jaredwiener", "posted_at": "2024-04-17 19:24:26", "comments": 0, "source_title": "Building an interactive 3D event badge with React Three Fiber \u2013 Vercel", "source_text": "Building an interactive 3D event badge with React Three Fiber \u2013 Vercel\n\nSkip to content\n\nContactLog In\n\nSign Up\n\n\u2190 Back to Blog\n\nEngineering\n\nWednesday, April 17th 2024\n\n# Building an interactive 3D event badge with React Three Fiber\n\nPosted by\n\nPaul Henschel\n\nDesign Engineer\n\nIn this post, we\u2019ll look at how we made the dropping lanyard for the Vercel\nShip 2024 site, diving into the inspiration, tech stack, and code behind the\nfinished product.\n\n## Inspiration\n\nWe\u2019ve shared digital tickets for event attendance in the past, but this time,\nwe wanted to take it one step further by creating a tangible experience.\n\nWhen Studio Basement made a video in Blender that depicted a virtual badge\ndropping down, we liked the idea of it so much that we started to wonder\nwhether we could make it interactive and run it in the browser.\n\nUltimately, we wanted a highly shareable element that rewards the user for\nsigning up and makes it worth their time.\n\n## The stack\n\nTo accomplish the task, we chose the following stack:\n\n  * Blender, to prepare and optimize the original models for the web\n  * React and React Three Fiber, which is a reactive, declarative renderer for Three.js\n  * Drei, an ecosystem of components and helpers for the Three.js space in React\n  * react-three-rapier, a declarative physics library based on the Dimforge Rapier physics engine\n  * MeshLine, a shader-based thick-line implementation\n\nWhile some of the concepts we\u2019re about to cover may not look familiar, don\u2019t\nlet them overwhelm you. The implementation is about 80 lines of mostly\ndeclarative code, with a sprinkle of math.\n\nCheck out this sandbox first to get an idea of what we\u2019re building:\n\n    \n    \n    import * as THREE from 'three' import { useRef, useState } from 'react' import { Canvas, extend, useThree, useFrame } from '@react-three/fiber' import { BallCollider, CuboidCollider, Physics, RigidBody, useRopeJoint, useSphericalJoint } from '@react-three/rapier' import { MeshLineGeometry, MeshLineMaterial } from 'meshline' extend({ MeshLineGeometry, MeshLineMaterial }) export default function App() { return ( <Canvas camera={{ position: [0, 0, 13], fov: 25 }}> <Physics debug interpolate gravity={[0, -40, 0]} timeStep={1 / 60}> <Band /> </Physics> </Canvas> ) } function Band() { const band = useRef(), fixed = useRef(), j1 = useRef(), j2 = useRef(), j3 = useRef(), card = useRef() // prettier-ignore const vec = new THREE.Vector3(), ang = new THREE.Vector3(), rot = new THREE.Vector3(), dir = new THREE.Vector3() // prettier-ignore const { width, height } = useThree((state) => state.size) const [curve] = useState(() => new THREE.CatmullRomCurve3([new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()])) const [dragged, drag] = useState(false) useRopeJoint(fixed, j1, [[0, 0, 0], [0, 0, 0], 1]) // prettier-ignore useRopeJoint(j1, j2, [[0, 0, 0], [0, 0, 0], 1]) // prettier-ignore useRopeJoint(j2, j3, [[0, 0, 0], [0, 0, 0], 1]) // prettier-ignore useSphericalJoint(j3, card, [[0, 0, 0], [0, 1.45, 0]]) // prettier-ignore useFrame((state, delta) => { if (dragged) { vec.set(state.pointer.x, state.pointer.y, 0.5).unproject(state.camera) dir.copy(vec).sub(state.camera.position).normalize() vec.add(dir.multiplyScalar(state.camera.position.length())) ;[card, j1, j2, j3, fixed].forEach((ref) => ref.current?.wakeUp()) card.current?.setNextKinematicTranslation({ x: vec.x - dragged.x, y: vec.y - dragged.y, z: vec.z - dragged.z }) } if (fixed.current) { // Calculate catmul curve curve.points[0].copy(j3.current.translation()) curve.points[1].copy(j2.current.translation()) curve.points[2].copy(j1.current.translation()) curve.points[3].copy(fixed.current.translation()) band.current.geometry.setPoints(curve.getPoints(32)) // Tilt it back towards the screen ang.copy(card.current.angvel()) rot.copy(card.current.rotation()) card.current.setAngvel({ x: ang.x, y: ang.y - rot.y * 0.25, z: ang.z }) } }) return ( <> <group position={[0, 4, 0]}> <RigidBody ref={fixed} angularDamping={2} linearDamping={2} type=\"fixed\" /> <RigidBody position={[0.5, 0, 0]} ref={j1} angularDamping={2} linearDamping={2}> <BallCollider args={[0.1]} /> </RigidBody> <RigidBody position={[1, 0, 0]} ref={j2} angularDamping={2} linearDamping={2}> <BallCollider args={[0.1]} /> </RigidBody > <RigidBody position={[1.5, 0, 0]} ref={j3} angularDamping={2} linearDamping={2}> <BallCollider args={[0.1]} /> </RigidBody > <RigidBody position={[2, 0, 0]} ref={card} angularDamping={2} linearDamping={2} type={dragged ? 'kinematicPosition' : 'dynamic'} > <CuboidCollider args={[0.8, 1.125, 0.01]} /> <mesh onPointerUp={(e) => (e.target.releasePointerCapture(e.pointerId), drag(false))} onPointerDown={(e) => (e.target.setPointerCapture(e.pointerId), drag(new THREE.Vector3().copy(e.point).sub(vec.copy(card.current.translation()))))}> <planeGeometry args={[0.8 * 2, 1.125 * 2]} /> <meshBasicMaterial transparent opacity={0.25} color=\"white\" side={THREE.DoubleSide} /> </mesh> </RigidBody > </group > <mesh ref={band}> <meshLineGeometry /> <meshLineMaterial transparent opacity={0.25} color=\"white\" depthTest={false} resolution={[width, height]} lineWidth={1} /> </mesh> </> ) }\n\nTo enter the code editing mode, press Enter. To exit the edit mode, press\nEscape\n\nYou are editing the code. To exit the edit mode, press Escape\n\n## Building a rough draft\n\nThe basic imports we need revolve around our canvas, physics, and the thick\nline for the lanyard:\n\nApp.js\n\n    \n    \n    import * as THREE from 'three'\n    \n    import { useRef, useState } from 'react'\n    \n    import { Canvas, extend, useThree, useFrame } from '@react-three/fiber'\n    \n    import { BallCollider, CuboidCollider, Physics, RigidBody, useRopeJoint, useSphericalJoint } from '@react-three/rapier'\n    \n    import { MeshLineGeometry, MeshLineMaterial } from 'meshline'\n\nIn order to use the MeshLine library, which is vanilla Three.js in React, we\nneed to extend it. The extend function extends React Three Fiber's catalog of\nknown JSX elements. Components added this way can then be referenced in the\nscene graph using camel casing, similar to native primitives (e.g., <mesh>):\n\nApp.js\n\n    \n    \n    extend({ MeshLineGeometry, MeshLineMaterial })\n\n### Setting up the canvas\n\nNow we can set up a basic canvas. We need React Three Fiber\u2019s <Canvas>\ncomponent, which is a doorway into declarative Three.js. We also add a\n<Physics> provider, which allows us to tie shapes to physics; in Rapier, this\nis called a <RigidBody>.\n\nWith this, we have everything we need:\n\nApp.js\n\n    \n    \n    export default function App() {\n    \n    return (\n    \n    <Canvas>\n    \n    <Physics>\n    \n    {/* ... */}\n    \n    </Physics>\n    \n    </Canvas>\n    \n    )\n    \n    }\n\n## The band component\n\nNow let\u2019s make the band happen. We need a couple of references to access them\nlater on. The canvas size is important for meshline, and a\nTHREE.CatmullRomCurve3 helps us to calculate a smooth curve with just a few\npoints. We only need four points for the physics joints:\n\nApp.js\n\n    \n    \n    function Band() {\n    \n    // References for the band and the joints\n    \n    const band = useRef()\n    \n    const fixed = useRef()\n    \n    const j1 = useRef()\n    \n    const j2 = useRef()\n    \n    const j3 = useRef()\n    \n    // Canvas size\n    \n    const { width, height } = useThree((state) => state.size)\n    \n    // A Catmull-Rom curve\n    \n    const [curve] = useState(() => new THREE.CatmullRomCurve3([\n    \n    new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()\n    \n    ]))\n\n### Defining the physics joints\n\nA joint is a physics constraint that tells the engine how shapes interact with\none another. We\u2019ll now start to connect the joints, and we\u2019ll later define a\nfixed <RigidBody> that cannot move.\n\nWe hang the first joint on the useRopeJoint the Rapier provides (there are a\nlot of different constraints for rotations, distances, etc.). The other joints\nwill hang on each other. Basically, we will have made a chain that hangs on a\nfixed point.\n\nuseRopeJoint requires two <RigidBody> references:\n\n  1. Two anchor points for each (we\u2019re using [0, 0, 0], which is the center point)\n  2. A length (we\u2019re using 1)\n\nOur rope is ready to swing!\n\nApp.js\n\n    \n    \n    useRopeJoint(fixed, j1, [[0, 0, 0], [0, 0, 0], 1])\n    \n    useRopeJoint(j1, j2, [[0, 0, 0], [0, 0, 0], 1])\n    \n    useRopeJoint(j2, j3, [[0, 0, 0], [0, 0, 0], 1])\n\n### Creating a curve\n\nRapier will now move the joints along an invisible rope, and we can feed our\nCatmull-Rom curve the positions of these joints. We let it make a smooth,\ninterpolated curve with 32 points and forward that to the meshline.\n\nWe do this at runtime at 60 or 120 FPS, depending on the monitor\u2019s refresh\nrate. React Three Fiber gives us an out to handle frame-based animations with\nthe useFrame Hook:\n\nApp.js\n\n    \n    \n    useFrame(() => {\n    \n    curve.points[0].copy(j3.current.translation())\n    \n    curve.points[1].copy(j2.current.translation())\n    \n    curve.points[2].copy(j1.current.translation())\n    \n    curve.points[3].copy(fixed.current.translation())\n    \n    band.current.geometry.setPoints(curve.getPoints(32))\n    \n    })\n\n### The view\n\nNow we need the view. It consists of the fixed <RigidBody type=\"fixed\">, three\n<RigidBody>'s for the joints (j1, j2, and j3), and the meshline that we\nextended above. The joints are positioned in a way that makes them fall down\nwith a slight swing:\n\nApp.js\n\n    \n    \n    return (\n    \n    <>\n    \n    <RigidBody ref={fixed} type=\"fixed\" />\n    \n    <RigidBody position={[0.5, 0, 0]} ref={j1}>\n    \n    <BallCollider args={[0.1]} />\n    \n    </RigidBody>\n    \n    <RigidBody position={[1, 0, 0]} ref={j2}>\n    \n    <BallCollider args={[0.1]} />\n    \n    </RigidBody >\n    \n    <RigidBody position={[1.5, 0, 0]} ref={j3}>\n    \n    <BallCollider args={[0.1]} />\n    \n    </RigidBody >\n    \n    <mesh ref={band}>\n    \n    <meshLineGeometry />\n    \n    <meshLineMaterial color=\"white\" resolution={[width, height]} lineWidth={1} />\n    \n    </mesh>\n    \n    </>\n    \n    )\n    \n    }\n\n## The card component\n\nAll that\u2019s missing is the interactive card, which we need to attach to the end\nof the last joint. For this, we\u2019ll need a new reference, some variables for\nmath, a state for dragging, and a new joint. This time, we use a spherical\njoint so the card can rotate:\n\nApp.js\n\n    \n    \n    const card = useRef()\n    \n    const vec = new THREE.Vector3()\n    \n    const ang = new THREE.Vector3()\n    \n    const rot = new THREE.Vector3()\n    \n    const dir = new THREE.Vector3()\n    \n    const [dragged, drag] = useState(false)\n    \n    useSphericalJoint(j3, card, [[0, 0, 0], [0, 1.45, 0]])\n\nRapier defines a few rigid-body types:\n\n  * fixed, which isn\u2019t affected by anything\n  * dynamic, the default, which reacts to any other rigid body\n  * kinematicPosition, which is the position controlled by the user, not the engine\n\nThe card needs to be kinematic when dragged and dynamic when it\u2019s not. We will\nlater use pointerEvents to set the dragged state.\n\nOur previous useFrame now changes to this:\n\nApp.js\n\n    \n    \n    useFrame((state) => {\n    \n    if (dragged) {\n    \n    vec.set(state.pointer.x, state.pointer.y, 0.5).unproject(state.camera)\n    \n    dir.copy(vec).sub(state.camera.position).normalize()\n    \n    vec.add(dir.multiplyScalar(state.camera.position.length()))\n    \n    card.current.setNextKinematicTranslation({ x: vec.x - dragged.x, y: vec.y - dragged.y, z: vec.z - dragged.z })\n    \n    }\n    \n    // Calculate Catmull curve\n    \n    curve.points[0].copy(j3.current.translation())\n    \n    curve.points[1].copy(j2.current.translation())\n    \n    curve.points[2].copy(j1.current.translation())\n    \n    curve.points[3].copy(fixed.current.translation())\n    \n    band.current.geometry.setPoints(curve.getPoints(32))\n    \n    // Tilt the card back towards the screen\n    \n    ang.copy(card.current.angvel())\n    \n    rot.copy(card.current.rotation())\n    \n    card.current.setAngvel({ x: ang.x, y: ang.y - rot.y * 0.25, z: ang.z })\n    \n    })\n\nCalculating the dragged state is the complicated bit of the code. Without\ngoing into too much detail, if you want to translate a pointer event\ncoordinate to a 3D object, this is called a camera unprojection. Three.js has\na method for this, unproject(state.camera), which does most of the math.\n\nThe obtained vector gets applied as a kinematic translation. We move the card\nwith the mouse/trackpad, and the lanyard joints will follow it where it goes.\n\nAnother hard nut to crack is that we allow the card to rotate, but we want it\nto always rotate from back to front\u2014which is not physically accurate, of\ncourse, but the experience would suffer otherwise. To solve this, we use the\ncurrent rotational velocity card.current.angvel() and the rotation\ncard.current.rotation(), and spin the y-axis towards the front.\n\n### The card\u2019s rigid body and pointer events\n\nWe use a <CuboidCollider> (a box shape) for the card and drop a <mesh> inside\nthat will move along with the <RigidBody>. This mesh will later be exchanged\nwith the Blender model.\n\nThe pointer events for up and down set the drag state. On the down point, we\ngrab the current point of the model, e.point, and subtract the card\u2019s position\nin space, card.current.translation(). We need this offset for the useFrame\nabove to calculate the correct kinematic position:\n\nApp.js\n\n    \n    \n    <RigidBody ref={card} type={dragged ? 'kinematicPosition' : 'dynamic'} >\n    \n    <CuboidCollider args={[0.8, 1.125, 0.01]} />\n    \n    <mesh\n    \n    onPointerUp={(e) => drag(false)}\n    \n    onPointerDown={(e) => drag(new THREE.Vector3().copy(e.point).sub(vec.copy(card.current.translation())))}>\n    \n    <planeGeometry args={[0.8 * 2, 1.125 * 2]} />\n    \n    <meshBasicMaterial color=\"white\" side={THREE.DoubleSide} />\n    \n    </mesh>\n    \n    </RigidBody>\n\n## Adding the dynamic name\n\nWe wanted the card to display the name of the user dynamically. To achieve\nthat, we\u2019ll create a new scene that renders the user's name alongside a base\ntexture. Then, we\u2019ll use Drei's <RenderTexture> component to render that scene\ninto a texture.\n\nWe start by creating a scene that renders the base of the badge texture:\n\nApp.js\n\n    \n    \n    <PerspectiveCamera makeDefault manual aspect={1.05} position={[0.49, 0.22, 2]} />\n    \n    <mesh>\n    \n    <planeGeometry args={[planeWidth, -planeWidth / textureAspect]} />\n    \n    <meshBasicMaterial transparent alphaMap={texture} side={THREE.BackSide} />\n    \n    </mesh>\n\nThe result of using Drei's <RenderTexture> component to render our badge\ntexture.\n\nWe have the badge texture, but we\u2019re still missing the name. We\u2019ll add it to\nthe scene using Drei's <Text3D> component:\n\nApp.js\n\n    \n    \n    <Center bottom right>\n    \n    <Resize key={resizeId} maxHeight={0.45} maxWidth={0.925}>\n    \n    <Text3D\n    \n    bevelEnabled={false}\n    \n    bevelSize={0}\n    \n    font=\"/ship/2024/badge/Geist_Regular.json\"\n    \n    height={0}\n    \n    rotation={[0, Math.PI, Math.PI]}>\n    \n    {user.firstName}\n    \n    </Text3D>\n    \n    <Text3D\n    \n    bevelEnabled={false}\n    \n    bevelSize={0}\n    \n    font=\"/ship/2024/badge/Geist_Regular.json\"\n    \n    height={0}\n    \n    position={[0, 1.4, 0]}\n    \n    rotation={[0, Math.PI, Math.PI]}>\n    \n    {user.lastName}\n    \n    </Text3D>\n    \n    </Resize>\n    \n    </Center>\n\nThis is an entirely different scene\u2014we want to add the result of the render\ninto our badge as a color. We achieve this using the <RenderTexture>\ncomponent, which will render our scene into a texture we can attach to the\nmesh.map:\n\nApp.js\n\n    \n    \n    <mesh geometry={nodes.card.geometry}>\n    \n    <meshPhysicalMaterial\n    \n    clearcoat={1}\n    \n    clearcoatRoughness={0.15}\n    \n    iridescence={1}\n    \n    iridescenceIOR={1}\n    \n    iridescenceThicknessRange={[0, 2400]}\n    \n    metalness={0.5}\n    \n    roughness={0.3}\n    \n    >\n    \n    <RenderTexture attach=\"map\" height={2000} width={2000}>\n    \n    <BadgeTexture user={user} />\n    \n    </RenderTexture>\n    \n    </meshPhysicalMaterial>\n    \n    </mesh>\n\n## Finishing touches\n\nWe have everything in place now. The basic meshes are quickly changed out for\nthe Blender models, and with a little bit of tweaking and math, we make the\nsimulation more stable and less shaky. Here's the sandbox we used to prototype\nthe component for the Ship site:\n\n    \n    \n    import * as THREE from 'three' import { useEffect, useRef, useState } from 'react' import { Canvas, extend, useThree, useFrame } from '@react-three/fiber' import { useGLTF, useTexture, Environment, Lightformer } from '@react-three/drei' import { BallCollider, CuboidCollider, Physics, RigidBody, useRopeJoint, useSphericalJoint } from '@react-three/rapier' import { MeshLineGeometry, MeshLineMaterial } from 'meshline' import { useControls } from 'leva' extend({ MeshLineGeometry, MeshLineMaterial }) useGLTF.preload('https://assets.vercel.com/image/upload/contentful/image/e5382hct74si/5huRVDzcoDwnbgrKUo1Lzs/53b6dd7d6b4ffcdbd338fa60265949e1/tag.glb') useTexture.preload('https://assets.vercel.com/image/upload/contentful/image/e5382hct74si/SOT1hmCesOHxEYxL7vkoZ/c57b29c85912047c414311723320c16b/band.jpg') export default function App() { const { debug } = useControls({ debug: false }) return ( <Canvas camera={{ position: [0, 0, 13], fov: 25 }}> <ambientLight intensity={Math.PI} /> <Physics debug={debug} interpolate gravity={[0, -40, 0]} timeStep={1 / 60}> <Band /> </Physics> <Environment background blur={0.75}> <color attach=\"background\" args={['black']} /> <Lightformer intensity={2} color=\"white\" position={[0, -1, 5]} rotation={[0, 0, Math.PI / 3]} scale={[100, 0.1, 1]} /> <Lightformer intensity={3} color=\"white\" position={[-1, -1, 1]} rotation={[0, 0, Math.PI / 3]} scale={[100, 0.1, 1]} /> <Lightformer intensity={3} color=\"white\" position={[1, 1, 1]} rotation={[0, 0, Math.PI / 3]} scale={[100, 0.1, 1]} /> <Lightformer intensity={10} color=\"white\" position={[-10, 0, 14]} rotation={[0, Math.PI / 2, Math.PI / 3]} scale={[100, 10, 1]} /> </Environment> </Canvas> ) } function Band({ maxSpeed = 50, minSpeed = 10 }) { const band = useRef(), fixed = useRef(), j1 = useRef(), j2 = useRef(), j3 = useRef(), card = useRef() // prettier-ignore const vec = new THREE.Vector3(), ang = new THREE.Vector3(), rot = new THREE.Vector3(), dir = new THREE.Vector3() // prettier-ignore const segmentProps = { type: 'dynamic', canSleep: true, colliders: false, angularDamping: 2, linearDamping: 2 } const { nodes, materials } = useGLTF('https://assets.vercel.com/image/upload/contentful/image/e5382hct74si/5huRVDzcoDwnbgrKUo1Lzs/53b6dd7d6b4ffcdbd338fa60265949e1/tag.glb') const texture = useTexture('https://assets.vercel.com/image/upload/contentful/image/e5382hct74si/SOT1hmCesOHxEYxL7vkoZ/c57b29c85912047c414311723320c16b/band.jpg') const { width, height } = useThree((state) => state.size) const [curve] = useState(() => new THREE.CatmullRomCurve3([new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()])) const [dragged, drag] = useState(false) const [hovered, hover] = useState(false) useRopeJoint(fixed, j1, [[0, 0, 0], [0, 0, 0], 1]) // prettier-ignore useRopeJoint(j1, j2, [[0, 0, 0], [0, 0, 0], 1]) // prettier-ignore useRopeJoint(j2, j3, [[0, 0, 0], [0, 0, 0], 1]) // prettier-ignore useSphericalJoint(j3, card, [[0, 0, 0], [0, 1.45, 0]]) // prettier-ignore useEffect(() => { if (hovered) { document.body.style.cursor = dragged ? 'grabbing' : 'grab' return () => void (document.body.style.cursor = 'auto') } }, [hovered, dragged]) useFrame((state, delta) => { if (dragged) { vec.set(state.pointer.x, state.pointer.y, 0.5).unproject(state.camera) dir.copy(vec).sub(state.camera.position).normalize() vec.add(dir.multiplyScalar(state.camera.position.length())) ;[card, j1, j2, j3, fixed].forEach((ref) => ref.current?.wakeUp()) card.current?.setNextKinematicTranslation({ x: vec.x - dragged.x, y: vec.y - dragged.y, z: vec.z - dragged.z }) } if (fixed.current) { // Fix most of the jitter when over pulling the card ;[j1, j2].forEach((ref) => { if (!ref.current.lerped) ref.current.lerped = new THREE.Vector3().copy(ref.current.translation()) const clampedDistance = Math.max(0.1, Math.min(1, ref.current.lerped.distanceTo(ref.current.translation()))) ref.current.lerped.lerp(ref.current.translation(), delta * (minSpeed + clampedDistance * (maxSpeed - minSpeed))) }) // Calculate catmul curve curve.points[0].copy(j3.current.translation()) curve.points[1].copy(j2.current.lerped) curve.points[2].copy(j1.current.lerped) curve.points[3].copy(fixed.current.translation()) band.current.geometry.setPoints(curve.getPoints(32)) // Tilt it back towards the screen ang.copy(card.current.angvel()) rot.copy(card.current.rotation()) card.current.setAngvel({ x: ang.x, y: ang.y - rot.y * 0.25, z: ang.z }) } }) curve.curveType = 'chordal' texture.wrapS = texture.wrapT = THREE.RepeatWrapping return ( <> <group position={[0, 4, 0]}> <RigidBody ref={fixed} {...segmentProps} type=\"fixed\" /> <RigidBody position={[0.5, 0, 0]} ref={j1} {...segmentProps}> <BallCollider args={[0.1]} /> </RigidBody> <RigidBody position={[1, 0, 0]} ref={j2} {...segmentProps}> <BallCollider args={[0.1]} /> </RigidBody> <RigidBody position={[1.5, 0, 0]} ref={j3} {...segmentProps}> <BallCollider args={[0.1]} /> </RigidBody> <RigidBody position={[2, 0, 0]} ref={card} {...segmentProps} type={dragged ? 'kinematicPosition' : 'dynamic'}> <CuboidCollider args={[0.8, 1.125, 0.01]} /> <group scale={2.25} position={[0, -1.2, -0.05]} onPointerOver={() => hover(true)} onPointerOut={() => hover(false)} onPointerUp={(e) => (e.target.releasePointerCapture(e.pointerId), drag(false))} onPointerDown={(e) => (e.target.setPointerCapture(e.pointerId), drag(new THREE.Vector3().copy(e.point).sub(vec.copy(card.current.translation()))))}> <mesh geometry={nodes.card.geometry}> <meshPhysicalMaterial map={materials.base.map} map-anisotropy={16} clearcoat={1} clearcoatRoughness={0.15} roughness={0.3} metalness={0.5} /> </mesh> <mesh geometry={nodes.clip.geometry} material={materials.metal} material-roughness={0.3} /> <mesh geometry={nodes.clamp.geometry} material={materials.metal} /> </group> </RigidBody> </group> <mesh ref={band}> <meshLineGeometry /> <meshLineMaterial color=\"white\" depthTest={false} resolution={[width, height]} useMap map={texture} repeat={[-3, 1]} lineWidth={1} /> </mesh> </> ) }\n\nTo enter the code editing mode, press Enter. To exit the edit mode, press\nEscape\n\nYou are editing the code. To exit the edit mode, press Escape\n\nAnd that's it! Once you get the hang of the basics and start playing with\nsimple shapes, the possibilities are endless.\n\nGet your virtual badge.\n\nRegister for Vercel Ship '24 to learn about AI-native user experiences,\nbuilding composable web applications, and the latest from our partners and\ncommunity.\n\nRegister Today\n\nExplore more\n\nRead the follow-up\n\nComposable AI for ecommerce: Hands-on with Vercel\u2019s AI SDK\n\n1 author\n\nApr. 9th, 2024\n\nRead the follow-up\n\nGuide to fast websites with Next.js: Tips for maximizing server speeds and\nminimizing client burden\n\n1 author\n\nNov. 29th, 2023\n\nRelated reading\n\nDesign Engineering at Vercel\n\nGlenn Hitchcock, Henry Heffernan, and 3 others\n\nBuilding an interactive WebGL experience in Next.js\n\nPaul Henschel, Anthony Shew\n\nPosted by\n\nPaul Henschel\n\nDesign Engineer\n\nRelated reading\n\nDesign Engineering at Vercel\n\nGlenn Hitchcock, Henry Heffernan, and 3 others\n\nBuilding an interactive WebGL experience in Next.js\n\nPaul Henschel, Anthony Shew\n\nDevelop.Preview.Ship.\n\nVercel is the platform for frontend developers, providing the speed and\nreliability innovators need to create at the moment of inspiration.\n\nStart Deploying\n\nTour the Product\n\n", "frontpage": false}
