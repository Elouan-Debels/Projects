{"aid": "40006048", "title": "Proposal to Add Signals to JavaScript", "url": "https://github.com/tc39/proposal-signals", "domain": "github.com/tc39", "votes": 4, "user": "michaelsbradley", "posted_at": "2024-04-11 19:46:33", "comments": 2, "source_title": "GitHub - tc39/proposal-signals: A proposal to add signals to JavaScript.", "source_text": "GitHub - tc39/proposal-signals: A proposal to add signals to JavaScript.\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\ntc39 / proposal-signals Public\n\ngenerated from tc39/template-for-proposals\n\n  * Notifications\n  * Fork 32\n  * Star 2.2k\n\nA proposal to add signals to JavaScript.\n\n### License\n\nMIT license\n\n2.2k stars 32 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# tc39/proposal-signals\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n9 Branches\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nNullVoxPopuliUpdate README.md (#170)9aef526 \u00b7\n\n## History\n\n136 Commits  \n  \n### .github/workflows\n\n|\n\n### .github/workflows\n\n| Update .github/workflows/test.yml  \n  \n### docs\n\n|\n\n### docs\n\n| docs: add initial survey template (#5)  \n  \n### meetings\n\n|\n\n### meetings\n\n| chore: wip initial repo setup following tc39 guidelines  \n  \n### packages/signal-polyfill\n\n|\n\n### packages/signal-polyfill\n\n| polyfill disclaimer  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| chore: add vite and vitest setup  \n  \n### .npmrc\n\n|\n\n### .npmrc\n\n| Initial commit  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| chore: wip initial repo setup following tc39 guidelines  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update README.md (#170)  \n  \n### Signals.svg\n\n|\n\n### Signals.svg\n\n| Signals logo SVG  \n  \n### package.json\n\n|\n\n### package.json\n\n| fix(package.json): correct repo (#98)  \n  \n### signals-logo.png\n\n|\n\n### signals-logo.png\n\n| Show logo (#80)  \n  \n### spec.emu\n\n|\n\n### spec.emu\n\n| chore: remove example content from spec.emu  \n  \n## Repository files navigation\n\n# \ud83d\udea6 JavaScript Signals standard proposal\ud83d\udea6\n\nStage 1\n\nAuthors: Rob Eisenberg and Daniel Ehrenberg\n\nThis document describes an early common direction for signals in JavaScript,\nsimilar to the Promises/A+ effort which preceded the Promises standardized by\nTC39 in ES2015. Try it for yourself, using a polyfill.\n\nSimilarly to Promises/A+, this effort focuses on aligning the JavaScript\necosystem. If this alignment is successful, then a standard could emerge,\nbased on that experience. Several framework authors are collaborating here on\na common model which could back their reactivity core. The current draft is\nbased on design input from the authors/maintainers of Angular, Bubble, Ember,\nFAST, MobX, Preact, Qwik, RxJS, Solid, Starbeam, Svelte, Vue, Wiz, and more...\n\nDifferently from Promises/A+, we're not trying to solve for a common\ndeveloper-facing surface API, but rather the precise core semantics of the\nunderlying signal graph. This proposal does include a fully concrete API, but\nthe API is not targeted to most application developers. Instead, the signal\nAPI here is a better fit for frameworks to build on top of, providing\ninteroperability through common signal graph and auto-tracking mechanism.\n\nThe plan for this proposal is to do significant early prototyping, including\nintegration into several frameworks, before advancing beyond Stage 1. We are\nonly interested in standardizing Signals if they are suitable for use in\npractice in multiple frameworks, and provide real benefits over framework-\nprovided signals. We hope that significant early prototyping will give us this\ninformation. See \"Status and development plan\" below for more details.\n\n## Background: Why Signals?\n\nTo develop a complicated user interface (UI), JavaScript application\ndevelopers need to store, compute, invalidate, sync, and push state to the\napplication's view layer in an efficient way. UIs commonly involve more than\njust managing simple values, but often involve rendering computed state which\nis dependent on a complex tree of other values or state that is also computed\nitself. The goal of Signals is to provide infrastructure for managing such\napplication state so developers can focus on business logic rather than these\nrepetitive details.\n\nSignal-like constructs have independently been found to be useful in non-UI\ncontexts as well, particularly in build systems to avoid unnecessary rebuilds.\n\nSignals are used in reactive programming to remove the need to manage updating\nin applications.\n\n> A declarative programming model for updating based on changes to state.\n\nfrom What is Reactivity?.\n\n#### Example - A VanillaJS Counter\n\nGiven a variable, counter, you want to render into the DOM whether the counter\nis even or odd. Whenever the counter changes, you want to update the DOM with\nthe latest parity. In Vanilla JS, you might have something like this:\n\n    \n    \n    let counter = 0; const setCounter = (value) => { counter = value; render(); }; const isEven = () => (counter & 1) == 0; const parity = () => isEven() ? \"even\" : \"odd\"; const render = () => element.innerText = parity(); // Simulate external updates to counter... setInterval(() => setCounter(counter + 1), 1000);\n\nThis has a number of problems...\n\n  * The counter setup is noisy and boilerplate-heavy.\n  * The counter state is tightly coupled to the rendering system.\n  * If the counter changes but parity does not (e.g. counter goes from 2 to 4), then we do unnecessary computation of the parity and unnecessary rendering.\n  * What if another part of our UI just wants to render when the counter updates?\n  * What if another part of our UI is dependent on isEven or parity alone?\n\nEven in this relatively simple scenario, a number of issues arise quickly. We\ncould try to work around these by introducing pub/sub for the counter. This\nwould allow additional consumers of the counter could subscribe to add their\nown reactions to state changes.\n\nHowever, we're still stuck with the following problems:\n\n  * The render function, which is only dependent on parity must instead \"know\" that it actually needs to subscribe to counter.\n  * It isn't possible to update UI based on either isEven or parity alone, without directly interacting with counter.\n  * We've increased our boilerplate. Any time you are using something, it's not just a matter of calling a function or reading a variable, but instead subscribing and doing updates there. Managing unsubscription is also especially complicated.\n\nNow, we could solve a couple issues by adding pub/sub not just to counter but\nalso to isEven and parity. We would then have to subscribe isEven to counter,\nparity to isEven, and render to parity. Unfortunately, not only has our\nboilerplate code exploded, but we're stuck with a ton of bookkeeping of\nsubscriptions, and a potential memory leak disaster if we don't properly clean\neverything up in the right way. So, we've solved some issues but created a\nwhole new category of problems and a lot of code. To make matters worse, we\nhave to go through this entire process for every piece of state in our system.\n\n### Introducing Signals\n\nData binding abstractions in UIs for the model and view have long been core to\nUI frameworks across multiple programming languages, despite the absence of\nany such mechanism built into JS or the web platform. Within JS frameworks and\nlibraries, there has been a large amount of experimentation across different\nways to represent this binding, and experience has shown the power of one-way\ndata flow in conjunction with a first-class data type representing a cell of\nstate or computation derived from other data, now often called \"Signals\". This\nfirst-class reactive value approach seems to have made its first popular\nappearance in open-source JavaScript web frameworks with Knockout in 2010. In\nthe years since, many variations and implementations have been created. Within\nthe last 3-4 years, the Signal primitive and related approaches have gained\nfurther traction, with nearly every modern JavaScript library or framework\nhaving something similar, under one name or another.\n\nTo understand Signals, let's take a look at the above example, re-imagined\nwith a Signal API further articulated below.\n\n#### Example - A Signals Counter\n\n    \n    \n    const counter = new Signal.State(0); const isEven = new Signal.Computed(() => (counter.get() & 1) == 0); const parity = new Signal.Computed(() => isEven.get() ? \"even\" : \"odd\"); // A library or framework defines effects based on other Signal primitives declare function effect(cb: () => void): (() => void); effect(() => element.innerText = parity.get()); // Simulate external updates to counter... setInterval(() => counter.set(counter.get() + 1), 1000);\n\nThere are a few things we can see right away:\n\n  * We've eliminated the noisy boilerplate around the counter variable from our previous example.\n  * There is a unified API to handle values, computations, and side effects.\n  * There's no circular reference problem or upside down dependencies between counter and render.\n  * There are no manual subscriptions, nor is there any need for bookkeeping.\n  * There is a means of controlling side-effect timing/scheduling.\n\nSignals give us much more than what can be seen on the surface of the API\nthough:\n\n  * Automatic Dependency Tracking - A computed Signal automatically discovers any other Signals that it is dependent on, whether those Signals be simple values or other computations.\n  * Lazy Evaluation - Computations are not eagerly evaluated when they are declared, nor are they immediately evaluated when their dependencies change. They are only evaluated when their value is explicitly requested.\n  * Memoization - Computed Signals cache their last value so that computations that don't have changes in their dependencies do not need to be re-evaluated, no matter how many times they are accessed.\n\n## Motivation for standardizing Signals\n\n#### Interoperability\n\nEach Signal implementation has its own auto-tracking mechanism, to keep track\nof the sources encountered when evaluating a computed Signal. This makes it\nhard to share models, components, and libraries between different frameworks--\nthey tend to come with a false coupling to their view engine (given that\nSignals are usually implemented as part of JS frameworks).\n\nA goal of this proposal is to fully decouple the reactive model from the\nrendering view, enabling developers to migrate to new rendering technologies\nwithout rewriting their non-UI code, or develop shared reactive models in JS\nto be deployed in different contexts. Unfortunately, due to versioning and\nduplication, it has turned out to be impractical to reach a strong level of\nsharing via JS-level libraries--built-ins offer a stronger sharing guarantee.\n\n#### Performance/Memory usage\n\nIt is always a small potential performance boost to ship less code due to\ncommonly used libraries being built-in, but implementations of Signals are\ngenerally pretty small, so we don't expect this effect to be very large.\n\nWe suspect that native C++ implementations of Signal-related data structures\nand algorithms can be slightly more efficient than what is achievable in JS,\nby a constant factor. However, no algorithmic changes are anticipated vs. what\nwould be present in a polyfill; engines are not expected to be magic here, and\nthe reactivity algorithms themselves will be well-defined and unambiguous.\n\nThe champion group expects to develop various implementations of Signals, and\nuse these to investigate these performance possibilities.\n\n#### DevTools\n\nWith existing JS-language Signal libraries, it can be difficult to trace\nthings like:\n\n  * The callstack across a chain of computed Signals, showing the causal chain for an error\n  * The reference graph among Signals, when one depends on another -- important when debugging memory usage\n\nBuilt-in Signals enable JS runtimes and DevTools to potentially have improved\nsupport for inspecting Signals, particularly for debugging or performance\nanalysis, whether this is built into browsers or through a shared extension.\nExisting tools such as the element inspector, performance snapshot, and memory\nprofilers could be updated to specifically highlight Signals in their\npresentation of information.\n\n#### Secondary benefits\n\n##### Benefits of a standard library\n\nIn general, JavaScript has had a fairly minimal standard library, but a trend\nin TC39 has been to make JS more of a \"batteries-included\" language, with a\nhigh-quality, built-in set of functionality available. For example, Temporal\nis replacing moment.js, and a number of small features, e.g.,\nArray.prototype.flat and Object.groupBy are replacing many lodash use cases.\nBenefits include smaller bundle sizes, improved stability and quality, less to\nlearn when joining a new project, and a generally common vocabulary across JS\ndevelopers.\n\n##### HTML/DOM Integration (a future possibility)\n\nCurrent work in W3C and by browser implementors is seeking to bring native\ntemplating to HTML (DOM Parts and Template Instantiation). Additionally, the\nW3C Web Components CG is exploring the possibility of extending Web Components\nto offer a fully declarative HTML API. To accomplish both of these goals,\neventually a reactive primitive will be needed by HTML. Additionally, many\nergonomic improvements to the DOM through integration of Signals can be\nimagined and have been asked for by the community.\n\n> Note, this integration would be a separate effort to come later, not part of\n> this proposal itself.\n\n##### Ecosystem information exchange (not a reason to ship)\n\nStandardization efforts can sometimes be helpful just at the \"community\"\nlevel, even without changes in browsers. The Signals effort is bringing\ntogether many different framework authors for a deep discussion about the\nnature of reactivity, algorithms and interoperability. This has already been\nuseful, and does not justify inclusion in JS engines and browsers; Signals\nshould only be added to the JavaScript standard if there are significant\nbenefits beyond the ecosystem information exchange enabled.\n\n## Design goals for Signals\n\nIt turns out that existing Signal libraries are not all that different from\neach other, at their core. This proposal aims to build on their success by\nimplementing the important qualities of many of those libraries.\n\n### Core features\n\n  * A Signal type which represents state, i.e. writable Signal. This is a value that others can read.\n  * A computed/memo/derived Signal type, which depends on others and is lazily calculated and cached.\n\n    * Computation is lazy, meaning computed Signals aren't calculated again by default when one of their dependencies changes, but rather only run if someone actually reads them.\n    * Computation is \"glitch-free\", meaning no unnecessary calculations are ever performed. This implies that, when an application reads a computed Signal, there is a topological sorting of the potentially dirty parts of the graph to run, to eliminate any duplicates.\n    * Computation is cached, meaning that if, after the last time a dependency changes, no dependencies have changed, then the computed Signal is not recalculated when accessed.\n    * Custom comparisons are possible for computed Signals as well as state Signals, to note when further computed Signals which depend on them should be updated.\n  * Reactions to the condition where a computed Signal has one of its dependencies (or nested dependencies) become \"dirty\" and change, meaning that the Signal's value might be outdated.\n\n    * This reaction is meant to schedule more significant work to be performed later.\n    * Effects are implemented in terms of these reactions, plus framework-level scheduling.\n    * Computed signals need the ability to react to whether they are registered as a (nested) dependency of one of these reactions.\n  * Enable JS frameworks to do their own scheduling. No Promise-style built-in forced-on scheduling.\n\n    * Synchronous reactions are needed to enable scheduling later work based on framework logic.\n    * Writes are synchronous and immediately take effect (a framework which batches writes can do that on top).\n    * It is possible to separate checking whether an effect may be \"dirty\" from actually running the effect (enabling a two-stage effect scheduler).\n  * Ability to read Signals without triggering dependencies to be recorded (untrack)\n  * Enable composition of different codebases which use Signals/reactivity, e.g.,\n\n    * Using multiple frameworks together as far as tracking/reactivity itself goes (modulo omissions, see below)\n    * Framework-independent reactive data structures (e.g., recursively reactive store proxy, reactive Map and Set and Array, etc.)\n\n### Soundness\n\n  * Discourage/prohibit naive misuse of synchronous reactions.\n\n    * Soundness risk: it may expose \"glitches\" if improperly used: If rendering is done immediately when a Signal is set, it may expose incomplete application state to the end user. Therefore, this feature should only be used to intelligently schedule work for later, once application logic is finished.\n    * Solution: Disallow reading and writing any Signal from within a synchronous reaction callback\n  * Discourage untrack and mark its unsound nature\n\n    * Soundness risk: allows the creation of computed Signals whose value depends on other Signals, but which aren't updated when those Signals change. It should be used when the untracked accesses will not change the result of the computation.\n    * Solution: The API is marked \"unsafe\" in the name.\n  * Note: This proposal does allow signals to be both read and written from computed and effect signals, without restricting writes that come after reads, despite the soundness risk. This decision was taken to preserve flexibility and compatibility in integration with frameworks.\n\n### Surface API\n\n  * Must be a solid base for multiple frameworks to implement their Signals/reactivity mechanisms.\n\n    * Should be a good base for recursive store proxies, decorator-based class field reactivity, and both .value and [state, setState]-style APIs.\n    * The semantics are able to express the valid patterns enabled by different frameworks. For example, it should be possible for these Signals to be the basis of either immediately-reflected writes or writes which are batched and applied later.\n  * It would be nice if this API is usable directly by JavaScript developers.\n\n    * If a feature matches with an ecosystem concept, using common vocabulary is good.\n\n      * However, it is important to not literally shadow the exact same names!\n    * Tension between \"usability by JS devs\" and \"providing all the hooks to frameworks\"\n\n      * Idea: Provide all the hooks, but include errors when misused if possible.\n      * Idea: Put subtle APIs in a subtle namespace, similar to crypto.subtle, to mark the line between APIs which are necessary for more advanced usage like implementing a framework or building dev tools versus more everyday application development usage like instantiating signals for use with a framework.\n  * Be implementable and usable with good performance -- the surface API doesn't cause too much overhead\n\n    * Enable subclassing, so that frameworks can add their own methods and fields, including private fields. This is important to avoid the need for additional allocations at the framework level. See \"Memory management\" below.\n\n### Memory management\n\n  * If possible: A computed Signal should be garbage-collectable if nothing live is referencing it for possible future reads, even if it's linked into a broader graph which stays alive (e.g., by reading a state which remains live).\n\n    * Note that most frameworks today require explicit disposal of computed Signals if they have any reference to or from another Signal graph which remains alive.\n    * This ends up not being so bad when their lifetime is tied to the lifetime of a UI component, and effects need to be disposed of anyway.\n    * If it is too expensive to execute with these semantics, then we should add explicit disposal (or \"unlinking\") of computed Signals to the API below, which currently lacks it.\n  * A separate related goal: Minimize the number of allocations, e.g.,\n\n    * to make a writable Signal (avoid two separate closures + array)\n    * to implement effects (avoid a closure for every single reaction)\n    * In the API for observing Signal changes, avoid creating additional temporary data structures\n    * Solution: Class-based API enabling reuse of methods and fields defined in subclasses\n\n## API sketch\n\nAn initial idea of a Signal API is below. Note that this is just an early\ndraft, and we anticipate changes over time. Let's start with the full .d.ts to\nget an idea of the overall shape, and then we'll discuss the details of what\nit all means.\n\n    \n    \n    interface Signal<T> { // Get the value of the signal get(): T; } namespace Signal { // A read-write Signal class State<T> implements Signal<T> { // Create a state Signal starting with the value t constructor(t: T, options?: SignalOptions<T>); // Get the value of the signal get(): T; // Set the state Signal value to t set(t: T): void; } // A Signal which is a formula based on other Signals class Computed<T = unknown> implements Signal<T> { // Create a Signal which evaluates to the value returned by the callback. // Callback is called with this signal as the this value. constructor(cb: (this: Computed<T>) => T, options?: SignalOptions<T>); // Get the value of the signal get(): T; } // This namespace includes \"advanced\" features that are better to // leave for framework authors rather than application developers. // Analogous to `crypto.subtle` namespace subtle { // Run a callback with all tracking disabled function untrack<T>(cb: () => T): T; // Get the current computed signal which is tracking any signal reads, if any function currentComputed(): Computed | null; // Returns ordered list of all signals which this one referenced // during the last time it was evaluated. // For a Watcher, lists the set of signals which it is watching. function introspectSources(s: Computed | Watcher): (State | Computed)[]; // Returns the Watchers that this signal is contained in, plus any // Computed signals which read this signal last time they were evaluated, // if that computed signal is (recursively) watched. function introspectSinks(s: State | Computed): (Computed | Watcher)[]; // True if this signal is \"live\", in that it is watched by a Watcher, // or it is read by a Computed signal which is (recursively) live. function hasSinks(s: State | Computed): boolean; // True if this element is \"reactive\", in that it depends // on some other signal. A Computed where hasSources is false // will always return the same constant. function hasSources(s: Computed | Watcher): boolean; class Watcher { // When a (recursive) source of Watcher is written to, call this callback, // if it hasn't already been called since the last `watch` call. // No signals may be read or written during the notify. constructor(notify: (this: Watcher) => void); // Add these signals to the Watcher's set, and set the watcher to run its // notify callback next time any signal in the set (or one of its dependencies) changes. // Can be called with no arguments just to reset the \"notified\" state, so that // the notify callback will be invoked again. watch(...s: Signal[]): void; // Remove these signals from the watched set (e.g., for an effect which is disposed) unwatch(...s: Signal[]): void; // Returns the set of sources in the Watcher's set which are still dirty, or is a computed signal // with a source which is dirty or pending and hasn't yet been re-evaluated getPending(): Signal[]; } // Hooks to observe being watched or no longer watched var watched: Symbol; var unwatched: Symbol; } interface SignalOptions<T> { // Custom comparison function between old and new value. Default: Object.is. // The signal is passed in as the this value for context. equals?: (this: Signal<T>, t: T, t2: T) => boolean; // Callback called when isWatched becomes true, if it was previously false [Signal.subtle.watched]?: (this: Signal<T>) => void; // Callback called whenever isWatched becomes false, if it was previously true [Signal.subtle.unwatched]?: (this: Signal<T>) => void; } }\n\n### How Signals work\n\nA Signal represents a cell of data which may change over time. Signals may be\neither \"state\" (just a value which is set manually) or \"computed\" (a formula\nbased on other Signals).\n\nComputed Signals work by automatically tracking which other Signals are read\nduring their evaluation. When a computed is read, it checks whether any of its\npreviously recorded dependencies have changed, and re-evaluates itself if so.\nWhen multiple computed Signals are nested, all of the attribution of the\ntracking goes to the innermost one.\n\nComputed Signals are lazy, i.e., pull-based: they are only re-evaluated when\nthey are accessed, even if one of their dependencies changed earlier.\n\nThe callback passed into computed Signals should generally be \"pure\" in the\nsense of being a deterministic, side-effect-free function of the other Signals\nwhich it accesses. At the same time, the timing of the callback being called\nis deterministic, allowing side effects to be used with care.\n\nSignals feature prominent caching/memoization: both state and computed Signals\nremember their current value, and only trigger recalculation of computed\nSignals which reference them if they actually change. A repeated comparison of\nold vs new values isn't even needed--the comparison is made once when the\nsource Signal is reset/re-evaluated, and the Signal mechanism keeps track of\nwhich things referencing that Signal have not updated based on the new value\nyet. Internally, this is generally represented through \"graph coloring\" as\ndescribed in (Milo's blog post).\n\nComputed Signals track their dependencies dynamically--each time they are run,\nthey may end up depending on different things, and that precise dependency set\nis kept fresh in the Signal graph. This means that if you have a dependency\nneeded on only one branch, and the previous calculation took the other branch,\nthen a change to that temporarily unused value will not cause the computed\nSignal to be recalculated, even when pulled.\n\nUnlike JavaScript Promises, everything in Signals runs synchronously:\n\n  * Setting a Signal to a new value is synchronous, and this is immediately reflected when reading any computed Signal which depends on it afterwards. There is no built-in batching of this mutation.\n  * Reading computed Signals is synchronous--their value is always available.\n  * The notify callback in Watchers, as explained below, runs synchronously, during the .set() call which triggered it (but after graph coloring has completed).\n\nLike Promises, Signals can represent an error state: If a computed Signal's\ncallback throws, then that error is cached just like another value, and\nrethrown every time the Signal is read.\n\n### Understanding the Signal class\n\nA Signal instance represents the capability to read a dynamically changing\nvalue whose updates are tracked over time. It also implicitly includes the\ncapability to subscribe to the Signal, implicitly through a tracked access\nfrom another computed Signal.\n\nThe API here is designed to match the very rough ecosystem consensus among a\nlarge fraction of Signal libraries in the use of names like \"signal\",\n\"computed\" and \"state\". However, access to Computed and State Signals is\nthrough a .get() method, which disagrees with all popular Signal APIs, which\neither use a .value-style accessor, or signal() call syntax.\n\nThe API is designed to reduce the number of allocations, to make Signals\nsuitable for embedding in JavaScript frameworks while reaching same or better\nperformance than existing framework-customized Signals. This implies:\n\n  * State Signals are a single writable object, which can be both accessed and set from the same reference. (See implications below in the \"Capability separation\" section.)\n  * Both State and Computed Signals are designed to be subclassable, to facilitate frameworks' ability to add additional properties through public and private class fields (as well as methods for using that state).\n  * Various callbacks (e.g., equals, the computed callback) are called with the relevant Signal as the this value for context, so that a new closure isn't needed per Signal. Instead, context can be saved in extra properties of the signal itself.\n\nSome error conditions enforced by this API:\n\n  * It is an error to read a computed recursively.\n  * The notify callback of a Watcher cannot read or write any signals\n  * If a computed Signal's callback throws, then subsequent accesses of the Signal rethrow that cached error, until one of the dependencies changes and it is recalculated.\n\nSome conditions which are not enforced:\n\n  * Computed Signals can write to other Signals, synchronously within their callback\n  * Work which is queued by a Watcher's notify callback may read or write signals, making it possible to replicate classic React antipatterns in terms of Signals!\n\n### Implementing effects\n\nThe Watcher interface defined above gives the basis for implementing typical\nJS APIs for effects: callbacks which are re-run when other Signals change,\npurely for their side effect. The effect function used above in the initial\nexample can be defined as follows:\n\n    \n    \n    // This function would usually live in a library/framework, not application code // NOTE: This scheduling logic is too basic to be useful. Do not copy/paste. let pending = false; let w = new Signal.subtle.Watcher(() => { if (!pending) { pending = true; queueMicrotask(() => { pending = false; for (let s of w.getPending()) s.get(); w.watch(); }); } }); // An effect effect Signal which evaluates to cb, which schedules a read of // itself on the microtask queue whenever one of its dependencies might change export function effect(cb) { let destructor; let c = new Signal.Computed(() => { destructor?.(); destructor = cb(); }); w.watch(c); c.get(); return () => { destructor?.(); w.unwatch(c) }; }\n\nThe Signal API does not include any built-in function like effect. This is\nbecause effect scheduling is subtle and often ties into framework rendering\ncycles and other high-level framework-specific state or strategies which JS\ndoes not have access to.\n\nWalking through the different operations used here: The notify callback passed\ninto Watcher constructor is the function that is called when the Signal goes\nfrom a \"clean\" state (where we know the cache is initialized and valid) into a\n\"checked\" or \"dirty\" state (where the cache might or might not be valid\nbecause at least one of the states which this recursively depends on has been\nchanged).\n\nCalls to notify are ultimately triggered by a call to .set() on some state\nSignal. This call is synchronous: it happens before .set returns. But there's\nno need to worry about this callback observing the Signal graph in a half-\nprocessed state, because during a notify callback, no Signal can be read or\nwritten, even in an untrack call. Because notify is called during .set(), it\nis interrupting another thread of logic, which might not be complete. To read\nor write Signals from notify, schedule work to run later, e.g., by writing the\nSignal down in a list to later be accessed, or with queueMicrotask as above.\n\nNote that it is perfectly possible to use Signals effectively without\nSymbol.subtle.Watcher by scheduling polling of computed Signals, as Glimmer\ndoes. However, many frameworks have found that it is very often useful to have\nthis scheduling logic run synchronously, so the Signals API includes it.\n\nBoth computed and state Signals are garbage-collected like any JS values. But\nWatchers have a special way of holding things alive: Any Signals which are\nwatched by a Watcher will be held alive as long as any of the underlying\nstates are reachable, as these may trigger a future notify call (and then a\nfuture .get()). For this reason, remember to call Watcher.prototype.unwatch to\nclean up effects.\n\n### An unsound escape hatch\n\nSignal.subtle.untrack is an escape hatch allowing reading Signals without\ntracking those reads. This capability is unsafe because it allows the creation\nof computed Signals whose value depends on other Signals, but which aren't\nupdated when those Signals change. It should be used when the untracked\naccesses will not change the result of the computation.\n\n### Omitted for now\n\nThese features may be added later, but they are not included in the current\ndraft. Their omission is due to the lack of established consensus in the\ndesign space among frameworks, as well as the demonstrated ability to work\naround their absence with mechanisms on top of the Signals notion described in\nthis document. However, unfortunately, the omission limits the potential of\ninteroperability among frameworks. As prototypes of Signals as described in\nthis document are produced, there will be an effort to reexamine whether these\nomissions were the appropriate decision.\n\n  * Async: Signals are always synchronously available for evaluation, in this model. However, it is frequently useful to have certain asynchronous processes which lead to a signal being set, and to have an understanding of when a signal is still \"loading\". One simple way to model the loading state is with exceptions, and the exception-caching behavior of computed signals composes somewhat reasonably with this technique. Improved techniques are discussed in Issue #30.\n  * Transactions: For transitions between views, it is often useful to maintain a live state for both the \"from\" and \"to\" states. The \"to\" state renders in the background, until it is ready to swap over (committing the transaction), while the \"from\" state remains interactive. Maintaining both states at the same time requires \"forking\" the state of the signal graph, and it may even be useful to support multiple pending transitions at once. Discussion in Issue #73.\n\nSome possible convenience methods are also omitted.\n\n## Status and development plan\n\nThis proposal is on the April 2024 TC39 agenda for Stage 1. It can currently\nbe thought of as \"Stage 0\".\n\nA polyfill for this proposal is available, with some basic tests. Some\nframework authors have begun experimenting with substituting this signal\nimplementation, but this usage is at an early stage.\n\nThe collaborators on the Signal proposal want to be especially conservative in\nhow we push this proposal forward, so that we don't land in the trap of\ngetting something shipped which we end up regretting and not actually using.\nOur plan is to do the following extra tasks, not required by the TC39 process,\nto make sure that this proposal is on track:\n\nBefore proposing for Stage 2, we plan to:\n\n  * Develop multiple production-grade polyfill implementations which are solid, well-tested (e.g., passing tests from various frameworks as well as test262-style tests), and competitive in terms of performance (as verified with a thorough signal/framework benchmark set).\n  * Integrate the proposed Signal API into a large number of JS frameworks that we consider somewhat representative, and some large applications work with this basis. Test that it works efficiently and correctly in these contexts.\n  * Have a solid understanding on the space of possible extensions to the API, and have concluded which (if any) should be added into this proposal.\n\n## Signal algorithms\n\nThis section describes each of the APIs exposed to JavaScript, in terms of the\nalgorithms that they implement. This can be thought of as a proto-\nspecification, and is included at this early point to nail down one possible\nset of semantics, while being very open to changes.\n\nSome aspects of the algorithm:\n\n  * The order of reads of Signals within a computed is significant, and is observable in the order that certain callbacks (which Watcher is invoked, equals, the first parameter to new Signal.Computed, and the watched/unwatched callbacks) are executed. This means that the sources of a computed Signal must be stored ordered.\n  * These four callbacks might all throw exceptions, and these exceptions are propagated in a predictable manner to the calling JS code. The exceptions do not halt execution of this algorithm or leave the graph in a half-processed state. For errors thrown in the notify callback of a Watcher, that exception is sent to the .set() call which triggered it, using an AggregateError if multiple exceptions were thrown. The others (including watched/unwatched?) are stored in the value of the Signal, to be rethrown when read, and such a rethrowing Signal can be marked ~clean~ just like any other with a normal value.\n  * Care is taken to avoid circularities in cases of computed signals which are not \"watched\" (being observed by any Watcher), so that they can be garbage collected independently from other parts of the signal graph. Internally, this can be implemented with a system of generation numbers which are always collected; note that optimized implementations may also include local per-node generation numbers, or avoid tracking some numbers on watched signals.\n\n### Hidden global state\n\nSignal algorithms need to reference certain global state. This state is global\nfor the entire thread, or \"agent\".\n\n  * computing: The innermost computed or effect Signal currently being reevaluated due to a .get or .run call, or undefined. Initially undefined.\n  * notifying: Boolean denoting whether there is an notify callback currently executing. Initially false.\n  * generation: An incrementing integer, starting at 0, used to track how current a value is while avoiding circularities.\n\n### The Signal namespace\n\nSignal is an ordinary object which serves as a namespace for Signal-related\nclasses and functions.\n\nSignal.subtle is a similar inner namespace object.\n\n### The Signal.State class\n\n#### Signal.State internal slots\n\n  * value: The current value of the state signal\n  * equals: The comparison function used when changing values\n  * watched: The callback to be called when the signal becomes observed by an effect\n  * unwatched: The callback to be called when the signal is no longer observed by an effect\n  * sinks: Set of watched signals which depend on this one\n\n#### Constructor: Signal(initialValue, options)\n\n  1. Set this Signal's value to initialValue.\n  2. Set this Signal's equals to options?.equals\n  3. Set this Signal's watched to options?.[Signal.subtle.watched]\n  4. Set this Signal's unwatched to options?.[Signal.subtle.watched]\n  5. Set this Signal's sinks to the empty set\n  6. Set state to ~clean~.\n\n#### Method: Signal.State.prototype.get()\n\n  1. If notifying is true, throw an exception.\n  2. If computing is not undefined, add this Signal to computing's sources set.\n  3. NOTE: We do not add computing to this Signal's sinks set until it is watched by a Watcher.\n  4. Return this Signal's value.\n\n#### Method: Signal.State.prototype.set(newValue)\n\n  1. If the current execution context is notifying, throw an exception.\n  2. Run the \"set Signal value\" algorithm with this Signal and the first parameter for the value.\n  3. If that algorithm returned ~clean~, then return undefined.\n  4. Set the state of all sinks of this Signal to (if it is a Computed Signal) ~dirty~ if they were previously clean, or (if it is a Watcher) ~pending~ if it was previously ~watching~.\n  5. Set the state of all of the sinks' Computed Signal dependencies (recursively) to ~checked~ if they were previously ~clean~ (that is, leave dirty markings in place), or for Watchers, ~pending~ if previously ~watching~.\n  6. For each previously ~watching~ Watcher encountered in that recursive search, then in depth-first order,\n\n    1. Set notifying to true while calling their notify callback (saving aside any exception thrown, but ignoring the return value of notify), and then restore notifying to false.\n  7. If any exception was thrown from the notify callbacks, propagate it to the caller after all notify callbacks have run. If there are multiple exceptions, then package them up together into an AggregateError and throw that.\n  8. Return undefined.\n\n### The Signal.Computed class\n\n#### Signal.Computed Internal slots\n\n  * value: The previous cached value of the Signal, or ~uninitialized~ for a never-read computed Signal. The value may be an exception which gets rethrown when the value is read. Always undefined for effect signals.\n  * state: May be ~clean~, ~checked~, ~computing~, or ~dirty~.\n  * sources: An ordered set of Signals which this Signal depends on.\n  * sinks: An ordered set of Signals which depend on this Signal.\n  * equals: The equals method provided in the options.\n  * callback: The callback which is called to get the computed Signal's value. Set to the first parameter passed to the constructor.\n\n#### Signal.Computed Constructor\n\nThe constructor sets\n\n  * callback to its first parameter\n  * equals based on options, defaulting to Object.is if absent\n  * state to ~dirty~\n  * value to ~uninitialized~\n\nWith AsyncContext, the callback passed to new Signal.Computed closes over the\nsnapshot from when the constructor was called, and restores this snapshot\nduring its execution.\n\n#### Method: Signal.Computed.prototype.get\n\n  1. If the current execution context is notifying or if this Signal has the state ~computing~, or if this signal is an Effect and computing a computed Signal, throw an exception.\n  2. If computing is not undefined, add this Signal to computing's sources set.\n  3. NOTE: We do not add computing to this Signal's sinks set until/unless it becomes watched by a Watcher.\n  4. If this Signal's state is ~dirty~ or ~checked~: Repeat the following steps until this Signal is ~clean~:\n\n    1. Recurse up via sources to find the deepest, left-most (i.e. earliest observed) recursive source which is marked ~dirty~ (cutting off search when hitting a ~clean~ Signal, and including this Signal as the last thing to search).\n    2. Perform the \"recalculate dirty computed Signal\" algorithm on that Signal.\n  5. At this point, this Signal's state will be ~clean~, and no recursive sources will be ~dirty~ or ~checked~. Return the Signal's value. If the value is an exception, rethrow that exception.\n\n### The Signal.subtle.Watcher class\n\n#### Signal.subtle.Watcher internal slots\n\n  * state: May be ~watching~, ~pending~ or ~waiting~\n  * signals: An ordered set of Signals which this Watcher is watching\n  * notifyCallback: The callback which is called when something changes. Set to the first parameter passed to the constructor.\n\n#### Constructor: new Signal.subtle.Watcher(callback)\n\n  1. state is set to ~waiting~.\n  2. Initialize signals as an empty set.\n  3. notifyCallback is set to the callback parameter.\n\nWith AsyncContext, the callback passed to new Signal.subtle.Watcher does not\nclose over the snapshot from when the constructor was called, so that\ncontextual information around the write is visible.\n\n#### Method: Signal.subtle.Watcher.prototype.watch(...signals)\n\n  1. If any of the arguments is not a signal, throw an exception.\n  2. Append all arguments to the end of this object's signals.\n  3. Add this watcher to each of the newly watched signals as a sink.\n  4. Add this watcher as a sink to each Signal. If this was the first sink, then recurse up to sources to add that signal as a sink, and call the watched callback if it exists.\n\n#### Method: Signal.subtle.Watcher.prototype.unwatch(...signals)\n\n  1. If any of the arguments is not a signal, or is not being watched by this watcher, throw an exception.\n  2. Remove each element from signals from this object's signals.\n  3. Remove this Watcher from that Signal's sink set.\n  4. If any Signal's sink set is now empty, then remove itself as a sink from each of its sources, and call the unwatched callback if it exists\n\n#### Method: Signal.subtle.Watcher.prototype.getPending()\n\n  1. Return an Array containing the subset of signals which are in the state dirty or pending.\n\n### Method: Signal.subtle.untrack(cb)\n\n  1. Let c be the execution context's current computing state.\n  2. Set computing to undefined.\n  3. Call cb.\n  4. Restore computing to c (even if cb threw an exception).\n  5. Return the return value of cb (rethrowing any exception).\n\nNote: untrack doesn't get you out of the notifying state, which is maintained\nstrictly.\n\n### Common algorithms\n\n##### Algorithm: recalculate dirty computed Signal\n\n  1. Clear out this Signal's sources set, and remove it from those sources' sinks sets.\n  2. Save the previous computing value and set computing to this Signal.\n  3. Set this Signal's state to ~computing~.\n  4. Run this computed Signal's callback, using this Signal as the this value. Save the return value, and if the callback threw an exception, store that for rethrowing.\n  5. Set this Signal's recalculating to false.\n  6. Restore the previous computing value.\n  7. Apply the \"set Signal value\" algorithm to the callback's return value.\n  8. Set this Signal's state to ~clean~.\n  9. If that algorithm returned ~dirty~: mark all sinks of this Signal as ~dirty~ (previously, the sinks may have been a mix of checked and dirty). (Or, if this is unwatched, then adopt a new generation number to indicate dirtiness, or something like that.)\n  10. Otherwise, that algorithm returned ~clean~: In this case, for each ~checked~ sink of this Signal, if all of that Signal's sources are now clean, then mark that Signal as ~clean~ as well. Apply this cleanup step to further sinks recursively, to any newly clean Signals which have checked sinks. (Or, if this is unwatched, somehow indicate the same, so that the cleanup can proceed lazily.)\n\n##### Set Signal value algorithm\n\n  1. If this algorithm was passed a value (as opposed to an exception for rethrowing, from the recalculate dirty computed Signal algorithm):\n\n    1. Call this Signal's equals function, passing as parameters the current value, the new value, and this Signal. If an exception is thrown, save that exception (for rethrowing when read) as the value of the Signal and continue as if the callback had returned false.\n    2. If that function returned true, return ~clean~.\n  2. Set the value of this Signal to the parameter.\n  3. Return ~dirty~\n\n## FAQ\n\nQ: Isn't it a little soon to be standardizing something related to Signals,\nwhen they just started to be the hot new thing in 2022? Shouldn't we give them\nmore time to evolve and stabilize?\n\nA: The current state of Signals in web frameworks is the result of more than\n10 years of continuous development. As investment steps up, as it has in\nrecent years, almost all of the web frameworks are approaching a very similar\ncore model of Signals. This proposal is the result of a shared design exercise\nbetween a large number of current leaders in web frameworks, and it will not\nbe pushed forward to standardization without the validation of that group of\ndomain experts in various contexts.\n\n#### How are Signals used?\n\nQ: Can built-in Signals even be used by frameworks, given their tight\nintegration with rendering and ownership?\n\nA: The parts which are more framework-specific tend to be in the area of\neffects, scheduling, and ownership/disposal, which this proposal does not\nattempt to solve. Our first priority with prototyping standards-track Signals\nis to validate that they can sit \"underneath\" existing frameworks compatibly\nand with good performance.\n\nQ: Is the Signal API meant to be used directly by application developers, or\nwrapped by frameworks?\n\nA: While this API could be used directly by application developers (at least\nthe part which is not within the Signal.subtle namespace), it is not designed\nto be especially ergonomic. Instead, the needs of library/framework authors\nare priorities. Most frameworks are expected to wrap even the basic\nSignal.State and Signal.Computed APIs with something expressing their\nergonomic slant. In practice, it's typically best to use Signals via a\nframework, which manages trickier features (e.g., Watcher, untrack), as well\nas managing ownership and disposal (e.g., figuring out when signals should be\nadded to and removed from watchers), and scheduling rendering to DOM--this\nproposal doesn't attempt to solve those problems.\n\nQ: Do I have to tear down Signals related to a widget when that widget is\ndestroyed? What is the API for that?\n\nA: The relevant teardown operation here is\nSignal.subtle.Watcher.prototype.unwatch. Only watched Signals need to be\ncleaned up (by unwatching them), while unwatched Signals can be garbage-\ncollected automatically.\n\nQ: Do Signals work with VDOM, or directly with the underlying HTML DOM?\n\nA: Yes! Signals are independent of rendering technology. Existing JavaScript\nframeworks which use Signal-like constructs integrate with VDOM (e.g.,\nPreact), the native DOM (e.g., Solid) and a combination (e.g., Vue). The same\nwill be possible with built-in Signals.\n\nQ: Is it going to be ergonomic to use Signals in the context of class-based\nframeworks like Angular and Lit? What about compiler-based frameworks like\nSvelte?\n\nA: Class fields can be made Signal-based with a simple accessor decorator, as\nshown in the Signal polyfill readme. Signals are very closely aligned to\nSvelte 5's Runes--it is simple for a compiler to transform runes to the Signal\nAPI defined here, and in fact this is what Svelte 5 does internally (but with\nits own Signals library).\n\nQ: Do Signals work with SSR? Hydration? Resumability?\n\nA: Yes. Qwik uses Signals to good effect with both of these properties, and\nother frameworks have other well-developed approaches to hydration with\nSignals with different tradeoffs. We think that it is possible to model Qwik's\nresumable Signals using a State and Computed signal hooked together, and plan\nto prove this out in code.\n\nQ: Do Signals work with one-way data flow like React does?\n\nA: Yes, Signals are a mechanism for one-way dataflow. Signal-based UI\nframeworks let you express your view as a function of the model (where the\nmodel incorporates Signals). A graph of state and computed Signals is acyclic\nby construction. It is also possible to recreate React antipatterns within\nSignals (!), e.g., the Signal equivalent of a setState inside of useEffect is\nto use a Watcher to schedule a write to a State signal.\n\nQ: How do signals relate to state management systems like Redux? Do signals\nencourage unstructured state?\n\nA: Signals can form an efficient basis for store-like state management\nabstractions. A common pattern found in multiple frameworks is an object based\non a Proxy which internally represents properties using Signals, e.g., Vue\nreactive(), or Solid stores. These systems enable flexible grouping of state\nat the right level of abstraction for the particular application.\n\nQ: What are Signals offering that Proxy doesn't currently handle?\n\nA: Proxies and Signals are complementary and go well together. Proxies let you\nintercept shallow object operations and signals coordinate a dependency graph\n(of cells). Backing a Proxy with Signals is a great way to make a nested\nreactive structure with great ergonomics.\n\nIn this example, we can use a proxy to make the signal have a getter and\nsetter property instead of using the get and set methods:\n\n    \n    \n    const a = new Signal.State(0); const b = new Proxy(a, { get(target, property, receiver) { if (property === 'value') { return target.get(): } } set(target, property, value, receiver) { if (property === 'value') { target.set(value)! } } }); // usage in a hypothetical reactive context: <template> {b.value} <button onclick={() => { b.value++; }}>change</button> </template>\n\nwhen using a renderer that is optimized for fine-grained reactivity, clicking\nthe button will cause the b.value cell to be updated.\n\nSee:\n\n  * examples of nested reactive structures created with both Signals and Proxies: signal-utils\n  * example prior implementations showing the relationship between reactive data atd proxies: tracked-built-ins\n  * discussion.\n\n#### How do Signals work?\n\nQ: Are Signals push-based or pull-based?\n\nA: Evaluation of computed Signals is pull-based: computed Signals are only\nevaluated when .get() is called, even if the underlying state changed much\nearlier. At the same time, changing a State signal may immediately trigger a\nWatcher's callback, \"pushing\" the notification. So Signals may be thought of\nas a \"push-pull\" construction.\n\nQ: Do Signals introduce nondeterminism into JavaScript execution?\n\nA: No. For one, all Signal operations have well-defined semantics and\nordering, and will not differ among conformant implementations. At a higher\nlevel, Signals follow a certain set of invariants, with respect to which they\nare \"sound\". A computed Signal always observes the Signal graph in a\nconsistent state, and its execution is not interrupted by other Signal-\nmutating code (except for things it calls itself). See the description above.\n\nQ: When I write to a state Signal, when is the update to the computed Signal\nscheduled?\n\nA: It isn't scheduled! The computed Signal will recalculate itself the next\ntime someone reads it. Synchronously, a Watcher's notify callback may be\ncalled, enabling frameworks to schedule a read at the time that they find\nappropriate.\n\nQ: When do writes to state Signals take effect? Immediately, or are they\nbatched?\n\nA: Writes to state Signals are reflected immediately--the next time a computed\nSignal which depends on the state Signal is read, it will recalculate itself\nif needed, even if in the immediately following line of code. However, the\nlaziness inherent in this mechanism (that computed Signals are only computed\nwhen read) means that, in practice, the calculations may happen in a batched\nway.\n\nQ: What does it mean for Signals to enable \"glitch-free\" execution?\n\nA: Earlier push-based models for reactivity faced an issue of redundant\ncomputation: If an update to a state Signal causes the computed Signal to\neagerly run, ultimately this may push an update to the UI. But this write to\nthe UI may be premature, if there was going to be another change to the\noriginating state Signal before the next frame. Sometimes, inaccurate\nintermediate values were even shown to end-users due to such glitches. Signals\navoid this dynamic by being pull-based, rather than push-based: At the time\nthe framework schedules the rendering of the UI, it will pull the appropriate\nupdates, avoiding wasted work both in computation as well as in writing to the\nDOM.\n\nQ: What does it mean for Signals to be \"lossy\"?\n\nA: This is the flipside of glitch-free execution: Signals represent a cell of\ndata--just the immediate current value (which may change), not a stream of\ndata over time. So, if you write to a state Signal twice in a row, without\ndoing anything else, the first write is \"lost\" and never seen by any computed\nSignals or effects. This is understood to be a feature rather than a bug--\nother constructs (e.g., async iterables, observables) are more appropriate for\nstreams.\n\nQ: Will native Signals be faster than existing JS Signal implementations?\n\nA: We hope so (by a small constant factor), but this remains to be proven in\ncode. JS engines aren't magic, and will ultimately need to implement the same\nkinds of algorithms as JS implementations of Signals. See above section about\nperformance.\n\n#### Why are Signals designed this way?\n\nQ: Why doesn't this proposal include an effect() function, when effects are\nnecessary for any practical usage of Signals?\n\nA: Effects inherently tie into scheduling and disposal, which are managed by\nframeworks and outside the scope of this proposal. Instead, this proposal\nincludes the basis for implementing effects through the more low-level\nSignal.subtle.Watcher API.\n\nQ: Why are subscriptions automatic rather than providing a manual interface?\n\nA: Experience has shown that manual subscription interfaces for reactivity are\nun-ergonomic and error-prone. Automatic tracking is more composable and is a\ncore feature of Signals.\n\nQ: Why does the Watcher's callback run synchronously, rather than scheduled in\na microtask?\n\nA: Because the callback cannot read or write Signals, there is no unsoundness\nbrought on by calling it synchronously. A typical callback will add a Signal\nto an Array to be read later, or mark a bit somewhere. It is unnecessary and\nimpractically expensive to make a separate microtask for all of these sorts of\nactions.\n\nQ: This API is missing some nice things that my favorite framework provides,\nwhich makes it easier to program with Signals. Can that be added to the\nstandard too?\n\nA: Maybe. Various extensions are still under consideration. Please file an\nissue to raise discussion on any missing feature you find to be important.\n\nQ: Can this API be reduced in size or complexity?\n\nA: It's definitely a goal to keep this API minimal, and we've tried to do so\nwith what's presented above. If you have ideas for more things that can be\nremoved, please file an issue to discuss.\n\n#### How are Signals being standardized?\n\nQ: Shouldn't we start standardization work in this area with a more primitive\nconcept, such as observables?\n\nA: Observables may be a good idea for some things, but they don't solve the\nproblems that Signals aim to solve. As described above, observables or other\npublish/subscribe mechanisms are not a complete solution to many types of UI\nprogramming, due to too much error-prone configuration work for developers,\nand wasted work due to lack of laziness, among other issues.\n\nQ: Why are Signals being proposed in TC39 rather than DOM, given that most\napplications of it are web-based?\n\nA: Some coauthors of this proposal are interested in non-web UI environments\nas a goal, but these days, either venue may be suitable for that, as web APIs\nare being more frequently implemented outside the web. Ultimately, Signals\ndon't need to depend on any DOM APIs, so either way works. If someone has a\nstrong reason for this group to switch, please let us know in an issue. For\nnow, all contributors have signed the TC39 intellectual property agreements,\nand the plan is to present this to TC39.\n\nQ: How long is it going to take until I can use standard Signals?\n\nA: A polyfill is already available, but it's best to not rely on its\nstability, as this API evolves during its review process. In some months or a\nyear, a high-quality, high-performance stable polyfill should be usable, but\nthis will still be subject to committee revisions and not yet standard.\nFollowing the typical trajectory of a TC39 proposal, it is expected to take at\nleast 2-3 years at an absolute minimum for Signals to be natively available\nacross all browsers going back a few versions, such that polyfills are not\nneeded.\n\nQ: How will we prevent standardizing the wrong kind of Signals too soon, just\nlike {{JS/web feature that you don't like}}?\n\nA: The authors of this proposal plan to go the extra mile with prototyping and\nproving things out prior to requesting stage advancement at TC39. See \"Status\nand development plan\" above. If you see gaps in this plan or opportunities for\nimprovement, please file an issue explaining.\n\n## About\n\nA proposal to add signals to JavaScript.\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\n### Code of conduct\n\nCode of conduct\n\n### Security policy\n\nSecurity policy\n\nActivity\n\nCustom properties\n\n### Stars\n\n2.2k stars\n\n### Watchers\n\n72 watching\n\n### Forks\n\n32 forks\n\nReport repository\n\n## Contributors 18\n\n\\+ 4 contributors\n\n## Languages\n\n  * TypeScript 100.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": true}
