{"aid": "39988345", "title": "Programming Language Scalability", "url": "https://blog.sulami.xyz/posts/programming-language-scalability/", "domain": "sulami.xyz", "votes": 1, "user": "goranmoomin", "posted_at": "2024-04-10 08:35:24", "comments": 0, "source_title": "Programming Language Scalability - sulami's blog", "source_text": "Programming Language Scalability - sulami's blog\n\nWeak Opinions, Strongly Held\n\nFeed \u2022 Uses \u2022 About\n\n# Programming Language Scalability\n\nPublished on 2024-04-09\n\nTags: staff\n\nI have been thinking about programming language scalability. I am not talking\nabout performance here, but organizational scalability. Let us start with a\nbit of background.\n\nOne of the reasons I originally joined CircleCI was because they were using\nClojure, and I had been dabbling in Clojure at the time.Though I've never met\nhim, I've been told Clojure was chosen because Paul Biggar liked it at the\ntime. He's now making Darklang, which looks interesting as well. I believe\ntheir choice of language caused a self-selection effect for many of the early\nengineers, probably for the better. Regardless, some time before I left the\ncompany, we got the mandate to move everything to Go. The company was going\nthrough an intense growth phase, and it was becoming increasingly difficult to\nhire Clojure engineers. We had a reasonable amount of Go code already,This\nalso predates my tenure, but when the CircleCI CLI was written, Clojure's\nsignificant application startup time disqualified it for CLI tools. In plain\nClojure, depending on your dependencies, you might wait 10 seconds or more\nwhile the runtime is loading before your program even starts doing anything.\nNot a big problem for server-side processes, in fact the original CircleCI\nmonolith took several minutes to load. Nowadays one could use GraalVM to get\naround this. From what I've been told, Go and Rust were in the running, and at\nthe time Go made it easier to produce a statically linked binary, so it won.\nBy the time the switch was mandated, I reckon almost half of all code running\nwas Go. so the choice was obvious. Another factor that played into this\ndecision was the fact that most Clojure engineers could drop into a Go service\nand make some changes relatively easily, while the reverse was not quite as\ntrue. This is not because the Clojure engineers were better, but because it is\nmore difficult to be effective in an unfamiliar Clojure codebase than in a Go\none.\n\nThere were also some technical growth pains we experienced on the Clojure\nside. Clojure being a highly dynamic language, we had a decent number of\nruntime errors, which we could only counter with additional testing and\nobservability. The lack of static types also made development more difficult\nfor anyone not directly familiar with the code, as almost everything tended to\nbe a bag of values in the form of a map.In my area in particular there were\nprobably a dozen or more different shapes of maps one would call \"a build,\"\nall of which had different sets of keys. One would then go and inspect callers\nto figure out which one was actually being passed. In some cases it wouldn't\neven be a single one. The macro system and a culture that emphasized\nexpressiveness led to a variety of different design patterns, each optimized\nfor their respective author's preferences, and inscrutable to everyone else.\nIt also did not help that Clojure has no standard approach to structure a\nservice, so everyone rolled their own. One could not freely jump between\ndifferent Clojure services without having to learn the different idioms.\n\nIn my current day job, we are running a Ruby on Rails monolith. The\nengineering department is much smaller at around 30 people, but the monolith\nhas been around for about a decade. While Rails engineers are easier to hire\nthan Clojure ones, especially here in Japan, we are experiencing some of the\nsame pain points as we did at CircleCI. Ruby is also dynamically typed, and\nhas a culture of domain-specific languages that read almost like plain\nEnglish. \"Automagical\" abstractions are seen as a virtue. As a result, we have\na variety of competing patterns for almost every situation, each of which\nrequires some learning. Within the monolithic architecture, no boundaries are\ndefined or enforced, and it is difficult to reason about the impact of any\ngiven change.I'm aware of projects like Packwerk, but besides the non-\nnegligible maintenance overhead, it only solves parts of the problem. What\npersonally gets me is the meta-programming and module system which together\nmake it difficult to track down where methods come from, even for LSP servers.\n\nIn both of these cases, the problems maybe could have been alleviated with\nbetter technical leadership or otherwise different practices, but I believe in\nsetting yourself up for success despite yourself. As organizations grow, one\ncannot depend on everyone being good at their job, or even average, if\nstatistics are to be believed. With this I would like to talk about the\nscalability of a programming language, which I will define it as:\n\n> A programming language is more scalable if an engineer unfamiliar with a\n> code base written in it produces correct code more quickly.\n\nScalability is often at odds with peak effectiveness, the maximum\neffectiveness of an engineer who is intimately familiar with the codebase,\nbecause the features driving peak effectiveness are often enabling\nabstractions tailored towards the specific use case at hand, like macros and\nsupport for domain-specific languages. These abstractions can make domain\nexperts more effective, but present an additional barrier to entry to everyone\nelse. At the extreme end of this spectrum sit code golf languages.\n\nThere are many factors that contribute to scalability. Prevalence determines\nhow easy it is to hire for, and to some extent also the support from the\necosystem in the shape of libraries, tooling and available knowledge.\nGuardrails help prevent mistakes, the biggest ones being memory safety and\nstatic type checking. The latter also enables better support for editor\nintegrations such as LSP which enhances discoverability. Standardized tooling\nfor the build process, formatting, testing, and so on further reduce the\npotential need to learn multiple approaches. Support for, and a culture of\nheavily using language extension features on the other hand reduce\nscalability, as detailed in the Lisp Curse. Languages that deviate a lot from\nthe mainstream are on average more difficult to learn, whether it is quirky\nsyntax with a lot of parentheses, or a weird execution model that involves\nmonads.\n\nTo be clear, language scalability is not just something managers want to\noptimize for in order to ensure engineers are fungible. While independent\nteams are a worthy goal to aspire to, in reality cross-team dependencies are\ncommon, and being able to submit a change to another team's code can reduce\nthe overhead incurred. And of course some code goes untouched for many months\nor years, to the point where even the original authors cannot claim\nfamiliarity anymore.\n\nAs an example, I have collected some subjective thoughts on the scalability of\nprogramming languages I am familiar with, ordered roughly from most scalable\nto least scalable, in the context of web service backend systems. In other\ncontexts the list would of course look different.If you have platform\nrequirements, the list might actually be very short.\n\nIf I wanted to select viable candidates from that list, I would probably pick\nbetween Rust, Go, or Java/Kotlin. C# would probably also work, but I have not\nwritten any in close to a decade. I arrive there with a simple heuristic, as\nall of these languages are statically typed and considered mainstream, almost\nboring. I am excluding C and C++ for the lack of guardrails, and Python and\nRuby for the lack of static typing. Typescript as a language might be fine,\nbut I personally have doubts about the stability of the tooling, which might\nbe unfounded. It is certainly popular, even on the backend.\n\nProgramming language scalability is only interesting for organizations, and\nonly beyond a certain size. If your engineering team can fit in a single room\nfor the next five years, it probably does not matter. Conventional wisdom is\nthat the best technology to start a new project is the one you know well. And\nsometimes there will be technical requirements that trump organizational ones.\nIn any case, you should take care to spend your innovation tokens wisely.\n\nBuilt 2024-04-09 23:08\n\n", "frontpage": false}
