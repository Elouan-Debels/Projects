{"aid": "39998634", "title": "Designing a Tagged Union type in C++/Subspace (2022)", "url": "http://orodu.net/2022/12/03/tagged-union.html", "domain": "orodu.net", "votes": 1, "user": "phewlink", "posted_at": "2024-04-11 05:19:22", "comments": 0, "source_title": "Designing a Tagged Union type in C++/Subspace", "source_text": "Designing a Tagged Union type in C++/Subspace | An Update on Writing Memory Safety Bugs\n\n# An Update on Writing Memory Safety Bugs\n\nHow could we write better software, and write software better?\n\nA blog by danakj Email GitHub Mastodon RSS\n\n# Designing a Tagged Union type in C++/Subspace\n\nDec 3, 2022 \u2022 Dana Jansens\n\nFirst blog post! The hardest part of writing blog posts about Subspace has\nbeen setting something up, and starting. So let\u2019s just dive in. I will write\nan introduction to Subspace in another post another day. Today, let\u2019s talk\nabout Undefined Behaviour.\n\n### Tagged Union\n\nA tagged union is a combination of two familiar C++ things: an enum and a\nunion. At a high level, you have a set of values and some data to associate\nwith each one. So a tagged union is some set of data attached to each value in\nthe enum, with the data held in a union.\n\nIn old C++, you would have to do this by literally writing a tag and a union.\n\n    \n    \n    struct HoldsThings { enum TypesOfThings { Car, House, Poetry, } tag; union { // Associated with `TypesOfThings::Car`. struct { std::string model; } car; // Associated with `TypesOfThings::House`. struct { int number; std::string street; } house; // Associated with `TypesOfThings::Poetry`. std::string poetry; } data; };\n\nThe structure is very free-form, and it\u2019s up to the author to ensure they\nactually access the right data at the right time.\n\nUnions have some very strict rules in C++, including:\n\n  * At most one member at a time is active (there can be zero active members).\n  * A member is made active by writing to it.\n  * Reading from a non-active member is Undefined Behaviour.\n\nSo if any user of HoldsThings messes up and reads or writes to a union member\nthat is not correct for the current tag, the result will be Undefined\nBehaviour. It also requires a lot of clunky code.\n\n#### C++17 and std::variant\n\nC++17 introduces std::variant, which provides a tagged union, except over a\nsize_t instead of over an enum. If you have a mapping from an enum to size_t\nthen you can essentially use it as a tagged enum. A variant can be read or\nwritten into by selecting based on the type of the member, but this provides\nno easy way to map between enum values and variant members, so we ignore it\nhere.\n\nThis is a big improvement over rolling it yourself. If you std::get() to read\nan inactive member, the std::variant will throw an exception.\n\nSo are we done? This still requires developers to map between enum values and\nsize_t. And enum values need not be contiguous, while the indices of a varint\nare, giving lots of chances for bugs. Because of this, I decided I wanted to\nprovide a true tagged union in Subspace.\n\n### Rust Enums\n\nRust has an enum keyword as well, but it natively allows you to attach data to\neach value in the enum, which means they are a tagged union. Pat Shaughnessy\ndoes a great job explaining how Rust enums are implemented in terms of how\ntheir data is stored. And in the comments, Ingvar Stepanyan made a very\ninteresting point, which I will quote here:\n\n> 1) In fact, what Rust uses for its representation is more like\n>  \n>  \n>     union tagged_num_or_str { struct num { char tag; short num; }\n> num_variant; struct str { char tag; char *str; } str_variant; };\n>\n> The difference, while obscure, is actually important for alignment and size\n> optimisation. For example, if you add one more u16 field to each variant,\n> you\u2019ll get:\n>  \n>  \n>     union tagged_num_or_str { struct num { char tag; short data; short num;\n> } num_variant; struct str { char tag; short data; char *str; } str_variant;\n> };\n>\n> which is 16 bytes and not\n>  \n>  \n>     struct tagged_num_or_str_2 { char tag; union { struct { short data;\n> short num; } num_variant; struct { short data; char *str; } str_variant; };\n> };\n>\n> which is 24 bytes.\n\nThis thoroughly nerd-sniped me. Could I do the same in C++?\n\n### Into the alignment rabbit hole\n\nFirst, what does std::variant do? It does the naive thing, putting the tag\noutside the structures, which makes sense given that it has no control over\nthe storage types within. In this case, each storage type is a tuple, and\nvariant can\u2019t just randomly stick a tag field into them.\n\n    \n    \n    auto v = std::variant<std::tuple<i8, u32>, std::tuple<i8, u64>>(); static_assert(sizeof(decltype(v)) == sizeof(u64) * 3u); // Tag is outside.\n\nI will have to introduce the integral types in another post, treat i32 as\nint32_t etc. for now.\n\nHere the size is dominated by the larger std::tuple<i8, u64>. Inside the tuple\nwe can conceptually think of the storage as:\n\n    \n    \n    struct { i8 field1; // 1 byte. // 7 bytes of padding for the `u64` to be aligned correctly. u64 field2; // 8 bytes. };\n\nThis takes up 16 bytes so far. Then the std::variant needs to add a tag in\nfront. Let\u2019s say it is only 1 byte:\n\n    \n    \n    struct variant { u8 tag; // 1 byte. // 7 bytes of padding for the `struct` with `u64`-alignment to // be aligned correctly. struct { i8 field1; // 1 byte. // 7 bytes of padding for the `u64` to be aligned // correctly. u64 field2; // 8 bytes. }; }; // Total: 24 bytes.\n\nThe compiler is forced to put 7 bytes of padding below the tag, because the\npadding below field1 is fixed. Skipping that padding would mis-align the u64\nmember, resulting some more Undefined Behaviour. This results in the size of\nour std::variant being 3 * sizeof(u64), or 24 bytes, even though it only holds\n10 bytes of interest.\n\nSticking the tag into the inner struct would remove 7 bytes of padding below\ntag, and 1 byte of padding below field1, which could reduce the size of the\nvariant to 16 bytes, which is the minimum possible size for this combination\nof values.\n\n    \n    \n    struct variant { struct { u8 tag; // 1 byte. i8 field1; // 1 byte. // 6 bytes of padding for the `u64` to be aligned // correctly. u64 field2; // 8 bytes. }; }; // Total: 16 bytes.\n\n### Stashing the tag in each Union member\n\nSubspace is all about rethinking assumptions about how a C++ library should be\nwritten. Above we said std::variant has no control over the inner types, so it\nhas to put the tag outside them. So what happens if we throw that assumption\naway?\n\nHere\u2019s a possible sus::Union with the same data as from the std::variant\nexample. But notably without the use of std::tuple, which was a key part of\nthe type we named above.\n\n    \n    \n    union Union { struct { u8 tag; // 1 byte. i8 field1; // 1 byte. // 2 bytes of padding for the `u32` to be aligned // correctly. u32 field2; // 4 bytes. // 8 bytes of padding to have the same size as the struct // below. } struct { u8 tag; // 1 byte. i8 field1; // 1 byte. // 6 bytes of padding for the `u64` to be aligned // correctly. u64 field2; // 8 bytes. }; }; // Total: 16 bytes.\n\nWe have a tagged union that optimizes its storage space. Looks great, ship it!\nLet\u2019s find an API that can support it!\n\nExcept, there\u2019s one problem. Remember how the C++ spec only allows you to read\nfrom the active member of the union? In order to know which element of the\ntagged union is active, we need to read the tag, but we can\u2019t read the tag\nunless we know which tag to read. So this sounds like instant Undefined\nBehaviour if we actually use the tag.\n\nBut the C++20 standard has some additional rules that can save us here. The\ncppreference docs for union have a single sentence which aludes to this:\n\n> If two union members are standard-layout types, it\u2019s well-defined to examine\n> their common subsequence on any compiler.\n\nBut this is actually more general than what the spec allows, so let\u2019s look at\nthat text instead:\n\n> One special guarantee is made in order to simplify the use of unions: If a\n> standard-layout union contains several standard-layout structs that share a\n> common initial sequence (11.4), and if a non-static data member of an object\n> of this standard-layout union type is active and is one of the standard-\n> layout structs, it is permitted to inspect the common initial sequence of\n> any of the standard-layout struct members; see 11.4\n\nThe tag is part of the \u201ccommon initial sequence\u201d of each structure in our\nunion since it:\n\n  * Is at the front of each structure, so there\u2019s nothing not-in-common before it.\n  * It has the same layout in each structure.\n\nBut this exception has a very big disclaimer: the structures must be Standard-\nLayout types. This isn\u2019t a property we have to think about a lot in day-to-day\nC++ work, but it turns out that it is critical to the rules of how you can use\na C++ union. The property can be checked by the std::is_standard_layout type\ntrait, and indeed integers (and our i8 and friends) are standard layout. So\nthis would actually work well for the types given here!\n\nIn fact, we used this same clause in Subspace\u2019s Option type to hide the\nboolean state for Option<T> inside the type T, inspired by Rust.\n\nSo it seems like we can have a minimally-sized tagged union in C++. At least\nfor some types?\n\n### Troubles with Standard-Layout\n\nA class is a Standard-Layout type, according to cppreference if it:\n\n>   * has no non-static data members of type non-standard-layout class (or\n> array of such types) or reference,\n>   * has no virtual functions and no virtual base classes,\n>   * has the same access control for all non-static data members,\n>   * has no non-standard-layout base classes,\n>   * only one class in the hierarchy has non-static data members, and\n>   * none of the base classes has the same type as the first non-static data\n> member.\n>\n\nI got through most of these rules with increasing joy until I reached: \u201conly\none class in the hierarchy has non-static data members\u201d. Ah... tuple. Tuple is\nthe way to define a type in the template system that mixes together\nheterogeneous types.\n\nThe implementation of tuple is up to the library to define, but C++ does place\nsome limitations on us. Inheritance is the tool that the language gives us for\nthis.\n\nThe std::tuple in libc++ is (as of Dec 2022) implemented roughly as\nsubclassing from a holder for each type in the tuple. Simplified as:\n\n    \n    \n    template <class... Ts> struct tuple : Ts... {};\n\nThis means that there are sizeof...(Ts) many classes in the hierarchy with\nnon-static data members. So tuple can not be standard layout (at least not\nwith more than 1 value in it).\n\nAnother way to implement this would be to have tuple subclass a series of base\nclasses, each one holding one type. This is the initial implementation of\nsus::Tuple, though the libc++ implementation makes me wonder if it performs\nbetter (for compile times?).\n\n#### Composition > Inheritance?\n\nThere is actually another way. As the Google C++ Style Guide says:\n\u201cComposition is often more appropriate than inheritance.\u201d And in fact\nstd::variant is not constructed through inheritance since unions can not\ninherit. And C++20 does provide a way for composition to be more space\nefficient in ways that only inheritance could do before. When inheriting from\na base class, the derived class can be given the tail padding of the base\nclass to place its fields. This has historically been commonly used for the\nempty base optimization, in which the derived class uses the single byte of\npadding in an empty subclass.\n\nC++20 brings the [[no_unique_address]] attribute, which performs a similar\nfunction for fields. A field marked with the attribute allows fields below it\nto be placed in its tail padding.\n\n    \n    \n    struct TailPadding { u64 first; // 8 bytes. u32 second; // 4 bytes. // 4 bytes of tail padding to make the size of TailPadding // a multiple of its alignment. }; // 16 bytes. struct S { [[no_unique_address]] TailPadding p; // 16 bytes, with 4 bytes of tail // padding. u32 i; // 4 bytes, placed inside TailPadding. }; // 16 bytes.\n\nHowever, the padding is only able to be used in this way if the TailPadding\ntype is not a standard-layout type. And MSVC doesn\u2019t appear to perform this\ntype of optimization at all except with empty classes. Therefore, using\ncomposition with [[no_unique_address]] does not afford us anything better than\ninheritance does for implementing our tuple. In order to get the space usage\nthat we see from Tuple as it is written, we are relying on the fact that the\nTuple is not standard-layout.\n\nSo, we are resigned to tuples being non-standard layout in order to use space\nat all efficiently. And if our tagged union wants to build a type that\nincludes a tag and some user-defined types, it is going to have to do it with\na tuple of at least 2 members:\n\n    \n    \n    union Union { tuple<tag, T1> a; tuple<tag, T2> b; }\n\nSince tuple<tag, T> is not a Standard-Layout type, our Union type can not\naccess the tag as we hoped for without incurring Undefined Behaviour. This\nmeans the tag has to be pulled out of a and b, just as in std::variant.\n\n### Can we avoid tuples?\n\nMany types in a program are not Standard-Layout types, including tuples. But\ncould we get minimally- sized tagged unions for the times when all the types\ninside are Standard-Layout types? To do so, we can\u2019t use tuples, nor\ninheritence to generate the types stored in the Union. The other tool we have\nto compose hetergeneous types is struct.\n\nGiven no boundaries on the API shape, I set out to see if we could generate\nstructs with a tag field each to hold in the tagged union.\n\nGenerating a struct with the sus_for_each() macro is easy enough, if we have\nthe set of types.\n\n    \n    \n    struct { u8 tag; i8; u32; };\n\nBut with a struct, we have to give them unique names. So I modified the\nsus_for_each() macro to concat a symbol like f to itself recursively.\n\n    \n    \n    struct { u8 tag; i8 f; u32 ff; };\n\nWhile building out the sus::Tuple type, I came across an interesting piece of\nstructured bindings. When structured bindings are applied to a struct, the\ncompiler will bind the fields of that struct in order. This means that while\nwe have to generate unique names for the struct fields, we don\u2019t need to know\nthem to refer to them! In the example below, a and b will references to s.f\nand s.ff respectively.\n\n    \n    \n    struct S { i8 f; u32 ff; } s; auto& [a, b] = s;\n\nBut C++ was not designed to build structs like this in the middle of a type\ndeclaration. While we can write std::variant<std::tuple<i32, i32>>, we can not\nwrite std::variant<struct { i8 f; u32 ff; }>. The spec disallows it, and the\ncompiler errors look like the following.\n\n  * Clang: error: declaration of anonymous struct must be a definition.\n  * GCC: error: types may not be defined in template arguments.\n  * MSVC just completely doesn\u2019t parse it: error C2947: expecting \u2018>\u2019 to terminate template-argument-list, found \u2018>\u2019.\n\nHaving the user of the Union type declare the structs themselves isn\u2019t an\noption, as they would need to put a tag inside them. At best, we could use a\nmacro to define a structure with a tag, then pass that type to the Union.\n\n    \n    \n    // A struct with generated internals. Still leaves room for error if something // is added to the struct above the macro. struct S { sus_union_types(i8, u32); }; // Or this could generate a struct named S. sus_union_struct(S, i8, u32); auto u = Union<S>;\n\nThis approach could generate a struct with a special tag so that Union ensures\nthe sus_union_types macro is used. But it hides a lot behind a macro, to the\npoint of making it unclear what is happening in this code at all. And so I\nabandoned trying to get a minimally-sized tagged union in C++ after all.\n\n### Union API choices\n\nThe points that felt important in the design of the Union API were:\n\n  1. It should be clear that a sus::Union type is being defined.\n  2. It shouldn\u2019t require the storage types to be defined externally.\n  3. It should make it as clear as possible which enum value is tied to what storage types.\n  4. Hard to use wrong, easy to understand what\u2019s happening.\n\nThe candiates I landed on were as follows.\n\nThis API here has a struct U declare the type associated with each enum value\nas fields. This fails our goals by requiring the type U to be declared\nbeforehand. It\u2019s also unclear what\u2019s going on, as the fields each correspond\nto one enum value, which feels surprising.\n\n    \n    \n    struct U { i8 i; u32 f; }; auto u = Union<U, Smurfs::Papa, Smurfs::Mama>();\n\nThis API is kinda what you\u2019d expect if you took a std::variant and put enums\ninto it. Instead of receiving a list of types, it receives a tuple of a list\nof types. Then an enum value for each type listed in the tuple. It fails our\ngoals in that it\u2019s easy to get things wrong. Once you get to 15 enum values\nand types, it gets very hard to tell which type is for which enum value. While\nyou\u2019d like to think that you would get a compiler error for getting the wrong\ntype, you may instead just get implicit type conversions.\n\n    \n    \n    auto u = Union<Tuple<i8, u32>, Smurfs::Papa, Smurfs::Mama>();\n\nThis API uses a macro to pair each enum value clearly with the type attached\nto it. This satisfies the problems of the previous API, but it fails our goals\nas well. It is not obvious that this defines a Union type. A macro here could\nevaluate to pretty much anything.\n\n    \n    \n    auto u = sus_union((Smurfs::Papa, i8), (Smurfs::Mama, u32));\n\nThis API is where I eventually landed so far. We use a macro to define pairs\nof enum values and types, which get transformed into a shape closer to\nTuple<int, float>, Smurfs::Papa, Smurfs::Mama internally. Macros can be magic,\nbut placed inside the template variables of the Union, we know the union is\ndefining the structure of the Union.\n\n    \n    \n    auto u = Union<sus_type_pairs((Smurfs::Papa, i8), (Smurfs::Mama, u32))>();\n\nThen, going a step further, I wondered if we need to only have one type per\nenum value. A Rust enum can define many types:\n\n    \n    \n    enum Smurfs { Papa(i8, u32), Mama(u64), }\n\nBy the power of nesting more sus_for_each() macros, we can get the same with\nour sus::Union type. Then accessing the storage associated with an enum value\nwill either give the single type stored within, or in the case of multiple\ntypes, a Tuple of all of them.\n\n    \n    \n    auto u = Union<sus_type_pairs((Smurfs::Papa, i8, u32), (Smurfs::Mama, u64))>(); u.get_ref<Smurfs::Papa>(); // Returns a `Tuple<const i8&, const u32&>`. // Which means you can use structured bindings: const auto& [a, b] = u.get_ref<Smurfs::Papa>(); // `a` is `const i8&`. // `b` is `const u32&`. u.get_ref<Smurfs::Mama>(); // Returns a `const u64&`.\n\nThis tagged union type will eliminate programming errors and Undefined\nBehaviour, and I hope will lead to better API designs in C++ programs, by\nmaking it easier and more natural to have types exist only when they are valid\nto be used.\n\nThis Union type\u2019s implementation is now happening in Subspace PR #99.\n\nEdit: Added the section on compostion with [[no_unique_address]] which I\nforgot to mention originally.\n\nEdit: Fixes in the last example, thanks @nigeltao.\n\nNote: The Union type has since been renamed to Choice.\n\n<\n\nBlog Archive\n\nArchive of all blog posts\n\n>\n\nNext Post\n\nWhy Subspace\n\nInteractions:\n\n", "frontpage": false}
