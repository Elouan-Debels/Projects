{"aid": "39988676", "title": "Rust 101", "url": "https://www.scotto.me/blog/rust-101/", "domain": "scotto.me", "votes": 30, "user": "silcoon", "posted_at": "2024-04-10 09:24:10", "comments": 0, "source_title": "Rust 101", "source_text": "Rust 101\n\n# / Rust 101\n\nApril 10, 2024 Tagged: rust\n\nI\u2019ve recently had the chance to try Rust for a project and it has been a\nsurprising pleasant experience. Rust is a modern language and I felt quire\nfamiliar with it in a few days. It has a simple and effective design and\nthanks to that, it gets frequently mentioned as a successor to old low level\nlanguages C like. Rust is fast and, in a lot of benchmarks, the compiled code\nperformance is comparable to C and C++. I don\u2019t have experience yet with other\nsimilar low-level languages as Nim or Zig but I believe that there\u2019s a reason\nwhy Rust got extremely popular in the last few years.\n\nIn this article I\u2019ll write down a quick overview of the most important concept\nthat I found make Rust a different and more evolved language compared to it\u2019s\npredecessor. The Rust documentation is really well written with a lot of\nexample and it will allow you to use the language in a very short time.\n\n## Memory Safety\n\nRust is a memory safe language which means that it\u2019s design prevent the\nprogrammer to do operation that could provoke memory faults and crashes of the\nprogram. If you ever wrote C or C++ you know what kind of bugs I\u2019m talking\nabout. This kind of problems are hard to spot and debug and in complex\nprograms, it gets easy to use an already free memory or to forget to free one.\n\nThere have been two main ways to manage program memory. One is letting the\nmemory management in the hands of the programmer (as C, C++), and the other is\nusing a Garbage Collector that will clean the unused allocated memory portions\nfor you (as Lisp, Java, Python, JS). Manually freeing the memory can get\ncomplicated with large and complex programs, and automatic garbage collection\ncan slow down your execution at random, and it\u2019s not that easy to control.\n\nRust bring a different approach; writing programs that are actually memory\nsafe by design. It does that by not exposing the memory management functions,\nwithout using an external tool to do the job. It introduces the concept of\nownership, a set of rules that check your code at compile time to prevent you\nto do operations that break the ownership of a variable.\n\n### Ownership\n\nThis are the ownership rules:\n\n  1. Each value in Rust has an owner.\n  2. There can only be one owner at a time.\n  3. When the owner goes out of scope, the value will be dropped.\n\n    \n    \n    let s1 = String::from(\"hello\"); // s1 is the owner of the String let s2 = s1; // s2 becomes the new owner, and s1 is invalidated println!(\"{}, world!\", s1); // This will cause a compile-time error because s1 is no longer valid\n\nThe previous code will not compile. The compiler would even give you\nsuggestion to what caused the error: error[E0382]: borrow of moved value: s1.\nOne may think that the string s1 should still be there, but in reality Rust\nalready called drop on the string structure, deallocating the memory segment\nand making it no longer valid.\n\nRust is getting in the way of the programmer for a good reasons; following\nthis rules will prevent problems with memory deallocation, like forgetting to\ndeallocate something, accessing a resource already deallocated, or double\nfreeing a variable. In exchange, Rust is enforcing some patterns and providing\nsome data structure to solve all ownership problems. The following is a useful\nschema I found on reddit, that quickly points you to which data structure is\nbetter to use for each scenario (T is the generic data type).\n\nsource:\nhttps://www.reddit.com/r/rust/comments/mgh9n9/ownership_concept_diagram/\n\n### Borrowing\n\nBorrowing is a mechanism that allows you to create references to data owned by\nanother variable, enabling multiple parts of your code to access and\npotentially modify the same data without transferring ownership.\n\n    \n    \n    fn main() { let mut s = String::from(\"hello\"); change(&mut s); } fn change(some_string: &mut String) { some_string.push_str(\", world\"); }\n\nIn the code above, I\u2019ve just created an mutable reference to a String object,\nand passed it to a function that modify the string. This behaviour it\u2019s called\nborrowing, since we borrow the value, and then give it back to the caller when\nfinished using it.\n\nIn Rust, we cannot borrow as mutable variable more than once. This restriction\nof preventing multiple mutable references to the same data, helps preventing\ndata races at compile time.\n\n## Structs and objects\n\nRust allows the creation of custom data types using struct and enum. A struct\nis between a C struct and a C++ class. It can be used as object and have\naccess to self, but it\u2019s missing a full support for inheritance.\n\n    \n    \n    struct Rectangle { width: u32, height: u32, } impl Rectangle { fn new(w: u32, h: u32) -> Rectangle { Rectangle { width: w, height: h, } } fn area(&self) -> f64 { (self.width * self.height) as f64 } } fn main() { let mut rect = Rectangle::new(3, 4); println!(\"Area: {}\", rect.area()); }\n\nA new struct Rectangle has been defined, with a simple area method which\naccess the property using the reference to itself.\n\nWhen a new struct is defined inside a file, it can be encapsulated simply by\navoiding the use of pub on the methods. This way, they will not be visible\nfrom outside but still accessible from inside.\n\n### Traits\n\nPolymorphism can be pefrormed by defining a Trait which adds the possibility\nto have shared behaviour between structures.\n\n    \n    \n    trait Area { fn area(&self) -> f64; } impl Area for Circle { fn area(&self) -> f64 { std::f64::consts::PI * self.radius * self.radius } }\n\nHere I\u2019ve defined a trait Area which every shape struct can implement in it\u2019s\nown way. The trait it\u2019s only the function signature, with parameters and\nexpected return type.\n\n### Enum\n\nEnum are just a way of define a set of values that a variable of that type can\ntake. It\u2019s similar to struct in the sense that accept the use of impl with\ncustom methods and traits.\n\n    \n    \n    enum Animal { Bird, Insect, Fish, Mammal, }\n\n## Pattern matching\n\nPattern matching is a construct that is essential in the Rust design. It\nallows to automatically match the value of a variable using it\u2019s possible\nstates, similar to the statement case in other languages. I use the operator\nmatch that receives the variable and give the possibility to execute code when\na value is matching.\n\n    \n    \n    impl Animal { fn can_fly(&self) -> bool { match self { Animal::Bird => true, Animal::Insect => true, _ => false, // Covers Fish and Mammal } } }\n\nFor example, here it\u2019s matching all the possible states that a variable of\ntype Animal can have. The option _ is a catch-all pattern, representing all\nthe other possible states that the variable can take.\n\n## Result and Option\n\nTwo enumerated types that are part of the Rust standard library are Result and\nOption. They\u2019re values used to deal with errors that need to be managed and\npotentially absent values. To access the value, the pattern matching method\nshown above is required.\n\nResult is used in case a function may fail and there\u2019s a need to grab the\nexception and handle it. Rust allows functions to throw errors and then catch\nthem from the caller by performing a match on the function\u2019s returned value.\n\n    \n    \n    use std::fs::File; use std::io; fn read_file(path: &str) -> Result<String, io::Error> { let file = File::open(path)?; let mut contents = String::new(); file.read_to_string(&mut contents)?; Ok(contents) } fn main() { match read_file(\"example.txt\") { Ok(contents) => println!(\"File contents: {}\", contents), Err(error) => println!(\"Error reading file: {}\", error), } }\n\n? is a special operator in Rust that allows to return the error directly,\nsaving you the boilerplate of writing another match.\n\nOption instead is used to return an optional value, since Rust doesn\u2019t have\nthe concept of null (and no Null Pointer Exception).\n\n    \n    \n    fn find_first_even(numbers: &[i32]) -> Option<i32> { for num in numbers { if num % 2 == 0 { return Some(*num); } } None } fn main() { let numbers = vec![1, 3, 5, 7, 8]; match find_first_even(&numbers) { Some(even) => println!(\"First even number: {}\", even), None => println!(\"No even numbers found\"), } }\n\n## Functional\n\nRust took closures and iterators from functional programming. It\u2019s easy to\nwrite inline functions and iterate over array with the set of functions\navailable for functional programming.\n\n    \n    \n    let numbers = vec![1, 2, 3, 4, 5]; let doubled: Vec<_> = numbers.iter().map(|x| { x * 2 }).collect();\n\nIn the code above I\u2019m using map over a list of numbers, and running the lambda\nfunction |x| x * 2 on it, in fact creating a closure. If you need to add the\npossibility to add iteraction support to a struct, you would need to implement\nthe Iterator trait, as shown in the docs\n\n## Analyzer\n\nrust-analyzer is what is going to help you understanding Rust and the patterns\nthat the language is guiding you to use. When integrated inside your favourite\neditor (I\u2019m using Zed right now), you will see warning and errors generated\ndirectly when saving a file.\n\nLet\u2019s try to analyse some broken code\n\n    \n    \n    fn main() { let s1 = String::from(\"hello\"); let s2 = s1; println!(\"{}\", s1); }\n\nWhy is this code broken?\n\n    \n    \n    error[E0382]: borrow of moved value: `s1` --> src/main.rs:4:20 | 65 | let s1 = String::from(\"hello\"); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 66 | let s2 = s1; | -- value moved here 67 | println!(\"{}\", s1); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info) help: consider cloning the value if the performance cost is acceptable | 66 | let s2 = s1.clone(); | ++++++++\n\nRust is telling that when the code does s2 = s1, it moves the value s1 so it\ncannot be used anymore in the println call. A solution is to clone s1 into s2\nso it will then have two independent instances of the string. Pretty handy to\nfind a quick solution, especially for beginners. The Rust team did a great job\nfor creating high quality error messages to guide the user to find a solution.\n\n## Macros\n\nRust supports different types of macros: declarative and procedural. Macro\nhelps extending the language by removing boilerplate code and even extending\nprograms with external code (e.g. plugins).\n\nDeclarative macros are called like functions, they just append ! to their\nname.\n\n    \n    \n    #[macro_export] macro_rules! vec { ( $( $x:expr ),* ) => { { let mut temp_vec = Vec::new(); $( temp_vec.push($x); )* temp_vec } }; } let v = vec![1, 2, 3, 4]; // Creates a new vec inline\n\nMy suggestion is to avoid using macros and always prefer functions where\npossible. Macros are hard to understand, maintain and document when they get\ncomplex.\n\n## Cargo and packages\n\ncargo is the official package manager for Rust. It downloads the dependencies\nand keep track of the Rust version the project is supporting. It can be used\nfor all the task related to the project, like running, building it, generating\nthe documentations, etc. The package registry is crates.io which counts more\nthan 140K packages as today.\n\n## Tests\n\nRust provides a test framework directly in the language which supports both\nunit and integration tests. cargo test is how to run all the tests for a\nproject.\n\nThis is a unit test example, included in the same file of the function\nimplementation.\n\n    \n    \n    #[cfg(test)] mod tests { #[test] fn it_works() { let result = 2 + 2; assert_eq!(result, 4); } }\n\n## When to use Rust\n\nRust at the moment is getting really popular, but I believe it is not a\nsolution for all types of problems. When performance are a requirement,\ninstead of using C or C++, Rust can provide a significant improvement over\nthem. Rust is nearly as fast as C, but it is definitely safer, and the choice\nwill pay off...\n\nRust new UI frameworks are emerging every year, and I believe is in a great\nspot, despite not being object oriented, to become the go-to language for\ncreating the next generation of desktop apps. Checkout Tauri which is a faster\nreplacement than Electron, or the new GPUI which uses native libraries and\nlooks very promising.\n\nsource: https://www.youtube.com/watch?v=6mZRWFQRvmw&t=27012s\n\n\u00a9 2024 Elia Scotto \u22c5 RSS feed\n\n", "frontpage": true}
