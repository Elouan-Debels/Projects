{"aid": "40039403", "title": "How programming languages influence each other and evolve", "url": "https://thetechenabler.substack.com/p/how-languages-influence-each-other", "domain": "thetechenabler.substack.com", "votes": 3, "user": "ingve", "posted_at": "2024-04-15 12:03:53", "comments": 0, "source_title": "How languages influence each other and evolve", "source_text": "How languages influence each other and evolve\n\n# The Tech Enabler\n\nShare this post\n\n#### How languages influence each other and evolve\n\nthetechenabler.substack.com\n\n#### Discover more from The Tech Enabler\n\nMy personal Substack for my role as a tech enabler inside a large media\ncompany. I write about work, culture, and programming in general. My current\nseries is all about tech trends and what I think teams should adopt or drop.\n\nContinue reading\n\nSign in\n\n# How languages influence each other and evolve\n\nNoah Hall\n\nApr 14, 2024\n\nShare this post\n\n#### How languages influence each other and evolve\n\nthetechenabler.substack.com\n\nShare\n\nWhat starts as a good idea in one place often ends up as a good idea in other\nplaces. There\u2019s plenty of examples of this, from API design, to language\nfeatures.\n\nOne such example which is interesting to look at is list comprehensions - a\nconcept that didn\u2019t even begin life as a programming concept, but then was\nadded early on into some languages known for inspiring others, and then became\na popular concept.\n\nIt\u2019s also interesting to look at languages which haven\u2019t adopted this, and\nwhy. Not all languages should adopt every idea, and not every language should\nhave the same implementation. Selective design takes ideas from many sources,\nfilters out the irrelevant ones, and adopts those that fit the principles of\nthe language. These concepts apply to all aspects of tech: from product\ndesign, to API design, to language design.\n\nLet\u2019s take a deeper look at list comprehensions.\n\nA disclaimer before we get started: I\u2019ve included a rough timeline, but can\u2019t\ncover every language. So I\u2019ll cover enough distinct languages to point out\nsome interesting points. Don\u2019t be offend if your favourite language is left\nout!\n\n###\n\nWhat is a list comprehension?\n\nList comprehensions allow a developer to write list manipulation succinctly,\nwithout needing to manually modify the list after creation. It originally came\nfrom maths, but became popular in immutable languages like Haskell. From\nthere, other languages adopted comprehensions - sometimes adapting them for\nother purposes, too.\n\nA basic example might look like:\n\n    \n    \n    [ greet(user) for user in users if user.name == \"Noah\" ]\n\nwhereas a more traditional for-loop would look like:\n\n    \n    \n    greeted_users = [] for user in users: if user.name == \"Noah\": greeted_users.append(greet(user))\n\nThe list comprehension in this example didn\u2019t need to call .append, and could\nbe expressed in one line.\n\nLet\u2019s take a look at why some languages have adopted this, and others haven\u2019t.\n\n###\n\nThe problem statement\n\nWe\u2019d like to take a nested list of user objects, and extract the name of any\nusers which are 30 years old. Imagine that the user objects are something\nlike:\n\n    \n    \n    type User = { first: age, second: name }\n\nThe pseudo-code to then process the list would look like this:\n\n    \n    \n    output_list = [] input_list = [ [ { \"age\": 29, \"name\": \"Joan\" }, { \"age\": 30, \"name\": \"Dave\" } ], [ { \"age\": 30, \"name\": \"Harry\" }, { \"age\": 35, \"name\": \"Sally\" } ] ] for sublist in input_list: for user in sublist: if user.age == 30: output_list.append(user.name) print(output_list) # [ \"Dave\", \"Harry\" ]\n\nLet\u2019s take a look at how these can be expressed in some languages1, starting\nat the root: mathematics.\n\n###\n\nMaths\n\nIn set theory, there\u2019s a syntax called set-builder notation. If we adapt it a\nlittle bit to fit programming, it looks something like this:\n\nIn maths, it\u2019s quite common to want to express some logical concept in as few\ncharacters and as many symbols as possible. Set builder syntax allows for the\nsimple representation of a complex set relation.\n\nThis concept and syntax were adopted by programming languages, with an origin\nin 1970s with languages such as ML, Miranda, KRC, Id. NPL, a language\nappearing in 1977, was the first with comprehensions, operating on sets rather\nthan lists. Id introduced array comprehensions in 1978, and in 1982, list\ncomprehensions (then known as ZF expressions) were introduced in a language\ncalled KRC.\n\n\ud83d\udca1 Interesting \ud83d\udca1: Set theory lacks a traditional debugging step that we have in\nprogramming languages. How might you inspect input_list, or sublist to check\ntheir values? This is interesting because list comprehensions in other\nlanguages are often hard to debug, as there is not a natural point to put a\nbreak or print expression. New comers to list comprehensions will often print\nthe values before the comprehension, and after, but not during. Many early\nlanguage adopters of comprehensions were lazy \u2014 values were only calculated as\nthey were needed by the program, which matches the theoretical application of\nset theory.\n\n###\n\nHaskell\n\nWhile other languages did have list comprehensions before Haskell, Haskell is\nreally where it became popular as a concept that then spread to other\nmainstream languages. In the first Haskell specification2, list comprehensions\nlooked like this:\n\n    \n    \n    [ x | xs <- input_list, User { name = x, age = 30 } <- xs ]\n\nThe most popular Haskell compiler, GHC, has many language extensions which add\nmany new features to Haskell code. There\u2019s a few for comprehensions, with the\nthree most notable being generalised list comprehensions, parallel list\ncomprehensions, and monad comprehensions. Generalised list comprehensions add\na SQL-inspired syntax, while monad comprehensions generalise the ability to\nmap and filter over any monad. Note that lists are a monad, so it is not\nstrange to provide monad comprehensions - something that other languages would\nfollow suit in doing, too.\n\n\ud83d\udca1Interesting\ud83d\udca1: Haskell\u2019s syntax is close to the set theory origins, and has\nlanguage extensions that provide alternative syntax and broader scope.\nHaskell\u2019s influence took an idea from smaller, experimental languages, and\nmade it notable with the mainstream language community.\n\n###\n\nPython\n\nPython introduced list comprehensions in 2.0, through PEP 202. Python\u2019s\nversion looks a lot like a regular for-loop, but condensed with inline ifs.\n\n    \n    \n    [ user[\"name\"] for sublist in input_list for user in sublist if user[\"age\"] == 30 ]\n\nPEP 274 then introduced dict and set comprehensions to Python 2.7 and 3.0,\nallowing for succinct ways of creating dicts and sets. Interestingly, this was\noriginally proposed for Python 2.3, but dropped in favour of generator\nexpressions with the dict() function constructor. The fact that this was\nreintroduced, with the exact same proposal, and accepted, is a good reflection\nof how long term language development happens. An idea might not seem as good\nas alternatives in the past, but with more information on usage and code\nstyle, it may become more attractive.\n\nAfter generators were introduced in PEP 255 (Python 2.2), generator\ncomprehensions were added with PEP 289 (Python 2.4). After async/await support\nwas introduced with PEP 492 (Python 3.5), async comprehensions were added with\nPEP 530 (Python 3.6).\n\n\ud83d\udca1Interesting\ud83d\udca1: Python was the first mainstream language to add list\ncomprehensions, so many developers know comprehensions from Python, rather\nthan set theory or Haskell. Comprehensions have become a standard way of\ninteracting with data in Python.\n\n###\n\nC#, DotNet\n\nC# added LINQ in version 3.0, which provided powerful ways of doing\ncomprehensions - including lists. LINQ support was added via the .Net\nframework, so other languages using it could implement their own LINQ\nintegrations (e.g Visual Basic). LINQ came out of Microsoft\u2019s language\nresearch producing Comega, a language focused on researching data querying and\nmanipulation. LINQ is very powerful, it might be the most powerful\nimplementation of comprehensions on this list. The syntax is quite distinct\nfrom the C# or Visual Basic it is contained in. This is an example of a DSL\nbeing a core language feature.\n\n    \n    \n    from sublist in input_list from user in sublist where user.age == 30 select user.name\n\n\ud83d\udca1Interesting\ud83d\udca1: Other .Net languages like Visual Basic also have support for\nLINQ - it\u2019s a language feature built into the .Net framework which is then\nexposed through each language\u2019s syntax. LINQ is also one of the most\ncomprehensive comprehension implementations.\n\n###\n\nJavaScript\n\nJavaScript\u2019s never had list comprehensions as part of the standard spec, but\nbrowsers used to implement their own extensions to the language. Firefox had\nlist comprehensions for a while, but dropped them when they weren\u2019t considered\nfor ECMAScript 7. The Firefox implementation looked like this:\n\n    \n    \n    [ user.name for (user of sublist) for (sublist of input_list) if (x.age === 30) ]\n\nWhen tc39 met in June of 2014, they decided to defer adding comprehensions so\nthat they could be generalised. When they then met in July, they looked at\nsome theoretical implementations of code using different styles, one Python-\nstyle, one LINQ-style, and the other using regular function calls. The\ndiscussion focused around generators and the need for array-like operations on\nthem (e.g filter, flatMap). Comprehensions were shelved until the next version\nof ECMAScript, and not brought up again. Generators still don\u2019t support these\noperations, either. Perhaps this is a reflection of JavaScript\u2019s usage in\nbrowsers, where datasets tend to be smaller than on the backend. A list\ncomprehension in Python could potentially deal with huge amounts of data,\nwhich would not make sense to exist in a browser.\n\nThe pure JavaScript version looks like this:\n\n    \n    \n    input_list .map( (sublist) => sublist.flatMap( (user) => user.age === 30 ? user.name : [] ) ).flat()\n\nECMA does not often add new syntax to JavaScript. Functions are added to the\nstandard library with each release, but new keywords are rarely added. I think\nthe last added keywords might be async/await in ES2017.\n\n\ud83d\udca1Interesting\ud83d\udca1: JavaScript rejected comprehensions, in favour of API methods.\nOne implementation of non-spec JavaScript (Firefox) did once support\ncomprehensions.\n\n###\n\nRuby\n\nRuby doesn\u2019t have list comprehensions, though it\u2019s been raised in the\ncommunity sometimes. Like JavaScript, the Ruby approach is to stick to a\ncommonly used pattern - chaining list map/filter function calls.\n\n    \n    \n    input_list .map { |sublist| sublist .select { |user| user.age == 30 } .map { |user| user.name } } .flatten\n\n\ud83d\udca1Interesting side-note\ud83d\udca1: Ruby\u2019s naming for filter (select) is my preferred\nname for a function that does (a \u2192 boolean) \u2192 List a \u2192 List a. Unlike filter,\nselect describes the action - selecting values that match a condition. filter\ncould mean \u201ckeep all values that match\u201d or \u201cremove all values that match\u201d,\ndepending on who you talk to, especially for those new to programming.\n\n###\n\nErlang and Elixir\n\nErlang\u2019s comprehensions support multiple different data types as the source,\nand have had many improvements, like tuple support, and map support. Since\nErlang uses recursion for control flow, building a list otherwise would\nrequire recursive logic. The comprehension format allows an immutable list to\nbe created without recursion.\n\n    \n    \n    [ user.name || user <- sublist, sublist <- input_list, user.age == 30 ]\n\nElixir has list comprehensions as part of the normal for syntax, again\nsimplifying list building.\n\n    \n    \n    for sublist <- input_list, %{age: age, name: name} <- sublist, age == 30, do: name\n\n\ud83d\udca1Interesting\ud83d\udca1: Since both Erlang and Elixir are BEAM-based languages, it\u2019s\ninteresting to see that the syntax for the user differs, with for being used\nmore generally in Elixir while Erlang would use recursion.\n\n###\n\nJava\n\nJava\u2019s approach is much like JavaScript and Ruby: instead of adding custom\nsyntax and keywords, Java added Streams in 1.8. Since stream APIs rely on\npassing functions to .map/.filter, there was a need for a way to create\nfunctions without the prior overhead of functions, so lambda expressions were\nadded in the same release.\n\nThe code ends up looking something like this in Java flavour pseudo-code:\n\n    \n    \n    widgets.stream() .map(sublist -> sublist .filter(user -> user.age == 30) .map(user -> user.name) ) .collect(Collectors.toList())\n\n\ud83d\udca1Interesting\ud83d\udca1: Java is often used for heavy data processing, so the stream\ninterface provides a way to interact with data that can be optimised. Rather\nthan change the syntax to introduce list comprehensions, Java added lambdas\nwhich have multiple uses for small, short lived functions, with a broader\napplication than comprehensions alone.\n\n###\n\nElm\n\nElm does not support list comprehensions, citing a lack of need for them in a\nlanguage which has map/filter support. This argument is similar to the ones\nfollowed by JavaScript, Ruby, and Java.\n\n    \n    \n    input_list |> List.concatMap (\\sublist -> List.filterMap (user -> if user.age == 30 then Just user.name else Nothing )\n\n\ud83d\udca1Interesting\ud83d\udca1: Despite being an ML language family, Elm deviates from\ncomprehensions in favour of function calls.\n\n###\n\nTimeline\n\nThis is my attempt at putting together a rough timeline with different\nbranches showing how ideas crossed between languages, but it\u2019s not perfect.\nFeel free to make a revision on the gist for it here.\n\n###\n\nAdding new features to a language\n\nLanguage designers for stable languages have to think about the future: any\nadded syntax complicates the parser, the language itself, and adds one more\nfeature that the language will need to support until a breaking change\nrelease. APIs can deprecated or moved out of the standard library, but syntax\nmust be supported or code won\u2019t parse. Why introduce new, unfamiliar, syntax\nto developers when existing patterns (like chaining .map/.filter) can be\napplied and developers only need to learn a new function, something they do\nevery day?\n\nPython already had for loops, but preferred not to use functional practices\nlike maps and filters, list comprehensions filled a gap in the language. On\nthe other hand, languages like JavaScript, Ruby, or Java had already\nestablished APIs that avoided the need for loops, so it makes total sense to\nnot add such a feature.\n\nThese principles can be applied to all design, whether it\u2019s language, API, or\nproduct. If you add a feature:\n\n  1. Does it provide value?\n\n  2. Will it be worth the cost of maintaining it?\n\n  3. Will users use it as you expect?\n\n  4. Will it fragment your community?\n\n###\n\nOther examples\n\nList comprehensions far from the only place languages have developed and\nshared new ideas. It\u2019s very rare for a concept to be entirely novel, and those\nnovel ideas often start in small experiments rather than established\nlanguages.\n\nSome good examples from recent years:\n\n  * Result union types (a type of either an Ok value, or an Error message)\n\n  * Optional union types (a type of either Just a value, or Nothing)\n\n  * Async / Await (syntax for handling asynchronous code in a similar way to synchronous code)\n\n  * Type inference\n\n  * Standardised Code formatters\n\n###\n\nA future idea I\u2019m excited about\n\nI\u2019m particularly excited about typed holes, which have already found their way\ninto Idris and Haskell among others. I think we\u2019ll see a similar adoption to\ntype inference in a few years, making it easier for both developers and\ntooling to help augment the gap between types and implementation. Pair that up\nwith more powerful generative AI tools, and you may be able to have type-safe,\nvalid, code generated that actually fits what you were trying to do.\n\n###\n\nClosing\n\nThis article came out of some discussions I\u2019ve been having lately, along with\nsome sidenotes I made from my post on mainstream languages I would use in\nproduction in 2024. The next article in the \u201cthings I recommend\u201d will be about\nniche languages, where this concept of language learning and development is\nmuch more relevant, as niche languages have more freedom to choose\nexperimental features.\n\nIn summary\n\nProjects of all kinds are often independent and unique, but that doesn\u2019t meant\nthey don\u2019t share ideas, concepts, or code. If you\u2019re looking to improve\nanything you do, it\u2019s always valuable to look around to see what others are\ndoing. Maybe you\u2019ll come up with something nobody is doing, but it\u2019s far more\nlikely you\u2019ll find something others are doing, but adapt it to your user case.\n\nIf you liked this post, feel free to share or subscribe, and don\u2019t be afraid\nto reach out to me!\n\nShare\n\n1\n\nSome of the language code snippets below are near-enough rather than exact\ncode.\n\n2\n\nHaskell Report 1.0\n\nShare this post\n\n#### How languages influence each other and evolve\n\nthetechenabler.substack.com\n\nShare\n\nComments\n\nSoftware engineering practices I like, in 2024\n\nEvery couple of years in software development, the meta changes. Libraries and\nframeworks are rotated in and out of popularity, languages evolve and...\n\nFeb 27 \u2022\n\nNoah Hall\n\n9\n\nShare this post\n\n#### Software engineering practices I like, in 2024\n\nthetechenabler.substack.com\n\n4\n\nMainstream languages I would use in production, in 2024\n\nI\u2019m a big programming language enthusiast, and the design of languages. More\nthan just the design, I\u2019m also passionate about being pragmatic and getting...\n\nApr 11 \u2022\n\nNoah Hall\n\n1\n\nShare this post\n\n#### Mainstream languages I would use in production, in 2024\n\nthetechenabler.substack.com\n\nDevelopment devices for software engineers I like, in 2024\n\nWhat would I use everyday for software development? It's pretty much always a\nChromebook!\n\nMar 11 \u2022\n\nNoah Hall\n\n1\n\nShare this post\n\n#### Development devices for software engineers I like, in 2024\n\nthetechenabler.substack.com\n\nReady for more?\n\n\u00a9 2024 Noah Hall\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
