{"aid": "39984642", "title": "OP Labs: Fault Proof Deep-Dive", "url": "https://blog.oplabs.co/fault-proof-deep-dive-part-2-cannon/", "domain": "oplabs.co", "votes": 1, "user": "yobananaboy", "posted_at": "2024-04-09 21:47:39", "comments": 0, "source_title": "Fault Proof Deep-Dive Part 2: Cannon", "source_text": "Fault Proof Deep-Dive Part 2: Cannon\n\nBlog\n\nSign in Subscribe\n\nGuest Post\n\n# Fault Proof Deep-Dive Part 2: Cannon\n\nPart two of the Fault Proof Deep-Dive Series with Coinbase concludes the\noverview of Cannon, the OP Stack\u2019s first Fault Proof Virtual Machine (FPVM)\nused as part of the Dispute Game.\n\n#### Alexis Williams\n\nApr 9, 2024 \u2022 4 min read\n\nThe Fault Proof Deep-Dive Series is a collaboration between Coinbase\u2019s\nBlockchain Security (BlockSec) team and OP Labs to provide in-depth\ninformation on all major components of Fault Proofs. By sharing this\ninformation, we hope to encourage others to learn more about the architecture\nand technical aspects of Fault Proofs. Together, we can move towards the\ndecentralized future of OP Stack L2 blockchains.\n\nIn this blog post, we\u2019ll be covering the offchain Cannon Fault Proof Virtual\nMachine (FPVM) implementation. Note that both the onchain and offchain FPVM\nimplementations together make Cannon. However, we will delineate the two by\nhaving Cannon refer to only the offchain implementation for this blog post.\n\n## What is Cannon?\n\nIn the previous blog post, we introduced MIPS.sol, the onchain FPVM. Cannon is\nthe offchain counterpart to MIPS.sol, written in Golang. However, unlike\nMIPS.sol, the offchain Cannon implementation is responsible for far more steps\nin a dispute game. Additionally, Cannon is the sole FPVM used for Fault\nDispute Games in the OP Stack.\n\n## Fault Proof Control Flow\n\nOnce again, let\u2019s review the Fault Proof process to understand where Cannon\nresides.\n\nIn the above diagram recreated from the Fault Proof Walkthrough video by\nClabby, we can see that Cannon interacts with OP-Challenger and OP-Program.\nOP-Challenger is the component that handles initiating challenges and\ninteracting with a dispute game, and OP-Program handles the derivation of L2\noutput from L1 inputs. However, the diagram is a simplification of the\ninteractions between OP-Challenger, Cannon, and OP-Program.\n\nDuring the course of an active dispute game, the bisection game will move from\npivoting over L2 output roots to state witness hashes. Cannon is responsible\nfor generating state witness hashes, which are the commitment to the results\nof the MIPS instructions\u2019 computation within the FPVM. Cannon will only be run\nonce the dispute game reaches that point. This portion of the bisection game\nis known as the execution trace. Up until this point, OP-Challenger has been\nconsulting OP-Node for state output roots, and has not made use of OP-Program\nor Cannon. However, once it is time to run Cannon for the dispute game, the\nalready compiled OP-Program will be loaded into the VM in Cannon which will\nthen begin to run MIPS instructions.\n\nDuring the execution trace portion of the bisection game, Cannon will run many\nMIPS instructions, and initially will provide state witness hashes to OP-\nChallenger. Eventually, a single MIPS instruction will be identified as the\nroot of disagreement between participants in the active dispute. Now, Cannon\nwill generate the witness proof, which contains all the information required\nto run the MIPS instruction onchain in MIPS.sol. The definitive post-state of\nthe MIPS instruction will then be used to resolve the fault dispute game.\n\n## Cannon Component Overview\n\nCannon is made up of several Golang files, which together have much more\nfunctionality than the onchain MIPS.sol. This is necessary, as Cannon is\nresponsible for more parts of the dispute game than MIPS.sol. These Golang\nfiles can be grouped by core components of Cannon that they implement, which\ninclude: the Executable and Linkable Format (ELF) loader, memory and state\nmanagement, MIPSEVM, and witness proof generation.\n\n### ELF Loader\n\nOP-Program is the code that will be compiled into an ELF file which in turn\ncontains MIPS instructions to run within Cannon. In order to get the contents\nof the ELF file into Cannon to run, it needs to be loaded into the MIPSEVM.\nThis process involves iterating over the ELF headers to determine all of the\nprograms that need to be loaded into the 32-bit memory space, locating the\ninitial values for the Program Counter (PC) and NextPC, instantiating the\nstack, heap, and data segment pointers in memory, and patching out any\nincompatible functions. Patching out an incompatible function simply writes\nover the first instructions within a function with a return back to the\noriginal pointer, and then a no-operation (NOP). Patching the binary loaded\ninto the MIPSEVM is important as the FPVM is unable to perform many system\ncalls, and does not support features such as concurrency.\n\n### Memory and State Management\n\nCannon stores and maintains the entire 32-bit memory address space available\nto the MIPSEVM. There is no restriction on the size of memory stored offchain,\nbut for MIPS.sol it is infeasible to store the entire 32-bit memory address\nspace. Therefore, memory is stored in a binary Merkle tree data structure\nwithin Cannon. To the MIPSEVM, this data structure is abstracted away through\nthe use of GetMemory(), ReadMemoryRange(), and SetMemory() functions. When it\nis time to generate the witness proof, Cannon will encode up to two memory\nMerkle proofs for MIPS.sol to use when running a MIPS instruction.\n\n### MIPSEVM\n\nWithin Cannon is the MIPSEVM, which implements the 32-bit, Big-Endian, MIPS\nIII Instruction Set Architecture (ISA). Unlike MIPS.sol, the MIPSEVM will run\nmany MIPS instructions, and is also responsible for tracking memory access\nwhich will be used to encode the second memory proof. However, both the\noffchain and onchain VM implementations must produce exactly the same results\ngiven the same instruction, memory, and register state. This is critical to\nensuring that the expected post-state from the MIPSEVM is the same as the\nactual post-state generated by MIPS.sol, which will be used to resolve the\ndispute game.\n\n### Witness Proof Generation\n\nOnce a single MIPS instruction has been identified as the root of disagreement\nbetween participants in a fault dispute game, Cannon will generate the witness\nproof so that the same instruction can be run onchain in MIPS.sol. Encoded in\nthe witness proof is the following information: the VM execution state, the\nmemory proof for the address of the instruction to run, and an additional\nmemory proof required only for load, store, or certain system call\ninstructions. Additionally, should the MIPS instruction need a Pre-image,\nCannon will also communicate a Pre-image key and offset to OP-Challenger so\nthat it can be posted onchain to PreimageOracle.sol.\n\n## Documentation For Cannon\n\nThis concludes our deep-dive of Cannon. In addition to this blog post, Coinbase has created in-depth documentation that provides more details on each of the components that make up Cannon. Check it out at Fault Proof VM - Cannon | Optimism Docs, and if you\u2019re interested in Optimism\u2019s official technical specification of Cannon, you can view that at Cannon Technical Specification.\n\n## Sign up for more like this.\n\nEnter your email\n\nSubscribe\n\n## Build faster, build together: Introducing the Superchain Developer Console\n\nA one-stop shop for aggregated tools and promotions, the Optimism Collective\u2019s\nnew Superchain Developer Console makes it easier than ever for developers to\nbuild and grow their businesses across the Superchain. The Superchain Dev\nConsole makes it as easy, and accessible to launch your app on the Superchain.\nWhether\n\nMar 22, 2024 2 min read\n\n## Open-source and feature-complete fault proofs bring permissionless\nvalidation to the OP Sepolia testnet\n\nFeature-complete fault proofs are live on OP Sepolia! This milestone testnet\nrelease lays the foundation for a \"multi-proof nirvana\" and Stage 2\nSuperchain.\n\nMar 19, 2024 3 min read\n\n## From EIP to Ethereum mainnet: the collective triumph of 4844\n\nThis blog post reflects on the journey from EIP-4844's inception to\nimplementation, and shares insights into what this update means for the future\nof Ethereum.\n\nMar 13, 2024 4 min read\n\n\u00a9 OP Labs PBC 2024. All Rights Reserved\n\n  * Terms of Use\n  * Privacy\n  * Community Notice\n  * Twitter\n  * Optimism.io\n\n", "frontpage": false}
