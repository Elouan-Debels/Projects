{"aid": "39988630", "title": "Pause and Resume GraphQL Subscriptions with EDFS and NATS JetStream", "url": "https://wundergraph.com/blog/distributed_graphql_subscriptions_with_nats_and_event_driven_architecture", "domain": "wundergraph.com", "votes": 1, "user": "jensneuse", "posted_at": "2024-04-10 09:17:21", "comments": 0, "source_title": "Distributed GraphQL Subscriptions with NATS and Event Driven Architecture", "source_text": "Distributed GraphQL Subscriptions with NATS and Event Driven Architecture -\nWunderGraph\n\nWunderGraph Cosmo Exclusive: Announcing Event Driven Federated Subscriptions\n\nWunderGraph\n\nDiscordTalk to an ExpertLogin\n\nBlog\n\n/\n\nEducation\n\n# Distributed GraphQL Subscriptions with NATS and Event Driven Architecture\n\nJens Neuse\n\n2024-04-10\u00b715min read\n\nIn today's fast-paced and interconnected world, building scalable and\nefficient applications is crucial. One area that often poses challenges is\nimplementing real-time updates and Subscriptions in a distributed system. In\nthis blog post, we will explore how to leverage NATS and Event Driven\nArchitecture to achieve distributed GraphQL Subscriptions. By combining the\npower of NATS messaging system with the flexibility of GraphQL, we can create\na robust and scalable solution for real-time data synchronization. So, let's\ndive in and discover how to build Event Driven Federated Subscriptions with\nNATS!\n\n##\n\nThe Basics of GraphQL Subscriptions\n\nBefore we dive into the details of Event Driven Federated Subscriptions (EDFS)\nwith NATS, let's take a moment to understand the basics of federated GraphQL\nSubscriptions.\n\nGraphQL Subscriptions are a powerful feature that allows clients to receive\nreal-time updates from the server. In contrast to traditional REST APIs, where\nclients have to poll the server for updates, GraphQL Subscriptions allow the\nclient to \"subscribe\" to a field in the Schema and receive a stream of updates\nfrom the server.\n\nHere's an example of a GraphQL Schema with a Subscription type:\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\nWe can now subscribe to the postAdded field and receive real-time updates\nwhenever a new Post is added to the system using the following subscription:\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\nThe GraphQL community has adopted multiple protocols for GraphQL\nSubscriptions, such as WebSockets and Server-Sent Events (SSE).\n\n##\n\nThe differences between traditional GraphQL Subscriptions and Federated\nGraphQL Subscriptions\n\nIn a traditional GraphQL setup, you have a single GraphQL server that handles\nall incoming Queries, Mutations, and Subscriptions. Clients connect to this\nserver directly and receive real-time updates through WebSockets or SSE. Once\nyou start scaling the system or introduce high availability, you need to\nimplement a mechanism to share state across all instances of the GraphQL\nserver to ensure that clients receive updates regardless of which server\ninstance they are connected to.\n\nThis is usually achieved by using a Pub/Sub system such as Redis, RabbitMQ, or\nNATS to distribute events across all server instances. This approach works\nwell, but it introduces additional complexity and operational overhead.\n\nIn a federated GraphQL setup, you have multiple independent GraphQL servers\nthat are connected through a Router/Gateway. Each server contributes a part of\nthe overall Schema. All individual Schemas are combined into a single\nfederated Schema through a process called composition. For a client, it looks\nlike a single GraphQL server when they connect to the Router, but behind the\nscenes, the Router plans the execution of each GraphQL Operation and routes\nsub-requests to the appropriate server.\n\n##\n\nChallenges of implementing real-time updates / Subscriptions in a distributed\nsystem like GraphQL Federation\n\nWhen it comes to GraphQL Subscriptions, the federated setup introduces\nadditional challenges.\n\n  1. Memory Usage and number of open connections: In a monolithic GraphQL server, each client connection is managed by the server itself, which means that one client connection maps to one connection on the server. In a federated setup, the client connects to the Router, which then connects to the origin GraphQL server, which in turn handles the connection from the Router. This means that each client connection results in three open connections and the associated memory overhead. This can easily become a bottleneck when you have a large number of clients connected to the system.\n  2. Resilience and Flexibility: While also affecting non-federated Subscriptions, the distributed nature of a federated setup introduces additional complexity when it comes to resilience and flexibility. When an origin server goes down, or you intend to scale the number of origin servers down, you need to ensure that the Router can handle the redistribution of Subscriptions to the remaining servers without losing any events. If you don't want to force clients to reconnect, you need to ensure that your origin servers keep running even when they are only serving a single client.\n  3. Data Synchronization and Ownership: A Subscription always needs to be tied to a source of truth. This source of truth is responsible for emitting events or updates to the Subscription. In a federated GraphQL setup, the source of truth will be one of the origin servers (Subgraphs). This means that coordination between Subgraphs is necessary if a Subscription needs to be updated based on data from multiple Subgraphs. This is counter to the idea of a federated setup, where each Subgraph is independent and doesn't need to know about the existence of other Subgraphs.\n  4. Overhead and Duplication: To achieve high availability and resilience, you'll want to run multiple instances of each origin server. This means that by default, you need to have a Pub/Sub system in place to distribute events across all instances of the origin server. So, if you're already using a Pub/Sub system as the (real) source of truth to invalidate Subscriptions, why introduce the additional complexity of piping events from the Pub/Sub system to the origin server and then to the Router?\n\nI think it's clear that there's a theme here. The \"real\" source of truth is\nthe Pub/Sub system, and the origin servers are just a layer of indirection.\nWhy pipe events from the Pub/Sub system to the origin server and then to the\nRouter? Why not connect the Router directly to the Pub/Sub system and let the\nRouter handle the distribution of events to the appropriate clients? This\nwould simplify the architecture, reduce the number of open connections, and\nmake the Subgraphs stateless (again).\n\n##\n\nIntroduction to Event Driven Federated Subscriptions (EDFS) - A new approach\nto distributed GraphQL Subscriptions\n\nEvent Driven Federated Subscriptions (EDFS) is a new approach to GraphQL\nSubscriptions that leverages Event Driven Architecture to achieve real-time\nupdates in a distributed system. The core idea is to connect the Router\ndirectly to an Event Source, such as NATS, and \"join\" additional fields to the\nevents using Federation.\n\nEDFS Architecture\n\nIn this setup, a client connects to the Router and starts a Subscription,\nwhich the Router maps to an event stream. When an event is published to the\nstream, the Router uses the Federation protocol to resolve additional fields\nby sending Queries to the appropriate Subgraphs. Once all fields for the\nSubscription are resolved, the Router emits the result to the client. In\nsimple terms, Queries and Mutations are directly triggered by a client\nrequest, while Subscriptions are triggered by an event from the Event Source,\nthe rest of the process is the same.\n\nThis approach has several advantages over traditional GraphQL Subscriptions:\n\n  1. Your Subgraphs (origin servers) are stateless and don't need to manage client connections\n  2. Only one connection per client is required, reducing memory overhead\n  3. No coordination between Subgraphs is necessary, as all Subgraphs can independently emit events to the Event Source\n  4. Less operational overhead, as you're not piping events through the Subgraphs\n\n##\n\nUnderstanding the Basics of NATS Messaging System in the context of EDFS\n\nEvent Driven Federated Subscriptions (EDFS) leverages Event Driven\nArchitecture to achieve real-time updates in a distributed system. To\nunderstand how EDFS works, it's important to have a good understanding of the\nunderlying messaging system. In this case, we will explore the basics of the\nNATS messaging system and how it fits into the overall picture of Event Driven\nArchitecture and Federation.\n\nNATS is a high-performance, cloud-native messaging system that is designed for\nbuilding modern, scalable, and efficient applications. It is a lightweight and\neasy-to-use messaging system that is well-suited for building distributed\nsystems and microservices. NATS provides a simple and efficient way to connect\nservices, share data, and distribute events across a distributed system.\n\nNATS is built around the concept of Subjects, which are hierarchical names\nthat are used to categorize messages. A Subject is a string that is used to\nidentify a message and route it to the appropriate subscribers. When a message\nis published to a Subject, it is delivered to all subscribers that are\ninterested in that Subject.\n\nIn the context of Event Driven Federated Subscriptions (EDFS), NATS is used as\nthe Event Source that emits events to the Router. When a client starts a\nSubscription, the Router maps the Subscription to a Subject in NATS. When an\nevent is published to the Subject which the Router has a Subscription for, the\nevent is received by the Router, which then resolves additional fields through\nthe Federation protocol as described earlier.\n\n##\n\nHow Event-Driven patterns and NATS can be leveraged to achieve a superior\nGraphQL Federation Architecture\n\nEDFS leverages Event-Driven patterns to implement real-time updates in a\ndistributed system without tightly coupling the origin servers and keeping\nthem stateless. Imagine an architecture where every team exposes Subscriptions\ndirectly from their Subgraphs. This would require each team to manage stateful\nclient connections and coordinate with other teams to ensure that\nSubscriptions are updated correctly. This is a huge ask on the teams and\nintroduces a lot of operational duplication and complexity. One of the ideas\nof Federation is to allow teams to work independently and choose the\ntechnology stack, language, and framework that best suits their needs.\nManaging stateful client connections at scale is a hard problem to solve, even\nmore so when every team has to solve it independently with different\ntechnologies and frameworks.\n\nBy introducing NATS as the Event Source, and EDFS as the protocol to resolve\nSubscriptions, we can decouple the Subgraphs from the client connections,\nstandardize on a single technology stack for real-time updates, and simplify\nthe operational overhead by managing client connections in a single place.\n\nModern engineering organizations are moving towards having a dedicated team\nthat is responsible for operating core infrastructure components such as NATS,\nFederation Routers, and other shared services. Usually, we refer to this team\nas the Platform Team or Infrastructure Team. By centralizing the\nresponsibility for managing stateful client connections and an Event Source in\na single team, we can reduce the operational overhead for individual teams and\nallow them to focus on building features and delivering value to the business.\n\n##\n\nStep-by-Step Guide to Implementing Distributed GraphQL Subscriptions with NATS\nand EDFS\n\nNow that we have a good understanding of Event Driven Federated Subscriptions\n(EDFS) and how NATS fits into the picture, let's walk through a step-by-step\nguide to implementing distributed GraphQL Subscriptions.\n\nLet's assume we want to build a simple real-time chat application that allows\nus to listen to messages in a chat room.\n\n  1. Define the EDFS Graph In the first step, we need to define our Subscription and attach it to our Event Source (NATS).\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\nThe @edfs__subscribe directive lets us attach the Subscription to one or more\nNATS Subjects. With the {{ args.roomID }} syntax, we can use the value of the\nroomID argument to dynamically generate the Subject.\n\nIf you want to learn more on how to use the EDFS directives, check out the\nEDFS Specification .\n\n  1. Add two more Subgraphs In the second step, we add a second Subgraph that extends the Message entity with the actual message content, and a third Subgraph that extends the Message entity with the User entity.\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\nThe sole purpose of the Message Subgraph is to be responsible for the actual\nmessage content, as we only want to publish the id of the message to the Event\nSource to keep the payload small, and the state of the message within the\nMessage Subgraph.\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n  1. Composing the Supergraph We can now compose the two Schemas into a single federated Schema.\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\nAs you can see, all Federation-related directives are removed from the Schema,\nas the Router will handle the Federation logic. From the user's perspective,\nit looks like a single GraphQL Schema.\n\n  1. Start a GraphQL Subscription In the next step, we need to make a Subscription request to the Router.\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n  1. Publish an event to NATS Finally, we can publish an event to NATS that triggers the Subscription. Let's use the NATS cli to publish an event to the room.123.messages Subject.\n\n1\n\nWhat's important to note here is that the event payload contains the\n__typename and the id of the entity. As it's possible to return an Interface\nor Union type from a Subscription, the Router needs to know the concrete type\nof the entity. In addition, all fields marked with @key are required to\nresolve the Subscription. In this case, we're required to return the id of the\nMessage entity. This is required so that the Router can join additional fields\nto the event stream from the Message Subgraph and the User Subgraph.\n\n  1. Receive the Subscription Result Once the event is published to NATS, the Router will receive the event and resolve the Subscription. The result will be sent to the client, and the client will receive the real-time update.\n\nHere's how the result might look like:\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\nAnd that's it! You've successfully implemented distributed GraphQL\nSubscriptions with NATS and Event Driven Federated Subscriptions (EDFS). For\nmore information on how to implement EDFS in your own projects, check out the\nEDFS documentation .\n\n##\n\nEDFS and CQRS: How to leverage EDFS to implement Command Query Responsibility\nSegregation\n\nCommand Query Responsibility Segregation (CQRS) is a design pattern that\nseparates the read and write operations of a system. In a CQRS architecture,\nthe read and write operations are handled by separate components, which allows\nfor better scalability, performance, and flexibility.\n\nEDFS can be leveraged to implement CQRS in a distributed GraphQL system. Let's\nsay we'd like to implement a system to scrape the content of a website and\nanalyze it using AI. This operation will be very resource-intensive and time-\nconsuming, so we want to split it into multiple steps to make it more\nresilient and scalable.\n\nFirst, we trigger the scraping operation by sending a Command to the system,\nwe can do this through a Mutation.\n\nNext, we want to receive real-time updates on the progress of the scraping\noperation, so we start a Subscription to listen to the progress events.\n\nFinally, once the scraping operation is complete, we want to retrieve the\nresults.\n\nBy using EDFS, we can implement the CQRS pattern in a distributed GraphQL\nsystem with clear separation of concerns. One Subgraph is responsible for\nhandling the Command (Mutation) which triggers the scraping operation, another\nSubgraph is responsible for performing the scraping operation and emitting\nprogress events to NATS, and a third Subgraph is responsible for storing the\nresults of the scraping operation and serving them to the client.\n\nThis approach allows us to scale each component independently and handle\nfailures gracefully. If the scraping operation fails, we can retry it without\naffecting the client's Subscription. If the client disconnects and reconnects,\nthey can resume the Subscription without missing any events.\n\nHere's an example of how you might implement CQRS with EDFS:\n\n1\n\n2\n\n3\n\n4\n\n5\n\nThis Subgraph is responsible for handling the Command to scrape a website.\nWhen the Mutation is called, it triggers the scraping operation and returns an\nID that can be used to start a Subscription to listen to the progress events.\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\nAll the EDFS Graph does is to tie the Subscription to a topic using the id\nwe've got from the Mutation.\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\nThis Subgraph is responsible for extending the stream of events with the\nactual progress of the scraping operation. Each time the scraping operation\nmakes progress, it emits an event to NATS to trigger the Subscription\ninvalidation in the Router.\n\nFrom the client's perspective, we can use a Mutation to kick off the scraping\noperation, and then start a Subscription to listen to the progress events.\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\nThis approach allows us to implement CQRS using distributed GraphQL. We can\nscale each component independently and handle failures gracefully, and we can\nprovide real-time updates to the client without tightly coupling the read and\nwrite operations.\n\nAt the same time, we can leverage the full power of the GraphQL ecosystem,\nsuch as clients for all languages and frameworks, Playground solutions, and\nthe ability to introspect the Schema.\n\nWhat's great about EDFS and GraphQL Federation is that it allows us to\nimplement CQRS on the \"backend-side\" without sacrificing the developer\nexperience on the \"client-side\". For an API consumer, it looks like a single\nGraphQL Schema, and they can use all the tools and libraries they're used to.\nThey don't even notice that the system is built using CQRS and EDFS.\n\n##\n\nNATS JetStream and EDFS: Never miss an event again with durable GraphQL\nSubscriptions\n\nSo far, we've used NATS as an ephemeral Pub/Sub broker to distribute events to\nall connected clients. While this works well for a lot of use cases, there are\nscenarios where you want to ensure that no event is lost, even if a client is\ndisconnected or a Router instance goes down for some time.\n\nOne such scenario is when you're building a real-time trading platform. In\nthis case, you want to ensure that every trade is recorded and processed\ncorrectly. If a client disconnects and reconnects, you want to ensure that\nthey receive all the trades that happened while they were disconnected.\n\nThis is where NATS JetStream comes into play. NATS JetStream is a high-\nperformance streaming system that provides durable and persistent messaging\ncapabilities.\n\nBy combining NATS JetStream with EDFS, we can build durable GraphQL\nSubscriptions that ensure that no event is lost. When a client starts a\nSubscription, the Router creates a durable Stream Consumer that keeps track of\nthe last event that was transmitted to the client.\n\nIf the client disconnects and reconnects, the Router can resume the\nSubscription from the last event that was transmitted to the client. Even if\nthe Router goes down, the client can reconnect to a different Router instance\nand resume the Subscription from the last event that was transmitted to the\nclient by starting the consumption of the Stream using the same Consumer name.\n\nHere's how you might implement durable GraphQL Subscriptions with NATS\nJetStream and EDFS:\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\nIn this example, we're using the streamConfiguration argument to specify the\nConsumer name and the Stream name. When a client starts a Subscription, they\ncan provide a unique Consumer ID, e.g. a UUID, that is used to create a\ndurable Stream Consumer in NATS JetStream. You can think of this Consumer ID\nas a \"bookmark\" that keeps track of the last event that was transmitted to the\nclient.\n\nAnother example where durable Streams can be useful is when you're building a\nnotification system. In this case, you want to ensure that every notification\nis delivered to the client.\n\nLet's sketch out how you might implement this:\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\nWe can now add a second Subgraph that extends the Notification entity with the\nactual notification content.\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nI think you can see the pattern here. We define the Subscription in the EDFS\nGraph and attach it to a NATS Subject. We then extend the Subscription in a\nSubgraph with additional fields. The Router joins the additional fields to the\nevent stream using the Federation protocol.\n\nIt's a simple GraphQL Subscriptions on the client-side, with support for\nmultiple WebSockets protocols and SSE. On the backend-side, we're using Event-\nDriven Architecture and Federation to implement real-time updates in a\ndistributed system.\n\n##\n\nBest Practices for Designing Event Driven Federated Subscriptions\n\nWhen designing Event Driven Federated Subscriptions (EDFS), there are several\nbest practices to keep in mind to ensure that your system is scalable,\nefficient, and resilient.\n\nWhen emitting events to the Event Source, it's important to only emit the keys\nof the entities that have changed, not the entire state of the entity. This\nkeeps the payload small and reduces the load on the Router and the Subgraphs.\nState should be retrieved from the Subgraphs using the Federation protocol.\n\nWhen defining your Subscriptions, it's important to use a consistent naming\nconvention for the topics that you attach your Subscriptions to. This makes it\neasier to manage and monitor your Subscriptions and ensures that they are easy\nto understand and maintain.\n\nIn the EDFS Graph, it's important to only define Entities with their keys. All\nadditional fields should be defined in the Subgraphs that extend the Entities.\n\n##\n\nFuture Trends and Innovations in Distributed GraphQL Subscriptions\n\nEvent Driven Federated Subscriptions (EDFS) is a powerful new approach to\nimplementing real-time updates in a distributed GraphQL system. By leveraging\nEvent Driven Architecture and CQRS, we can build scalable, efficient, and\nresilient systems that provide real-time updates to clients without tightly\ncoupling the read and write operations. But this is really just the beginning.\n\nBy combining EDFS and NATS JetStream, we can add more advanced features such\nas time traveling, replaying events, deduplication, and more. With JetStream\nas the Event Source, consumers can subscribe to a stream of events and replay\nevents from a specific point in time, or even pause a Subscription, go\noffline, and resume the Subscription when they come back online, all without\nmissing any events.\n\n##\n\nConclusion\n\nIn this blog post, we've explored how to leverage NATS and Event Driven\nArchitecture to implement Subscriptions in a distributed GraphQL system. By\nusing Event Driven Federated Subscriptions (EDFS), we can build scalable,\nefficient, and resilient systems that provide real-time updates to clients\nwithout tightly coupling the read and write operations. We've also explored\nhow EDFS can be leveraged to implement CQRS in a distributed GraphQL system,\nand we've discussed best practices for designing EDFS. Finally, we've looked\nat future trends and innovations in distributed GraphQL Subscriptions.\n\nI hope this blog post has given you a good understanding of how to implement\ndistributed GraphQL Subscriptions with NATS and EDFS, and I hope it has\ninspired you to explore new ways to build real-time updates in your own\nsystems.\n\nIf you have any questions or feedback, feel free to reach out to me on Twitter\nat @TheWorstFounder . I'd love to hear your thoughts and ideas on this topic!\n\nIf you want to learn more about EDFS and how to implement it in your own\nprojects, check out the EDFS documentation .\n\nNext\n\n    When to use GraphQL vs Federation vs tRPC vs REST vs gRPC vs AsyncAPI vs WebHooks - A 2024 Comparison \u2192\n\nWunderGraph - Rethinking API Integrations\n\nProduct\n\n  * Cosmo Router\n  * Documentation\n  * Features\n  * Pricing\n  * Architecture\n  * Enterprise\n\nResources\n\n  * GitHub\n  * Platform Status\n  * Apollo GraphOS Alternative\n\nCompany\n\n  * Why WunderGraph\n  * Professional Services\n  * Support\n  * Blog\n  * Customers\n\nRelated Projects\n\n  * Open Federation\n  * BFF Patterns\n  * GraphQL API Gateway\n  * Open Previews\n\nSOC 2 Certified\n\n\u00a9 2024 WunderGraph, Inc. All rights reserved.\n\nPrivacy PolicyTerms of Use\n\nRSSAtomJSON\n\n", "frontpage": false}
