{"aid": "39986202", "title": "Meshlet Triangle Locality Matters", "url": "https://zeux.io/2024/04/09/meshlet-triangle-locality/", "domain": "zeux.io", "votes": 1, "user": "ibobev", "posted_at": "2024-04-10 01:50:48", "comments": 0, "source_title": "Meshlet triangle locality matters", "source_text": "zeux.io - Meshlet triangle locality matters\n\nBits, pixels, cycles and more\n\nArseny Kapoulkine (email, , )\n\n#### Author\n\nArseny Kapoulkine (email, , )\n\nWork, projects and publications\n\n#### Posts\n\nIf you like this blog, you should follow it via RSS and read older posts. Here\nare the recent posts:\n\n  * Meshlet triangle locality matters\n  * Condvars and atomics do not mix\n  * LLM inference speed of light\n  * It is time\n  * Efficient jagged arrays\n  * Fine-grained backface culling\n  * Meshlet size tradeoffs\n  * Approximate projected bounds\n  * VPEXPANDB on NEON with Z3\n  * On Proebsting's Law\n\n\u00ab Condvars and atomics do not mix  \n---  \n  \n# Meshlet triangle locality matters\n\n09 Apr 2024\n\nWhen working with mesh shaders, the geometry needs to be split into meshlets:\nsmall geometry chunks where each meshlet has a set of vertices and triangle\nindices that refer to the vertices inside each meshlet. Mesh shader then has\nto transform all vertices and emit all transformed vertices and triangles\nthrough the shader API to the rasterizer. When viewed through the lens of\ntraditional vertex reuse cache, mesh shaders seemingly make the reuse explicit\nso you would think that vertex/triangle locality within one meshlet doesn\u2019t\nmatter.\n\nYou would be wrong.\n\n# Construction\n\nAs covered in an earlier post, it\u2019s non-trivial to select an optimal meshlet\nconfiguration, as it presents a challenging balance between improving vertex\nreuse and maintaining reasonable meshlet culling rates; additionally, on\ndifferent GPUs the meshlet execution maps differently to the underlying\nhardware, with various efficiency criteria^1. Once we do select a meshlet\nconfiguration, splitting geometry into meshlets becomes non-trivial: not only\nare there a lot of different possible ways to split a mesh into fixed-size\nmeshlets, but it\u2019s not even clear what we need to optimize for!\n\nmeshoptimizer provides two algorithms for this task: meshopt_buildMeshletsScan\nand meshopt_buildMeshlets.\n\nmeshopt_buildMeshletsScan expects an index sequence that is optimized for\nvertex reuse, and splits it into meshlets such that a meshlet always\ncorresponds to the longest subsequence that still satisfies meshlet limits;\nwhen a limit is exceeded, a new meshlet starts. This algorithm is very fast\nand is suitable to run at load time when working with mesh shaders using\nmeshes that were optimized for the traditional rasterization pipeline, but can\noften produce too many meshlets or meshlets that are not spatially coherent.\n\nmeshopt_buildMeshlets, on the other hand, aggregates triangles into meshlets\nusing heuristics that maximize topological and spatial proximity: the goal is\nto minimize the amount of border vertices that waste vertex reuse potential,\nand keep the triangles of a given meshlet clustered together (plus,\noptionally, keep the triangle normals of a given meshlet pointing in roughly\nthe same direction to improve cone culling rejection rates).\n\nmeshopt_buildMeshlets is a better algorithm. On most meshes, it produces fewer\nmeshlets than meshopt_buildMeshletsScan (usually by 1-3%), and the meshlets\ncan be more easily culled by various meshlet culling techniques (resulting in\n1-5% more meshlets culled). The Scan variant is really only provided for load-\ntime use, where the extra cost of running the full buildMeshlets algorithm may\nbe prohibitive.\n\n# Discovery\n\nAs I was investigating results from a recent academic publication^2, some\nthings didn\u2019t quite add up. The testing was done using niagara, and depending\non the algorithms being selected and the parameters they were run with, the\nmeshes would sometimes get more meshlets but render faster. By itself this is\nnot necessarily surprising: niagara uses a series of culling optimization\nsteps; but what\u2019s surprising is that there would be cases where a particular\nsplit into more meshlets would produce as many output triangles or more, but\nrender faster.\n\nDuring mesh shading, the mesh shader itself does some amount of work that is\nsomewhat sensitive to the meshlet contents - for example, vertex attributes\nneed to be fetched from the vertex buffer using potentially arbitrary indices,\nwhich could cause a variable number of cache misses. The rasterization stage\nthen will do triangle setup and culling, which is fixed function but still\ntakes time; and of course, depending on the order of triangles the shading may\nget more or less efficient due to depth rejection.\n\nTo isolate as many effects as possible, I\u2019ve changed niagara locally so that\nno culling was performed anywhere, the mesh shader only used built-in position\noutput (no other attributes), and changed the mesh shader to simply output\nvec4(0.0) for all vertices, which ensured minimal cost and uniform load for\nmesh shader itself and eliminated fragment shader overhead. The performance\ndifference between different meshlet algorithms remained and if anything\nbecame more pronounced - what was previously a couple percent difference in\nperformance was now 10+%.\n\n# Investigation\n\nWith a stable and more sensitive performance environment, it became easier to\nexperiment; after a few different attempts, I tried to use buildMeshletsScan\nand it resulted in significantly faster (10%) rendering while producing a few\nmore meshlets. Moreover, adjusting build parameters to produce more meshlets\noften resulted in a configuration where significantly more meshlets generated\nvia buildMeshletsScan were faster to render than significantly fewer,\ngenerated via buildMeshlets.\n\nSince the Scan algorithm doesn\u2019t do anything smart, this had to have been due\nto the order of triangles inside each meshlet affecting the rendering\nperformance. I then validated this theory by running existing vcache\n(meshopt_optimizeVertexCache*) and vfetch (meshopt_optimizeVertexFetch)\noptimization algorithms that meshoptimizer provides on meshlet triangle data\nitself, reordering data inside each meshlet individually. This ended up\n\u201cfixing\u201d all confusing results observed so far - now fewer meshlets were never\nslower to render as long as each meshlet was carefully optimized, and\nbuildMeshlets resulted in smaller rendering times, as it should.\n\nCuriously, while vcache (reordering triangles so that new triangles refer to\nmore recently seen vertices) provided the major benefit, vfetch (reordering\nindex values so that the sequence of indices inside the meshlet is relatively\nsequential) also helped a little bit - the numbers were on the order of 10-15%\nimprovement from vcache optimization and 1-2% from vfetch optimization,\ndepending on the mesh. This is despite the fact that, since the mesh shader\nsimply emitted zero position for each vertex, the shader itself did not depend\non these values at all - it simply copied them to rasterizer buffers (using\ngl_PrimitiveIndicesEXT API).\n\nUnfortunately, this is where the detailed investigation hits a wall. Clearly,\nthe values that are being fed to the rasterizer need to be somewhat local to\nget better performance, but the exact mechanism here is uncertain.\nUnfortunately, this happens in a fixed-function stage where APIs provide no\nofficial counters, and NSight Graphics only gives one counter of\nsignificance^3 that is changing in this workload (ISBE allocation stalled),\nwhich is an indication that for meshes that are slower to render, the mesh\nshader spends more time waiting on the rasterization queue to have space. This\nis not very useful because it is possible that the problem is the size of the\nqueue (for example, triangle indices are compacted in some way inside the\nqueue), or that the rasterizer itself benefits from locality (for example, by\ncaching edge equations in a short window of triangles), or both. The mesh\nshader active execution time was unchanged so the problem must be scoped to\nthe rasterizer\u2019s triangle setup, but that\u2019s as much as can be said with\ncertainty.\n\n> Note: NSight also shows a delta in PES+VPC throughput, but this can\n> similarly be attributed to both rasterizer not being as efficient on a\n> different index sequence as well as not being fed quickly enough from mesh\n> shading stage due to size limitations.\n\nIt\u2019s worth noting that AMD never mentions anything of this sort in their mesh\nshader optimization materials, and on my integrated AMD RDNA2 GPU there was no\ndifference one way or the other: performance of more densely packed meshlet\nsequences was better regardless of the triangle order within each meshlet.^4\n\n# Solution\n\nOne of my hypotheses was that mesh shader outputs data in a buffer that uses\ntriangle strips as a storage format. This was motivated by the fact that when\nNV_mesh_shader Vulkan extension was introduced, using mesh shaders through it\nreflected the number of mesh shader invocations in the pipeline statistic that\nnormally corresponds to geometry shaders, suggesting that both use the same\nhardware - and geometry shaders\u2019 native output format is triangle strips. This\ninitially seemed like a good lead, especially since using\nmeshopt_optimizeVertexCacheStrip (which isn\u2019t strictly speaking producing a\nperfect strip order but usually produces an order fairly close to one)\nperformed better than meshopt_optimizeVertexCache - however, after digging\ndeeper and comparing performance of various orders with the number of shared\nedges between consecutive triangles, the theory got invalidated. I still\nsuspect that the rasterizer stores triangles encoded in some way to reduce\nspace which happens to benefit both strips and lists with good locality, but\nit\u2019s hard to know for sure^5.\n\nUltimately, since we\u2019re dealing with the behavior of a fixed function unit\nthat can only be observed by comparing performance (a mesh-specific and flimsy\nindicator!), I ended up experimenting for a while with a few different ways to\noptimize triangle sequences for locality and implemented an optimization\nalgorithm that reorders triangles to maximize recency of seen vertices within\na short window as well as reordering index values to be sequential. The\nalgorithm is now available in meshoptimizer as meshopt_optimizeMeshlet which\nshould be a one-line addition to a meshlet optimization pipeline.\n\nIn the future, if more hardware details are disclosed or other vendors are\nfound to have similar, but better documented, behavior, the algorithm can be\nimproved further - for now, it provides a significant speedup on NVidia\nhardware (in a 100% rasterizer bound workload mentioned above it accelerated\nrendering by 10-15%; more realistically, when triangles end up actually\nrasterized, mesh shader is running vertex transformation and cluster culling\nis active, I\u2019ve measured 3-5% improvement depending on the mesh on triangle-\ndense scenes in niagara - still a good win for something like a shadow pass!),\nwithout any detrimental effects on AMD.\n\n# Conclusion\n\nIf you are working with meshlets, it\u2019s highly recommended to update to the\nlatest version of meshoptimizer (or rather to the latest commit, this will be\npart of 0.21 that hasn\u2019t been released yet) and use the newly added\nmeshopt_optimizeMeshlet function on each meshlet as part of your geometry\nprocessing pipeline. Similarly to all other optimization algorithms, it\naffects triangle order but doesn\u2019t affect appearance otherwise.\n\nIt\u2019s a little frustrating that these optimizations have to be discovered and\ndeveloped blindly, without much information about what helps and what hurts\nperformance from IHVs; hopefully one day NVidia will publish more detailed\nperformance optimization guides!^6\n\n  1. AMD recently published a blog post as well as a GDC talk that goes into specifics of mesh shader behavior on AMD hardware; this post will be mostly concerned with NVidia. \u21a9\n\n  2. This probably needs another review post, but the summary is that you should keep using the latest meshoptimizer versions for meshlet building. \u21a9\n\n  3. In theory, NSight Graphics Pro might have more metrics but it\u2019s not publicly available; if someone from NVidia wants to send me a build or explain what is going on, that would be great! \u21a9\n\n  4. I do not have an Intel Arc GPU or Apple M3 to test; for now, I am assuming this is unique to NVidia GPUs. \u21a9\n\n  5. In a similar situation with hardware vertex reuse, I was able to use pipeline statistics as an accurate reflection of what happens in hardware; this allowed doing very small modifications on synthetic index buffers to understand the behavior. Doing the same analysis with only performance as a guide is very difficult and error-prone. \u21a9\n\n  6. Surely with the recent ML developments gaming and graphics are just a passion project for NVidia, so it\u2019s okay to be more open ;-) \u21a9\n\n\u00ab Condvars and atomics do not mix  \n---  \n  \nShow Comments\n\n", "frontpage": false}
