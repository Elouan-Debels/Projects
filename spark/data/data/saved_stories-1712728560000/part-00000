{"aid": "39985539", "title": "The Easiest Way to Build Reactive Local-First Apps", "url": "https://bndkt.com/blog/2024/the-easiest-way-to-build-reactive-local-first-apps-with-tinybase-and-powersync", "domain": "bndkt.com", "votes": 3, "user": "jamesgpearce", "posted_at": "2024-04-09 23:53:34", "comments": 0, "source_title": "The Easiest Way to Build Reactive Local-First Apps with TinyBase and PowerSync", "source_text": "The Easiest Way to Build Reactive Local-First Apps with TinyBase and PowerSync\n- bndkt\n\n# The Easiest Way to Build Reactive Local-First Apps with TinyBase and\nPowerSync\n\n2024-04-09\n\nI\u2019ve written about the advantages of offline-first and how easy it is to\nimplement and maintain offline-first apps with PowerSync before. Now, while\nbuilding apps in an offline-first approach makes data access and state\nhandling considerably easier than dealing with remote API calls all the time,\nthere are still ways to make implementing reactive UI even more efficient.\n\n## What is TinyBase?\n\nTinyBase is a reactive data store for local-first apps built by James Pearce,\na former Engineering Director at Meta. At its core, it provides local stores\nwith either key-value or tabular data that you can bind your UI to (with out-\nof-the-box support for React). With no custom rendering logic required, the UI\nchanges whenever the data changes. This makes implementations of data-heavy\napplications easy and incredibly performant. However, a local data store is\nonly part of the story; most applications must load this data from somewhere\nand save it upon changes. This is where TinyBase persisters come into play -\nyou can think of them as target-specific adapters in charge of loading from\nand saving to local or remote data sources like databases, API endpoints, or\nsync services. The design of TinyBase allows for a very flexible combination\nof stores and persisters, which means different stores can connect to\ndifferent data sources, or one store can connect with multiple data sources\nand effectively sync between them.\n\n## What is PowerSync?\n\nPowerSync is a Postgres to SQLite sync layer that allows you to build local-\nfirst apps with various technologies like React and React Native, Flutter,\nJavaScript web frameworks, or even Kotlin and Swift. Using \u201cSync Rules,\u201d\nPowerSync solves the two most challenging parts of building offline-first apps\nin a very elegant and straightforward way: Determining which data to sync for\nwhich user/device and then executing the sync by reconciling the differences\nbetween the local state and server state. PowerSync works with any Postgres\nbackend, but the easiest way to get started is to connect it to Supabase using\nthe existing integration.\n\n## Why use TinyBase and PowerSync together?\n\nIf you\u2019re not yet building apps with an offline-first approach, refer to my\nearlier blog post about offline-first apps for a discussion of the benefits of\nthis approach.\n\nIf you\u2019re already using TinyBase, you have a very efficient local setup that\nlets you develop reactive UI optimized for performance with very little code\nand powerful local query capabilities. The question remains, though, of how to\npopulate the local data store and how to persist in changes to a backend\nservice. Most apps are multi-user, if not multi-tenant apps, so this task gets\ncomplicated by the question of which backend data to sync to which local\nstore. This is where PowerSync comes in, which allows you to define Sync Rules\nthat encapsulate exactly this logic succinctly and take care of the\nsynchronization behind the scenes. This makes it very easy to work with a\nlocal set of data and be sure that it\u2019s a correct representation of the\nbackend state in terms of the scope of data the user is supposed to access and\nthe most recent version of this data.\n\nIf you\u2019re already using PowerSync, data scoping and syncing are solved for\nyou. PowerSync also allows you to implement reactive queries using their local\nSDKs to build highly performant local-first apps, including reactive UI,\nwithout any additional tooling. In my opinion, there are still benefits to\ngain from adding TinyBase as the local data store:\n\n  * The flexibility to add arbitrary combinations of stores and persisters makes you very flexible in your setup of data sources and storage. You can combine multiple data sources (like synced data from a Postgres backend via PowerSync, data accessed from REST endpoints, and collaborative data from a YJS endpoint) into a single data pane that your app\u2019s UI handles consistently irrespective of the data\u2019s source.\n  * This setup further encapsulates the local data handling and comes with its query builder TinyQL, which is not unlike an ORM. Just like with ORMs, there are arguments in favor and against this approach, and some people will prefer to avoid any further layers of abstractions and instead write raw SQL queries to query the local PowerSync database. I like the ORM approach, and especially in projects where specialized roles (or even distinct teams) work on different aspects of an app, I see a lot of value in giving the \u201cUI team\u201d a single data access paradigm with TinyBase. TinyQL\u2019s syntax is close enough to SQL to be intuitive for everyone familiar with SQL but succinct and constrained enough to be accessible for someone tasked with implementing UI components who might not want to \u201clearn backend stuff like databases.\u201d\n  * Finally, the aforementioned decoupling of the \u201cUI data layer\u201d from the \u201cbackend data layer\u201d makes it easier to switch data sources without re-implementing large parts of the frontend code base. This allows for selectively changing data storage approaches for parts of the UI (for example, when making parts of an app collaborative by adding CRDT capabilities via YJS or Automerge) or, frankly, for swapping out entire backend setups (for example, to switch from individually implemented REST endpoints to a hosted Supabase instance automatically synchronized via PowerSync).\n\n## How to integrate TinyBase and PowerSync?\n\nIntegrating TinyBase and PowerSync is straightforward. Since the recent 4.8\nrelease, TinyBase ships with a PowerSync persister built-in. Follow the\nPowerSync docs to set up the PowerSync instance, including appropriate Sync\nRules and connecting the local SDK. Then, follow the TinyBase setup to create\na local store and add the PowerSync persister, passing it an instance of the\nlocal PowerSync database. Here\u2019s a simple example for setting up the store and\npersister in React:\n\n    \n    \n    import { usePowerSync } from \"@journeyapps/powersync-sdk-react-native\"; import { createStore } from \"tinybase/store\"; import { createPowerSyncPersister } from \"tinybase/persisters/persister-powersync\"; const powerSync = usePowerSync(); const store = createStore(); const persister = createPowerSyncPersister(store, powerSync, { mode: \"tabular\", tables: { load: { profiles: { tableId: \"profiles\", rowIdColumnName: \"id\", }, contacts: { tableId: \"contacts\", rowIdColumnName: \"id\", }, }, save: { profiles: { tableName: \"profiles\", rowIdColumnName: \"id\", }, contacts: { tableName: \"contacts\", rowIdColumnName: \"id\", }, }, }, });\n\n## Conclusion\n\nIf TinyBase takes care of your local data storage and accurately reflects your\ndata in the UI state, and PowerSync takes care of automatically syncing an\nappropriate scope of data with a Postgres backend (potentially taken care of\nfor you by Supabase), what is left for you as a developer to take care of? I\nwould argue that\u2019s the beauty of this tech stack. I can\u2019t think of a better\nway to concentrate on the core capabilities of your app, making sure it\ndelivers value to users with intuitive screen interactions without worrying\nabout data access, state, and performance.\n\nAboutBlogProjects\n\n\u00a9 2024 Benedikt M\u00fcller. All rights reserved.\n\n", "frontpage": false}
