{"aid": "39985549", "title": "What was it like to use Lisp on an IBM 704?", "url": "https://www.quora.com/What-was-it-like-to-use-LISP-on-an-IBM-704", "domain": "quora.com", "votes": 1, "user": "ngcc_hk", "posted_at": "2024-04-09 23:55:03", "comments": 0, "source_title": "What was it like to use LISP on an IBM 704?", "source_text": "What was it like to use LISP on an IBM 704? - Quora\n\nSomething went wrong. Wait a moment and try again.\n\nWhat was it like to use LISP on an IBM 704?\n\nSort\n\nD. Schm\u00fcdde\n\nFunctional Programming, Networked Technology, AI\n\n\u00b7 7y\n\nM. Mitchell Waldrop captures a slice of Lisp\u2019s early days on the 704 in his\nbook The Dream Machine -\n\nThe 704 couldn't be modified for time-sharing with a mere change in software.\nAlterations would have to be made in its hardware as well, with most obvious\nbeing the addition of an \"interrupt\" system that would allow the machine to\nput one task on hold and switch to another. \"I was very shy of proposing\nhardware modifications,\" McCarthy later wrote, \"especially as I did not\nunderstand electronics well enough to read the logic diagrams.\" [...] He\ndiscovered that IBM had already created a gadget th\n\nM. Mitchell Waldrop captures a slice of Lisp\u2019s early days on the 704 in his\nbook The Dream Machine -\n\nThe 704 couldn't be modified for time-sharing with a mere change in software.\nAlterations would have to be made in its hardware as well, with most obvious\nbeing the addition of an \"interrupt\" system that would allow the machine to\nput one task on hold and switch to another. \"I was very shy of proposing\nhardware modifications,\" McCarthy later wrote, \"especially as I did not\nunderstand electronics well enough to read the logic diagrams.\" [...] He\ndiscovered that IBM had already created a gadget that would make a very nice\ninterrupt system - a \"real time package\" that had been developed at the\nrequest of Boeing, to allow the 704 to take in data from wind-tunnel\nexperiments - and he talked the company into forgoing the package's\n$2,500-per-month rental charge and letting MIT use one for free. He got the\nComputation Center engineers to design the hardware for patching in a\nFlexowriter, a kind of stand-alone typewriter that was more typically used for\npunching out paper tapes. And then... Well, then McCarthy had to do a lot of\nmarching in place, as IBM delayed delivery of the real-time package for more\nthan a year.\n\nThe first public demonstration of time-sharing consisted of a nervous John\nMcCarthy's standing next to the Flexowriter in the 704's first-floor control\nroom and speaking via closed-circuit TV to a fourth-floor lecture hall filled\nwith MIT's prestigious Industrial Affiliates. He was acutely aware that this\nwould also be the first public demonstration of Lisp, with disaster lurking at\nevery turn. And he was even more acutely aware that the system was a kludge,\nan awkward patchwork of hardware and software that would simply let the 704\nexecute a bit of Lisp code between every batch job.\n\nStill, as McCarthy later told the story, things were going well enough, if\nrather slowly - until the program unexpectedly ran out of memory and\nautomatically called a housekeeping routine. THE GARBAGE COLLECTOR HAS BEEN\nCALLED, type the Flexowriter at a stately ten characters per second. SOME\nINTERESTING STATISTICS ARE AS FOLLOWS ... and on and on and on, with McCarthy\nunable to stop it. [...] His point had been made: the 704, however crudely,\nwas sharing its time.\n\nRelated questions\n\nWhat was it like to use a LISP machine?\n\nWho's idea was it to put an 'S' in lisp?\n\nWhy is LISP used so little in spite of the fact that it is often acclaimed as\none of the best programming languages?\n\nWhat is the \"killer feature\" of Lisp?\n\nHow hard is it to learn LISP?\n\nMark Miller\n\nHave been an amateur computer historian for many years, though it's not my\nthing \u00b7 Author has 3.4K answers and 5.9M answer views\n\n\u00b7 8y\n\nI cannot answer this directly, since I haven't used Lisp on a 704, but I have\nread about the first publicly demonstrated time-sharing system in America at\nMIT, in 1961. It was a Lisp environment running on a 704. The 704 was a batch\nprocessing mainframe that was originally designed to only process one complete\ntask/job at a time, with jobs submitted as batches of punch cards. It was\nmodified by John McCarthy, and a team he assembled, with cooperation from IBM\nfor parts he needed, to make it task-switch between dynamically taking input\nfrom users, character by character on teletypes, spending t\n\nI cannot answer this directly, since I haven't used Lisp on a 704, but I have\nread about the first publicly demonstrated time-sharing system in America at\nMIT, in 1961. It was a Lisp environment running on a 704. The 704 was a batch\nprocessing mainframe that was originally designed to only process one complete\ntask/job at a time, with jobs submitted as batches of punch cards. It was\nmodified by John McCarthy, and a team he assembled, with cooperation from IBM\nfor parts he needed, to make it task-switch between dynamically taking input\nfrom users, character by character on teletypes, spending time on processing\nresults for each user's task, and printing their results at each of their\nterminals.\n\nThe point of the demonstration was a proof of concept of interactive computing\nusing time sharing, which was an unorthodox way of using computers at the\ntime. It was the first demonstration of a Lisp REPL. The user typed Lisp\nexpressions at a keyboard, just as is done today, except everything--input and\noutput--was printed on a continuous sheet of printer paper. They'd hit Return\nto submit the expression for evaluation, and see a printed result. Since the\ncomputer likely task-switched during I/O, there may have been noticeable,\nmomentary pauses as results were printed. A humorous part to the story came\nfrom the fact that the Lisp environment printed status messages on its\ninternal operation. So it let it be known that it was doing something like\n\"emptying the garbage,\" since it also implemented garbage collection. The\naudience didn't quite understand what that meant at the time. :)\n\nMcCarthy's demonstration became the inspiration for creating CTSS (the\nCompatible Time-Sharing System) on MIT's IBM 709 mainframe that same year,\nwhich would have the first American implementation of a command line\ninterface, inspired by the Lisp REPL.\n\nAlan Kay\n\nHave designed a few programming languages \u00b7 Author has 645 answers and 7.5M\nanswer views\n\n\u00b7 Updated 3y\n\nRelated\n\nWhat was it like programming an IBM 1401 back in the 60\u2019s?\n\nThe IBM 1401 was the first computer I programmed as part of a real job (an\nenlisted man in the US Air Force at Air Training Command (ATG), Randolph AFB,\nSan Antonio, Texas).\n\nIn the early 60s, the USAF had a quite difficult aptitude test made for them\nby IBM to screen potential programmers for any of their computers. I took it\nfor fun in early 1962, passed it, and was assigned to Randolph AFB, and IBM\ntraining school for the 1401. The training was done in one intense week, wall\nto wall.\n\nThe range of HW architectures was much wider back then, but the 1401 was still\nthought to be \u201codd\u201d, and today w\n\nThe IBM 1401 was the first computer I programmed as part of a real job (an\nenlisted man in the US Air Force at Air Training Command (ATG), Randolph AFB,\nSan Antonio, Texas).\n\nIn the early 60s, the USAF had a quite difficult aptitude test made for them\nby IBM to screen potential programmers for any of their computers. I took it\nfor fun in early 1962, passed it, and was assigned to Randolph AFB, and IBM\ntraining school for the 1401. The training was done in one intense week, wall\nto wall.\n\nThe range of HW architectures was much wider back then, but the 1401 was still\nthought to be \u201codd\u201d, and today would be considered very unusual. It had been\ndeveloped to gradually subsume \u201cpunched card accounting machine\u201d (PCAM) tasks\n(for which IBM was the world\u2019s largest company). As with many businesses back\nthen, Air Training Command had a number of \u201cshops\u201d of such machines, with\nperhaps 50 to 100 machines each laid out over 0.5 to an acre.\n\n\u2014 I can\u2019t believe that Google won\u2019t yield a picture of one of these large\n\u201cshops\u201d \u2014 perhaps someone can find one \u2014\n\nA very small PCAM \u201cshop\u201d \u2014 imagine with 50+ machines in an enormous room ...\n\nThe 1401 computer was a \u201ccharacter machine\u201d, with a memory of 5K to 16K\ncharacters of 6 info bits plus a \u201cword mark\u201d bit each \u2014 these were set to\nindicate ends of \u201cwords\u201d (a sequence of characters in memory addressed by the\nlow order character. A \u201cdata character\u201d was (most generally) an encoding of a\n12-row punched card column: 4 bits to encode 0\u20139 and the other two bits to\nencode the \u201czone row bits\u201d. Note that this just gives you 40 combinations, but\nother tricks were used ...\n\nTo add two numbers, the 1401 essentially did elementary school arithmetic,\nprogressing character by character until one or both word marks were reached.\n(This meant that the 1401 could be set up to add one half of memory to the\nother half.)\n\nThe 1401\u2019s memory cycle for one character was 11.5 microseconds ... so by\ncomputer standards of today it was both tiny and a snail. By PCAM standards,\nand tape standards, it was quite fast enough.\n\nIt was essentially a two address machine, but the address registers persisted,\nso you could deal with \u201cfields\u201d on \u201ccards\u201d sequentially by e.g. doing one two\naddress add \u2014 an opcode and two three digit addresses (which would be\nterminated by the word marks), and the next add would only require the opcode\nbecause it would use where the address registers wound up from the previous\noperation. (Instructions were processed in the left to right direction with\nword marks at the opcodes.)\n\nThe 1401 was thus essentially a variable sized word and variable sized\ninstruction machine. Getting lots of stuff done was greatly rewarded by\ncareful planning.\n\nIBM 1401 - Wikipedia A nicely detailed article.\n\nThe IBM Reference Manual we used (the version here is accidentally from early\n1962, just about exactly when I started programming the 1401).\n\nThe punched cards to be worked on were read by a card reader, converted to\ntapes, processed, the results went back to tapes, were printed, and/or punched\nback into card form.\n\nIBM eventually made and sold well over 10,000 of these machines (the first\nmass produced computer in history).\n\nThe IBM 1401 \u201cmainframe\u201d.\n\n1403 Printer\n\n1402 Card reader/punch (good for putting program listings on top of)\n\nIBM 729 Tape Drives \u2014 with vacuum tape loop buffering\n\nThe 1401 we worked on at ATC had 8K bytes of memory and six very fast tape\ndrives for those days. There was no OS, and most debugging was \u201cdesk\nchecking\u201d. You could get \u201c3 minutes\u201d once a day to try a program, but you\ncouldn\u2019t touch the machine \u2014 you put your listing on top of the card reader\nand asked the operator to do this and that (making friends with the machine\noperators was critical).\n\nThe basic learning process was to do the one week hardware school, after which\nyou were quite able to program anything on the 1401 (this was one of the\nfruits of the difficult aptitude test \u2014 it probably overscreened, but everyone\nwho did pass it had absolutely no trouble learning a whole tricky machine and\nits machine code successfully in a week).\n\nThen you spent some months \u201cprogramming\u201d \u2014 which was called \u201ccoding\u201d. What was\ncalled \u201cprogramming\u201d back then was design and flowcharting the design. The\nPCAM machines were all flowcharted, and these were dataflow schemes. These had\nto be serialized a bit to be converted to computer processing.\n\nA \u201ccoder\u201d was thus a human \u201ccompiler\u201d \u2014 whose job it was to convert the higher\nlevel programming language of flowcharts to working machine code.\n\nAfter a few months of this \u201con the job training\u201d and assessment one was\nallowed to do some design, programming, and then coding for new tasks. There\nwere already seasoned (a year or so) programmers \u2014 also mostly enlisted men \u2014\nwho were generally very helpful.\n\nThere was another larger computer there \u2014 the Burroughs 220 \u2014 and learning it\nand doing similar kind of work on it improved the programming and coding for\nboth machines.\n\nA few other things I should mention.\n\nIt was possible to be extremely clever with the 1401, and it should be obvious\nthat the wordmark scheme allowed clever memory allocation schemes, overlays,\netc.\n\n(It is well worth your time to take a look at Val Schorre\u2019s 1964 \u201cMeta II\u201d\nsystem at UCLA, a compiler-compiler that would run in an 8K 1401. I wish I had\nknown about this when I was a 1401er, but its invention happened after I went\nback to school.)\n\nWe were able to make a batch operating system that would run all the shop\njobs, and which fit into the top few hundred characters of memory (and using\ntape to help).\n\nIBM had an extremely capable \u201ctailored macro\u201d assembler \u2014 Autocoder \u2014 that\nallowed a wide range of expression and \u201cconditional assembly\u201d to produce\nhighly optimized and compact code.\n\nIBM already had a policy to \u201cmake everything run on everything\u201d, and this\nmeant that both the relatively new FORTRAN, and the even newer COBOL had to be\ncompilable and runnable, even on the smaller configurations. The latter never\nmade it into the ATC shop while I was there, but there was a FORTRAN \u201cfor\ncuriosity\u2019s sake\u201d (this was because the compiler took about 100 passes (or\n\u201cpulls\u201d of the tape drive) i.e. a very long time).\n\nReports Program Generator (RPG) was used for a few jobs (I tried it a few\ntimes along with others). It made a few vanilla tasks quicker, but the macro\nlibrary we had developed was generally more convenient, and only a little more\ndangerous.\n\nThe older larger slower vacuum tube Burroughs 220 did have something really\ninteresting: the BALGOL compiler (Algol 58 with a few Burroughs touches). It\nhad one of the most beautiful manuals, and this got me to read it. One of the\nofficers had been a CalTech grad and had used it there. At ATC, it was also a\n\u201ccuriosity\u201d but as a much \u201csweeter and cleaner\u201d example of a higher level\nlanguage.\n\nThe next machine in line for ATC was to be a Burroughs B5000, a truly amazing\nmachine whose hardware was made directly for an Algolic language (Algol 58\nreally), and all of whose software \u2014 including the OS (it had one) \u2014 was\nwritten in higher level form. I learned this machine from the documentation,\nonly understood about half of it, and was back to college before it showed up.\n(A few years later \u2014 by accident \u2014 one of my grad school profs was Bob Barton,\nthe main inventor of this marvelous design.)\n\nI was able to get back in school for the fall of 1963, and the AF let people\nout up to 100 days early to not miss a term. I was able to get a good part\ntime job programming for the National Center for Atmospheric Research (NCAR)\nin Boulder, that would pay my tuition and room and board for the rest of my\nundergrad years at the U of Colorado.\n\nHans H\u00fcbner\n\nCommon Lisp programmer\n\n\u00b7 13y\n\nRelated\n\nWhat was it like to use a LISP machine?\n\nOne of the distinctive features of the Lisp machine was its uniformity,\ncombined with the total lack of security. There was no trusted kernel that was\nonly accessible to special system code. Rather, everything was written in\nLisp, and when you knew how to program high-level code, you already knew the\ntools that you'd use to do low-level system work.\n\nI was very impressed when I was first introduced to a Symbolics MacIvory by a\nfriend on a vintage computing festival. I was a VAX lover at the time and had\na VMS box with me, and the Symbolics came with a DECNET stack. We thought:\nLet's hook th\n\nOne of the distinctive features of the Lisp machine was its uniformity,\ncombined with the total lack of security. There was no trusted kernel that was\nonly accessible to special system code. Rather, everything was written in\nLisp, and when you knew how to program high-level code, you already knew the\ntools that you'd use to do low-level system work.\n\nI was very impressed when I was first introduced to a Symbolics MacIvory by a\nfriend on a vintage computing festival. I was a VAX lover at the time and had\na VMS box with me, and the Symbolics came with a DECNET stack. We thought:\nLet's hook the two things together and see if the Symbolics can access the\nfiles on the VAX through DECNET. Setup went smoothly, but when we tried to\nopen a file remotely using Emacs on the Lisp Machine, we were sent to the Lisp\nmachine debugger. A bit of looking around with the Lisp inspector showed us\nthat the DECNET stack on the VAX was sending an unexpected (higher) version\nnumber to the lispm. We patched the expected version number in the Symbolics\nDECNET stack from within the debugger session, restarted the file access\nattempt and presto: The VAX file was open and editable in Emacs.\n\nThis is one of the things that made the Lisp Machine so cool: It was an\nintegrated, uniform environment and if you were a hacker, you could actually,\npractically use the box at all levels and fix it when you needed to.\nAdmittedly, Symbolics already kind of crippled that idea in that Genera came\nwithout the full source code by default - This is one of the reasons why GNU\nexists, but GNU is really underwhelming in terms of hackability compared to\nwhere Lisp Machines were in the early 1990ies.\n\nNowadays, the Symbolics user interface is hopelessly archaic and obsolete. 20\nyears ago, it made you feel like you were god and look the contemporary window\nsystems (i.e. Windows, MacOS, GEM, AmigaOS) look like toys. But time has\npassed, and common sense how a computer UI should work like has been\nestablished. With today's knowledge, it is extremely hard to work with a\nSymbolics for anyone who has been exposed to other UI's before because it is\nso different. You really need a special keyboard to begin with.\n\nRelated questions\n\nWhat was it like to use a LISP machine?\n\nWho's idea was it to put an 'S' in lisp?\n\nWhy is LISP used so little in spite of the fact that it is often acclaimed as\none of the best programming languages?\n\nWhat is the \"killer feature\" of Lisp?\n\nHow hard is it to learn LISP?\n\nDid IBM ever release a version of Lisp?\n\nWhy did LISP fail?\n\nWhy was LISP abandoned for other languages in AI programming?\n\nHow is LISP being used today?\n\nWhat are the advantages of LISP?\n\nWhat are the key features of the LISP programming language?\n\nWhat is Lisp used for?\n\nHow widely is lisp used nowadays?\n\nWhen was Lisp invented, and why was it created?\n\nWhich is the most useful LISP today?\n\nRelated questions\n\nWhat was it like to use a LISP machine?\n\nWho's idea was it to put an 'S' in lisp?\n\nWhy is LISP used so little in spite of the fact that it is often acclaimed as\none of the best programming languages?\n\nWhat is the \"killer feature\" of Lisp?\n\nHow hard is it to learn LISP?\n\nDid IBM ever release a version of Lisp?\n\nWhy did LISP fail?\n\nWhy was LISP abandoned for other languages in AI programming?\n\nHow is LISP being used today?\n\nWhat are the advantages of LISP?\n\nAbout \u00b7 Careers \u00b7 Privacy \u00b7 Terms \u00b7 Contact \u00b7 Languages \u00b7 Your Ad Choices \u00b7\nPress \u00b7\n\n\u00a9 Quora, Inc. 2024\n\n", "frontpage": false}
