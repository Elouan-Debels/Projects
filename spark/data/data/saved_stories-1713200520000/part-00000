{"aid": "40038885", "title": "The security implications of packages in front-end apps", "url": "https://martijnhols.nl/gists/the-security-implications-of-packages-in-frontend-apps", "domain": "martijnhols.nl", "votes": 2, "user": "MartijnHols", "posted_at": "2024-04-15 10:59:52", "comments": 0, "source_title": "The security implications of packages in front-end apps by Martijn Hols", "source_text": "The security implications of packages in front-end apps by Martijn Hols\n\nGists by Martijn Hols\n\n\u2190 More gists\n\nPublished today\n\n# The security implications of packages in front-end apps\n\nThird-party packages are great. They provide a lot of functionality and save\nus a lot of time. But what exactly are the security implications of using\nthird-party packages in a front-end app (such as a React app)?\n\nMany aspects play a role in the security of using a third-party package on the\nfront-end;\n\n  * unintentional security vulnerabilities\n  * deliberately introduced malicious code\n  * install scripts\n  * bundling and transpilation\n  * package (maintainer) trustworthiness\n  * sub-dependencies\n\nAll of these also apply to front-end apps\u2014 to an extent.\n\nLet's explore these aspects and their implications.\n\n## Unintentional security vulnerabilities\n\nUnintentional security vulnerabilities reported in security advisories are the\nmost obvious vulnerabilities. GitHub, Gitlab, npm, yarn, and many other tools\nprovide automated scanning of security advisories. Most of those can be\nresolved fairly easily by updating to the suggested version.\n\nMonitoring and resolving these is the least you can do, but don't fall into\nthe trap of thinking this is enough.\n\nAverage security advisories for a front-end project\n\nAside\n\nIn my opinion the vast majority of front-end JavaScript security advisories\nare boring (i.e. unimpactful). A large majority are in development tooling,\nand unless they can be exploited via the network, they have zero impact. The\nrest are usually either ReDoS or only an issue if the package is used in a\nserver context. There are very few vulnerabilities that actually matter for\nthe front end.\n\n## Deliberately introduced malicious code\n\nDeliberately introduced malicious code by a lone hacker, hacking group, or\nstate hackers is the scariest kind of vulnerability. This is where someone\nadds malicious code to an otherwise useful package, turning it into a Trojan\nHorse. The right Trojan Horse could do almost anything; from hijacking your\ncodebase and the data on your dev machine to installing ransomware or even\nhijacking all the user data on your servers.\n\nPure front-end apps are (almost) immune to the worst of this, as they don't\nexecute any privileged code on the host (your dev machine or server). There's\nstill plenty to be careful of though, as a Trojan could still inject code into\nyour bundle to hijack user cookies or keylog login and credit card\ncredentials. Your cookies should be safe if you use HTTP-only cookies. Data\ntheft through AJAX calls can be mitigated with a Content Security Policy\n(CSP), but it doesn't prevent JavaScript injection entirely (not even if you\nuse nonces).\n\nIt's a different story when you're using the package within your SSR or SSG\ncode, as then the package gets the same access as your server. Assuming your\nSSR/SSG backend has a database connection, that would probably mean access to\nall your data.\n\nYou wouldn't detect a really well-made Trojan Horse without thoroughly\ninspecting the package code. Someone smart will hide and obfuscate the\nmalicious code, only run it in production mode, only for every 100th request,\nand only after two weeks from now (or something like that).\n\nWith the impact a Trojan Horse could have, by the time a security advisory has\nbeen published, it may have been too late.\n\nAside\n\nRecently xz came in the news with a backdoor in an extremely popular Linux\npackage. From what it seems, it was sheer luck that the right person found it\nat all. Hackers will learn from this, and next time we'll probably not be so\nlucky.\n\n## Install scripts\n\nInstall scripts are an often overlooked danger of installing a new package.\nAny package can execute scripts after installation which can do pretty much\nanything you can do on your machine. Maybe it builds a C-executable for faster\ncompilation, or maybe the script just installed malware.\n\nThis makes installing a package pretty much as risky as installing a random\nexecutable from the internet. What do you think would happen to your computer\nif you just installed every single application you ran into on the internet?\n\nThere's no reason not to be as wary, if not more wary, of package install\nscripts.\n\nSome of the install scripts of a front-end project as reported by Can I Ignore\n\nTip\n\nYou can disable script execution by adding ignore-scripts true to your .yarnrc\nor ignore-scripts=true to your .npmrc, but this will probably be a bit more\ninvolved with certain packages.\n\n## Bundling and transpilation\n\nAn obfuscated bundled package\n\nMost packages undergo bundling and transpilation (e.g. TypeScript to\nJavaScript) processes before publication. As a result, the code you get when\nyou install a package does not match the code that is visible on GitHub. It\nwould be very easy for a bad actor to sneak something extra in. These changes\nwould be almost completely hidden, as they won't appear in a commit message, a\ndiff, a GitHub release, the changelog, dependabot changes, or anywhere really.\n\nThe only way to see the real changes is by looking into the (often hard-to-\nread) code of the package as it was published.\n\n## Package (maintainer) trust\n\nFor most developers, package (maintainer) trustworthiness plays a big role in\nselecting what packages to use. If the package looks trustworthy and a lot of\npeople use it, it's probably safe, right? Some go further and look into\nissues, how the maintainers respond to them, and other projects the developer\nhas worked on.\n\nA common rule of thumb I hear used is to only use packages with a certain\namount of stars on GitHub. Unfortunately, star count isn't all that reliable.\n\nWe need better ways to determine trustworthiness.\n\nAside\n\nEven if you were to check the trustworthiness of package managers when you\nfirst select a package, the maintainers of a package rarely stay the same\nforever. You would have to check again before every update. After all, it's\nencouraged to share maintainer access in Open Source projects.\n\n## Sub-dependencies\n\nSub-dependencies, sub-dependencies, and more sub-dependencies.\n\nMost packages come with dozens of sub-dependencies. All of the above applies\nto every single one of them. Even if you're going to review package code or\n(like the rest of the world) do a quick scan of the package and its\nmaintainers, you'll need to do it for every single dependency, and especially\nthe sub-dependencies. There's no better place to hide malicious code.\n\n## In conclusion\n\nEvery single front-end package, like any other kind of package, brings\nsecurity risks. Some risks can be mitigated, such as through a Content\nSecurity Policy and disabling install scripts, other mitigations, such as\nanalyzing maintainers and package code, would require such a tremendous amount\nof effort that they are usually too unreasonable.\n\nThe real solutions will need to happen at the platform level such as a module-\nlevel permissions system (experimental) and deny by default install scripts\n(RFC).\n\nFor now, I will be doing the following for my projects:\n\n  * Automatic security advisory monitoring\n  * Disabling install scripts\n  * Setup a Content Security Policy\n  * Use as few packages as possible\n    * Copy over adding a dependency\n    * Removing small, abandoned, and/or untrustworthy dependencies\n  * Avoid obfuscated packages\n  * Increasing the barrier to adding new packages\n  * Reducing dependency update frequency\n\nI reckon the only reason package security hasn't been a more common issue is\nbecause we're lucky most people online are still nice.\n\nps\n\nDon't forget about your CI tooling. GitHub Actions, for example, automatically\nuses the latest version of actions by default. These can inject nasty stuff\ninto your builds as well, and their code is even less visible.\n\nsecurity\n\npackages\n\nnpm\n\nfrontend\n\n", "frontpage": false}
