{"aid": "40037567", "title": "What Is OpenID Connect Authentication? A Practical Guide", "url": "https://developer-friendly.blog/2024/04/14/what-is-openid-connect-authentication-a-practical-guide/", "domain": "developer-friendly.blog", "votes": 1, "user": "meysamazad", "posted_at": "2024-04-15 06:27:30", "comments": 0, "source_title": "What is OpenID Connect Authentication? A Practical Guide - Developer Friendly Blog", "source_text": "What is OpenID Connect Authentication? A Practical Guide - Developer Friendly\nBlog\n\nSkip to content\n\n\ud83d\udd0a My latest book \ud83d\udcd6, Ultimate Docker for Cloud-Native Applications \ud83d\udc0b, is out!\nGrab your copy now! \ud83c\udff7\ufe0f\n\n# What is OpenID Connect Authentication? A Practical Guide\u00b6\n\nOpenID Connect is the modern-day solution to an ever-lasting problem: to\nauthenticate users when the identity provider and the service provider are\ndifferent entities.\n\n## Introduction\u00b6\n\nAWS (and other providers) highly recommend against storing long-lived\ncredentials outside your AWS account^1.\n\nThe rationale is that those secrets can be compromised and put your account at\nrisk. Even on non-extreme cases, you are advised to rotate your credentials\nand having to update every credential can be cumbersome when working at scale.\n\nThat's where OpenID Connect (OIDC) comes in.\n\n## What is OpenID Connect?\u00b6\n\nLet's provide a formal definition first^2:\n\n> OpenID Connect is an interoperable authentication protocol based on the\n> OAuth 2.0 framework of specifications (IETF RFC 6749 and 6750). It\n> simplifies the way to verify the identity of users based on the\n> authentication performed by an Authorization Server and to obtain user\n> profile information in an interoperable and REST-like manner.\n\nAnother great definition is provided by the Mozilla^3 (corrections and typo\nhighlighted):\n\n> OpenID Connect (OIDC) is a protocol that allows web applications (also\n> called relying parties, or RP) to authenticate users with an external server\n> called the OpenID Connect Provider (OP). This server typically gets user\n> information from an identity provider (IdP), which is a database of user\n> credentials and attribute information.\n>\n> The communication with the OpenID Connect Provider (OP) is done using\n> tokens. An ID token is provided to the web application (RP) by the OpenID\n> Connect Provider (OP) once the user has authenticated. It contains a JSON\n> document which informs the web application (RP) about how, and when the user\n> has authenticated, various attributes, and for how long the user session can\n> be trusted. This token can be re-newed as often as necessary by the web\n> application (RP) to ensure that the user and its attributes are both valid\n> and up to date.\n\nBest of them all, is the definition in the abstract of the RFC itself^4:\n\n> The OAuth 2.0 authorization framework enables a third-party application to\n> obtain limited access to an HTTP service, either on behalf of a resource\n> owner by orchestrating an approval interaction between the resource owner\n> and the HTTP service, or by allowing the third-party application to obtain\n> access on its own behalf.\n\nNow, at least the first definition is too formal for my non-native English\nspeaker brain. Let's simplify it a bit to understand what it means.\n\n## Simplified Explanation With an Example\u00b6\n\nIn this guide, we will cover a practical example. Let's break down the\nrequirements of this scenario:\n\n  * The requirement for this scenario is to allow GitHub Actions' job(s) running in a specific repository to access AWS Parameter Store\n\nsecurely. This may be the repository of your infrastructure or your\napplications trying to read the secure secrets from AWS Parameter Store and\npassing them to the runner.\n\n  * The hard requirement for our scenario is to avoid storing any credentials in GitHub Secrets^6 and use OIDC mechanism to authenticate the runner jobs to the AWS services instead.\n\nThe following image is an over simplified diagram of the scenario we are\ntrying to achieve:\n\nGitHub Actions runner talking to AWS Parameter Store\n\nLet's break down what's happening in the diagram above:\n\n  1. The CI runner authenticates itself to GitHub Actions identity server and fetches an access token.\n  2. The runner will use the access token for the next step to talk to AWS API.\n  3. The AWS IAM will verify the access token to make sure it has been issued by the trusted identity provider. If so, the request will be granted access to the AWS SSM.\n\nWith that in mind, let's simplify the definitions above with our example.\n\n  * The client\n\nis the entity trying to access a service, e.g., a runner job in GitHub Actions\ntrying to access the services of AWS.\n\n  * The service provider is the service the user is trying to access, e.g., AWS Parameter Store.\n\n  * The OpenID Connect provider and identity provider is the service that authenticates the user, e.g., GitHub Actions\n\n. The OIDC provider can be a separate entity from the Identity Provider, but\nin our case, it is the same.\n\nOIDC Compatibility\n\nA hard requirement on implementing and adopting OIDC as an authentication\nmechanism is that both the service provider and the identity provider must\nsupport OIDC protocol. In other words, they should be OIDC compatible and\nimplement the corresponding RFCs^7.\n\nWhen the runner job tries to access AWS Parameter Store, it needs to\nauthenticate itself to GitHub Actions. After the authentication, it will have\nan access token, using which it can access AWS Parameter Store that is\nprotected behind AWS IAM.\n\nPresenting that access token to AWS IAM, and the verification of that token is\nthe crux of the OIDC mechanism.\n\nIn essence, the IAM will verify the access token before allowing the runner\njob to access the AWS Parameter Store. The verfication of the access token\nhappens behind the scenes with the public key provided at the /.well-\nknown/openid-configuration endpoint of the identity provider.\n\nTo elaborate further, the AWS IAM will fetch the public key from the URL in\nthe GitHub Action's /.well-known/openid-configuration JWK endpoint and using\nthat public key, verifies the signature of the access token. If the signature\nis valid, the IAM will allow the runner job to access the AWS Parameter Store.\n\nIf we try it locally, we will get the following output:\n\n    \n    \n    curl -s \\ https://token.actions.githubusercontent.com/.well-known/openid-configuration \\ | tee github-actions-oidc-endpoint.json\n    \n    \n    curl -s \\ https://token.actions.githubusercontent.com/.well-known/jwks \\ | tee github-actions-oidc-jwks.json\n\nThis process can numb your brain if you're new to OIDC. But the idea is\nstraightforward: some other services keep the username-password (GitHub\nActions) and will generate access token for it to authenticate to other\nservices (AWS IAM).\n\nIf you're interested in how the OIDC access token verification works, I\nrecommend giving the RFC 6749 & 6750 a read. I also recommend this blog post\nthat provided a practical example as well.\n\nIdentity Provider vs. OpenID Connect Provider vs. Service Provider\n\nThe terms Identity Provider and OpenID Connect Provider are used\ninterchangeably in our blog post. The identity provider is the service holding\nthe credentials and authenticating the client. The OpenID Connect Provider is\nthe service that implements the OIDC protocol and provides the client with the\naccess token.\n\nThat access token, in turn, will be sent to the service provider to access the\nservices.\n\nGitHub OIDC, in our case, acts as both the identity provider and the OIDC\nprovider. AWS SSM, however, acts as the service provider. AWS IAM will verify\nthe access token issued by GitHub OIDC before granting access to the AWS SSM.\n\n## Why use OpenID Connect?\u00b6\n\nAmong countless obvious and non-obvious reasons, here are a few, and by no\nmeans exhaustive:\n\n  * You can use one identity provider for all your services and not creating multiple accounts for each service in every environment.\n  * You never have to store long-lived credentials and take the overhead of rotating them\n\n.\n\n  * You can have a centralized place to manage your users and their permissions. This works better at scale.\n\n## OpenID Connect in Practice\u00b6\n\nBased on the foundations we laid above, let's see how we can use OpenID\nConnect in a practical scenario. This gives a good chance to fully understand\nthe concepts we discussed so far.\n\nIn the rest of this guide, we will implement the scenario we have specified\nabove and try to grant GitHub Actions runners access to AWS Parameter Store\nwithout passing any access-key and secret-key to the runner jobs.\n\n### OIDC Provider\u00b6\n\nTo start with, you need to create an OIDC identity provider in your AWS\naccount^9.\n\nDirectory Structure\n\n    \n    \n    . \u251c\u2500\u2500 main.tf \u2514\u2500\u2500 versions.tf\n\nversions.tf\n\n    \n    \n    terraform { required_version = \"< 2\" required_providers { aws = { source = \"hashicorp/aws\" version = \"~> 5.44\" } tls = { source = \"hashicorp/tls\" version = \"~> 4.0\" } } }\n\nmain.tf\n\n    \n    \n    data \"tls_certificate\" \"this\" { url = \"https://token.actions.githubusercontent.com\" } resource \"aws_iam_openid_connect_provider\" \"this\" { url = \"https://token.actions.githubusercontent.com\" # also known as the \"audience\" client_id_list = [ \"sts.amazonaws.com\", ] thumbprint_list = [ data.tls_certificate.this.certificates.0.sha1_fingerprint, ] }\n\nApplying this TF code is quite simple:\n\n    \n    \n    export AWS_PROFILE=\"PLACEHOLDER\" tofu plan -out tfplan tofu apply tfplan\n\n### IAM Role\u00b6\n\nWe have created the Identity Provider in AWS. That is the service that will\nauthenticate the runner jobs and issues the access token to them.\n\nHowever, within the AWS IAM, we need to authorize the identities of the\naforementioned identity provider to access the AWS SSM. That is done using the\nAWS IAM role and IAM policy.\n\nTo create the IAM role, we use the following TF code:\n\nDirectory Structure\n\n    \n    \n    . \u251c\u2500\u2500 iam.tf \u251c\u2500\u2500 main.tf \u251c\u2500\u2500 variables.tf \u2514\u2500\u2500 versions.tf\n\nvariables.tf\n\n    \n    \n    variable \"github_owner\" { description = \"The account username or organization name\" default = \"developer-friendly\" } variable \"github_repository\" { description = \"The repository name\" default = \"oidc-github-aws\" }\n\niam.tf\n\n    \n    \n    locals { repository_name = \"${var.github_owner}/${var.github_repository}\" repository_branch = \"refs/heads/main\" } data \"aws_iam_policy_document\" \"this\" { statement { actions = [ \"sts:AssumeRoleWithWebIdentity\", ] effect = \"Allow\" principals { type = \"Federated\" identifiers = [aws_iam_openid_connect_provider.this.arn] } condition { test = \"StringEquals\" variable = \"${aws_iam_openid_connect_provider.this.url}:aud\" values = [\"sts.amazonaws.com\"] } condition { test = \"StringEquals\" variable = \"${aws_iam_openid_connect_provider.this.url}:sub\" values = [\"repo:${local.repository_name}:ref:${local.repository_branch}\"] } } } resource \"aws_iam_role\" \"this\" { name = \"github-actions-oidc-role\" assume_role_policy = data.aws_iam_policy_document.this.json managed_policy_arns = [ \"arn:aws:iam::aws:policy/AmazonSSMReadOnlyAccess\", ] }\n\nApplying this code is as before. But let's explain the highlights of this TF\ncode.\n\n  1. The audience of the IAM role ensures that the runner job's token is only valid if talking to the sts.amazonaws.com service. There are other services within AWS and restricting it will enhance the security posture.\n  2. The conditional for subject on line 24 ensures that only the runner jobs in the specified repository are allowed to assume the role and none other.\n  3. The attached managed policy (line 34) is tailored to our scenario. Your requiments may vary; you can also attach custom policies to the IAM role.\n\nThe final IAM role will have a trusted policy similar to this^9:\n\n    \n    \n    { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::123456123456:oidc-provider/token.actions.githubusercontent.com\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringLike\": { \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:*\" }, \"StringEquals\": { \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\" } } } ] }\n\nBefore we move on to the GitHub side, let's also create a sample secret in the\nAWS Parameter Store so that we can later fetch that value for testing.\n\nWe would also create the necessary GitHub Variables^11 to be used inside the\nCI workflow definition later on.\n\nDirectory Structure\n\n    \n    \n    . \u251c\u2500\u2500 github.tf \u251c\u2500\u2500 iam.tf \u251c\u2500\u2500 main.tf \u251c\u2500\u2500 providers.tf \u251c\u2500\u2500 ssm.tf \u251c\u2500\u2500 variables.tf \u2514\u2500\u2500 versions.tf\n\nversions.tf\n\n    \n    \n    terraform { required_version = \"< 2\" required_providers { aws = { source = \"hashicorp/aws\" version = \"~> 5.45\" } tls = { source = \"hashicorp/tls\" version = \"~> 4.0\" } github = { source = \"integrations/github\" version = \"~> 6.2\" } } }\n\nvariables.tf\n\n    \n    \n    variable \"github_owner\" { description = \"The account username or organization name\" default = \"developer-friendly\" } variable \"github_repository\" { description = \"The repository name\" default = \"oidc-github-aws\" } variable \"ssm_demo_parameter\" { description = \"The SSM parameter name\" default = \"/some/parameter/in/aws/ssm\" }\n\nproviders.tf\n\n    \n    \n    provider \"github\" { owner = var.github_owner }\n\nssm.tf\n\n    \n    \n    resource \"aws_ssm_parameter\" \"this\" { name = var.ssm_demo_parameter type = \"String\" value = \"This is not a secret, nor secure!\" }\n\ngithub.tf\n\n    \n    \n    data \"aws_region\" \"current\" {} data \"aws_caller_identity\" \"this\" {} resource \"github_actions_variable\" \"this\" { for_each = { AWS_REGION = data.aws_region.current.name AWS_ROLE_ARN = aws_iam_role.this.arn SSM_DEMO_PARAMETER = var.ssm_demo_parameter } repository = var.github_repository variable_name = each.key value = each.value } resource \"github_actions_secret\" \"this\" { repository = var.github_repository secret_name = \"AWS_ACCOUNT_ID\" plaintext_value = data.aws_caller_identity.this.account_id }\n\nApplying the above TF files will require you to have the GitHub CLI installed\nand authenticated^12.\n\nIf you don't want to install the extra binary on your system, you can also\npass a GitHub Personal Access Token (PAT) as specified in the docs^13.\n\n### GitHub Actions Workflow\u00b6\n\nWe have prepared everything from AWS & GitHub side. Now, it's time to trigger\na workflow in the said repository and test if it is able to read the secrets\nfrom AWS Parameter Store.\n\n.github/workflows/ci.yml\n\n    \n    \n    name: ci on: push: branches: - main env: AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} jobs: demo: runs-on: ubuntu-latest permissions: id-token: write steps: - name: Configure AWS Credentials uses: aws-actions/configure-aws-credentials@v4 with: aws-region: ${{ vars.AWS_REGION }} role-to-assume: ${{ vars.AWS_ROLE_ARN }} - name: Whoami run: aws sts get-caller-identity - name: Print the demo parameter run: | aws ssm get-parameters \\ --names ${{ vars.SSM_DEMO_PARAMETER }} \\ --with-decryption\n\nWhat's important here is that we are not passing in any credentials to the\nworkflow; there is no AWS access-key and secret-key anywhere, nor do we store\nsuch values in GitHub Secrets.\n\nIt takes away the maintenance of secret rotation and also allows us not to\nworry about the authentication process as that is happening by the two\nservices, i.e., the GitHub Actions as the OIDC provider and the AWS as the\nservice provider.\n\nThis, in effect, means that any runner job inside the said repository will get\nthe access token from GitHub Actions and use that to authenticate to AWS IAM.\nWhich also means that no matter which disposable environment the runner job is\nin and how many times it has run, it will always be able to access the AWS SSM\nwithout any manual intervention.\n\nAnother very important highlight is that the runner job identity might change\nbecause of the dynamic nature of the GitHub Actions runners; another\ndisposable runner might pick up the job and run it to completion and that will\nmess up with all our authentication system if we were to assign IAM Policy to\na specific user of the said identity provider (see the screenshot below).\n\nThat is the true power of adopting OIDC as an authentication mechanism.\n\nThe successful CI job run will look like this:\n\nSuccessful GitHub Actions CI run\n\nYou will notice that the caller ID ARN has an assumed-role in it. This is what\nit means to grab the temporary credentials from the IAM role and use them to\naccess the AWS services^14.\n\nYou can also notice the UserId which is the name assigned to the runner job by\nthe GitHub Actions identity provider. For the record, AWS has no username\nrepresenting that identifier, but only because it trusts the recently added\nidentity provider, it acknowledges the request as being valid and grants\naccess.\n\n## Bonus: CloudTrail Logs\u00b6\n\nWe have done all the required steps to authenticate and grant access to the\nrunner job in GitHub Actions to access the AWS Parameter Store.\n\nLet's take a look at the CloudTrail logs to see the successful request and\nresponse.\n\nNotice the principal ID and the assumed role ARN in the log is the same as\nwhat we saw in the CI job screenshot. This confirms that the authentication\nhas been successful and the identity provider and the service provider were\nable to work together to grant access to the runner job.\n\n## Conclusion\u00b6\n\nThat concludes are tutorial on OpenID Connect and how to use it to\nauthenticate GitHub Actions runner jobs to access AWS services securely.\n\nOn a day to day operations job, you will find yourself needing to grant access\nfrom one service to another. OpenID Connect (OIDC) is the modern-day solution\nto this problem. It has a neat approach to handle authentication that won't\nrequire any long-lived credentials, yet still be flexible enough for you to\ndefine a granular access control on the service provider side.\n\nI am guilty of passing long-lived credentials in the past, but I am glad that\nwith this new finding, I can alter my past and current workflows for a more\nsecure and robust and yet less overhead approach.\n\nI hope you too can find spots in your workflows where you can adopt OIDC and\nmake your services more secure and resilient.\n\nThanks for reading thus far, ciao, and till next time!\n\nOIDC future blogs\n\nThere will be at least two more blog posts on the OIDC topic. One will be to\nauthenticate Kubernetes in-cluster ServiceAccounts with the AWS so that the\npods can access the AWS services.\n\nThe other will be mainly focused on Ory Hydra, a great opensource project that\nimplements the OIDC protocol & can give you customization and pluggable\narchitecture over your auth setup.\n\nStay tuned for more goodies!\n\n  1. https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc.html \u21a9\n\n  2. https://openid.net/developers/how-connect-works/ \u21a9\n\n  3. https://infosec.mozilla.org/guidelines/iam/openid_connect.html#oidc-in-a-nutshell \u21a9\n\n  4. https://datatracker.ietf.org/doc/html/rfc6749 \u21a9\n\n  5. https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html \u21a9\n\n  6. https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions \u21a9\n\n  7. https://openid.net/specs/openid-connect-core-1_0.html \u21a9\n\n  8. https://www.onelogin.com/learn/oidc-vs-saml \u21a9\n\n  9. https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services#adding-the-identity-provider-to-aws \u21a9\u21a9\n\n  10. https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html \u21a9\n\n  11. https://docs.github.com/en/actions/learn-github-actions/variables \u21a9\n\n  12. https://cli.github.com/manual/gh_auth_login \u21a9\n\n  13. https://registry.terraform.io/providers/integrations/github/6.2.0/docs#authentication \u21a9\n\n  14. https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role.html \u21a9\n\n  15. https://registry.terraform.io/providers/hashicorp/aws/5.45.0/docs/resources/cloudtrail \u21a9\n\nApril 13, 2024 April 11, 2024 GitHub\n\nCopyright \u00a9 Meysam Azad\n\nMade with Material for MkDocs and hosted by GitHub Pages We respect your\nprivacy. To manage your cookie preferences, click here. Licensed under the\nApache-2.0 license\n\n", "frontpage": false}
