{"aid": "40065682", "title": "Rust GUI framework performance comparison", "url": "http://lukaskalbertodt.github.io/2023/02/03/tauri-iced-egui-performance-comparison.html", "domain": "lukaskalbertodt.github.io", "votes": 2, "user": "todsacerdoti", "posted_at": "2024-04-17 15:02:39", "comments": 0, "source_title": "Tauri vs Iced vs egui: Rust GUI framework performance comparison (including startup time, input lag, resize tests)", "source_text": "Tauri vs Iced vs egui: Rust GUI framework performance comparison (including\nstartup time, input lag, resize tests) \u00b7 Lukas\u02bc Blog\n\nLukas\u02bc Blog\n\n\ud83c\udf49\n\n# Tauri vs Iced vs egui: Rust GUI framework performance comparison (including\nstartup time, input lag, resize tests)\n\nFeb 3, 2023\n\nRecently I found myself in need of doing GUI with Rust, so I researched and\nexperimented a bit. In this post, I want to share the data I collected, as it\nmight help others. I will mostly compare Tauri, Iced and egui as those seem to\nbe popular choices. I spent quite a bit of time performing tests to assess the\nspeed/performance of these libraries, as a snappy UI experience is something I\nreally value.\n\n# \ud83d\udd11 Key takeaways\n\n  * All three are likely fast enough for most cases.\n  * Tauri falls slightly behind Iced and egui in terms of startup time and resize performance (on my machine).\n\nNote: This is by no means a full comparison! There are certainly important\naspects that are not mentioned in this post. Also be sure to read the\ndisclaimer regarding my performance tests! If you find any factual error,\nplease let me know so that I can fix the post :)\n\n# Quick introduction\n\n  * Tauri: Uses the webview by the OS to render an HTML/JS frontend. You can chose any frontend framework (JS or Rust). \u201cBackend\u201d is written in Rust, can communicate with frontend via built-in methods.\n  * Iced: Elm-inspired (reactive) GUI library. Uses wgpu for rendering on desktop; experimental web backend to create DOM for rendering. All code in Rust.\n  * egui: Immediate mode GUI using OpenGL for custom rendering. All code in Rust.\n\n# Comparison\n\nStatistics| Tauri| Iced| egui  \n---|---|---|---  \nGitHub| 60k\u2605, used by 10k| 18k\u2605, used by 2k| 13k\u2605, used by 6k  \ncrates.io downloads (recent/all-time)| 145k / 485k| 30k / 180k| 135k / 600k  \nArchitecture & Implementation| Tauri| Iced| egui  \nProgramming model| Depends on chosen frontend-framework| Elm-like/reactive|\nImmediate mode  \nDesktop| \ud83d\udfe2 via OS webview| \ud83d\udfe2 wgpu-based| \ud83d\udfe2 backend-agnostic, default backend\nis OpenGL-based  \nWeb| \ud83d\udfe1 not built-in, manual setup possible| \ud83d\udfe0 experimental, via iced_web| \ud83d\udd34\nvia WebGL^\u2020  \nSubjective Ratings| Tauri| Iced| egui  \nStability/Maturity| \ud83d\udfe2 1.0, big community, has sponsors, multiple devs, has\nGovernance page| \ud83d\udfe0 0.7, \"experimental\", active development since 2019, used a\nlot| \ud83d\udfe0 0.20, \u201cin active development\u201d, \u201cinterfaces in flux\u201d, \u201clacks features\u201d,\nactive development since 2019, mainly one dev, used a lot  \nDocumentation| Fairly good; lots of templates; could use more guide-level docs\nfor backend; crate docs could be better| Good crate docs, but lacking guide-\nlevel docs; \"book\" basically non-existent; many examples| Good crate docs;\nmany examples  \nDX| \ud83d\udfe2 Frontend instant reload; browser dev tools; good CLI tools| \ud83d\udfe0 Always\nrecompile; debug overlay with performance metrics| \ud83d\udfe0 Always recompile  \nPerformance on my machine(see disclaimer below!)| Tauri| Iced| egui  \nStartup time| \u2248380ms (window after \u2248125ms)| \u2248230ms (window after \u224833ms)|\n\u2248280ms  \nInput delay (frame = 16ms)| 2\u20133 frames| 3 frames| 2 frames  \nResize| \ud83d\udfe0 10\u201315fps| \ud83d\udfe1 12-30fps| \ud83d\udfe1 12-30fps  \nBinary size| 5MB| 17MB| 18MB  \n  \n\u2020 Using a canvas-based renderer on the web is not optimal for a number of\nreasons (not being able to ctrl+f, inputs being weird, ...). See here for more\ninformation.\n\n# Performance\n\n## Important disclaimer\n\nEverything was measured on my Ubuntu 20.04, Gnome 3.36.8, X11, Nvidia\nproprietary drivers, without animations (disabled in Gnome Tweaks), 60Hz\nmonitor. I hardly changed any desktop/Gnome configuration, but still: the\nsetup could be borked for any number of reasons (#linux). The fact that moving\nwindows around was not always 60fps is already an indicator that something is\nwrong.\n\nDo not interpret these performance metrics as a universal statement about\nthese GUI libraries. I have not even tested Windows or macOS, which could\nbehave wildly different.\n\n## Methodology\n\nAll of these measurements were taken by recording the full screen with OBS,\nthen counting frames in Avidemux. Programs used:\n\n  * Tauri: helloworld example at 7e8e0e76ec.\n  * Iced: todos example at 98a717383a (yes, I should have used \u201chello world\u201d, too, but I don\u2019t think it makes a difference in this case).\n  * egui: hello_world example at 5725868b57.\n  * Sublime Text Build 4143 with a project and many tabs open.\n  * VS Code 1.74.3 with home directory opened in the side browser, but hardly any tabs.\n  * xclock\n\nThe first three I compiled myself with cargo build --release. The last three I\nincluded for comparison. I mainly use Sublime Text, an editor using a custom\nUI framework, which is often praised for its snappy UI. VSCode is a very\npopular editor that uses Electron, which is often criticized for being slow\nand sluggish. I figured xclock is a super low level UI application, without\nany framework, using X calls directly.\n\nAnd yes, I realize this is not a fair comparison for Sublime Text and VSCode,\nas they are useful programs with lots of data loaded, instead of minimal\nexamples. I still think the comparison is useful.\n\n## Startup time\n\nBinaries were directly started from the terminal (no cargo or npm used). I\ncounted the frames from the moment my \u201cEnter\u201d press was drawn by the terminal\nuntil the window appears/the final UI is rendered. This is not an exact\nmeasurement of the absolute perceived startup time, but it\u2019s useful for a\nrelative comparison. Numbers are in ms, one number per test/trials.\n\nFinal render| Window appears| Visual jumps| Behavior of window contents  \n---|---|---|---  \nTauri| 366, 417, 400| 100, 134, 150| 1| First grey, then final UI  \nIced| 333, 217, 266, 217, 217| 33, 33, 33, 33, 50| 1| First black, then final\nUI  \negui| 300, 200, 283, 300, 250| \ud83e\udc14| 0| Final UI from the start  \nxclock| 66, 100, 84| \ud83e\udc14| 0| Final UI from the start  \nSublime| 450, 450, 467| \ud83e\udc14| 0| Final UI from the start  \nVSCode| 1450, 1250, 1450| 500, 484, 517| 4| First grey, after 180ms blue, one\nframe later three color areas (roughly resembling the layout), roughly 400ms\nlater almost final UI, 130ms later icons are drawn  \n  \n## Resizing\n\nApp was horizontally resized (changing its width). FPS was determined by\nlooking at the recording and counting frames between changes. By \u201cdecorations\u201d\nI mean the window title bar with close buttons and the like.\n\nResize FPS| Behavior  \n---|---  \nTauri| \u224810\u201315 fps| UI lags behind window  \nIced| \u224812\u201330| UI in sync with window. Funnily, decorations lag behind  \negui| \u224812\u201330| UI in sync with window  \nxclock| \u224820\u201330| UI in sync with window  \nSublime| \u224820\u201330| UI in sync with window  \nVSCode| \u22488\u201312| UI lags behind window (sometimes black replacement, sometimes\nblue)  \n  \n## Input lag\n\nFor each application I pick an element that changes color on hover. I count\nhow many frames the cursor is over said element without the element changing\ncolor. The cursor is also recorded by OBS: I don\u2019t know how exact this is, but\nthe cursor sometimes seemed to lag/skip a frame in the recording. So take\nthis, as everything else, with a grain of salt.\n\nInput lag in frames (each tested multiple times):\n\n  * Tauri: 3, 2, 2, 3, 3, 3, 3\n  * Iced: 3, 3, 3, 3, 3, 3, 3\n  * egui: 2, 2, 2, 2, 2, 2\n  * Sublime: 2, 2, 2, 3, 2\n  * VSCode: 3, 4, 6, 3, 3, 6\n\n## Scrolling smoothness\n\nI checked Tauri, Sublime Text, and VSCode and all three scroll with 30\u201360fps.\nSublime hits the 60fps more often than the other two, but also skips a frame\nfrom time to time.\n\nDiscuss on Reddit.\n\n## Comments\n\nBlog developed on GitHub\n\n@LukasKalbertodt\n\n", "frontpage": false}
