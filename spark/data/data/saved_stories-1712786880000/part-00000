{"aid": "39992274", "title": "Don't let Alloy facts make your specs a fiction", "url": "https://www.hillelwayne.com/post/alloy-facts/", "domain": "hillelwayne.com", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-10 16:06:07", "comments": 0, "source_title": "Don't let Alloy facts make your specs a fiction", "source_text": "Don't let Alloy facts make your specs a fiction\n\nSkip to Content\n\nHillel Wayne\n\n# Don't let Alloy facts make your specs a fiction\n\nPosted on Apr 10, 2024\n\nI\u2019ve recently done a lot of work in Alloy and it\u2019s got me thinking about a\ncommon specification pitfall. Everything in the main post applies to all\nformal specifications, everything in dropdowns is for experienced Alloy users.\n\nConsider a simple model of a dependency tree. We have a set of top-level\ndependencies for our program, which have their own dependencies, etc. We can\nmodel it this way in Alloy:\n\n    \n    \n    sig Package { , depends_on: set Package } run {some depends_on}\n\nIf we look through some of the generated examples, we see something odd: a\npackage can depend on itself!\n\nThese kinds of nonsensical situations arise often when we\u2019re specifying,\nbecause we have an intent of what the system should be but don\u2019t explicitly\nencode it. When this happens, we need to add additional constraints to prevent\nit. For this reason, Alloy has a special \u201cfact\u201d keyword:^1\n\n    \n    \n    fact no_self_deps { all p: Package { p not in p.depends_on } }\n\nAlloy will not generate any models that violate a fact, nor will it look for\ninvariant violations in them. It\u2019s a \u201cfact of reality\u201d and doesn\u2019t need to be\nexplored at all.\n\n## The pitfall of facts\n\n\u201cNo self-deps\u201d is a great example of a fact. It\u2019s also an example of a\nterrible fact. Beginners often make this mistake where they use facts to model\nthe system, which quickly leads to problems.\n\nConsider the real system for a second, not the spec. Where do the package\nmanager dependencies come from? Usually a plain text file like package.json or\nCargo.toml. What if someone puts manually a self-dependency in that file?\nPresumably, you want the package manager to detect the self-dep and reject the\ninput as an error. How do you know the error-handling works? By having the\nchecker verify that it accepts valid manifests and rejects ones with self-\nloops.\n\nExcept it can\u2019t test the rejection because we told it not to generate any\nself-dependencies. Our fact made the self-deps unrepresentable.\n\nNormally in programming languages, \u201cmaking illegal states unrepresentable\u201d\n(MISU) is a good thing (1 2 3 4). But specification covers both the software\nyou are writing and the environment the software is running in, the machine\nand the world. If you cannot represent the illegal state, you cannot represent\nthe world creating an illegal state that your software needs to handle.\n\nInstead of facts, you want predicates. Then you can test for the predicate\nbeing true or check that it\u2019s necessary to get other properties. Make the\nconstraint explicit instead of implicit.\n\n    \n    \n    // instead of fact no_self_deps {/*body*/} run {some_case} check {some_property} // do pred no_cycles {/*body*/} run { no_cycles and some_case } check {no_cycles implies some_property}\n\nPredicates have the additional benefit of being \u201clocally scoped\u201d: if you have\nthree facts and want to check a model with only two of them, you have to\ncomment the third fact out.\n\n## When to use facts\n\nSo where should we use facts? When does it make sense to universally enforce\nconstraints, when doing so could potentially weaken our model?\n\nFirst, facts are useful for narrowing the scope of a problem. \u201cNo self-deps\u201d\nis a perfectly reasonable fact if we\u2019re only specifying the package installer\nand something else is responsible for validating the manifests. Writing the as\na fact makes it clear to the reader that we\u2019re not supposed to validate the\nmanifest. This means we don\u2019t make any guarantees if the assumption is false.\n\nSecond, facts rule out fundamentally uninteresting cases. Say I\u2019m modeling\nlinked lists:\n\n    \n    \n    sig Node { next: lone Node //lone: 0 or 1 }\n\nThis generates regular lists and lists with cycles, which are interesting to\nme. I don\u2019t want to constrain away either case. But it also generates models\nwith two disjoint lists. If I only care about single linked lists, I can\neliminate extra lists with a fact:\n\n    \n    \n    fact one_list { some root: Node | root.*next = Node }\n\nSimilarly, you can use facts to eliminate extraneous detail. If I\u2019m modeling\nusers and groups, I don\u2019t want any empty groups. I\u2019d add a fact like\nUsers.groups = Group.\n\nThird, you can use constraints to optimize a slow model. This is usually\nthrough symmetry breaking.\n\nFinally, you can use facts to define necessary relationships that Alloy can\u2019t\ncan\u2019t express natively. In the project I worked on, we had Red and Blue nodes\nin our graph. Red nodes had at least one edge to another node, Blue nodes had\nat most one. We wrote this as\n\n    \n    \n    abstract sig Node { } sig Red extends Node { edge: some Node } sig Blue extends Node { edge: lone Node }\n\nBut then we couldn\u2019t write generic predicates on nodes that use edge, because\nAlloy treated it as a type error. Instead we wrote it with a fact:\n\n    \n    \n    abstract sig Node { edge: set Node } sig Blue, Red extends Node {} fact { all r: Red | some r.edge all r: Blue | lone r.edge }\n\n## Conclusion\n\nConstraints are dangerous because you need error states in order to check that\nyour program avoids error states.\n\nIf you\u2019re interested in learning more about Alloy, there\u2019s a good book here\nand I maintain some reference documentation. I\u2019m also working on a new Alloy\nworkshop. I ran an alpha test last month and plan to run a beta test later\nthis summer. Sign up for my newsletter to stay updated!\n\nThanks for Jay Parlar and Lorin Hochstein for feedback. If you liked this\npost, come join my newsletter! I write new essays there every week.\n\nI train companies in formal methods, making software development faster,\ncheaper, and safer. Learn more here.\n\n  1. In other specification languages this is usually either a runtime constraint (like in TLA+) or a direct modification to the system spec itself. ^[return]\n\nCategories: Programming\n\nTags: Alloy, Formal Methods\n\nPowered by Buttondown.\n\n\u00a9 2024 Hillel Wayne\n\n", "frontpage": false}
