{"aid": "39999455", "title": "Building PostgreSQL Extensions: Dropping Extensions and Cleanup", "url": "https://www.crunchydata.com/blog/building-postgresql-extensions-dropping-extensions-and-cleanup", "domain": "crunchydata.com", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-11 07:50:21", "comments": 0, "source_title": "Building PostgreSQL Extensions: Dropping... | Crunchy Data Blog", "source_text": "Building PostgreSQL Extensions: Dropping... | Crunchy Data Blog\n\nProduction Postgres\n\n# Building PostgreSQL Extensions: Dropping Extensions and Cleanup\n\nDavid Christensen\n\nDavid Christensen\n\nApr 10, 2024\u00b78 min read\n\nI recently created a Postgres extension which utilizes the pg_cron extension\nto schedule recurring activities using the cron.schedule(). Everything worked\ngreat. The only problem was when I dropped my extension, it left the cron job\nscheduled, which resulted in regular errors:\n\n    \n    \n    2024-04-06 16:00:00.026 EST [1548187] LOG: cron job 2 starting: SELECT bridge_stats.update_stats('55 minutes', false) 2024-04-06 16:00:00.047 EST [1580698] ERROR: schema \"bridge_stats\" does not exist at character 8 2024-04-06 16:00:00.047 EST [1580698] STATEMENT: SELECT bridge_stats.update_stats('55 minutes', false)\n\nIf you look in the cron.job table, you can see the SQL for the cron job is\nstill present, even though the extension/schema isn\u2019t:\n\n    \n    \n    select schedule, command, jobname from cron.job; schedule | command | jobname -----------+-------------------------------------------------------+---------------------------------- 0 0 * * 0 | SELECT bridge_stats.weekly_stats_update() | bridge-stats-weekly-maintenance 0 * * * * | SELECT bridge_stats.update_stats('55 minutes', false) | bridge-stats-hourly-snapshot (2 rows)\n\nThis got me thinking: how can you create a Postgres extension that can clean\nup after itself for cases like this?\n\n## How Extension Creation/Cleanup works\n\nIf you\u2019ve created or used an extension in Postgres (such as pg_partman,\nPostGIS, pg_kaboom, etc) you may know that every extension in PostgreSQL has a\nSQL file that gets run as part of the creation.\n\nThis SQL file may create database objects for you, such as schemas, tables,\nfunctions, etc. When database objects are created in the context of a CREATE\nEXTENSION command, they have an object dependency created against the\nunderlying pg_extension object. (These are stored in the pg_depend system\ncatalog, if you are interested in the more fine-grained details.)\n\nWhen Postgres removes an extension (via the DROP EXTENSION command), it will\nalso remove any dependent objects that were created for this extension. (This\nis true for any dependencies, all of which are tracked in a similar way.)\n\nThis is how a simple command like DROP EXTENSION can remove dozens or hundreds\nof associated objects.\n\n## Why didn\u2019t this cleanup?\n\nYou may be asking why this didn\u2019t clean up the underlying cron jobs, since\nPostgres is clearly able to track the individual database objects associated\nwith a given extension?\n\nThis is because the dependencies are tracked at the database object level\n(basically tracking the entries in the system tables that depend on each\nother). It is not general-purpose for cleanup.\n\n## So how to clean up?\n\nWe would like to be able to clean up these rows that were created by our\nextension. We don\u2019t want to spam the user\u2019s logs with unnecessary errors,\nparticularly since we know exactly what we did to create the external rows.\n\nIn an ideal world, the extension itself could register a function that could\nbe called when it\u2019s being cleaned up. However, we do not live in an ideal\nworld. (Not to mention there is probably a 125-email thread on the pgsql-\nhackers mailing list as to why that\u2019s a bad idea; leaving finding that as an\nexercise to the reader...)\n\nSince we don\u2019t have that capacity, the general advice on the interwebs and in\nthe Postgres docs is to use an EVENT TRIGGER.\n\n## Attempt 1: CREATE EVENT TRIGGER\n\nEvent triggers are a function that runs around special \u201cevents\u201d that occur in\na database. The current event trigger types are ddl_command_start,\nddl_command_end, sql_drop, and rewrite_table. These let you take special\naction inside the database and run code when a given event occurs.\n\nSince we are trying to run some code when this extension is dropped, clearly\nwe want the sql_drop event trigger type.\n\nLet\u2019s take an initial stab at our cleanup function, created in our extension\u2019s\nSQL file:\n\n    \n    \n    CREATE FUNCTION bridge_stats.cleanup() RETURNS event_trigger AS $$ DECLARE obj record; BEGIN FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects() LOOP IF obj.object_identity = 'bridge_stats' AND obj.object_type = 'extension' THEN PERFORM cron.unschedule('bridge-stats-weekly-maintenance'); PERFORM cron.unschedule('bridge-stats-hourly-snapshot'); END IF; END LOOP; END; $$ LANGUAGE plpgsql; CREATE EVENT TRIGGER bridge_stats_cleanup ON sql_drop WHEN TAG IN ('DROP EXTENSION') EXECUTE FUNCTION bridge_stats.cleanup();\n\nThis seems like a straightforward attempt. We have created a function and an\nevent trigger pair that end up being run any time a DROP EXTENSION is run. Our\nbridge_stats.cleanup() function in turn verifies that the extension itself is\nin the list of the dropped objects (returned by the\npg_event_trigger_dropped_objects() function), and if it is, then we run the\nappropriate commands to unschedule our cron jobs. Easy-peasy.\n\n## Let\u2019s go ahead and verify\n\n\u201cThat was easy,\u201d I say to myself, closing my text editor of choice (emacs, of\ncourse), and open my terminal to verify:\n\n    \n    \n    postgres=# create extension bridge_stats; CREATE EXTENSION postgres=# drop extension bridge_stats; DROP EXTENSION postgres=# select schedule, command, jobname from cron.job; schedule | command | jobname -----------+-------------------------------------------------------+---------------------------------- 0 0 * * 0 | SELECT bridge_stats.weekly_stats_update() | bridge-stats-weekly-maintenance 0 * * * * | SELECT bridge_stats.update_stats('55 minutes', false) | bridge-stats-hourly-snapshot (2 rows)\n\nThe sweet smell of succ\u2014oh wait. That didn\u2019t work.\n\nAdding logging (a la RAISE NOTICE 'BLARGH'), it appears that my event trigger\nwas not even being called.\n\nAfter considering a bit, it occurred to me that this wasn\u2019t working because\nthe event trigger must have been deleted as part of the extension\u2019s schema, so\nit did not exist in the system when the sql_drop event trigger was called.\n\nPerhaps the sql_drop event was run too late in the process? What about another\none of the event trigger types?\n\n## Attempt 2: CREATE EVENT TRIGGER 2: the what the heckening\n\nLooking at other options in the event trigger space, what are we left with?\n\n  * ddl_command_start - run at the start of a DDL command\n  * ddl_command_end - run at the end of a DDL command\n  * rewrite_table - run when a table is rewritten\n\nClearly rewrite_table is off the, uh, err\u2014you know\u2014menu. Reading the docs for\nddl_command_start and ddl_command_end shows that they are triggered before and\nafter a DDL command is run.\n\n\u201cAhh,\u201d I exclaim, quickly transforming my existing event trigger into one\nbased around the ddl_command_start event, since ddl_command_end runs after\neven sql_drop, so that one was out:\n\n    \n    \n    CREATE FUNCTION bridge_stats.cleanup() RETURNS event_trigger AS $$ DECLARE obj record; BEGIN FOR obj IN SELECT * FROM pg_event_trigger_ddl_commands() LOOP IF obj.object_identity = 'bridge_stats' AND obj.object_type = 'extension' THEN PERFORM cron.unschedule('bridge-stats-weekly-maintenance'); PERFORM cron.unschedule('bridge-stats-hourly-snapshot'); END IF; END LOOP; END; $$ LANGUAGE plpgsql; CREATE EVENT TRIGGER bridge_stats_cleanup ON ddl_command_start WHEN TAG IN ('DROP EXTENSION') EXECUTE FUNCTION bridge_stats.cleanup();\n\nYou can see that I\u2019ve changed a couple of things relative to the previous\nversion:\n\n  * I am using pg_event_trigger_ddl_commands() instead of pg_event_trigger_dropped_objects(); simple API change for this specific filter.\n  * I changed the ON action of the CREATE EVENT TRIGGER statement to be ddl_command_start\n\n## Verification, part deux\n\nAnd now, on to verification:\n\n    \n    \n    postgres=# create extension bridge_stats; CREATE EXTENSION postgres=# drop extension bridge_stats; ERROR: pg_event_trigger_ddl_commands() can only be called in an event trigger function CONTEXT: PL/pgSQL function bridge_stats.cleanup() line 5 at FOR over SELECT rows\n\nQueue the reaction gif where I am puzzled at the turn of events.\n\nThis function is now clearly getting called, since it is giving me an error\nmessage related to the specific function I\u2019m calling. It is also clearly an\nevent trigger, since it\u2019s literally a function returning event_trigger and\nit\u2019s been executed by the event trigger created by CREATE EVENT TRIGGER.\n\nWell, for whatever reason, it would empirically appear that there is something\nodd going on with using ddl_start_command in this way; perhaps something with\nrunning this on a DROP command? In any case, rather than trying to debug this\nclearly odd behavior, I started thinking about a different approach.\n\n## Attempt 3: A Hero\u2019s Journey\n\nSo if we recall my explanation about the dependencies inside Postgres and the\nobjects created by extensions, we can see that the DROP EXTENSION was\npreemptively deleting my event trigger and the underlying function, meaning\nthat it didn\u2019t exist at the time the sql_drop event was issued. What if there\nwas some way to somehow break that dependency so the event trigger would still\nexist to be fired, then it could clean itself up after it was done?\n\nThis lead me down the path to ALTER EXTENSION.\n\nALTER EXTENSION lets you dynamically add or remove dependencies between a\nspecific extension and other database objects. While database objects created\nduring CREATE EXTENSION are automatically associated with the creating\nextension, perhaps we could use this to our advantage.\n\nWith blazing eyes and a new tool in my hand, I made the following adjustments\nto my original attempt:\n\n    \n    \n    CREATE FUNCTION bridge_stats.cleanup() RETURNS event_trigger AS $$ DECLARE obj record; BEGIN FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects() LOOP IF obj.object_identity = 'bridge_stats' AND obj.object_type = 'extension' THEN PERFORM cron.unschedule('bridge-stats-weekly-maintenance'); PERFORM cron.unschedule('bridge-stats-hourly-snapshot'); END IF; END LOOP; DROP SCHEMA bridge_stats CASCADE; -- the only new line in this function! END; $$ LANGUAGE plpgsql; CREATE EVENT TRIGGER bridge_stats_cleanup ON sql_drop WHEN TAG IN ('DROP EXTENSION') EXECUTE FUNCTION bridge_stats.cleanup(); ALTER EXTENSION bridge_stats DROP EVENT TRIGGER bridge_stats_cleanup; ALTER EXTENSION bridge_stats DROP FUNCTION bridge_stats.cleanup(); ALTER EXTENSION bridge_stats DROP SCHEMA bridge_stats;\n\nAs you can see, I have added the ALTER EXTENSION command to exclude the event\ntrigger, the underlying function, and the owning schema from being owned by\nthe extension.\n\nI also added a DROP SCHEMA inside the cleanup() function to ensure that the\nobjects that I manually detached from the extension\u2019s schema would still get\nclean up.\n\nSince everything else in the bridge_stats schema would get cleaned up by the\nDROP EXTENSION command, this would serve to finish the job, since a function\ncan successfully delete itself in Postgres. (It\u2019s true!)\n\n## Final verification\n\nSo of course, we need to verify that everything works as expected:\n\n    \n    \n    postgres=# create extension bridge_stats; CREATE EXTENSION postgres=# drop extension bridge_stats; DROP EXTENSION postgres=# select schedule, command, jobname from cron.job; schedule | command | jobname ----------+---------+--------- (0 rows)\n\nSuccess!\n\n## TL;DR;\n\nThe top-down takeaway here is if you want to run some sort of cleanup action\nwithin a Postgres extension, you will have to:\n\n  * Create your event trigger and associated function\n  * ALTER EXTENSION DROP the event trigger, the function, and the schema\n  * Ensure the cleanup function removes the objects you detached after doing whatever other cleanup job.\n\nI hope that my experience of figuring out \u201cjust write an event trigger\u201d helps\nsomeone else!\n\n## Enjoy this article?\n\nYou will love our newsletter!\n\nWritten by\n\nDavid Christensen\n\nApril 10, 2024 \u2022More by this author\n\n## Footer\n\n### Products\n\n  * Crunchy Postgres\n  * Crunchy Postgres for Kubernetes\n  * Crunchy Bridge\n  * Crunchy Certified PostgreSQL\n  * Crunchy PostgreSQL for Cloud Foundry\n  * Crunchy MLS PostgreSQL\n  * Crunchy Spatial\n\n### Services & Support\n\n  * Enterprise PostgreSQL Support\n  * Migrate from Heroku\n  * Ansible\n  * Red Hat Partner\n  * Trusted PostgreSQL\n  * Crunchy Data Subscription\n\n### Resources\n\n  * Customer Portal\n  * Software Documentation\n  * Postgres Tutorials\n  * Crunchy Bridge Walkthrough\n  * Postgres Operator Walkthrough\n  * Blog\n  * Events\n\n### Company\n\n  * About Crunchy Data\n  * Team\n  * News\n  * Careers\n  * Contact Us\n  * Newsletter\n  * Branding\n  * Security\n\n### Crunchy Data Newsletter\n\nSubscribe to the Crunchy Data Newsletter to receive Postgres content every\nmonth.\n\nYouTubeLinkedInTwitterGitHub\n\n\u00a9 2018-2024 Crunchy Data Solutions, Inc.\n\nThis site uses cookies for usage analytics to improve our service. By\ncontinuing to browse this site, you agree to this use. See our privacy policy\nto learn more.\n\n", "frontpage": false}
