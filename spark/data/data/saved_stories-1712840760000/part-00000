{"aid": "39999159", "title": "Running DOS Apps on Windows from 1.0 to 95 (2020)", "url": "https://gekk.info/articles/dosapps.html", "domain": "gekk.info", "votes": 2, "user": "andrea76", "posted_at": "2024-04-11 07:04:30", "comments": 0, "source_title": "Running DOS Apps on Windows", "source_text": "Running DOS Apps on Windows\n\ngekk.info \u00ab articles\n\nRunning DOS Apps on Windows\n\nSynopsis  \n---  \nIt's well documented that a great selling point of Windows throughout all its\nearly editions (up to at least 95) was the ability to run DOS applications,\nand specifically to run multiple at once. Most of us have probably done this\nat some point, unless you're young enough that the first Windows you ever used\nwas 64-bit, where they removed DOS functionality.Despite this capability being\nmentioned in countless reviews of the success story of Windows, the actual\nfunctionality of it is almost entirely undocumented online. When I looked into\nit myself, I discovered that the experience actually changed considerably\nbetween early Windows versions, in some cases in surprising ways.Having\nthoroughly explored everything from Windows 1 to Windows 95, I'd like to\ndocument everything I learned about this. If you only experienced this after\n1995, some of this might be quite surprising to you.I have gone into deeper\ndetail than I probably needed to, but if I didn't go into detail, there\nwouldn't be that much to write here at all. This will be a highly tedious\ndescription of the specific functionality of five releases of Windows, and a\nfairly visual one, so I recommend you follow along with the screenshots even\nif you're listening to this in audio form.If you like my writing, consider\ntossing me a few bucks. It takes a lot of work and payment helps me be\nmotivated.Listen to this article (Part 1): (Article is not guaranteed to be\nidentical to audio)Listen to this article (Part 2): (Article is not guaranteed\nto be identical to audio)\n\n#### Table of Contents\n\nPrinciples Windows 1.0 Windows 2.11 / 286 Windows 2.11 / 386 Windows 3.0\nWindows 3.1 Windows 95 Conclusion\n\n#### Errata\n\n7/25/2020: Corrected an error regarding color support - bright white\nbackground colors were available in DOS windows beginning in 3.1. I was\nconfused because in QBasic, \"White\" is actually what we would call \"light\ngrey,\" the color named \"Grey\" is a dark grey, and the actual \"Bright White\"\ncolor is all the way at the bottom of the list.7/24/2020: Originally published  \nPrinciples  \n---  \nIt's worth discussing how all this works so you understand the challenges that\nare being overcome here. The ability to run multiple DOS programs at once is a\npretty neat trick, given that this software heralds from an era of computing\nthat was just barely ahead of what the Apple ][ was doing in 1978. If you want\nto skip this, go ahead.The root of the problem is that the IBM PCs basic\narchitecture crystallized a very long time ago, in 1981. In a world where ten\nkilobytes of RAM counted for about what a gig does now, there was not a lot of\nroom for \"overhead\" and the idea that you would run two programs\nsimultaneously was generally unrealistic except at the high end of the\ncomputing world, which most PC buyers were nowhere near. You needed every bit\n(ha) of memory you could get, and when memory became more affordable a few\nyears later, it was too late to change anything.After just a couple years on\nthe market, MS-DOS had become the unquestioned OS of choice for the PC* and\ndeveloped a monumental stable of software, every bit of which was essential to\nsomeone, somewhere, and could not be easily replaced. Thus began one of the\nlongest tails in technology history, as the PC industry and Microsoft began\ncontorting themselves to try not to break compatibility with old software\nwhile still moving forward with advanced functionality. _*(specifically, since\nthere were MS-DOSes for other architectures, and other OSes for the PC)Because\nDOS was developed under constraints very similar to those in the late '70s\nthat gave us the \"bitty boxes\" (C64, Apple ][, ZX Spectrum, etc.) it was not\nbuilt with any kind of \"supervision\" in mind. In other words, there was no\nabstraction level above the current running program. DOS was more like a set\nof tools than what we think of as an operating system now - specifically, it\nhad no \"process management\"; no concept of \"processes\" at all, in fact.\n\n## DOS\n\nWhen the machine booted, the part of DOS that was considered \"the OS\" - the\ncode for accessing disk drives, writing text to screen, etc. - was copied into\nmemory, and then execution was handed off to the command interpreter,\nCOMMAND.COM, which was an application like any other, at which point you could\nbegin entering commands to use the computer.At this point, DOS was no longer\n\"running\" in any meaningful way. The code was \"resident,\" meaning it was\npresent in the computer's memory, but the processor wasn't executing any of\nit. Instead, the CPU was busy executing whatever the current program was - if\nyou were at the command prompt, then all the code the PC was executing was\npart of COMMAND.COM. When you launched another application, COMMAND.COM was\nvacated and replaced by that other application.In other words, while an\napplication was running, DOS was almost totally out of the picture. The only\ntime execution returned to DOS itself was when the application requested a\n\"service\" from DOS, like accessing a disk drive, at which point it would tell\nthe CPU to go execute one of DOS' stored routines for this, and when that\nroutine was done, control would return to the application. This meant that,\ngenerally speaking, the current program had absolute control of the PCs\nexecution and it's memory. It could in fact choose to overwrite DOS itself,\nobliterating it out of memory, and DOS couldn't do a damn thing about it.The\ncurrently running app also had the option to speak directly to hardware. The\nwhole purpose of DOS was to abstract things like that so programs wouldn't\nneed to know the details of the system they were running on, but since the IBM\nPC was extremely consistent hardware-wise in its early incarnations, it was\nentirely optional for developers to take advantage of that, and often there\nwere reasons - of performance, perhaps - to bypass DOS and do things\ndirectly.DOS provided disk access routines, but the app could blow right by\nthem and shoot commands straight to the floppy drive if it wanted. DOS\nprovided routines for printing text and clearing the screen, but the app could\njust write directly to video memory. I can't speak to how common this kind of\nbehavior actually was, but it certainly wasn't rare, and it speaks to a larger\nproblem - DOS apps simply expect total control over the system.If you run two\nDOS apps at once, they're going to stomp on each other, because each one\nthinks it's in charge of the whole machine. The first one would store data in\nthe same spot that the second one stored program code, and thus one would\noverwrite the other and crash it. So DOS was a single-tasking operating system\n- you could run one program at a time, and when you wanted to run another, you\nhad to exit, return to the command prompt, and then launch your other\napp.Consequently, if you were working on something in Microsoft Multiplan and\nwanted to go look up some data in dBase, you had to quit completely out of\nMultiplan and then start dBase, which would take over the system and totally\noverwrite the previous app. To get back to where you were you'd have to exit\ndBase, restart Multiplan, load your document and find your place again - in\nthe process, totally forgetting what you were there to do in the first place,\nbecause it's so many steps and takes so long.Right from the get-go, PC users\nwanted to be able to look at one program, then rapidly switch to another. On\nits face this seems to mean \"run two programs at once,\" which is what we do\nnow, but that's not quite the full story. Let's touch on how that works\nnowadays, however.\n\n## Multiprocessing\n\nTo be clear, you cannot run two programs \"at once\" on a computer. Some would\ncall this semantics, but it's important in a very real way, especially when\ntalking about 80s-era PCs.Modern multicore CPUs get very close to true\nparallel processing by letting separate programs run on separate cores, but of\ncourse, nobody has a CPU so big that they have one core per process. And even\nif you did, programs still have to share other resources - the system bus,\nhard drives, and so on. Access to these resources has to be carefully managed\nso that only one application can use them at a time, and each one has to be\ncleaned up after before another one can use the same resources. Otherwise, one\nprogram could leave the hardware in a state where the commands that the next\nprogram sends put it in an unusable state and crash the machine, or corrupt\ndata.Even with all our modern pipelined cleverness, you have the fundamental\nproblem that a CPU, and a computer in general, has a limited amount of\nphysical hardware and can't dedicate some to each individual program that's\nrunning. When you have more processes running than you have silicon, the only\noption left is to share resources by dividing up the amount of time that each\nprocess gets to use the hardware - this is one of the oldest concepts in\ncomputing, and goes back to the late '50s.The fundamentals of this process are\nsimple: At any given moment, one program has near-total control of the entire\nsystem, to execute its code and use all the resources, and then after it\nexecutes for a bit, it goes into a paused state and control is handed off to\nthe next program, which does its work and then hands off to the next. This\ncontinues in a round-robin fashion, so that every program gets to use the\nhardware for a certain portion of every second.Modern implementations take\nthis to a fever pitch with all the complex machinations used to make this\nprocess efficient, but the fundamentals have never changed; this is how your\nPC is operating right now.One big hurdle to overcome in implementing this is\nthat programs don't just execute instructions in a vacuum. As code is\nexecuted, there are side effects. Some are values internal to the CPU, like\nthe status of CPU registers and the current position of the instruction\npointer. This is called \"CPU state,\" and is specific to each running program.\nWhen you switch from one program to another, you have to save that information\n- called \"context switching\" - and restore it when you come back. Storing this\ninfo takes extra time and memory.Another hurdle is the state of other\nhardware. If two programs are talking to the hard drive, you can't let them\nboth just blindly issue commands every time they get control of the CPU. The\nfirst process might start a data read that the second process interrupts with\na data write, confusing the hard drive controller. So when switching from one\nprocess to another, you also have to save the state of these other hardware\nresources - and possibly even delay switching tasks until those hardware\nrequests are complete.If you have enough RAM to store this state, and if your\napps don't need too many cycles per second to appear responsive, you can do\nall this and the user will feel like they're \"running multiple programs at\nonce.\"Now, in business applications - the driving force behind the first\ncouple decades of computing - actual \"multiprocessing\" of this type is not as\nimportant as simple usability - users just don't want to have to close one\nprogram in order to open another, as they did throughout the DOS days. That,\nultimately, is the goal: it doesn't matter if the computer is perfectly\nspeedy, or if programs can run simultaneously, it just matters that users not\nhave to lose all their work in one program simply in order to look at another.\n\n## Multitasking\n\nThis desire was of course tremendous right from the start of computing. Who\nwants to be stuck in one program at a time? So, almost from the earliest days\nof the IBM PC, software was created to enable task switching with various\ndegrees of success.\n\n### Early Attempts\n\nMicrosoft actually released a version of DOS with true multitasking support,\nbut it generally required software to be specially written for it. You can see\nit here - EDLIN is running, and I can switch to a new command prompt by\npressing Alt and selecting from a menu, or I can start a new task.This didn't\nsolve the core problem - that you wanted to run your old, 1983-vintage copy of\ndBase II, and your old copy of Multiplan, at the same time. Since neither of\nthose programs were developed for this version of DOS, they couldn't play\nball. This creates a chicken and egg problem wherein nothing was written for\nmultitasking DOS, so nobody would buy multitasking DOS, and since nobody had\nthat DOS, nothing would be written for it.Even if software did get updated for\nnew OSes, users had already spent a lot of money on the software they had by\nthe time anyone started trying to solve this problem, and they wouldn't have\nwanted to re-buy that software. The feature that users needed was to share the\nmachine between two apps of any vintage, with both apps thinking they were the\nonly program running on the machine.An IBM product, TopView, was another early\nattempt to fully solve this problem. It was a textmode program, not a\ngraphical one, but it allowed multiple DOS apps to run at once, with their\ntext output diverted into separate \"windows\" on a shared \"desktop.\" Here you\ncan see it running fdisk and GWBASIC simultaneously, with both executing at\nonce - while I'm doing things in fdisk, the code in GWBASIC continues\nincrementing a number. So this is true multiprocessing, after a\nfashion.TopView only worked if the apps were \"well behaved.\" This is a term\nyou'll see throughout articles on this topic, and what it means is that the\napp didn't do any direct hardware access - it used DOS \"system calls\" for\neverything, which gave TopView an opportunity to \"intercept\" those calls and\nredirect them for its own purposes.For instance, when a program wrote to what\nit thought was character position 2,10 on the screen, TopView altered the\ncoordinates so they drew into the \"window\" it had created for that app\ninstead. The advantage to this is that you can simply hand off the processor\nto each app one at a time and allow them to do what they want, and the results\nwill always end up safely back in TopView's hands where it can figure out\nwhere they're meant to go.The biggest problem is that this stops working the\nmoment your app touches direct video memory, for instance, which many did,\nmaking them incompatible with this approach. Also, TopView just sucked. I used\nit for about 20 minutes while writing this article and every step of the\nprocess was unpleasant. Being limited to textmode does nothing to help the\nsituation._Footnote: The third pic is the TopView PIF Editor for later\nreference. PIFs tell Topview how to run apps - this will be explained much\nmore thoroughly later in this article, since TopView evolved, in a sense, into\nWindows itself.\n\n### Task Switchers\n\nThere was a specific class of commercial products called \"task switchers\" that\nallowed you to run multiple programs and switch between them with a shortcut\nlike alt+tab, and in fact early versions of Windows, as you'll see, were often\nlittle more than this. These programs couldn't run simultaneously - at any\ngiven moment, one program had complete control of the screen and all hardware\nresources, and then when you switched tasks, that program got completely\nsuspended and another one took over.There's very little info about how these\nworked online but as far as I can tell, they just used brute force. I mean, I\ncan't think of any other approach, and talking to friends who have done more\nresearch into this than me they seem to agree: When you hit the task switch\nshortcut, the switcher just takes a snapshot of various hardware resources\nlike video memory and CPU register status, saves it all to another spot in\nmemory, then transfers control to another app, all with what we would now call\n\"userland\" code - the switcher is just another program running on the\ncomputer.I don't know how popular these programs were, but they certainly had\ntheir proponents - since they didn't try to \"intercept\" the input/output from\napps, but mostly let them run as if they were in total control of the system,\nI imagine they were somewhat more compatible with not-so-well-behaved apps.But\nwhat happens when the program you want to run is even more poorly behaved, if\nyou will? Since these switchers would have needed to \"manually\" save the state\nof all hardware resources, they would have to predict what was in use. If a\nprogram did anything the switcher wasn't prepared for, like alter graphics\ncard configuration registers, the system could have entered an unusable state\nor even crashed when a task switch occurred.Also, while lots of DOS apps were\nnice enough to pay attention to where they were in memory and only make\nchanges to their own data, nothing stopped any app from scribbling all over\nsystem memory and corrupting other programs.I may not have hard answers to how\nthese switchers worked, but the proof is in the pudding - while you can\nprobably tell me the name of the OS installed on Macs in 1985, and you can\ndefinitely name the most popular way to run multiple DOS programs on the PC in\n1995, you almost certainly can't name a DOS task switcher or multitasking\nenvironment offhand. There were at least a half dozen and none of them are\nremembered now, which tells us they didn't do brisk business.You actually can\nname one of them, though you might not know it. For it's first couple\nversions, Windows' ability to run multiple DOS apps was a hybrid of \"task\nswitching\" and the TopView approach. Compatible apps could run in windows\nconcurrently, while apps that wanted to write to the screen and so on were\nceded control of the hardware while running. The fact that most people have\nnever seen or heard of these editions of Windows also speaks to how poorly\nthis approach probably went for Microsoft.To sum it all up, the trick we're\ndiscussing here is just incredibly difficult to pull off. Taking programs that\nwere meant to run using the entire resources of a computer and trying to\ngimmick them into sharing the computer is just incredibly difficult - until\nhardware changes came that specifically enabled this.\n\n## Hardware Advances\n\nThe original IBM PC CPU was an Intel 8088, a cost-reduced form of their more-\nor-less flagship 8086 chip, and throughout the 80s it remained the\noverwhelming definition of the platform. Though it was an advanced processor\nperhaps in 1981, in retrospect it looks like little more than a fast\ncalculator now, without a lot of advanced purpose-oriented features. Though\nIntel released several considerably faster and more advanced processors\nthroughout the 80s, the bulk of PC software targeted the 8086/8088. The newer\nprocessors had backwards compatibility modes allowing them to run 8086\nsoftware at faster speeds, but only a few programs actually targeted the newer\nchips.\n\n### The 286\n\nThe 80286 was Intel's consumer followup to the 8086, and it introduced a much\nmore advanced mode of operation, called protected mode. The full details of\nthis are extremely complicated, but in the simplest terms, protected mode\nallowed multiple programs to share one PC without being able to interfere with\neach other. Each process gets locked into an area of memory in which it can do\nwhatever it likes, but an attempt to reach outside of that area results in a\nCPU-level alert being triggered, at which point the operating system - which\nactually has a higher privilege level within the CPU itself - is allowed to\ntake over execution and decide what to do about it.This feature allows you to\nrun multiple programs without worrying that one might overwrite another's\nmemory or crash the entire system. If a program tries to access memory it's\nnot allowed to touch, the CPU stops it, and the OS can step in and make a\njudgment call - either permitting the access if it thinks it's reasonable,\nredirecting the access to somewhere else in memory, or stopping the process in\nits tracks and terminating it.This is a fantastic capability and could have\nrevolutionized computing overnight when it was released in 1982, except that\nby that point there was already an enormous DOS software ecosystem. Protected\nmode completely altered how the system worked, and virtually no DOS software\nwould run correctly in this state. So instead, these chips were largely\nrelegated to running in backwards compatibility mode - called \"real mode\" -\nand while they could be switched between protected and real mode, it was\nextremely slow and awkward, so it had little impact on the PC world.\n\n### The 386\n\nThe 80386 was the third major leap forward in Intel's x86 processor line, and\nit would have been very easy at release to totally miss the feature that was\ngoing to change how the IBM PC worked completely. I think I actually found\nsome articles in magazines about the 386 which did exactly this - decried it\nas a simple bump in speed and instruction set that had no real impact on the\nevolution of the platform.Buried in the feature list however was something\ncalled Virtual 8086 mode, and this feature was in fact a massive step forward\nfor the DOS application ecosystem of the day. It fixed the problems with\nprotected mode, enabling the CPU to run DOS apps and new protected mode apps\nat the same time, by - in no uncertain terms - running the DOS apps in virtual\nmachines.This works pretty much like the virtual machines we use nowadays.\nEach DOS app gets cordoned off into a space in memory where, as far as it\nknows, it's the only program running on the machine. When it tries to write\nto, say, the spot in memory where 8088 machines stored their video, the CPU\ncatches those write attempts and alerts the operating system, which can\nredirect them to a device driver or put them in an entirely different spot in\nmemory so they can be displayed only when the OS chooses.In fact, all the\nhardware of the host machine is emulated - the OS presents a \"fake\" graphics\ncard, a \"fake\" keyboard, a \"fake\" hard drive and so on, all of which translate\nthe blunt, simplistic requests of 1981-era software into the polite,\ncooperative discourse of modern, community-conscious software. In this way,\nmultiple concurrent DOS apps can run in these tiny walled gardens, and as far\nas they know, each one has a whole PC to itself, while in reality their input\nand output is entirely simulated - a Truman Show for elderly software.This is\nhow the Windows that most of us remember worked. By leveraging the\ncapabilities of the 386, Windows was able to run multiple DOS apps\nsimultaneously. Microsoft took a run at making this happen without the\ncapabilities of the 386, but it was not a pretty sight, as you'll see - it was\nfragile, tedious and limited, and therefore failed to put Windows on the map.\nCuriously, not even the addition of the 386 to the equation solved this\nproblem - before Windows could gain any respect, it had to make significant\nleaps forward in the overall user experience.Now, let's look at how this all\nworked.  \nWindows 1.0 (1985)  \n---  \nWindows 1.0 is as far as I can tell roundly considered a joke, a token effort\nmeant to fill a commitment Microsoft had made and little more. Whether it was\never intended to actually run DOS applications in any context more demanding\nthan a public tech demo is questionable.One of the problems with it is that it\nhas no overlapping windows, but uses a tiling window manager instead. This is\npretty unpleasant to look at, but surprisingly well designed all things\nconsidered. When you launch an app, it usually takes up the entire screen by\ndefault, with other apps minimized to icons in the taskbar - that's the green\narea, where you can see a floppy icon representing a minimized MS-DOS\nExecutive. Once you've started an app however, you can then drag another icon\nonto the screen to split the view either horizontally or vertically, and you\ncan resize these splits to fit windows to their contents. You can then drag\napps by their titlebars to rearrange and add new splits as desired.At higher\nresolutions (which were possible, though rare) this might be a somewhat usable\nUI, but I find it pretty hard to look at, and given the public response to\nWindows 1.0 I'd guess I'm not alone. Notice of course that there are native\ngraphical apps for this OS - a few programs actually got published for Windows\n1.0, and the API was sufficiently stable that they still run in much, much\nlater editions.My experience with this version is disjointed to say the least.\nIt took me several days to manage to get it to run correctly at all, and I\neventually found out that you have to run it on DOS 3.3 or it'll just break in\na bunch of weird ways. I also can't find a manual anywhere, so I had to puzzle\nout how it worked based partially on the documentation for the non-enhanced\nversion of Windows 2, which is largely similar.\n\n## DOS Apps\n\nSo first, I'll try to run dBase II. This is a very old but extremely venerable\nPC app from 1983 which I imagine some people would still have had around in\n'85, although it had been supplanted by dBase III in '84.This is your very\nfirst experience using Windows for one of its core purposes, so how does this\nprocess feel to the user? Well, this is, unmistakably, an error message. You\nhave attempted to run one of the many programs you've used for years, which\nyou were told Windows will run, and you have received an error saying that\nWindows cannot find a file, and given no explanation for why that matters.\nThis is a resounding UX wet fart, no bones about it.I can't find a Windows 1\nmanual, but for Windows 2, the manual section referred to is 163 pages into\nthe Windows User Guide and runs for dozens more - this part is more\nunderstandable, given that the technology to figure out how to run a DOS\nprogram automatically had not yet arrived in the pre-386 era. In short, the\nuser is about to be taken to old program school and made to earn a\ndegree.However, if we just hit OK, the app launches:Notice that it's running\nin fullscreen - the app takes up the entire screen, just as if it were running\nin DOS normally, and there is no way (that I can tell) to get back to Windows\nor change programs.When you quit the app, it stays on the screen until you\npress a key - this is so that if the program printed something before it\nexited, you can read it before Windows takes over the screen again. Some apps,\nyou can imagine, would be useless if they hadn't done this.When operating this\nway, Windows is nothing more than a program launcher of the sort that was\ncommon at this time, with no multitasking at all. In order to go beyond this,\nyou need a Program Information File - the missing \"PIF\" that was mentioned.\n\n## Program Information Files\n\nWhat I've shown you above is not Windows putting its best foot forward. There\nare better ways to run DOS software, but they require significant work on the\nusers part.If programs are (sigh) well-behaved, Windows can run them in a far\nmore modern format. To wit:Here, dBase II is running in a window. It updates\nmore slowly than when running fullscreen, and I'd guess that's because Windows\nhas replaced the BIOS routines for printing text with its own code, that\nstores each DOS app's text output in a different spot in memory, and it only\nperiodically checks that memory for updates and updates the graphical\nscreen.There are other things I can do in this mode, but we'll cover those\nshortly. Let's first look at how I accomplished this. To make this program\nrun, I created a PIF with Pifedit.exe:You may know the PIF format as the one\nthat continued being used for shortcuts to DOS apps in Windows 95. This format\noriginated in IBM TopView, and never changed in concept, except that by\nWindows 95 user intervention was not needed in most cases. Here, it absolutely\nis.A PIF primarily tells Windows how (sigh) \"well behaved\" an app is. The\nvarious Directly Modifies checkboxes warn Windows about the parts of the app\nthat it needs to be careful around. About half of these options disable\nwindowed mode and force the app to run in fullscreen. Here's roughly what the\nsettings do:\n\n  * First, you have to give the executable name so Windows knows when to engage this PIF - unlike later versions of Windows, PIFs are not tied to specific files on the disk. If you launch DBASE.EXE (or .COM) anywhere on the machine, regardless of drive or folder, this PIF will take effect.\n  * You can also give a \"friendly name\" to the app so that it shows up with a better title than just the filename, and give command line parameters and a default directory to run in.\n  * Then we have options to tell Windows how much RAM the program needs, and how much it prefers. This affects the amount of available RAM that Windows reports to the program, so if you set the minimum to 128k and the desired to 512k, and Windows finds 256k free, it'll report that much to the app.\n  * Now we have the Modifies boxes:\n    * The Screen checkbox is for apps that write directly to video memory, and simply forces fullscreen mode.\n    * Keyboard is for apps that read the keyboard directly, and disables all task switching shortcuts - meaning if you enable this and an app won't let you exit, you're stuck in it permanently until you reboot.\n    * Memory is for a couple scenarios: one is for apps (called TSRs) that launch and then exit, leaving themselves \"resident\" in memory so that other apps can access their code, and another is when you want to run an app that takes up nearly all system memory, in which case Windows will swap itself to disk to leave more room for the app to run.\n    * COM1 and 2 are interesting; they just give exclusive access to a serial port to that program so two apps that want to use the same port can't run simultaneously. It's surprising to me that this doesn't also apply to printers, but I think at this point printing was meant to be handled through the Windows print spooler anyway.\n  * Next is the Program Switch option. This touches on the mechanics of task switching. In order to tab away from one program and into another, Windows needs to save a copy of the screen so that it can restore it when the app is recalled. \"Text\" reserves 4KB, enough for a single screen of text. \"Graphics/Multiple Text\" reserves up to 36KB to save a bitmap screen. \"Prevent\" disables switching, saving 4KB.\n  * Screen Exchange is supposed to refer to printscreen behavior - but I can't get this to work in Windows 1. In 2.x, these settings allow you to press Alt+Printscreen to screenshot a running DOS app, which requires Windows to reserve some memory to store the shot. Note that in textmode, a screenshot will just be the text, which you can paste into e.g. Notepad, while in graphical mode it will be a bitmap you can paste into e.g. Paint. I'm not sure why this isn't working, and I don't have a manual to refer to.\n  * Finally, you can have the app close automatically on exit - otherwise we get a \"zombie window\" which you'll see later.\n\nAs the user, you are expected to create one of these PIFs manually for every\nprogram you want to run. Windows comes with a small assortment:These are of\ncourse optimized for popular third party apps of the time, a practice\nMicrosoft would continue with increasing fervor as the years went on. At this\npoint there were thousands of DOS applications in the world however, so with\nonly 60 or so shipped with the OS, the user would almost certainly need to\ncreate their own PIFs frequently.\n\n## Fullscreen Capabilities\n\nIf a program is set up with a PIF that makes it run in fullscreen, you don't\nget a lot of amenities other than the ability to minimize it with Alt+Tab.\nHere's a minimized dBase, in the taskbar:You could start multiple copies of\ndBase and switch between them by alt+tabbing out, then clicking on the one you\nwant. This seems like a pretty irritating process - I don't appear to be able\nto alt+tab directly from program to program; it just highlights the icon,\nafter which I have to press Space to get this menu, then select Zoom to reopen\nthe app. It's not smooth at all.There doesn't appear to be anything else you\ncan do with a fullscreen app. This would get better for a bit in a later\nedition, but Windows is mostly about... windows, so that's where the bulk of\nfunctionality will remain.\n\n## Windowed Capabilities\n\nWindowed mode confers a number of new options. Here I've tested with fdisk,\nsince it's a very clean, first-party Microsoft app with a textmode UI:First,\nas seen here, we can run in a split window, with other DOS apps or with native\nWindows graphical apps. This gets cramped very fast, but a pair of side by\nside windows would probably be a somewhat useful geometry. You can keep\nlaunching processes until you run out of RAM - I made it to 3 here, but with\nsome adjustments to the PIF I might be able to run more.When an app finishes\nexecuting, it usually hangs open like this;Notice the parentheses around the\nname - like fullscreen mode, Windows leaves the app open so you can see the\nfinal output. In order to actually close the window you can't just press a key\nhowever, you have to go up and actually hit the Close option on the window\nmenu.Curiously, this doesn't seem to happen with all programs - some, like\nfdisk, exit immediately. I'm not sure if this is because they're returning\nsome different exit code to the OS or what. This is what the \"Close window on\nexit\" option in the PIF is supposed to control.You can maximize a DOS window\nto fill the entire screen, covering even the taskbar, at which size I believe\nyou get a full 80x25 display.With an app running in a window, you can now\ninteract with it in a limited fashion using the mouse. Here, I've copied some\ntext from a DOS window and pasted it into Write.You can also paste directly\ninto a DOS box, and your text will be entered as virtual keystrokes. This\ninteroperability is a big bullet point justifying Windows' existence - I\ncould, for instance, copy complex commands I made in a dBase session and save\nthem in a text file for frequent re-use, something that was probably enabled\nby special programs called \"TSRs\" under DOS, but would have been tedious at\nbest.You'll notice something about that window menu - the Close option is\ngreyed out. Would you be surprised to learn that in this version of Windows,\nit is impossible to exit a DOS program without its cooperation? There's no\ntrick, no workaround - it cannot be done. Once a DOS program is launched, it\nhas to exit of its own free will, or it's simply stuck running.Also, while we\ncan open multiple copies of a program at once......only one actually executes\nat a time. When I click away from the first one to the second, it freezes and\nthe second one starts running. Windows only gives processor time to one DOS\ntask, probably because the complexity of constantly unloading and reloading\nthe hardware context of multiple apps is just too high to do efficiently and\nreliably.The apps I've run so far are extremely simple in how they interact\nwith the screen - all they do is print text. If we try to run something more\nsophisticated, Windows has problems. Here's Multiplan 4:This launches in\nfullscreen, but if I turn off the Directly Modifies: Screen flag in the PIF, I\nget a blank white window with no text. I got the same result from trying to\nrun anything else that attempts to have a \"textmode GUI\" style interface, like\nDOS Edit or QBasic. Curiously, it also crashes as soon as I press any key -\nand this happens even if I run it in fullscreen. As long as there's a PIF at\nall, it crashes as soon as I do anything - if I delete the PIF, it runs fine,\nbut in fullscreen and with no task switching.Another thing I should point out\nis that there is no color text support at all - here is fdisk running\nfullscreen, versus windowed. Notice that the fullscreen text is bright white\nand grey, but in a window it all renders as black on white. I'm not sure\noffhand why this is - Windows has color support, and this information is\ndefinitely being stored in memory, so why they wouldn't use it I don't know.\n\n## Usability\n\nAs noted before, Windows 1 was not meant to be good by all reports, and I\nwould say it isn't.The tiling window manager is very uncomfortable, and it\nfeels like it makes very poor use of screen space despite it being about as\nlean as it possibly could be. It does not look or feel polished, and it\nrequires too much tedious fiddling to make everything work - you can't tell\nfrom the screenshots, but it took ages to get all this working just because\nmoving from task to task in this OS requires a ton of extraneous clicks. The\nGUI is not good.With that said, it does do what it promises to some extent.\nOnce you create PIFs, DOS apps do work if they're sufficiently basic, and\ncopying text between programs is extremely useful. However, a number of apps\nthat I threw at it wouldn't run in a window, and one wouldn't run at all.This\nrelease would not put Windows on the map. That wouldn't happen for a while,\nbut let's see where Microsoft goes next.  \nWindows 2.x / 286 (1987-89)  \n---  \nNote: There were several versions of this OS including 2.03, 2.1 and 2.11.The\nnaming conventions of this OS are confusing. There are several versions, some\nsold as \"Windows 2.0,\" some sold as \"Windows/286,\" some sold as \"Windows/386.\"\nAll of these are versions of Windows 2.x.The name Windows/286 does not mean\nthat this version of the OS requires a 286 - it will run on an 8088 with\nalmost full features, it just distinguishes that it is not the 386-enhanced\nversion, but that it does have support for expanded memory, which was\nintroduced on the 286.I will be referring to Windows/286 and Windows/386 as if\nthey were different operating systems, but they were released simultaneously,\nand it's probably accurate to say that both are simply Windows 2 running in\ntwo different modes.2.x continued Windows' trend of unsuccess in the market,\nbut that's not to say that it did nothing to improve the functionality of DOS\napps. In fact, there are considerable improvements throughout.The new window\nmanager (with overlapping windows!) is drastically more pleasant to use than\nits predecessor. I have found references in magazines to Windows 2 being used\nby actual consumers, which I can't say for Windows 1, so let's consider this\nvery possibly to be the first Windows anyone ever bothered with.Nothing has\nimproved in the basic \"run an app\" process:The same PIF error happens, and the\nPIF editor hasn't added anything new - Windows/286 appears to be mostly\nidentical to Windows 1 in terms of what it can run and how, but there are\nchanges right off the bat.\n\n## Fullscreen Capabilities\n\nAn app with no PIF launches fullscreen, taking over the entire computer. This\nis Windows operating in \"task switcher\" mode, mostly like it did in Windows\n1.0 - it doesn't know enough about the program to try to put it in a window,\nso it's ceding the entire system to it. Compared to the previous version\nhowever, there are new capabilities even here.If you're used to Windows 95,\nyou might try hitting Alt+Enter at this point, but that key combo does\nnothing. The next thing you might try, if you had a lot of experience with DOS\non Windows, is Alt+Spacebar, and that does do something:When you hit that key\ncombo, Windows now injects this textmode menu. You'll notice the \"Restore\"\noption is not functional - in other words, you can't change this app to a\nwindow (the thing that Alt+Enter does in later versions.) Window-izing an app\nis only possible with a PIF setting; you can't switch modes on the fly.You can\nalso Alt+Tab to cycle through running apps, and it shows you a preview of the\napp you're about to switch to using the menubar:Notice that the title says MS-\nDOS Executive - the name of the app that will be switched to if I let go of\nAlt. Selecting this allows you to escape back to Windows, but as with Windows\n1.0, you still can't quit a DOS program without using its Exit option - even\nafter you get back to Windows, you can't exit it while DOS programs are\nrunning.There's no longer a \"taskbar\" area, minimized icons just go to the\nbottom of the \"desktop.\" With a DOS program minimized, you can see it there as\nbefore. The menu allows you to return to the app, that's it.From within the\napp, you can now use the menu to copy and paste text, an improvement for apps\nthat can only run in fullscreen textmode. To do so, you press Alt+Spacebar,\nselect the Mark option, and then use the arrow keys to navigate the cursor and\nshift to select text.In the above pictures I'm marking a command I had\npreviously entered. I can then go back into the menu, select Copy, and then go\nback in and select Paste, which reenters the text as virtual keystrokes. If I\nhad entered a complex command, I could store it in the clipboard so I don't\nhave to retype it multiple times. This uses the Windows global clipboard, so I\ncan still use this to interchange text with Windows apps like Notepad.Probably\nthe oddest thing about all this is what happens when you do quit a DOS app the\ncorrect way, by choosing the apps own Exit option. The app ends and becomes a\nzombie, like this:You may recall that the term \"Inactive\" remained for a long\ntime. When you quit a DOS app in Windows 95 or later, the window would often\nswitch to this Inactive title and remain until you closed it. This makes\nsense, and as in Windows 1.0 it's good that windows hangs here, but because it\ndoesn't have the ability to convert the program to a window - as later\nversions could - you're stuck in full-screen with this dead app. Pressing\nenter does not close it as it did in Windows 1.0.At this point, in order to\nreturn to Windows, you need to press either Alt+Spacebar or the down arrow key\nto summon the window menu and navigate to Close. If you hit Escape out of\nreflex you could simply be stuck here, looking at a blinking cursor on a black\nscreen, unsure what's going on. It's not catastrophic, but it's, uh, not a\nfantastic user experience.\n\n## Windowed Capabilities\n\nWindowed mode has not directly improved, except that it benefits from the new\noverlapping window manager. Everything you could do in Windows 1.0, you can do\nhere.When apps end, the window also obtains the Inactive banner, as it does in\ntextmode, which is clearer than the parentheses.\n\n## Usability\n\nIf you create PIFs for each of the apps you use, and those apps are reasonably\nsensible in their behavior, Windows/286 will let you run them side by side in\ndecent harmony.With the new window manager, this is definitely a more pleasant\nexperience. However, in practice, I still have not been able to get most apps\nto work in windowed mode. Lotus 1-2-3 and Multiplan, for instance, can be made\nto work in fullscreen but I cannot find a configuration that will let them run\nin a window - they just say there isn't enough memory, no matter what I\ndo.Perhaps this is because I don't exactly understand the memory model of this\nera - I never was able to make sense of EMS and XMS in the 95 days, and while\nyou could say this limited perspective makes me unqualified to write this\narticle, I should clarify that I have the entire Internet at my disposal, and\nsomeone in 1985 did not. If I can't figure this shit out now, what was it like\n33 years ago?Also, I don't think that non-textmode apps can run in windowed\nmode at all. In any case the memory requirements to do this are so high that I\ncouldn't figure out an incantation that didn't just throw a memory error and\nrefuse to run.With that said, the need to run apps in a window is not\nparamount. It is, however, a tremendous bummer if you ask me. Running multiple\napps on the same screen had been a white whale of the IBM PC for years at this\npoint and it would have been remarkable if this edition of Windows had fully\nachieved it.As with Windows 1, apps do not execute simultaneously. Whichever\napp is focused executes and all others are suspended.This is not the holy\ngrail that Windows was meant to be, mostly because the hardware just didn't\nhave what it took yet. It seems like a pretty solid task switcher, but the\nprivations of getting tasks running are so intense that I imagine many people\nnever even gave it a solid try.  \nWindows 2.x / 386 (1987-89)  \n---  \nWindows/386 is another beast entirely.Given the monumental new capabilities\noffered by the 80386 processor's Virtual 8086 Mode (V-8086), the experience of\nrunning DOS apps changes completely for the better.As you can see, there's no\nobvious difference between this and the previous unenhanced edition, but let's\nlaunch a DOS app:It doesn't look very different, but here, you can press\nAlt+Enter:Windows/386 has added considerable new functionality to DOS apps,\nnow that it can run them in VMs.Programs don't give an error about a missing\nPIF on startup, they just start immediately and go to fullscreen. At this\npoint you can now hit Alt+Enter to switch to windowed mode, which Just Works -\nno PIF required. You can create PIFs (which you'll see shortly) but they're\nonly to help Windows when it can't figure out what an app wants.I'm not sure\nhow much heavy lifting V-8086 is doing here. It appears that we no longer need\nto allocate memory for programs, for instance - I can launch apps that I\ncouldn't get running with the defaults (or at all) in Windows/286 and they\njust work, immediately. Switching dynamically to windowed mode requires a\nconsiderable amount of RAM, since Windows has to store their entire screen\ncontents as well as its own - and in color, as you'll see - yet Windows\nmanages it without a hitch.My guess is that Windows/386 is able to leverage\nextended memory to make this all Just Work without any user intervention, by\nplacing VMs and saved screen contents up in higher RAM areas that Windows/286\ncould barely use. Also, since V-8086 turns over control to Windows when an app\ntries to reach outside of its allocated memory, Windows can probably allocate\nmore on the fly as long as the access was legitimate, removing the need to\nspecify how much RAM an app needs ahead of time.A nice improvement over the\nprevious OS is that when you exit a fullscreen app, instead of becoming\ninactive and staying fullscreen, it now switches to windowed mode\nautomatically, which makes it much clearer how to move forward.\n\n## Color\n\nYou'll have noticed that the color scheme of textmode DOS windows is now\nwhite-on-black instead of the opposite. This is not an arbitrary change, but\nis actually because VM windows now support color:QBasic wouldn't even run in a\nwindow in previous versions, but now works quite well in one, with full\ncolor... sort of.These aren't the exact intended colors of QBasic - the third\nimage is a screenshot of it running in fullscreen to demonstrate what it\nshould look like. Everything's brighter and washed out in windowed mode. This\nis odd, because Windows is running in VGA here. Even in 16-color mode it\nshould have been able to choose a reasonable palette to match textmode colors.\nI'm not sure exactly what's going on here, but I think it's something like\nthis:Windows 2.x ostensibly supports VGA graphics, but was made at a time when\nthose cards were still rare and expensive, so it's really designed for EGA.The\nonly thing that the VGA driver does is increase the screen resolution to\n640x480, at which resolution it only has 16 colors available. That 16-color\npalette can be chosen from the entire 256 color VGA gamut, but Windows uses\nthe default EGA palette for compatibility with the majority of Windows apps,\nwhich would have expected to run mostly on EGA cards.Now, EGA also had fully\nsaturated colors in its gamut, but not in it's default palette, which was\nbased in turn on the 16-color CGA palette. CGA's palette had eight colors,\nplus light and dark variants, and its light colors were unpleasantly\ndesaturated. It's \"bright blue\" was the unsatisfying shade (Dodger Blue) you\nsee above, for instance. I have always hated CGA's colors, but they're what\nIBM chose in 1981, so it is what it is, and that's why the bright blue here\nlooks like that instead of a nice fully-saturated blue - because Windows is\nusing the most compatible palette possible.But that doesn't explain it all.\nWhy is the background color a bright blue at all, instead of the dark one, as\nintended? The CGA palette did contain a dark blue, so why not use that? Well,\nfor some reason all the background colors in the DOS window are being forced\nto their \"high intensity\" variants. Grey becomes white, dark blue becomes\nDodger Blue, and so on. This is why the white characters in each menu option\nare invisible - they were supposed to be on a grey background where they would\nhave shown up, but that grey has become white.Why did Microsoft do this? I'm\nnot enough of a wizard to dig into the hardware registers and find out what\npalette is actually being used, but even running in EGA mode Windows should\nhave had better colors available. Did they not actually use the original CGA\npalette's dark colors? Why wouldn't they have done that? It's a weird problem,\nand what's weirder is that it's retained in several subsequent Windows\nreleases, but changes to introduce new problems with each version as the\nWindows default palette changes.This is a minor complaint however, because\nit's still worth it to be able to run an app with somewhat correct color,\ninstead of the black and white of Windows/286.\n\n## Graphics\n\nNow, in addition to color, DOS apps can even display graphics in a window now.\nThis app, Xanaro Agility, uses medium resolution CGA graphics and it works\nperfectly in a window:I believe the reason this was not possible before is\nthat graphics mode under DOS never used system calls to draw anything -\nprograms always wrote their graphics directly into video memory, and without\nthe V-8086 VM it would have been impossible to intercept those calls and\nredirect them. Windows/386 is perfectly capable of doing that however, and\ndoes so with aplomb.Now that graphics work, the Mark feature now allows you to\ncopy graphics out of a window and paste them into other apps, as you can see\nhere. Paint at this point used strictly one-bit black and white due to memory\nconstraints, so copying a color CGA app would require a third party app.You\ncan now even run certain games in a window, like Bruce Lee here (although it\nruns too fast to play):All of this \"just works\" - I didn't have to make any\nPIFs or change any settings - although Windows included one for dBase, it\nstill works if I delete it.Let's talk more about games for a second.\n\n## Games\n\nWindowed games do not work, and never really would, however they can tell us\nwhere the limits of Windows' DOS emulation are, since high resolution DOS\ngraphics are relevant to productivity software as well. Games of course push\ngraphics to their limit - Bruce Lee runs as shown above, but it's an extremely\nold, CGA-era title. Newer games using EGA/VGA do not work correctly:Here I'm\nattempting to run Apogee's Crystal Caves. It's able to make it as far as the\ntitle screen (although you'll notice, again, that the colors have been coerced\ninto the high-intensity palette - compare to the fullscreen version in the\nthird image), but when it tries to load the menu, Windows identifies some kind\nof faux pas it has committed and gives the error you see in the fourth\nimage.Commander Keen fails immediately on startup with this same message. Note\nthat these games do run in fullscreen mode and can be alt+tabbed out of just\nfine, they just refuse to run windowed.While Windows was never intended to run\ngames in this era, there are certainly business applications that would run\ninto these same problems. A high resolution GIF viewer for viewing files\ndownloaded from BBSes for instance may have had this kind of issue.This makes\nme wonder what exactly the issue was. I'm not certain what graphics mode\nCrystal Caves is in during startup, but I would have guessed it's 320x200x4\nEGA, the same mode the game itself runs in. Executing it in DOSbox, I don't\nsee anything that looks like a mode change when it switches from the title\nscreen to the menu. The only thing I can think of is that this occurs when a\nDOS app makes a write to video memory that doesn't fall within the parameters\nthat Windows expects.I assume that windowed graphics work essentially by\nemulating a graphics card. Since video on a PC is generated by reading a\nseries of memory locations and interpreting them based on the status of a\nbunch of graphics card config registers, Windows must be interpreting those\nregister writes by the software in order to know how to render what's being\nwritten to video memory.Presumably Microsoft made code that accounts for\ncertain video modes and settings typical of business software, but isn't ready\nfor everything that can be done with a graphics card. If it sees anything it\ndoesn't understand, it panics and pitches the program to exclusive fullscreen\nmode where it can program the graphics card directly without interfering with\nthe rest of the OS.\n\n## Fullscreen Mode\n\nAn interesting loss of functionality actually occurred for apps that run in\nfullscreen: Alt+Spacebar no longer summons a textmode menubar. Instead, it\npunches out to windowed mode immediately, where the user can then use the\nMark, Copy and Paste options. This means that the textmode menubar existed in\nonly a single version of Windows, which is intriguing considering how clever\nit was.Consequently, when you Alt+Tab, instead of seeing the menubar with the\nname of the app you're about to switch to layered on top of your current\nprogram, the entire screen blanks and you see this instead:It's interesting\nthat they decided to forego the approach of layering the switcher interface\nover the app itself. Maybe they found the latter was visually confusing, or\nsomething about the V-8086 architecture prevented it.\n\n## Multiprocessing\n\nIn previous versions, I could run multiple DOS apps, but only one would\nexecute at a time. Under Windows/386, I can run multiple apps concurrently, as\nin, both executing at once:You can't see it in this non-moving picture, but\nthen it's also not very visually impressive, despite still being a tremendous\ntechnological advance - both copies of dBase II here are running an infinite\nloop that increments a number, and both are updating simultaneously. This is\nproper multiprocessing, just like what we have nowadays. Making this work,\nhowever, requires some user intervention - by default, only the currently\nselected app will execute and all others are paused, and the user has to\nchange some settings to alter that.\n\n## Program Settings\n\nBy pulling up Settings from the window menu of a running app, you can see some\non-the-fly configuration for the DOS VM that's now available. Display Options\nobviously just switches from windowed to fullscreen, but the others do\ninteresting things. There's no specific manual for Windows/386 apparently, so\nsome of this I have to infer:\n\n  * Execution allows you to simply pause a program. I assume this is so that you can halt an app that consumes a ton of CPU time and totally hangs the rest of the machine, do something in another app briefly, and then return and resume the CPU-hog app.\n  * Tasking Options allows you to specify whether an app should execute only while in the foreground, continue executing when in the background, or take exclusive control. This latter forces the program to run in fullscreen, and I believe it also pauses any other apps while this one is selected, even if they were set to run in the background. Notably, a program set to fullscreen mode, but with Background enabled, will actually continue executing even when not focused, even though the output is totally invisible at that point.\n  * Terminate is a novel feature. As I said, in prior versions of Windows you could not stop a program without using its Exit option. In Windows/386, presumably because of the process isolation offered by V-8086, you can do this - but it gives you a scare message first:\n\nForcibly terminating processes remained a sketchy option through all Windows\nversions prior to NT taking over the product line. Up until Windows ME,\nctrl+alt+del was a way to sometimes regain control of your system in an\nemergency, but frequently failed, and even when it succeeded it often\ncorrupted the system state.It was better than having to hit the reset button,\nbut not by much, so I'm assuming the same is true here - this would let you\nrecover to a point, but a savvy user would heed this warning and reboot as\nsoon as possible after saving their work.\n\n## Program Information Files\n\nThe PIF remains in Windows/386, but some changes have occurred.While there are\nsimilarities, the Directly Modifies section - the most important element of\nthe old PIF editor - is completely gone. Windows no longer needs forewarning\nof how the app behaves, because V-8086 allows it to run rampant within its\nsandbox. The section has been replaced with Usage Controls which just\nreplicates the options from the application settings regarding background and\nexclusive execution.The change here is enormous. The PIF is no longer an\nessential part of launching an app, just a way of tuning it - giving it more\ninitial memory so it's less likely to run out, for instance, or just providing\na nicer title, or making it close on exit. These are handy, but not required.\nApps mostly run fine with the default settings.The PIF would remain throughout\nthe history of Windows, but would become less and less useful over time as\nWindows got better at figuring things out on its own like this.\n\n## Usability\n\nNeedless to say, this version of Windows is a tremendous leap forward. I\ngrabbed four programs and just ran them with no effort - some of which\nwouldn't run on the previous OS at all.The simple way to put it is that,\nalthough there will be significant refinements in later editions, the\nfunctionality of the DOS VM in Windows/386 is pretty much a solved problem as\nfar as business software goes.. I was not, for instance, expecting graphical\napps to work in a window at all - I assumed that functionality had come in\nWindows 95, and while there will be enhancements at that point, everything\nseems to work pretty well in this version. The 386's new features appear to\nhave knocked this problem right out of the park.  \nWindows 3.0 (1990)  \n---  \nWindows 3.0 was heralded as the OS Microsoft had promised in 1983 and failed\nto deliver until 1990. It's improvements were far too numerous to list, but\nwe'll focus on the enhancements to DOS apps.First, although Windows 2.x\nostensibly supported VGA resolution, I guess I'd have to say it didn't make\nvery good use of it. I'm not sure why offhand, but Windows 3.0 running at\nnearly the same resolution* seems to have much more \"breathing room.\" _*\nWindows/286 ran at exactly the same resolution as Windows 3.0 here - 640x480.\nWindows/386 runs at 640x450 for some arcane compatibility purpose, but both\nfeel equally cramped.Here, let's launch fdisk:Despite there being no more\npixels on the screen, this feels like I can breathe a little easier while\nusing it. The second image above proves that the text size is exactly the\nsame, and the window border appears to be only two pixels larger on either\nside. Maybe that's enough to make the difference, or maybe it's a subtler\npsychovisual effect, but 3.0 definitely feels lighter to work with, which is\nprobably a big part of why it succeeded.Another thing you might notice is that\nthe colors are better. The FDISK in Windows 2 was all in bright white text,\nwhile under 3.0 it has white and grey. Let's check out QBasic:It's still not\nquite where it should be. The menus are now grey as they should be, so the\nwhite letters show up now, but the text area and bottom status bar are intense\ncolors when they should be dim ones. In fact, all background colors are still\nforced to high-intensity - except bright white, which always appears as grey,\nand dark grey renders as black.Some of these are explained by the\naforementioned palette issues, but white for instance was obviously available\nin the Windows palette, and is an option for foreground text, just not\nbackground color, so I don't get this.Also, notice that the bright blue is now\nfully saturated instead of the awful old CGA Dodger Blue.\n\n## Program Settings\n\nIn general, running apps seems the same:But some interesting changes have\noccurred. Let's take a look at the program settings again:Notice that there\nare now priority \"weights\" which allow you to give a program a very specific\nposition in the CPU scheduling hierarchy - this implies a design that\nanticipates that you might run many concurrent applications, to the point\nwhere you need three digits of precision to specify the order in which they\nshould be given processor time. This speaks to significant ambition on\nMicrosoft's part, which probably proved to be valid.The Tasking Options have\nchanged to checkboxes from radio buttons, which belies a very interesting\nimprovement in functionality. You used to have to select either foreground, or\nbackground, or exclusive, but now you can select a combination, because\nMicrosoft has added some novel new options.First, Exclusive no longer makes an\napp fullscreen. Instead, it simply pauses all other DOS VMs while it has focus\n- in other words, \"exclusivity\" now only applies to how processor time is\nscheduled amongst DOS apps - it does not require taking over the whole system\nand pausing all Windows apps.In addition however, you can now select both\nExclusive and Background at once. This seems contradictory at first, but\nremember that we are talking about very precise tuning features at this point.\nIf Exclusive is selected, that means this app will always pause all other apps\nwhen focused, even ones that have Background enabled. If Exclusive and\nBackground are selected however, this app will continue running when it\ndoesn't have the focus, just without exclusive access to the processor.Now, as\nI said before, the PIF has not gone anywhere, and there's a lot to explore\nthere.\n\n## Program Information Files\n\nThis version of Windows no longer comes with a PIF folder containing presets\nfor certain apps. It does, however, have a small list of known programs in\nSETUP.INF, which I believe is used by a search feature built into the OS which\nscans your hard drive for EXEs and adds them to Program Manager for you. If\nany of those EXEs match a program in SETUP.INF, a PIF is autocreated to give\nit functioning default settings based on Microsoft's testing. This would\nexpand considerably in 95, where I will describe it in more detail.The initial\nview of the new PIF editor looks a lot like the old PIF editor, with some\nminor changes. However, as you can see, there is now an Advanced dialog with a\nton of extra options - again, all for fine tuning behavior.We have the new\npriority settings, a lot more options for assigning XMS and EMS memory,\nkeyboard shortcut adjustment to suit applications with special needs, and then\na whole host of strange things I can't begin to understand, like \"Emulate Text\nMode\" and \"Lock Application Memory.\"There's also an option to allow an app to\nbe closed while active, meaning you don't have to go into it's Settings menu\nand click Terminate. You'll still get a warning if you try to close it, but\nit's nonetheless more convenient, and it suggests more confidence on\nMicrosoft's part that you can force-quit DOS tasks without wrecking the\nsystem.The Windows 3.0 manual - a substantial tome - goes into excruciating\ndetail about all of these settings, but what I find the most interesting is\nactually what you don't see right away.Notice the Mode menu? Selecting that\ngives us two options, 386 Enhanced and Standard. If we select the latter, we\nget this:Suddenly we're back to the old nonsense, like Directly Modifies. What\ngives?Despite the clear improvements that the 80386 offered, and the fact that\nthis chip was now five years old and had even been superseded by the 80486,\nWindows 3.0 still supports operation on 8088 and 286 machines, as well as\nmachines with extremely little RAM (less than a megabyte!) For these systems,\nyou need to run Windows in reduced operating modes.In Real Mode, Windows 3.0\nworks like Windows/286 did - DOS apps have the same constraints, and in fact\neven worse ones. Even using the PIF editor, there is no way to run a program\nin a window in this mode. All DOS apps run fullscreen, and the Alt+Spacebar\nmenu is gone - the only thing you can do is Alt+Tab between programs. I'm not\nsure if copy/paste even works in this mode, since you can't mark a part of the\nscreen to copy anymore.Standard Mode is like Real Mode except it can still use\nexpanded memory, which provides support for the 80286 as well as better memory\nutilization on low-RAM 386s. As far as I can tell the same constraints to\nprogram operation apply in Standard Mode, though I can't test this because it\ncrashes my VM - since the PIF Editor doesn't distingush between Real and\nStandard, and since the 286 doesn't have Virtual 8086 Mode, I have to assume\nthere are no improvements over Windows/286's capabilities here.The other\nreason Real Mode exists is for compatibility with native Windows 1.x/2.x apps\nthat won't run under 386 Enhanced Mode - per the manual, Windows 3.0 will\ndetect this situation and tell you that you need to restart with WIN /R to run\nthem.\n\n## Usability\n\nWhile there are many more tuning options in Windows 3.0, based on my limited\ntesting it seems like Windows/386 had largely solved the problem of being able\nto throw a DOS app at Windows and have it just get right to running it, so,\ndespite this OS release being Microsoft's first great triumph in the GUI\nworld, it seems like the DOS element was a sufficiently solved problem that\nall there was to do from here on was tweak it.  \nWindows 3.1 (1992)  \n---  \nI'm not sure why it is that Windows 3.1 is the go-to when people name a\nWindows OS of this era. It came out two years after 3.0, and does not seem to\ncontain any enormous leaps in functionality that my eyes can see, but it must\nhave been astronomically successful even compared to 3.0. The phrase \"Windows\nthree point one\" seems to just roll off people's tongues, and when referring\nto the series, \"Windows three\" feels somehow incomplete.The changes to DOS\nperformance in Windows 3.1 do not seem enormous. Once again the palette issues\nwith DOS VMs have changed to new ones:The overall QBasic editor finally\nappears more or less correct - the low-intensity colors are now available, so\nthe background is no longer an eye-searing blue.If we check the options\nhowever, we find that dark red and brown both render as a strange maroon-puce\nkind of thing. This again appears to be an issue with the default palette\nselected by Windows - if I mess around in the color control panel I can\ndiscover this maroon-ish color as one of the few solid colors in the brown\nregion. But why not dither these colors? Acceptable brown and red colors could\nbe accomplished that way. I really don't get it.There is also a delightful new\ndesaturated green I cannot begin to explain. I think my optic nerve isn't\nreally sure what to do with it, but it must have been needed for some striking\nicons in order to justify adding it to the stock VGA palette. With all that\nsaid, bright white is now available, so at this point arguably the only colors\nthat are problematic are red and brown, since they both appear as the exact\nsame color.There are few functional changes - minor alterations to the layout\nand options in the PIF editor give access to new EMS/XMS features that the\nvast majority of users would never have understood, for instance:And the font\nof DOS VMs can now be changed:And finally, there's an interesting alteration\nto the message you get when you terminate a DOS app:This new message doesn't\nactually say that the system will become unstable if you do this, it just says\nit's not a great idea and should only be done as a last resort. This suggests\nMicrosoft had become bolder about V-8086 and trusted it more firmly.Other than\nthat however, this is largely identical to Windows 3.0.\n\n## Program Information Files\n\nPart of why I include 3.1 here at all is because a significant expansion to\nthe way Windows handles DOS apps was added in this release.\nC:\\Windows\\System\\Apps.inf contains a big list of programs that Microsoft\ntested in-house and found good default settings for. This concept was coming\ninto existence in 3.0 but had not been expanded into an automatic system yet,\nand 3.1's approach would be extended even further in 95, so I documented it in\nmore detail down there.  \nWindows 95 (1995)  \n---  \nWindows 95 was, of course, Microsoft's Great Shift, the grand alteration of\nthe cosmos, but what impact did it have on the person who primarily used DOS\nsoftware? At this point, what were the majority of computer owners using on a\ndaily basis - Windows 3.x apps, or DOS apps? I don't know, but DOS certainly\nremained a significant element of Microsoft's plan.\n\n## Program Settings\n\nThe process of launching a DOS app is not fundamentally different than Windows\n3.x; you just click on it. Here's fdisk and Ability for comparison:Several\nthings have changed. Windows now have a toolbar where you can select a\ndifferent font size on the fly, which I appreciate quite a bit. You can access\nthe Mark, Copy and Paste options from buttons, instead of making trip after\ntrip to the program menu, also an improvement.Also, while there are plenty of\nprogram settings still accessible from the new Properties button, they've also\nprovided a button for direct access to toggle the Background execution option\n- which, as of this edition of Windows, is finally on by default for the first\ntime. Windows 95 feels confident enough in its DOS multitasking ability that\nall launched apps will execute concurrently, and the option to disable\nbackground execution is presumably only provided in case a program\nmisbehaves.The actual program settings we'll explore later in the PIF section.\nThey're basically identical to the PIF settings we'll see there, although\ncuriously, some of them are meaningless here - you can't adjust the Working\ndirectory, for instance, since that only applies when a program first starts,\nso changes made to that field just go nowhere.\n\n## Video\n\nLet's take a look at QBasic again:The colors have gotten neither worse nor\nbetter since 3.1, and would not - these are the best colors that Windows would\never use for DOS VMs in VGA 16 color mode.A comment I should make here is that\nthe above problem would probably go away if I ran in a color depth above 4bpp\n(16 colors), but I'm deliberately not doing that, because I don't think higher\nresolutions or color depths were part of Microsoft's target platform, nor do I\nnecessarily think many users had those things.I do not know very much about\nthe state of graphics cards in this era. To be frank, I was actually\nastonished to learn a few years ago that Windows 3 could run at resolutions\nabove 640x480 at all. I had simply never thought about it very hard, but when\nI did, I found that I felt like I had never seen a machine running Windows 3\nin a higher resolution than that, and since 3 was so old, it just seemed\nnatural that it wouldn't be able to do any better.In actual fact, graphics\ncards have been available for many years that could run even Windows 1 in\nhigher resolutions and color depths. I can't give you specific dates and\nmodels, but I can say that in 1991 you could certainly buy a 1024x768 monitor\nand a card to drive it at higher color depths.How many people ran Windows 3 or\neven Windows 2 at higher resolutions and color depths I can't say however, and\nI also suspect that even by the time 95 came out, Microsoft did not assume\nthat anyone had anything better than that. Windows 95 will no longer run on an\nEGA card like previous editions, but it is very much at home on VGA - that's\nwhat's listed in the system requirements, all the screen metrics are very\ncomfortable at that resolution, and all the icons are designed to look great\nin 16 colors.It would take another 6 years for Windows XP to begin demanding a\nhigher resolution or color depth, hardware permitting, so I feel pretty\ncomfortable saying that this is how Windows 95 was meant to be used and so I\nhave not installed an SVGA or VESA driver for any of these screenshots. I\ncould have done that in Windows 3 even, and didn't do it there for the same\nreason - I think that what we see in these pictures is how possibly a majority\nof business users experienced Windows, so this is what counts for historical\naccuracy.\n\n## Metrics\n\nOnce again Windows 95 feels like it has more breathing room on the screen,\nlike Microsoft has squeezed even more pixels out of 640x480 somehow - but this\ntime, it's actually because the default font for DOS VM windows has been\nchanged.Under Windows 3 and earlier, the default font was 8x12, but under 95\nthe default is 6x8, so the dimensions and aspect ratio have both changed. The\nabove image shows the newer font below the older, demonstrating just how much\nspace this saves.Oddly, I don't remember this being the default in any version\nof Windows I ever used, but I've tested on 98 and ME and they all use this\nfont by default, so my memory appears to be false. I think this is because my\nuse of DOS on Windows 95 and 98 was primarily for games, which I usually ran\nin fullscreen. By the time I spent significant time in the command prompt\nwithin Windows rather than under real DOS mode, I was running NT - and I've\nfound that NT's equivalent, NTVDM, also runs in 8x12 by default even in the\nfirst release, so I think my memories blurred together.Sometimes these new\nfont sizes have strange effects. For instance, with some apps, Windows picks\nthe extremely tiny, nigh-unreadable 4x6 font, for unknown reasons.\n\n## Program Information Files\n\nWhile the PIF remains, 95 does a lot to isolate the user from them wherever\npossible.\n\n### Automatic PIFs\n\nYou'll notice that QBasic does not show up as simply \"QBASIC\" here, but has an\nicon and full name - a \"friendly name\" as programmers put it.This is part of\nMicrosoft's lengthy and storied backwards compatibility struggle. As part of\nthe runup to Windows 95's release, Microsoft tested an unholy number of\nprograms - basically everything they could get their hands on - and analyzed\nin extreme detail how they worked. Some of that analysis resulted in hardcoded\nchanges to how Windows operated to make specific programs run, but a lot of\napps just needed adjustments to their memory settings and that sort of\nthing.Microsoft could have implemented this by creating PIFs for every program\nthey tested, which is exactly what they had done with Windows/386, but\nstarting in 3.1 they decided to take a more abstract approach. The file\nC:\\Windows\\Inf\\Apps.inf contains presets, icon assignments and names for all\nthe programs they tested.When you launch an app listed in this file, these\nsettings are condensed and compiled into a PIF file. If the program is on a\nfloppy, the PIF goes to C:\\Windows\\Pif, exactly as it worked in previous\neditions of Windows; otherwise it goes in the program directory. There's\nsomething like 460 entries in this file.I'm guessing the reason they didn't\njust ship the premade PIFs in C:\\Windows\\PIF like they did in 2.x is because\nevery PIF takes up a certain minimum amount of disk space, and 460 PIFs would\nhave taken up at least half a megabyte at a time when that was a precious\nresource.\n\n### PIF Settings\n\nNow, creating PIFs yourself is certainly possible. In fact, it's now fully\nautomated - you don't actually have to create one by hand, or even locate a\nspecial PIF editor program as in previous versions - just pull up the\nproperties on a DOS app:The number of settings here has actually decreased -\nWindows 3.1 had a ton of arcane options that seem to have disappeared. The\npriority settings for instance are gone, and all the extremely esoteric stuff\nlike \"Lock Application Memory.\" Presumably Windows had gotten so much better\nat process management that it no longer needed those things.A particularly\ninteresting change is that Allow close when active has changed to Warn if\nstill active. In other words, Windows now considers it universally acceptable\nto exit a running DOS app with the window Close button rather than having to\ndive into the settings and hit Terminate; this is just a normal thing to do\nnow. There is still a warning by default:But the warning has become even\ngentler than 3.1's. Now it just says you'll lose data, and carries a yellow\nwarning rather than a red \"STOP!\" icon.\n\n### PIF Creation\n\nNow, when you make any changes to the program settings, Windows automatically\ncreates or updates a PIF named after the executable in the same directory.\nThis has many implications.This new behavior is an improvement over previous\neditions, where PIFs had no fixed storage location. I'm not sure exactly how\nit worked, but it seems like when you ran any executable in previous versions,\nWindows scanned the program directory, C:\\Windows\\PIF, and who knows where\nelse looking for a matching PIF. I've had PIFs work even if they were just in\nthe Windows directory itself, or the root of the drive, regardless of where\nthe EXE that I launched was.Additionally, while PIFs in previous Windows\neditions could specify an \"initial directory,\" which would tell any launched\ncopy of that program where to find its data files, they didn't point to\nspecific programs. That is to say, a PIF for Dbase.exe under Windows 3.1 would\napply to any program with the name Dbase.exe, anywhere on the system or on\nremovable media, so if it specified an initial directory on the C drive, a\ncopy of the app launched from floppy would start in that folder - an\ninflexible approach.Under Windows 95 however, a PIF applies only to a specific\ncopy of a program, e.g. C:\\dbase\\dbase.exe - in fact, if that program is moved\nor deleted, you have to edit the PIF to point to the new location or it'll\nstop working. This gives flexibility, because you can create PIFs specific to\nparticular copies of an app, but it also creates some fragility, because even\njust renaming a folder will cause the PIFs in that folder to \"break\" since\nthey now point to a folder that doesn't exist.This new direct linkage turns\nthe PIF from an abstract, OS-level \"setting\" into something specific to a\nparticular EXE file, emphasized by the fact that it usually lives with the\nprogram. PIFs were placed in the same folder as the program they were created\nfor, and DOS software sold at this time included PIFs on the install media\nthat were placed in the installed directory.\"Implicit PIF creation,\" if you\nwill, masks the user from a lot of irritating extra steps, but also begins an\nera of growing \"side effects\" in Windows - the OS silently creating files in\nresponse to innocuous user input, with specific information baked into them,\nwithout making it quite clear it has done so, creating potential confusion in\nthe process, as well as potential new compatibility issues.\n\n## Compatibility\n\nWindows 95 famously does a tremendous amount behind the scenes to try to make\napps run, far more than previous versions, and while this is generally\nbeneficial, you as the user do not really know what's being done to \"help\" you\nat any given moment.For instance, while testing Xanaro Ability, I created a\nPIF entirely by accident - I had changed some innocuous setting in the\nproperties and then set them back, but a PIF got created anyway. After that,\nthe app crashed every time I tried to launch it, even when I clicked on the\nEXE file itself - because if a PIF is present in the same folder as an EXE,\nit'll be used even if you didn't click on it.Deleting the PIF made the program\nrun again, but I eventually found that by changing the startup mode in the PIF\nto Windowed instead of Fullscreen it would also fix it - but it still launched\nfullscreen when I did this, and I had to alt+enter to actually window it. I\nhave no idea why this happened, and I'm sure it's not the strangest thing new\nusers might encounter.dBase II, which had run perfectly in each previous\nedition, has finally broken in 95. The app launches okay, but as soon as you\ntry to open a database it reports \"FCB unavailable,\" a critical error.In 2020,\nI'm able to google this and find out that very early editions of DOS (<2.x)\nused something called a File Control Block, which was replaced by file handles\nin later releases. There was a backwards compatibility feature in DOS that the\nuser could enable or disable as needed, and presumably Windows 95 now has this\ncompatibility mode turned on implicitly - unfortunately, dBase only works if\nthe compatibility option is off.Supposedly there are ways to correct this\nproblem but nothing I could find would do it - dBase simply refused to run\nwith any settings I could find, and those suggestions (if one even works)\nwould have been much harder to find in 1995. Dropping to actual DOS fixed\nit.dBase II is from 1983, so it probably wasn't within Microsoft's target\nsoftware demographic by this point, but the fact of the matter is that it\nworked in Windows 2.0 and 3.1 but no longer does, at least without arcane\nwrangling. I suspect this is because Microsoft had by this time built new\nfunctionality into the underlying DOS in order to make things Just Work better\nfor most apps, and not tested it against extremely old software like this,\nfiguring it was pretty reasonable at this point to say \"just get a new\nversion, that program's 12 years old.\"\n\n## Graphics & Games\n\nSupport for graphical DOS apps has increased a tiny bit.This is the menu of\nCrystal Caves, which Windows 3 refused to run at all. Under Windows 95 it\nworks just fine at this stage, although it runs at about 3 FPS. As a footnote,\nI remember running (in later versions of Windows) much more sophisticated\ngames in DOS VMs, and they also worked fine but ran at about 3 FPS. This is\nprobably because Windows has too much going on in full GUI mode to have time\nto waste copying the current state of the video memory to the screen more than\na few times a second.If I try to advance to the game however, it turns to\ngibberish:To reiterate, I have no idea what's going on here. While Windows 3\npunched out after the title, Windows 95 makes it as far as the menu, but when\nthe actual game starts it can't render the graphics. So it gets further but\nstill fails, and I'm not sure why.Again, all of this should be the same video\nmode, EGA 320x200x4bpp, so there must be some subtle detail to the video\nconfiguration that I don't know about. EGA video is pretty basic and linear,\nbut Windows seems to be interpreting this as if it were some funky interlaced\nvideo mode that I don't understand.So the graphics support of the 95 DOS VM is\nclearly improved, but not by enough to support games. There may have been\nproductivity applications that were made usable by this improvement, ones that\nused high res graphics modes but didn't go as far as whatever feature these\ngames depend on.Now, in Windows 3, when you tried to window-ize a graphical\napp running in a mode that Windows couldn't handle, it was supposed to suspend\nthe app and then show you a snapshot of the app in the window. I was never\nable to get that to work - it just threw an error about not having enough RAM.\nBefore we discuss this further though, consider - how would this work? If\nWindows couldn't handle the app running in a window, why would it be able to\nhandle it when suspended?Windows 95's answer to that question is... it can't.\nIt attempts, and fails. If I launch Commander Keen (which Windows 3 refuses to\nrun outright) I get this:It's totally unable to display Keen, even on the\ntitle screen. Windows 3 was right to refuse to try to run this. Windows 95\nattempts but fails. It feels like a weird step backwards, especially because I\nknow there are games that do cause Windows 95 to throw an error about the\nvideo mode not being possible in a window, although I can't find any at the\nmoment.As a footnote, the red color here is fully saturated. If I fullscreen\nthis game, that red color becomes the desaturated red that was typical of the\nold CGA palette. This makes sense because the 95 palette requires fully\nsaturated red, green, yellow and blue in order to create the Windows logo - so\nthe default palette is now totally decoupled from legacy EGA/CGA colors.\n\n## Usability\n\nI could go through dozens of apps here and test what does and doesn't work,\nbut my object was to stick to a few programs and see how they behave from\nversion to version. I also haven't dug deep into whether they work\nconsistently, don't crash during operation, etc. because that's a massive\nproject - and really, the goal here is more to address the initial user\nexperience. If a program worked, but crashed during operation, I don't think\nthat had nearly as much impact on whether the user liked Windows 95 than if it\nfailed to run at all.I might be too personally invested to comment accurately\non the improvements to the DOS user experience under Windows 95, because I\ngrew up with it. It's natural that I would feel more at home with it than\nprevious editions, but I think there are still some objective truths to be\nfound here.Although the addition of the Taskbar had impact on the experience\nof Windows as a whole, I think it made substantial improvements to running DOS\napps.DOS programs take up a big chunk of screen space. At 640x480, even at\nlower font sizes it's hard to fit more than a couple programs on the screen.\nUnder Windows 3 it was easy to lose track of what you actually had running -\nyou could alt+tab, but that required a lot of keystrokes to \"experimentally\"\nfind out what was running if you'd forgotten. You could also use the task\nswitcher dialog from 3.1 onward, but again, you had to stop what you were\ndoing, hit a key combo, and then explore the list.The 95 taskbar shows you\nwhat's running at a glance, including icons if you or Windows chose one. In\nthe chaotic jumble of programs running above, you can tell what's running\nimmediately, and jump to any program - Ability runs in graphical mode so it\nreally needs to be maximized to be useful, so if you pull that up, all your\nother windows will be hidden behind it, but you can retrieve one instantly by\nclicking its taskbar button. Windows 3 could only provide this if you\nminimized every window when you switched to another one.Again, this was\nhelpful for native GUI apps as well, but I think it would have made a huge\ndifference in the ability to rapidly switch between programs that all looked\nkind of same-y.Overall, using DOS apps on Windows 95 is as good as it gets. I\ndon't think Microsoft made any great leaps forward with DOS \"emulation\" after\nthis, until NT's completely rerolled DOS emulator, NTVDM, which is an entirely\nseparate topic that I might tackle in another article.While I stipulated that\nI did all these tests in basic VGA mode, the fact is that by 1995 you could\nbuy a better graphics card at diminishing prices, and the serious user very\nprobably did do that eventually even if they remained a heavy DOS application\nuser. With higher resolution and color depth, you can get programs to run with\nlarger fonts, accurate colors, and plenty of \"breathing room,\" at which point\nI think we can safely say that, with exceptions for the rare high-resolution,\nhigh-color application, DOS on Windows was a solved problem.  \nConclusion  \n---  \nI can't decide whether I think Microsoft took a surprisingly large or\nsurprisingly small number of steps to make it to \"full\" DOS functionality.\nCertain things worked much earlier than I would have guessed - and I think\nit's peculiar that certain things never worked, like 256-color VGA mode.As\nWindows became a more capable games platform, Microsoft leaned in hard to\nvideogame support, but never did improve DOS emulation to a point where you\ncould practically play much of anything in a window. In fact, I seem to recall\nNT did a little better at this at times. You'd think they could have managed\nit under 9x, and that they would have considered it worthwhile, but perhaps\nit's a harder trick than I think.I have no deep insight into how all this\nworks on a technical level - my goal was to document the user experience and\nthe apparent capabilities, especially because there's so little coverage of\nthe details of early Windows editions online. I hope you liked it and maybe\nlearned something interesting.If this was interesting to you, or if you found\nerrors and wish to submit corrections, email me: articles@gekk.infoIf you like\nmy writing, consider tossing me a few bucks. It takes a lot of work and\npayment helps me be motivated.List of Articles\n\n", "frontpage": false}
