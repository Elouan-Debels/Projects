{"aid": "40002278", "title": "Recreating Nanite: Runtime LOD Selection", "url": "https://jglrxavpok.github.io/2024/04/02/recreating-nanite-runtime-lod-selection.html", "domain": "jglrxavpok.github.io", "votes": 2, "user": "ibobev", "posted_at": "2024-04-11 14:04:31", "comments": 0, "source_title": "Recreating Nanite: Runtime LOD selection", "source_text": "Recreating Nanite: Runtime LOD selection | jglrxavpok\u2019s blog\n\n# jglrxavpok's blog\n\n## Random thoughts and progress on my personal projects.\n\n# Recreating Nanite: Runtime LOD selection\n\nCategories:\n\ncarrot\n\ngame-engine\n\nrendering\n\nrecreating-nanite\n\nThis article is part of the \u201cRecreating Nanite\u201d series, you should read the\nprevious articles to fully understand what is going on here!\n\nTable of contents:\n\n  * Theory\n  * Implementation\n\n    * Writing errors to meshlets\n    * Culling at runtime\n  * Results and debug views\n  * Conclusion and special thanks\n\nRelated commits:\n\n  * Runtime selection of LODs v1\n  * Fix error projection not using camera position properly\n  * Fixing cluster bound generation\n\n## Theory\n\nAs explained in the previous articles, I now have a hierarchy of clusters with\nLODs. But now the culmination of these articles is to actually select the LODs\nat runtime: we want to render the best mesh possible for a given size on\nscreen.\n\nHowever, contrary to the rest of the Nanite tech, the presentation pdf is a\nbit vague about the metrics used to switch between LODs. Of course Epic may\nwant to keep some secrets, but anyone who would want to use virtual geometry\nwill need to come up with a metric to select LODs. What I know, is that I want\nto select LODs if they are detailed enough: I want the lowest detailed mesh\nthat still avoids less than 1 pixel error when compared to the original mesh,\nfor its current screen size. The goal is to have a mesh that is perceptually\nthe same as the original mesh when rendered at a given screen size.\n\nHow did I do it then?\n\nWhen simplifying meshes, meshoptimizer outputs a simplification error. This is\na float that represents the error, in terms of mesh extents, of the\nsimplification. I don\u2019t know the algorithm behind it, so I am not 100% sure I\nunderstand the exact meaning of what this represents. I understand this\nsimplification error as how much the shape of the mesh has been modified, as\nin how much smaller/bigger the mesh got in terms of its size. Of course not\nall parts of the mesh may shrink/grow that much so the actual bounding sphere\nmay not change, but some parts may have \u201cshrinked\u201d by at most simplification\nerror percents.\n\nDisplacement error represented between original mesh (circle) and simplified\nmesh (square)\n\nBy multiplying the simplification error by the size of the original mesh, you\ncan get an error in world units that is no longer dependent on the mesh\nbounds.\n\nHowever, because LOD generation is iterative, this simplification error is on-\ntop of the simplification error due to the previous LOD. This mean that the\nsimplification error cannot be used directly: one needs to accumulate error.\n\nHere\u2019s the outline of the algorithm when simplifying a meshlet group:\n\n  1. Simplify the meshlet group, you will get the simplification error as a side output.\n  2. Compute the bounds of the simplified group.\n  3. Multiply the simplification error by the radius of the group. I will call this error meshSpaceError.\n  4. Compute the maximum error of the child meshlets, and add it to meshSpaceError.\n  5. Set the parent error and parent bounds of the meshlets from the previous-LOD group to meshSpaceError and the bounds of the simplified mesh.\n\nNote: meshlets of the same group must have the same error and bounds to make\nthe same LOD decision. If you store per-meshlet bounds, you will get\nartefacts: expect missing meshlets, or overlapping meshlets!\n\n### Why add the maximum error of child meshlets? (Step 4)\n\nIf a parent is not simplified much, its error will be small, therefore its\nerror may be less than its children\u2019s errors, so the resulting error for the\nparent will be equal to the children\u2019s errors. And clusters with parentError\n== selfError will never be rendered (explanation further down). Additionally,\nerror must increase when increasing LOD: LODs with fewer details have more\nsimplification errors, because they are simplified more.\n\nFurthermore, simplification is done iteratively, so the error of the parent is\nrelative to the children. The error stored inside the meshlets must be\nsomewhat \u201cglobal\u201d, ie the error of a parent must no longer depend from the\nchild.\n\nTo solve this issue, I personally add the child errors to the parent\u2019s error\nto make it increase. Not sure if that\u2019s the correct way to do it, but works\nfine for me. This addition matches all that is required for the LOD system to\nwork:\n\n  * Monotonically increasing error values\n  * Error values that are independent from other meshlets, which allows parallel selection of LODs!\n\n## Implementation\n\nLet\u2019s start by adding the necessary data to Meshlet:\n\n    \n    \n    struct Meshlet { std::uint32_t vertexOffset = 0; std::uint32_t vertexCount = 0; std::uint32_t indexOffset = 0; std::uint32_t indexCount = 0; std::uint32_t lod = 0; + Math::Sphere boundingSphere; + Math::Sphere parentBoundingSphere; + + // Meshlets form a graph where the root is the most simplified version of the entire model, and each node's children + // are the meshlets which were simplified to create that node. + // Everything is expressed in mesh space here + float parentError = std::numeric_limits<float>::infinity(); // set to infinity if there is no parent (ie the node has no further simplification) + float clusterError = 0.0f; };\n\nFor each meshlet, I store the group bounding sphere, the parent bounding\nsphere, as well as the error values for the group and the parent. These values\nwill be shared by all meshlets of a same group. It is possible to reduce the\nmemory footprint by adding an indirection and storing these values per group\ninstead of per meshlet, but I decided to keep it simple for now.\n\nThe changes in Meshlet have to be replicated inside Cluster:\n\n    \n    \n    struct Cluster { vk::DeviceAddress vertexBufferAddress = (vk::DeviceAddress)-1; vk::DeviceAddress indexBufferAddress = (vk::DeviceAddress)-1; std::uint8_t triangleCount; std::uint32_t lod; glm::mat4 transform{ 1.0f }; + Math::Sphere boundingSphere{0.0f}; // xyz + radius (vec4) + Math::Sphere parentBoundingSphere{0.0f}; // xyz + radius (vec4) + float error = 0.0f; + float parentError = std::numeric_limits<float>::infinity(); };\n\nThis will make it available for shaders. The values are simply copied from\nmeshlets when generating the clusters:\n\n    \n    \n    for(std::size_t i = 0; i < desc.meshlets.size(); i++) { auto& cluster = gpuClusters[i + firstClusterIndex]; cluster.vertexBufferAddress = vertexData.view.getDeviceAddress() + vertexOffset; cluster.indexBufferAddress = indexData.view.getDeviceAddress() + indexOffset; const auto& meshlet = desc.meshlets[i]; + cluster.boundingSphere = meshlet.boundingSphere; + cluster.parentBoundingSphere = meshlet.parentBoundingSphere; + cluster.parentError = meshlet.parentError; + cluster.error = meshlet.clusterError; vertexOffset += sizeof(Carrot::Vertex) * meshlet.vertexCount; indexOffset += sizeof(std::uint32_t) * meshlet.indexCount; }\n\n### Writing errors to meshlets\n\nLOD 0 clusters have no error and infinite parent error: you cannot get a more\ndetailed model than the original one by simplification.\n\n    \n    \n    - appendMeshlets(primitive, indexBuffer); + { + Carrot::Vector<unsigned int> lod0Indices; + lod0Indices.resize(indexBuffer.size()); + meshopt_Bounds lod0Bounds = meshopt_computeClusterBounds( + lod0Indices.data(), lod0Indices.size(), + &primitive.vertices[0].pos.x, primitive.vertices.size(), sizeof(Carrot::Vertex)); + appendMeshlets(primitive, indexBuffer, + lod0Bounds, // boundingSphere + 0.0f // cluster error + ); + }\n\nThen after simplifying a group of meshlets:\n\n    \n    \n    // previousLevelMeshlets are meshlets from the LOD before the one being generated // group.meshlets is the list of meshlets of the current group // simplifiedIndexBuffer is the index buffer for the simplified mesh // see previous articles on LOD generation for more information // 1. compute group bounds from group mesh data glm::vec3 min { +INFINITY, +INFINITY, +INFINITY }; glm::vec3 max { -INFINITY, -INFINITY, -INFINITY }; // remap simplified index buffer to mesh-wide vertex indices for(auto& index : simplifiedIndexBuffer) { index = group2meshVertexRemap[index]; const glm::vec3 vertexPos = glm::vec3 { primitive.vertices[index].pos.xyz }; min = glm::min(min, vertexPos); max = glm::max(max, vertexPos); } Carrot::Math::Sphere simplifiedClusterBounds; simplifiedClusterBounds.loadFromAABB(min, max); // 2. compute group scale from group mesh data float localScale = meshopt_simplifyScale(&groupVertexBuffer[0].pos.x, groupVertexBuffer.size(), sizeof(Carrot::Vertex));\n\nmeshoptimizer\u2019s simplification routines return an error which is relative to\nthe object, so we need to multiply by the object size to have a value in world\nunits. This is necessary to have error values which are independent from one\nmeshlet to the next.\n\n    \n    \n    // 3. multiply simplification error by size of group // that way, simplification error is in world units instead of being relative to the mesh float meshSpaceError = simplificationError * localScale; float childrenError = 0.0f; // 4. find max of child error (see Theory part of article for explanation) for(const auto& meshletIndex : group.meshlets) { const auto& previousMeshlet = previousLevelMeshlets[meshletIndex]; // ensure parent(this) error >= child(members of group) error childrenError = std::max(childrenError, previousMeshlet.clusterError); } // 5. set parent errors of meshlets used to generate this LOD meshSpaceError += childrenError; for(const auto& meshletIndex : group.meshlets) { previousLevelMeshlets[meshletIndex].parentError = meshSpaceError; previousLevelMeshlets[meshletIndex].parentBoundingSphere = simplifiedClusterBounds; } // ... appendMeshlets(primitive, simplifiedIndexBuffer, simplifiedClusterBounds, // use same group bounds for all meshlets meshSpaceError // use same error for all meshlets );\n\nAfter this, meshlets contain all the data necessary for culling!\n\n### Culling at runtime\n\nNanite has a fancy system to iterate over the entire graph of clusters. I\ndecided to keep things simple for now: a flat list of all loaded clusters, and\nI will iterate over them all each frame. Is it performant? Probably not. Is it\neasy to understand? Absolutely!\n\nHere\u2019s what the render loop looks like before adding automatic LOD selection\n(details are not important):\n\n    \n    \n    // setting up state, see previous articles // ... for(const auto& [index, pInstance] : models) { // for each model rendered via virtual geometry if(const auto instance = pInstance.lock()) { if(!instance->enabled) { continue; } if(instance->pViewport != renderContext.pViewport) { continue; } packet.clearPerDrawData(); packet.unindexedDrawCommands.clear(); packet.useInstance(instance->instanceData); std::uint32_t instanceIndex = 0; for(const auto& pTemplate : instance->templates) { std::size_t clusterOffset = 0; for(const auto& cluster : pTemplate->clusters) { // ========================= // Test whether we should render a given cluster. This is what I will focus on: // ========================= if(testLOD(cluster, *instance)) { auto& drawCommand = packet.unindexedDrawCommands.emplace_back(); drawCommand.instanceCount = 1; drawCommand.firstInstance = 0; drawCommand.firstVertex = 0; drawCommand.vertexCount = std::uint32_t(cluster.triangleCount)*3; triangleCount += cluster.triangleCount; GBufferDrawData drawData; drawData.materialIndex = 0; drawData.uuid0 = instance->firstInstance + instanceIndex; packet.addPerDrawData(std::span{ &drawData, 1 }); } instanceIndex++; clusterOffset++; } } verify(instanceIndex == instance->instanceCount, \"instanceIndex == instance->instanceCount\"); if(packet.unindexedDrawCommands.size() > 0) renderer.render(packet); } }\n\nThe part that really interest me for this article is the testLOD lamba used to\nknow whether I want to render a cluster. At this point, it is simply a check\nof Cluster::lod against a static int to show only clusters with the wanted\nLOD.\n\nLet\u2019s add automatic LOD selection!\n\nThe idea is:\n\n  1. Transform a sphere S1 with its center at the center of the cluster boundingSphere, and radius error, into view space.\n  2. Compute the radius in pixels of sphere S1 when rendered on screen, which will be named clusterError.\n  3. Do the same for S2 with center parentBoundingSphere and radius parentError, store the result in parentError.\n  4. Finally, one can decide whether the cluster should be rendered: the cluster is rendered if clusterError <= errorThreshold && parentError > errorThreshold.\n\nWhat is errorThreshold? This represents the maximum tolerated error, in\npixels, of a cluster. I set it to 1 by default, to allow a maximum of 1 pixel\ndifference between the original mesh and the selected LOD, at the current\nscreen size.\n\nCode time!\n\n    \n    \n    auto testLOD = [&](const Cluster& c, const ClusterModel& instance) { if(lodSelectionMode == 0) { return c.lod == globalLOD; } else { // assume a fixed fov and perspective projection const float testFOV = glm::half_pi<float>(); const float cotHalfFov = 1.0f / glm::tan(testFOV / 2.0f); const float testScreenHeight = renderContext.pViewport->getHeight(); // https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space auto projectErrorToScreen = [&](const Math::Sphere& sphere) { if(!std::isfinite(sphere.radius)) { return sphere.radius; } const float d2 = glm::dot(sphere.center, sphere.center); const float r = sphere.radius; return testScreenHeight / 2.0f * cotHalfFov * r / glm::sqrt(d2 - r*r); }; // 1. Math::Sphere projectedBounds { c.boundingSphere.xyz, std::max(c.error, 10e-10f) }; const glm::mat4 completeProj = camera.getCurrentFrameViewMatrix() * instance.instanceData.transform * c.transform; projectedBounds.transform(completeProj); // 2. const float clusterError = projectErrorToScreen(projectedBounds); // 3. Math::Sphere parentProjectedBounds { c.parentBoundingSphere.xyz, std::max(c.parentError, 10e-10f) }; parentProjectedBounds.transform(completeProj); const float parentError = projectErrorToScreen(parentProjectedBounds); // 4. return clusterError <= errorThreshold && parentError > errorThreshold; } };\n\n## Results and debug views\n\nHere\u2019s the result of all this work:\n\nZoom into DamagedHelmet and not a standford bunny, which shows the amount of\ntriangle increasing when the camera gets near the models\n\nIf you want to go into recreating Nanite yourself too, you will want to have a\nfew debug views!\n\nI personally have:\n\n  1. Triangle (different color per triangle)\n  2. Cluster (different color per cluster)\n  3. LOD (LOD index used to render a given pixel)\n  4. Projected screen error (result of clusterError computed inside testLOD) (error exaggerated by a factor of 10 for this screenshot)\n\nDebug views with numbers are done with this shader: Smaller Numbers by\nP_Malin.\n\nHere\u2019s a similar zoom in than the previous GIF with the LOD view:\n\nZoom into DamagedHelmet and not a standford bunny, which shows the index of\nthe LOD used to render parts of the model\n\n## Conclusion and special thanks\n\nFinally, I have filled the main objective of a Nanite-like system: automatic\nLODs ! Of course, there are lots of features I want to add to the system, but\nthis looks like a big milestone. For example, the LOD selection is done on the\nCPU, and it is done sequentially. This is not performant at all, so in the\nnext article, I will explain how I replaced this CPU implementation with a\nmesh shader based LOD system!\n\nSpecial thanks to JMS55 and LVSTRI from the Graphics Programming Discord,\nwhich through discussions, helped me find a somewhat clear way to explain the\nruntime selection.\n\nThe bunny model I used in this article is: not a standford bunny model by\nJocelyn Da Prato.\n\n> Go back to post list. <\n\nProjects by jglrxavpok can be found on GitHub. Additional CSS by anonymous\nfriend.\n\nGenerated with GitHub Pages using Merlot\n\n", "frontpage": false}
