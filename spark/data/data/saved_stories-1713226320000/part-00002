{"aid": "40043831", "title": "Upgrading my Chumby 8 kernel part 8: audio", "url": "https://www.downtowndougbrown.com/2024/04/upgrading-my-chumby-8-kernel-part-8-audio/", "domain": "downtowndougbrown.com", "votes": 1, "user": "jandeboevrie", "posted_at": "2024-04-15 18:11:16", "comments": 0, "source_title": "Downtown Doug Brown \u00bb Upgrading my Chumby 8 kernel part 8: audio", "source_text": "Downtown Doug Brown \u00bb Upgrading my Chumby 8 kernel part 8: audio\n\n# Downtown Doug Brown\n\n## Thoughts from a combined Apple/Linux/Windows geek.\n\n  * Home\n  * About\n  * Mac ROM SIMMs\n  * Software\n  * Microcontroller lessons\n  * Contact\n\nApr\n\n14\n\n## Upgrading my Chumby 8 kernel part 8: audio\n\nDoug Brown Linux 2024-04-14\n\nAfter getting many of the PXA16x peripherals working in modern Linux kernels\nduring my Chumby 8 kernel upgrade saga (here are links to parts 1, 2, 3, 4, 5,\n6, and 7), I really felt like I was starting to reach the finish line. The\ndisplay was working well enough to play low-resolution videos, I had basic 2D\nacceleration up and running, the touchscreen was operational, and Wi-Fi worked\nflawlessly. Audio was the only major component left to tackle. The Chumby 8\nhas built-in speakers, a headphone jack, and a microphone.\n\nThe Linux sound subsystem is something I had exactly zero experience with\nprior to this project, so it felt very intimidating. It took me a while to get\nfamiliar with it. The relevant project is Advanced Linux Sound Architecture\n(ALSA) and in particular, the ALSA System on Chip (ASoC) layer is where most\nof my work would be for this project.\n\nBefore digging in too deep, I needed to look at the Chumby 8 schematics and\nfigure out what I would be dealing with. With no prior audio experience to\nlean on, I wasn\u2019t sure what to expect. Let\u2019s take a look at the relevant\nsection of the schematic:\n\nOkay, so it\u2019s using a Wolfson WM8961 audio codec. This chip was discontinued\nin 2013. I\u2019m going to be honest \u2014 this \u201ccodec\u201d terminology confused me at\nfirst. I thought an audio codec was more like a data format, such as MP3, AAC,\nVorbis, etc. It turns out it\u2019s one of those situations where hardware and\nsoftware people use the same word with different meanings. My understanding\nwas correct for the software side, but on the hardware side, the word codec is\nused to refer to an ADC/DAC for converting between analog and digital signals.\n\nThe way the WM8961 works is you write a bunch of register values over I^2C\n(the SCLK and SDIN pins) to set it up, and then send/receive audio data\nto/from it using I^2S. Despite the names being similar, I^2S is not related to\nI^2C. After playing with it a bit, I actually think it\u2019s pretty similar to\nSPI. There are a bit clock and data in and out pins just like SPI. The main\ndifference is SPI has a chip select signal to specify when the chip should be\npaying attention, whereas I^2S has an LRCLK signal that indicates which\nchannel (left or right) the data corresponds with.\n\nAs you can see above there are SPK_LP/LN and SPK_RP/RN outputs for the\nspeakers. These end up going to a connector on the PCB where the speakers plug\nin. There\u2019s additionally a bunch of filtering circuitry that I definitely\ndon\u2019t have enough experience to understand. The microphone is also hooked up\nto this chip (LINPUT). There is also an unused right input channel.\n\nThe headphone output is also provided by the WM8961 (HP_L and HP_R). The\nheadphone jack has a detection signal which is used to activate a transistor\nto control a signal (HP_IN) which will let me know when headphones are plugged\nin. HP_IN goes straight to one of the PXA166\u2019s GPIO pins.\n\nHere is where the I^2C bus goes. The schematic calls it PWR_SCL/SDA, but it\u2019s\nalso known as twsi2 in Linux\u2019s pxa168.dtsi file.\n\nAs for the I^2S signals, they go into the PXA166\u2019s SSP1 peripheral:\n\nThere is also an extra I2S_CDCLK0 signal that goes to the MCLK input of the\nWM8961. This is known as the \u201cmaster clock\u201d and is a separate clock that is\nneeded by the codec chip. Typically, based on my understanding, it\u2019s supposed\nto be a multiple of the sample rate you\u2019re working with. I opted to make it\n256 times the sample rate (256Fs). So for example, if I\u2019m playing a 44.1 kHz\nsound, MCLK will be 11.2896 MHz. It was fairly difficult for me to glean this\nrequirement based on reading the datasheets, but after looking at random\ndiscussions online and other sample code it became clearer.\n\nAll right, so that gave me enough information to get started. I needed to\nconfigure the codec chip over I^2C on TWSI2, set up I^2S audio on SSP1, output\nMCLK on AC97_SYSCLK, and detect headphone insertion on GPIO_97. How in the\nworld would I get started?\n\nBy looking at the old Chumby 2.6.28 kernel, of course. I looked at Chumby\u2019s\ninitialization scripts and got an idea of what the dependencies would be for\nplaying a sound. Being able to play a sound in 2.6.28 would be a good first\nstep, and it would give me a reference to compare against if I ran into any\nissues with the newer kernel. I already had a minimal rootfs set up from when\nI was getting Wi-Fi working, so I just had to copy some more binaries,\nlibraries, config files, etc. out of the original Chumby rootfs into my\nminimal rootfs for 2.6.28. One thing that was helpful was to use strace to see\nwhat was happening when I tried to run commands like amixer and aplay.\nEventually after I got enough of the underlying libraries and config files\nfigured out, I came up with this somewhat hacky sequence of commands I could\nrun to play a sound in the old Chumby kernel:\n\n    \n    \n    modprobe i2c-pxa modprobe snd-soc-wm8961 modprobe snd-soc-silvermoon mdev -s mkdir /dev/snd cp -R /dev/controlC0 /dev/pcmC0D0* /dev/timer /dev/snd/ amixer set Speaker 127 aplay /smw_game_over.wav\n\nThis played the Super Mario World game over sound for me (here\u2019s where I got\nit). Yay, I had a simple working test setup in the old kernel. Next up, I\nlooked at how everything was hooked up in that older version. Most of the fun\nwas in the snd/soc/pxa directory \u2014 in particular, I saw that snd-soc-pxa3xx,\nsnd-soc-pxa3xx-ssp, and snd-soc-silvermoon were modules being built.\nsilvermoon_wm8961.c seemed to contain the glue to hook everything together.\nsnd/soc/codecs/wm8961.c had some Chumby-specific hacks. I also discovered,\nunsurprisingly, that the PXA3xx sound driver mostly just seemed like a bunch\nof DMA (direct memory access) setup stuff. This makes a lot of sense. Once you\nhave everything up and running, you\u2019re mainly just continually using DMA to\nkeep the data flowing to the codec.\n\nI tried to find modern equivalents to these drivers in the mainline kernel.\nThe WM8961 driver still existed, but didn\u2019t support device tree. The\nsound/soc/pxa directory was also still there, but there was nothing specific\nto the PXA3xx. Instead, I saw some PXA2xx drivers. It still seemed like these\nwould be helpful. I also found some older, unmerged patches adding PXA168\nsupport from 2010. I figured I could look at these and try to fit them in with\nthe newer kernel.\n\nHere\u2019s an overview of what I needed to accomplish:\n\n  * Enable I^2C support for the PXA168\n  * Enable DMA support for the PXA168\n  * Port the old unmerged PXA168 patches to a modern kernel\n  * Update the WM8961 driver to work with device tree and hook it up\n  * Figure out how to reference the PXA audio drivers from device tree\n  * Figure out how to create an audio card (hopefully, simple-audio-card) to connect the SoC and codec together.\n  * Enable ALSA tools in buildroot\n  * Get the Super Mario World game over sound playing over the speakers\n  * Figure out how to play sound through the headphone jack\n  * Detect when headphones are plugged in\n\nYikes, that\u2019s actually a lot of stuff to do. Some of it is simple, but I can\nsee why nobody (to my knowledge) has ever bothered getting the Chumby\u2019s audio\nworking on modern kernels. When I\u2019m overwhelmed with a zillion prerequisites\nlike this, I like to break it up into baby steps and focus on one thing at a\ntime.\n\nLet\u2019s start with I^2C support. That should be fairly straightforward. It turns\nout that the mainline kernel\u2019s device tree include file for the PXA16x already\nhas the TWSI devices enabled! TWSI is the name used by Marvell for what is\nessentially their I^2C controller IP. This was pretty easy to turn on in my\nkernel config. I just needed to enable CONFIG_I2C_PXA and turn on twsi1 and\ntwsi2 in the device tree. As part of this I also hooked up the onboard AT24C08\n\u201cpersonality EEPROM\u201d to twsi1. This would provide an easy way to verify that\nI^2C was working. It turns out twsi2 wasn\u2019t enabled automatically at startup,\nso I hacked in a fix to U-Boot to ensure they were both enabled. I think the\nLinux clocking should have been able to handle that, but I was more focused on\njust getting it working.\n\nThis all went really well. After doing that, I saw kernel messages at startup\nabout the newly-enabled controllers and the EEPROM:\n\n    \n    \n    i2c i2c-0: PXA I2C adapter i2c i2c-1: PXA I2C adapter at24 0-0050: supply vcc not found, using dummy regulator at24 0-0050: 1024 byte 24c08 EEPROM, writable, 1 bytes/write\n\nI was able to dump the EEPROM with a simple command:\n\n    \n    \n    cat /sys/class/i2c-dev/i2c-0/device/0-0050/eeprom > /tmp/eeprom-backup.bin\n\nThis dump file contained strings like \u201csexi\u201d, \u201cchum\u201d, \u201cvers\u201d, etc. so I was\npretty confident that I had succeeded. I^2C was officially working! I love it\nwhen everything in the kernel just works the way it\u2019s supposed to.\n\nLet\u2019s move onto DMA. DMA is important because if you\u2019re sending a bunch of\naudio data over I^2S, you don\u2019t want the CPU to be in charge of manually\nsending all of that audio data. That would be crazy. You want to allow the DMA\ncontroller to do it in the background in order to free up the CPU to do other\nmore important stuff. Also, it was pretty clear from looking at the existing\naudio code that DMA would be a dependency of the audio support.\n\nDMA is another thing that already had a driver in the kernel. I just had to\nfind it, and then hook it up in the device tree, which also entailed\nspecifying the DMA channels for the various peripherals. I filled them out for\nthe SSP devices. I also had to enable the driver in the kernel config.\n\nAmazingly enough, this all just seemed to magically work:\n\n    \n    \n    pxa-dma d4000000.dma-controller: initialized 32 channels on 100 requestors\n\nThe kernel was spitting out a bunch of errors at startup though:\n\n    \n    \n    pxa-dma d4000000.dma-controller: error -ENXIO: IRQ index 1 not found pxa-dma d4000000.dma-controller: error -ENXIO: IRQ index 2 not found pxa-dma d4000000.dma-controller: error -ENXIO: IRQ index 3 not found ... pxa-dma d4000000.dma-controller: error -ENXIO: IRQ index 31 not found\n\nI later ended up discovering that these errors were actually harmless and I\nsubmitted a patch to the upstream kernel to fix it. The extra IRQs are\noptional \u2014 only IRQ 0 is used on the PXA168. Thus, the driver needed to be\nusing platform_get_irq_optional() instead of platform_get_irq(). This fix\nlanded in kernel 6.1 and was backported to a bunch of older kernels.\n\nBy the way, if you look closely at my submitted patch for the DMA bug, I\nscrewed up the \u201cFixes\u201d tag and forgot to add a closing \u201c)\u201d to the end of the\nline. I think the existing parentheses near the end of the line confused my\nbrain. Luckily it was caught before it made its way to Linus for Linux\n6.1-rc5.\n\nI thought I would need to actually make some progress on the audio in order to\ntest the DMA, but I figured out that DMA was already working at this point.\nThat\u2019s because I hooked up the correct DMA channels to the SSP controllers,\nand as you may recall from the last post, the touchscreen uses SPI. It turns\nout that using DMA with the touchscreen actually bogged it way down. The\ntouchscreen still worked, but it had become much less responsive after I\nturned on DMA.\n\nThis puzzled me for a brief moment, and then a light bulb went off in my head.\nMy touchscreen driver does very, very small SSP transactions (16 bits) one at\na time in a thread. For small individual transactions like this, going through\nthe whole process of setting up DMA ended up being much slower than just\nletting the CPU do it. I worked around this by increasing the minimum DMA\nburst size in the SSP driver. It had been set up to use DMA even on 1-byte\ntransactions. I pulled a number out of thin air and decided to tell it to only\nuse DMA on transactions that are at least 8 bytes. That completely fixed the\ntouchscreen. I was still glad this happened because it helped me verify that\nDMA was working.\n\nNext up, I knew that the WM8961 audio codec would be needed in order to get\nthis setup working. All I needed to do was add support for device tree to the\ndriver. I decided to send this change straight to the mainline kernel, just in\ncase someone might try to remove the driver due to it not being used anywhere.\nThe actual code was pretty straightforward \u2014 the hardest part was actually\ngetting the device tree documentation correct. It took me two tries to get it\nmerged because I made a few mistakes in my first attempt (V1, V2). Sometimes\nthe code review process can be a bit intimidating, but at the end of the day\nit\u2019s all about ensuring good quality of code and shouldn\u2019t be taken\npersonally. I\u2019m glad this wasn\u2019t my first submitted patch or I might have been\nscared away!\n\nThat took care of most of the low-hanging fruit. With DMA and I^2C working,\nand the codec available to add to the device tree, I had most of the\nprerequisites out of the way so that I could start tinkering with actual audio\nstuff. This is where it started to get more difficult to split the work up\nbecause there were interdependencies between the different components, so\nthings got a little hectic. I\u2019m still in a little bit of disbelief that I\nfigured this all out, so it might be difficult to logically explain it all.\nI\u2019ll try to step through it as best as I can.\n\nI did a bunch of research and noticed that there had been some prior patches\nto add support for the PXA168 to ASoC. In particular, this one was pretty\ninteresting because it had a table with a bunch of hardcoded register setups\nfor various bit rates. I was pretty sure I\u2019d need something similar in order\nto configure the PXA168 to have correct MCLK and bit clock frequencies.\n\nI basically started tossing things together to try to get it working. I\nensured the ASoC pxa-ssp driver was allowed to be enabled with this\narchitecture, and then added a port of the custom PXA168 logic in a couple of\ncommits (1, 2). Then I tried to mix it all into a simple-audio-card in the\ndevice tree. I didn\u2019t really know what I was doing here, but I used other\nboards as examples to try to walk myself through it. The math being used in\nthe MCLK/BCLK tables in the original patch supplied by the Marvell employee\nconfused me, so I went with my own calculation based on an MCLK of 256Fs as\ndiscussed earlier. With 16 bits per sample and 2 channels, this meant I would\nneed to divide MCLK by 256/16/2 = 8 to end up with the correct bit clock.\n\nI knew I would need to configure SSP1 to use this new configurable clock as\nopposed to one of the hardwired constant clocks it can use, so I took care of\nthat as well. I opted to reconfigure the clock source in U-Boot out of\nsimplicity. I\u2019m thinking that the common clock framework would have been a\nbetter place for all of this clocking setup. At this point I just wanted to\nget it working!\n\nWith everything sort of hooked up, I gave it a shot. I tried to play my sound\nwith aplay:\n\n    \n    \n    aplay /smw_game_over.wav\n\nAs expected, it didn\u2019t work right out of the gates.\n\n    \n    \n    wm8961 1-004a: MCLK has not been specified wm8961 1-004a: ASoC: error at snd_soc_dai_hw_params on wm8961-hifi: -22 ssp-dai0-wm8961-hifi: ASoC: __soc_pcm_hw_params() failed (-22)\n\nI believe I had the clocking hooked up wrong, and just hacked something\ntogether by adding:\n\n    \n    \n    system-clock-frequency = <11289600>;\n\n...to the codec section of the simple-audio-card, but that was just a\ntemporary stopgap solution. That number is exactly 256 times 44,100 (44.1\nkHz). I didn\u2019t take the best notes about what I did here because I was trying\nall kinds of things, but I eventually didn\u2019t need that line anymore. I believe\nthis ended up being the better solution so that it worked properly with\ndifferent bit rates:\n\n    \n    \n    mclk-fs = <256>;\n\nThis got me a bit further. Next I was getting a null pointer dereference:\n\n    \n    \n    Unable to handle kernel NULL pointer dereference at virtual address 00000000 [00000000] *pgd=00000000 Internal error: Oops: 5 [#1] PREEMPT ARM Modules linked in: libertas_sdio libertas sha256_generic libsha256 cfg80211 snd_soc_pxa_ssp snd_soc_simple_card rfkill snd_pxa2xx_lib snd_soc_wm8961 snd_soc_simple_card_utils snd_pcm_dmaengine snd_soc_core snd_pcm chumby8_ts snd_timer snd soundcore spi_pxa2xx_platform ssp CPU: 0 PID: 193 Comm: aplay Not tainted 5.18.9 #3 Hardware name: Marvell PXA168 (Device Tree Support) PC is at snd_dmaengine_pcm_get_chan+0x14/0x1c [snd_pcm_dmaengine] LR is at pxa2xx_pcm_hw_params+0x2c/0xec [snd_pxa2xx_lib] ... Backtrace: snd_dmaengine_pcm_get_chan [snd_pcm_dmaengine] from pxa2xx_pcm_hw_params+0x2c/0xec [snd_pxa2xx_lib] pxa2xx_pcm_hw_params [snd_pxa2xx_lib] from pxa2xx_soc_pcm_hw_params+0x18/0x1c [snd_pxa2xx_lib] pxa2xx_soc_pcm_hw_params [snd_pxa2xx_lib] from snd_soc_pcm_component_hw_params+0x48/0xb8 [snd_soc_core] snd_soc_pcm_component_hw_params [snd_soc_core] from __soc_pcm_hw_params+0x504/0x6a8 [snd_soc_core] __soc_pcm_hw_params [snd_soc_core] from soc_pcm_hw_params+0x38/0x50 [snd_soc_core] soc_pcm_hw_params [snd_soc_core] from snd_pcm_hw_params+0x158/0x420 [snd_pcm] snd_pcm_hw_params [snd_pcm] from snd_pcm_ioctl+0x280/0x19ac [snd_pcm] snd_pcm_ioctl [snd_pcm] from sys_ioctl+0x538/0xcd4 sys_ioctl from ret_fast_syscall+0x0/0x1c\n\nInspecting the code further, I tracked the problem down to being caused by\npxa2xx_pcm_open() returning early because snd_soc_dai_get_dma_data() was\nreturning null. Comparing the pxa-ssp driver to other similar drivers, it\nseemed different. A lot of other drivers set up the DMA in their probe\nfunctions, but the pxa-ssp driver was doing it in the startup/shutdown\nfunctions. I simply changed the pxa-ssp driver to be more like the others and\nset up the DMA in the probe function. Was this the correct solution? I don\u2019t\nknow \u2014 but the fact that other drivers did it this way made me feel like I was\ngoing in the right direction. It definitely fixed the issue.\n\nWith this in place, I actually got something to play some sound \u2014 sort of. It\nnever worked the very first time I would try to play a sound. I had to remove\nand reinsert the kernel module in order to get it to work. Also, the pitch was\nwrong, and it sounded kind of scratchy, but hey, it was playing a sound!\n\nI was totally stoked! I got sound working! It wasn\u2019t perfect, but at this\npoint I felt confident I would be able to figure it out. I tackled the various\nproblems one by one. It turns out that I had to add special code in the PXA168\nSSP setup to manually turn on MCLK immediately, because by default the WM8961\ncan\u2019t be configured unless it\u2019s actively receiving MCLK. This solved the issue\nof sound only working after the second time the kernel module was loaded.\n\nAs for the incorrect pitch, the SSP controller was being set up with an\ninitial \u201cdummy\u201d bit, so it was sending out 17 bits per sample instead of 16.\nThis caused the sound to play slower. There are different data formats\nsupported by the WM8961 including I^2S mode, left-justified, and right-\njustified. I^2S mode is weird in that it expects LRCLK to change 1 cycle\nbefore the actual data for the new channel should be transmitted. I believe\nthis was the reason for the dummy bit. However, adding it caused a total of 17\nbits to be sent per sample instead of 16. I\u2019m still not sure if this is a\nmistake in the Linux driver for all PXAxxx chips, or if the PXA168\u2019s\ncontroller behaves slightly differently from the others. It\u2019s hard to know for\nsure without other PXA2xx/3xx hardware to test with.\n\nEither way, the solution was easy: switch to left-justified mode instead.\nLeft-justified mode is very similar to I^2S mode, except the new data starts\nat the exact same time as the LRCLK transition, and the LRCLK polarity is\ninverted. What I mean by inverted is that in left-justified mode, a high LRCLK\nmeans it\u2019s left channel data, whereas in I^2S mode, a high LRCLK means it\u2019s\nright channel data.\n\nSince the modes are very similar, it was easy enough to simply add left-\njustified support to the PXA audio driver. I do feel like my change was a\nlittle messy for this though.\n\nWith left-justified mode implemented, I actually got perfect audio playback!\nThe scratchiness and incorrect pitch were gone.\n\nAs you can see, sometime during this process I also changed to the actual\nChumby logo. The colorful screen in the first video was useful for making sure\nI had the colors mapped correctly in the LCD controller.\n\nI probably could have called it good enough at this point, but it was around\nnow that I remembered the Chumby 8 also has a microphone. I couldn\u2019t resist\ntrying to get the microphone working. At face value it didn\u2019t seem too scary,\nespecially since a Chumby developer had provided some sample commands used for\ntheir factory microphone testing. Of course, this led me down another crazy\nrabbit hole.\n\nIt started out simple. I hooked up the microphone and MICBIAS in device tree,\nwhich did take a bit of research and looking at other example boards, but it\nwasn\u2019t too bad. Then I tried recording but it didn\u2019t work at all. I eventually\ndiscovered that the mic did work, but I had to record in stereo, and the\nmicrophone data was showing up in the right channel instead of the left\nchannel. This led me to realize that I actually had LRCLK inverted from what\nit was supposed to be. That was important because the mic is mono and only\nhooked to the left channel in the Chumby. I hadn\u2019t noticed when I switched to\nleft-justified mode that LRCLK needed to be backwards from how it was set up\nin I^2S mode. That was pretty simple to fix.\n\nThat was only the beginning of this saga though. After I did that, I noticed\nthat when I was playing audio, the data for the two audio channels was being\nsent out of order. I was sending left sounds to the right speaker and vice-\nversa. So my backwards LRCLK was just happening to work previously because I\nwas providing the data in the wrong order! I couldn\u2019t figure out how to swap\nthe two 16-bit channels before sending them out over I^2S. It\u2019s possible that\nthere\u2019s some magic solution to tell the DMA controller to swap the 16-bit\nchannels in each 32-bit word being transmitted. I don\u2019t know \u2014 I couldn\u2019t\nfigure it out.\n\nI ended up reading in detail about the SSP controller in the PXA168. In\nparticular I noticed that it supports something called network mode, where you\ncan allocate time slots dedicated for data to be sent. It turns out the Linux\ndriver actually used to use network mode but eventually switched away from it.\nIt was unclear to me exactly why this change was made in 2009. The PXA168\ndatasheet specifically says network mode is for emulating the I^2S protocol.\nI\u2019m sure there was a very good reason for switching away, but I found that\nnetwork mode was just what I needed for ensuring the data was being sent out\nin the correct order. It wasn\u2019t too difficult to switch the driver over, and\nit allowed me to remove an ugly hack I had needed for the old method.\n\nWith the change to network mode all implemented, my rabbit hole journey was\ncomplete and audio playback and recording worked great, right?\n\nWrong. Somehow I managed to discover another bug. Sometimes if I played a mono\nsound with aplay, the left channel sounded fine but the right channel would\nplay back as random static noise instead of silence like it was supposed to.\nThe weird part is it would only happen after I had tried recording! And\nsometimes recording would fix the issue and make the static go away.\n\nI was intentionally disabling the right channel when playing back mono sound.\nThere shouldn\u2019t have been any data at all on the right channel. But something\nwas causing it to play back random noise even though it was supposedly\ndisabled. And why would it only happen after recording?\n\nI still have no explanation for why this happened. It smells like a silicon\nbug to me, but it might just be my lack of understanding of how the SSP\nperipheral works. Maybe weirdness like this was why the kernel developers\nswitched away from network mode. I really wanted to use network mode, though.\nIt was perfect for what I needed, aside from this strange bug. What I ended up\ndoing was removing the second channel altogether when playing back mono sound,\nrather than disabling it. Removing the channel and adding 16 bits of dummy\ndata to replace it completely solved the issue. This fix was included with my\nfinal commit I linked earlier.\n\nSo yeah. If I\u2019m being 100% honest with myself, I\u2019m still not totally sure how\nI got this all working or if my solution is correct. I came up with a somewhat\nhacky fix that works, but seems to go against intentional decisions made by\nkernel developers 15 years ago. I can play audio reliably and the microphone\nworks too. I\u2019m writing this post over a year after I first figured it out, and\nI\u2019m still afraid of even thinking about trying to upstream my audio fixes. I\ncan\u2019t provide great reasons for why the random issues I saw happened, and I\nhave no idea whether my fixes are truly the best approach. I think at minimum,\nI would need to clean up the clocking to use the common clock framework. Also,\nI would need to test against other PXA2xx/3xx devices to see if they are also\naffected by the \u201c17 instead of 16 bits\u201d pitch/speed shift issue. I feel like\nother kernel developers would have noticed that though, so I\u2019m tempted to\nassume it\u2019s something weird about the PXA168. The bottom line is that I think\nfor the foreseeable future, my PXA audio fixes are going to stay in my branch.\n\nBy the way, I also got headphone jack detection working. It was super easy to\nset up. This commit I linked earlier adds the detection. All I had to do was\nadd this line to the correct section of my device tree:\n\n    \n    \n    simple-audio-card,hp-det-gpio = <&gpio 97 GPIO_ACTIVE_LOW>;\n\nThe mapping of GPIO 97 matches the schematic diagram I showed at the start of\nthis post. That was really easy! Back in the 2.6.28 days, the Chumby kernel\nhad Chumby-specific hacks in the WM8961 driver to add headphone plugin/removal\ndetection. It was pretty cool seeing how much simpler things have gotten since\nthen. A one-line addition to the device tree is a lot easier than vendor-\nspecific kernel hacks!\n\nHere\u2019s a quick demo of how the headphone detection works. It creates an input\ndevice that you can look at to detect whether headphones are plugged in.\nevtest is a simple utility that can monitor it:\n\n    \n    \n    # evtest No device specified, trying to scan all of /dev/input/event* Available devices: /dev/input/event0: Chumby Speaker Headphones /dev/input/event1: Chumby 8 touchscreen Select the device event number [0-1]: 0 Input driver version is 1.0.1 Input device ID: bus 0x0 vendor 0x0 product 0x0 version 0x0 Input device name: \"Chumby Speaker Headphones\" Supported events: Event type 0 (EV_SYN) Event type 5 (EV_SW) Event code 2 (SW_HEADPHONE_INSERT) state 0 Properties: Testing ... (interrupt to exit) Event: time 1713155219.026612, type 5 (EV_SW), code 2 (SW_HEADPHONE_INSERT), value 1 Event: time 1713155219.026612, -------------- SYN_REPORT ------------ Event: time 1713155224.496627, type 5 (EV_SW), code 2 (SW_HEADPHONE_INSERT), value 0 Event: time 1713155224.496627, -------------- SYN_REPORT ------------\n\nI started out with no headphones inserted, then plugged them in, and finally\nremoved them 5 seconds later. I believe there is userspace software that will\nrecognize this particular switch event and knows to enable/disable the\nheadphone and speaker as necessary. I can also manually control headphone and\nspeaker volume independently with amixer:\n\n    \n    \n    amixer set Headphone 25% amixer set Speaker 70%\n\nI should also add that I was concerned about any possible differences between\nthe old kernel and the new kernel in terms of how the WM8961 was set up. The\nWM8961 setup is basically just a bunch of register writes over I^2C. I\npainstakingly compared what the old and new kernels were doing. It seemed like\nChumby\u2019s kernel defaulted to a higher speaker AC gain (7 instead of 3), and\nalso did some tweaks to the volume and mic bias controls to bring them out to\nthe user separately and limit the volumes. Nothing seemed too crazy. I was\nmostly concerned about trying to drive the speakers louder than they should\nbe, so for now I\u2019ll just make sure to not drive the volume too high.\n\nInterestingly, it appears the Infocast and Chumby 8 had slightly different\nlimits. The Infocast was limited to a maximum of 121 for the headphone volume\nand 119 for the speakers, whereas the Chumby 8 had the full limit of 127 on\nboth of them. I don\u2019t know if that was a requirement from Insignia, or if the\nhardware changed a bit between revisions. Either way, it seems like with my\ndefault gain of 3, it sounds fine even when I go up to 127 on the Infocast.\n\nWhew! That was a lot to figure out. What it comes down to is I struggled a lot\nwith implementing audio support on the Chumby 8, but I got it working well\nenough. This was probably the most difficult part of my entire Chumby kernel\nmodernization. I think the main reason for that is my lack of experience with\nALSA. It was still pretty impressive that the vast majority of the\ninfrastructure for audio support on the PXA168 was already there in the\nmainline kernel. I mainly just had to add a little bit of glue code for the\nPXA168 and fix some random issues. I\u2019d still love to know whether other PXA\ndevices using the same driver play their sounds slightly too slowly.\n\nAt this point with the Chumby 8\u2019s display, touchscreen, Wi-Fi, and audio\nworking, there wasn\u2019t much left to do, but I\u2019m not done writing about this\nproject yet. I\u2019ll give you a little teaser for the next post. I\u2019d like to talk\nabout a strange issue I noticed. The CPU was always showing up as being 100%\nloaded, even with nothing running. The original Chumby 2.6.28 kernel\ndefinitely didn\u2019t do this. What was happening to cause the CPU to be so busy?\nStay tuned for the next post to find out all about it.\n\nAddress: https://www.downtowndougbrown.com/2024/04/upgrading-my-\nchumby-8-kernel-part-8-audio/\n\n\u00ab More fun with Apple\u2019s internal tools: creating a PDS card\n\nTrackback\n\n### no comments\n\n### Add your comment now\n\n  * ## Subscribe\n\n  * ## Recent Posts\n\n    * Upgrading my Chumby 8 kernel part 8: audio\n    * More fun with Apple\u2019s internal tools: creating a PDS card\n    * How Apple\u2019s developers reflashed Mac ROMs in the \u201990s\n    * Upgrading my Chumby 8 kernel part 7: touchscreen\n    * Revisiting programmable Mac ROM SIMMs in Quadras\n    * Porting my Mac ROM SIMM programmer from AVR to ARM\n    * How am I supposed to safely disable this warning on ARM GCC?\n    * How to create a Qt 5 ARM/Intel universal binary for Mac\n  * ## Categories\n\n    * Classic Mac (8)\n    * Computer repair (8)\n    * Electronics repair (4)\n    * iOS (3)\n    * Linux (34)\n    * Mac ROM hacking (11)\n    * Microcontroller lessons (11)\n    * Microcontrollers (1)\n    * Product reviews (5)\n    * Python (1)\n    * Qt (5)\n    * Uncategorized (20)\n    * Windows (5)\n  * ## Archives\n\n    * April 2024 (1)\n    * December 2023 (1)\n    * November 2023 (2)\n    * September 2023 (3)\n    * August 2023 (3)\n    * June 2023 (1)\n    * May 2023 (1)\n    * April 2023 (1)\n    * March 2023 (2)\n    * January 2023 (1)\n    * December 2022 (3)\n    * August 2022 (1)\n    * May 2022 (2)\n    * March 2022 (1)\n    * December 2021 (1)\n    * June 2021 (1)\n    * April 2021 (1)\n    * January 2021 (1)\n    * September 2020 (1)\n    * August 2020 (1)\n    * July 2020 (1)\n    * May 2020 (1)\n    * June 2019 (1)\n    * April 2019 (1)\n    * December 2018 (1)\n    * August 2018 (1)\n    * May 2018 (1)\n    * April 2018 (3)\n    * February 2018 (1)\n    * October 2017 (1)\n    * July 2017 (1)\n    * May 2017 (3)\n    * March 2017 (1)\n    * October 2016 (1)\n    * June 2015 (1)\n    * March 2015 (1)\n    * November 2014 (1)\n    * August 2014 (3)\n    * July 2014 (1)\n    * April 2014 (1)\n    * March 2014 (1)\n    * February 2014 (1)\n    * November 2013 (1)\n    * August 2013 (1)\n    * June 2013 (3)\n    * April 2013 (1)\n    * March 2013 (1)\n    * January 2013 (2)\n    * December 2012 (2)\n    * August 2012 (1)\n    * July 2012 (2)\n    * June 2012 (1)\n    * May 2012 (1)\n    * February 2012 (3)\n    * January 2012 (1)\n    * November 2011 (1)\n    * October 2011 (2)\n    * August 2011 (3)\n    * May 2011 (1)\n    * April 2011 (1)\n    * March 2011 (2)\n    * November 2010 (2)\n    * October 2010 (3)\n    * July 2010 (5)\n  * ## Recent Comments\n\n    * Doug Brown on Parallel Port Tester\n    * Christopher J Siegle on Parallel Port Tester\n    * Doug Brown on Upgrading my Chumby 8 kernel part 7: touchscreen\n    * Ben Stern on Upgrading my Chumby 8 kernel part 7: touchscreen\n    * Dump of Interesting Links \u2013 David Walz on How Apple\u2019s developers reflashed Mac ROMs in the \u201990s\n    * Doug Brown on Upgrading a motherboard\u2019s BIOS/UEFI (the hard way)\n    * jj on Upgrading a motherboard\u2019s BIOS/UEFI (the hard way)\n    * Phil on Virtualizing Mac OS X 10.4 with VMware\n    * Matt B on More fun with Apple\u2019s internal tools: creating a PDS card\n    * Doug Brown on Parallel Port Tester\n  * ## Spam Blocked\n\n187,760 spam blocked by Akismet\n\nDowntown Doug Brown \u00b7 coogee theme \u00b7 2008 \u00b7 Privacy Policy\n\nRSS Feed \u00b7 WordPress \u00b7 TOP\n\n", "frontpage": false}
