{"aid": "39980409", "title": "Migrating 500 tests from Mocha to Node.js", "url": "https://astro.build/blog/node-test-migration/", "domain": "astro.build", "votes": 1, "user": "glenjamin", "posted_at": "2024-04-09 15:21:31", "comments": 0, "source_title": "Migrating 500+ tests from Mocha to Node.js", "source_text": "Migrating 500+ tests from Mocha to Node.js | Astro\n\nSkip to content\n\nMarch 25, 2024\n\n# Migrating 500+ tests from Mocha to Node.js\n\nBy\n\nEmanuele Stoppa\n\nBjorn Lu\n\nOver a month ago, we discussed a possible migration to the Node.js test\nrunner. While we were sufficiently happy with Mocha, we are always looking to\nmake our CI jobs faster.\n\nRelying on a test runner baked inside our runtime had some advantages for our\nmain monorepo:\n\n  * Two fewer dependencies to install and maintain in our monorepo: mocha and chai.\n  * Maintainability: there are more people involved in the Node.js project to maintain the Node.js test runner.\n  * Future benefits: we believe the test runner will improve with time, and eventually save some time in our CI workflows.\n\n## From an idea to a PoC\n\nThe Astro monorepo has more than 500 testing suites: between integration tests\nand unit tests, we have 664 suites, with a total of 1603 tests. The majority\nof these tests are integration tests.\n\nAn integration test, in our monorepo, means creating a tiny Astro project,\nbuilding this project with a specific environment (development, static\ngeneration (SSG) or dynamic generation (SSR)), and then running assertions\nover the built pages. That\u2019s right, each integration test requires vite to\nbuild and bundle the project.\n\nBefore deciding to undertake this migration, we wanted to make sure that\nmoving away from Mocha was not a mistake. Despite its quirks, Mocha is a very\ncapable test runner! It\u2019s been around for a long time and is battle-tested. If\nyou use Mocha, you are in good hands.\n\nThe idea of the PoC was to understand:\n\n  * The flexibility of the Node.js CLI arguments and how customizable the test reporters could be.\n  * The speed of execution of the testing suites.\n  * The overall developer experience.\n\n### How we started\n\nWe started by migrating only one of our packages that didn\u2019t already use\nastro\u2019s integration suite: create-astro. This was a good opportunity to play\nwith the built-in assertion library node:assert, to learn about the options it\noffered, and evaluate its performance compared to Mocha.\n\nSince create-astro only had a handful of tests, it was relatively easy to\nmigrate the test files to use node:test and node:assert instead of mocha and\nchai. After that, the only thing left was to update the mocha command to node\n--test to execute the tests. However, we quickly ran into issues using the\nnode --test command, including:\n\n  * It had trouble parsing the glob syntax when passing multiple arguments (e.g. node --test \"test/*.test.js\" --test-name-pattern=\"foo\").\n  * It wasn\u2019t possible to pass the --test-concurrency flag (only available in Node.js 21 and above), but could be worked around by using the programmatic API concurrency option.\n  * Nitpicking, but the argument names were verbose: --test-name-pattern instead of --match, -m arguments; --test-timeout instead of --timeout, -t arguments, etc.\n\nHence, to solve these issues, we created a custom script which can be called\nwith the astro-scripts test command. This decision also proved useful in order\nto enable more workarounds as you\u2019ll see later.\n\n### Opening Pandora\u2019s box\n\nAfter successfully migrating the first package, we then attempted to migrate\nthe testing suites of the @astrojs/node package. This integration is one of\nour most downloaded integrations, so we have plenty of tests. Plus, the tests\nof this package all have integration tests, so it was a good opportunity to\ncheck the performance of the test runner.\n\nOnce the PR was ready, we noticed that Node.js test runner was significantly\nslower than Mocha. We investigated, and we discovered that Node.js spawns a\nnew process for each test file to ensure that each testing suite is run in\nisolation. Running a testing suite in isolation is, generally, a good practice\nbecause it assures that tests run in an unpolluted environment.\n\nHowever, our testing suites were already isolated. In fact, we were able to\nrun our testing suites with Mocha using the main thread without running into\nany of the typical issues: side effects, polluted environments, etc.\nUnfortunately, Node.js didn\u2019t provide an option to run all tests in the same\nthread. So, we had to come up with a solution to the slow test runs. (Aren\u2019t\nwe engineers, after all? We solve problems!)\n\nUsing our internal astro-scripts test command, we were able to work around\nthis by creating a temporary file that imports all the testing suites, and we\nlet Node.js test that single file. This way, only one process is spawned for\nthe file and we reach the same level of performance as if we were using the\nmain process.\n\nHowever, this came with its own downside: if there was a test failure or a\ntimeout, we weren\u2019t able to tell which test was the cause. This was the main\nquirk we found, and while not every team may have made this choice, we\naccepted this trade-off in order to give us the benefits mentioned earlier.\nAfter all, we had previously accepted Mocha\u2019s quirks!\n\n### Node.js assert and chai\n\nDuring the migration, we had to remove the chai library for\nnode:assert/strict. This task uncovered that with chai, you can execute the\nsame check in different ways. For example, you can run an equality check at\nleast in four different ways:\n\n    \n    \n    import { expect } from \"chai\";\n    \n    expect(\"foo\").to.eq(\"foo\")\n    \n    expect(\"foo\").to.be.eq(\"foo\")\n    \n    expect(\"foo\").to.equal(\"foo\")\n    \n    expect(\"foo\").to.be.equal(\"foo\")\n\nOn the one hand, it\u2019s good to have this kind of flexibility. But on the other,\nthe code for the tests becomes inconsistent. With the Node.js assertion\nmodule, there is only one way to perform this check:\n\n    \n    \n    import { assert } from \"node:assert/strict\";\n    \n    assert.equal(\"foo\", \"foo\")\n\nThe Node.js assertion module provides almost all of the functionalities we\nrequired, so the migration from chai wasn\u2019t as painful as we thought it might\nbe. Our use of chai was very minimal. However, we do miss the .includes\nshortcut of chai:\n\n    \n    \n    import { expect } from \"chai\";\n    \n    expect(\"It's a fine day\").includes(\"fine\")\n\nThe Node.js assertion module doesn\u2019t provide such a utility, so instead we\nended up using the equality assertion with the String#includes function:\n\n    \n    \n    import assert from \"node:assert/strict\";\n    \n    assert.equal(\"It's a fine day\".includes(\"fine\"), true)\n\n### Here come the dragons\n\nAs mentioned before, we have a lot of test files and we add new tests almost\nevery day. Opening a one-off PR that does the migration of the whole monorepo\nis unfeasible. It would require a lot of work from one person, and keeping the\nbranch updated would be stressful.\n\nSo we came up with a simple plan:\n\n  * Migrate first the small packages inside the monorepo.\n  * Slowly migrate the main package - astro - by having Mocha and Node.js test runner in the same CI.\n  * Remove Mocha.\n\nIn order to achieve that, we asked for help from our community. We thought\nthis was the perfect opportunity to let people that aren\u2019t familiar with\nAstro\u2019s business logic contribute to the project. And, we could make the\nmigration process go more quickly.\n\nWe created and pinned an umbrella issue to coordinate the efforts. Each\ncontributor took ownership of the migration of an individual package, opening\na separate PR for each one. Two new first-time contributors to the project\neven joined the efforts. It was a fantastic thing to see. In one week, we were\nable to migrate all packages!\n\nMigrating the main package astro was a feat! It\u2019s the package that contains by\nfar the highest number of tests. In order to perform this migration slowly and\ncarefully, we had to come up with an out-of-the-box solution.\n\nWe set up the Node.js test runner to test only the files called *.nodetest.js.\nDoing so allowed us to keep testing all files in the CI. Then, the rest was\njust a matter of coordinating our community by providing (and documenting!) a\nclear process for them to follow:\n\n  * Use the umbrella issue to tell other contributors which files you intend to migrate;\n  * Rename the files to migrate from *.test.js to *.nodetest.js;\n  * Migrate the files;\n  * Open a PR, wait for a review, and if successful, an Astro maintainer will merge the PR.\n\nWith the help of @log101, @mingjunlu, @VoxelMC, @alexnguyennz, @xMohamd,\n@shoaibkh4n, @marwan-mohamed12, @at-the-vr and @ktym4a we migrated almost 300\ntest suites in one week!\n\n### The results\n\nWe are quite happy with the results. We haven\u2019t seen any significant\nregression in the performance of our tests. The assertion module that Node.js\nprovides has all the utilities we need, and the describe/it pattern is\nsupported, so the migration from Mocha was smooth.\n\nThere are, however, still a few hiccups regarding the developer experience\ncompared to using Mocha.\n\nFor example, to run one single test suite in Mocha, using it.only is enough.\nWith the Node.js test runner you have to:\n\n  * Run the CLI using the --test-only argument.\n  * Add .only to the describe that contains the it.only you want to run.\n  * If there are multiple instances of describe, all of them need to be marked with .only.\n\nAnother example is that using --test-name-patterns could be improved. This\nargument is used to run only the tests that match a particular name pattern.\nThe DX isn\u2019t great because the CLI litters the terminal with messages about\ntests that don\u2019t match (which aren\u2019t run). This makes it more difficult to\nunderstand which tests are actually run. Plus, the command is really slow just\nfor running tests that match some pattern.\n\nNode.js test runner is still young and with its active development, has all\nthe right cards to become better. For example, the Node.js project is\ncurrently evaluating running tests using the main process after we voiced our\nuse case.\n\nIn the spirit of true open-source collaboration, we are pleased that improving\nAstro by switching our tests to Node.js will, in turn, improve Node.js itself!\n\n", "frontpage": false}
