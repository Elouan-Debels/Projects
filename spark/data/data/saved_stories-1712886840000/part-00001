{"aid": "40006102", "title": "A simple algorithm to compute the square root of an integer, byte by byte", "url": "https://lemire.me/blog/2024/04/11/a-simple-algorithm-to-compute-the-square-root-of-an-integer-byte-by-byte/", "domain": "lemire.me", "votes": 2, "user": "ibobev", "posted_at": "2024-04-11 19:51:47", "comments": 0, "source_title": "A simple algorithm to compute the square root of an integer, byte by byte", "source_text": "A simple algorithm to compute the square root of an integer, byte by byte \u2013\nDaniel Lemire's blog\n\nSkip to content\n\nDaniel Lemire's blog\n\nDaniel Lemire is a computer science professor at the Data Science Laboratory\nof the Universit\u00e9 du Qu\u00e9bec (T\u00c9LUQ) in Montreal. His research is focused on\nsoftware performance.\n\n## Support my work!\n\nI do not accept any advertisement. However, you can you can sponsor my open-\nsource work on GitHub.\n\nJoin over 12,500 email subscribers:\n\nYou can follow this blog on telegram. You can find me on twitter as @lemire or\non Mastodon.\n\n## Recent Posts\n\n## Recent Comments\n\n## Pages\n\n## Archives\n\n## Boring stuff\n\n# A simple algorithm to compute the square root of an integer, byte by byte\n\nA reader asked me for some help in computing (1 \u2013 sqrt(0.5)) to an arbitrary\nprecision, from scratch. A simpler but equivalent problem is to compute the\nsquare root of an integer (e.g., 2). There are many sophisticated algorithms\nfor such problems, but we want something relatively simple. We\u2019d like to\ncompute the square root bit by bit...\n\nFor example, the square root of two is...\n\n  1. 5 / 4\n  2. 11 / 8\n  3. 22 / 16\n  4. 45 / 32\n  5. 90 / 64\n  6. 181 / 128\n  7. ...\n\nMore practically, 8-bit by 8-bit, we may want to compute it byte by byte...\n\n  1. 362 / 256\n  2. 92681 / 65536\n  3. 23726566 / 16777216\n  4. ...\n\nHow can we do so?\n\nIntuitively, you could compute the integer part of the answer by starting with\n0 and incrementing a counter like so:\n\n    \n    \n    x1 = 0 while (x1+1)**2 <= M: x1 += 1\n\nIndeed, the square of the integer part cannot be larger than the desired\npower.\n\nYou can repeat the same idea with the fractional part... writing the answer as\nx1+x2/B+... smaller terms.\n\n    \n    \n    x2 = 0 while (x1*B + x2 + 1)**2 <= M*B**2: x2 += 1\n\nIt will work, but it involves squaring ever larger numbers. That is\ninefficient.\n\nWe don\u2019t actually need to compute powers when iterating. If you need to\ncompute x**2, (x+1)**2, (x+2)**2, etc. You can instead use a recursion: if you\nhave computed (x+n)**2 and you need the next power, you just need to add\n2(x+n) + 1 because that\u2019s the value of (x+n+1)**2 \u2013 (x+n)**2.\n\nFinally, we get the following routine (written in Python). I left the asserts\nin place to make the code easier to understand:\n\n    \n    \n    B = 2**8 # or any other basis like 2 or 10 x = 0 power = 0 limit = M for i in range(10): # 10 is the number of digits you want limit *= B**2 power *= B**2 x*=B while power + 2*x + 1 <= limit: power += 2*x + 1 x += 1 assert(x**2 == power) assert(x**2 <= limit) # x/B**10 is the desired root\n\nThe algorithm could be further optimized if you needed more efficiency.\nImportantly, it is assumed that the basis is not too large otherwise another\ntype of algorithm would be preferable. Using 256 is fine, however.\n\nObviously, one can design a faster algorithm, but this one has the advantage\nof being nearly trivial.\n\nFurther reading: A Spigot-Algorithm for Square-Roots: Explained and Extended\nby Mayer Goldberg\n\nCredit: Thanks to David Smith for inspiring this blog post.\n\n## Published by\n\n### Daniel Lemire\n\nA computer science professor at the University of Quebec (TELUQ). View all\nposts by Daniel Lemire\n\nPosted on April 11, 2024April 11, 2024Author Daniel LemireCategories\n\n### Leave a Reply Cancel reply\n\nYou may subscribe to this blog by email.\n\nTerms of use Proudly powered by WordPress\n\n", "frontpage": false}
