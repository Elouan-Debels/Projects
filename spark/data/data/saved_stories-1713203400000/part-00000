{"aid": "40039238", "title": "THT Language Design Notes", "url": "https://tht.dev/about/design-notes", "domain": "tht.dev", "votes": 1, "user": "hu3", "posted_at": "2024-04-15 11:47:28", "comments": 0, "source_title": "Design Notes", "source_text": "Design Notes | THT\n\nVersion: v0.7.1 - Beta. We welcome contributors & feedback.\n\n# Language Design Notes\n\n### About\n\nThis page contains list of reasons behind many of the design decisions made\nfor THT.\n\nUltimately, every decision is a trade-off, trying to balance many factors like\nfamiliarity, simplicity, safety, etc.\n\nNot every decision will appeal to everyone, but I hope this page will show\nthat a lot of thought was put into every part of the language.\n\n### Design Principles\n\nHere are some of the higher-level principles that helped guide these\ndecisions:\n\n  * Favor human performance over machine performance\n  * Reduce cognitive load by minimizing micro-decisions & visual noise\n  * Optimize for the most common cases (the 80/20 rule)\n  * Make the right way (best practices) easier than the wrong way\n  * Favor 1-to-1 shortcuts over invisible magic\n  * Be familiar to PHP and (secondarily) JavaScript programmers\n\n### Confidence Score\n\nThe \u201cV1 Confidence\u201d percentage for each feature shows the likelihood that it\nwill remain unchanged by Version 1.0.\n\nNothing is etched in stone, so feedback from Beta users could change things.\n\n### Comparisons\n\nIn a couple of cases, I refer to the Laravel framework, because it is a larger\ncodebase and an example of well-written, modern PHP code.\n\n### Contents\n\n  * Dot Methods\n  * JSON Maps\n  * Prefixed Binary Operators\n  * No Semicolons\n  * No Outer Parens\n  * Dollar Variables\n  * Single-Quoted Strings\n  * No for Loop\n  * No Unary Increment ++ and --\n  * No while Loop\n  * CamelCase Names\n  * No Null\n  * 1-Based Indexing\n\n## Dot Methods\n\n    \n    \n    // PHP Module->method() // THT Module.method()\n\nTHT replaces the arrow notation of PHP's method calls because they are simply\neasier to type and create less visual noise.\n\nThis approach is mainstream, and hopefully non-controversial.\n\nOther languages that use dot method calls: JavaScript, Java, Python, Ruby,\nSwift\n\nV1 Confidence: 100%\n\n## JSON Maps\n\n    \n    \n    // PHP [ 'key' => 'value', 'num' => 123 ] // THT { key: 'value', num: 123 }\n\nTHT replaces arrow/bracket notation with JS object-literal notation.\n\nThis is easier to type and contains less visual noise, and should be familiar\nto all web developers.\n\nV1 Confidence: 100%\n\n## Prefixed Binary Operators\n\n    \n    \n    // PHP $result = $op1 | $op2 // THT $result = $op +| $op2\n\nBinary operators are almost never used in web development, and the operators\nare too easily mistaken for their logical counterparts.\n\nIf you want a bitmask, most of the time a keyword Map will be easier to work\nwith.\n\nThis approach is borrowed from Raku (Perl 6).\n\nV1 Confidence: 100%\n\n## No Semicolons\n\n    \n    \n    // PHP $a += 1; print($a); // THT $a += 1 print($a)\n\nThis reduces visual noise, and it reinforces the good practice of having only\none statement per line.\n\nIt will sometimes be inconvenient for those of us with semicolons engrained in\nour muscle memory, but THT gives super clear feedback when a mistake is made,\nso it\u2019s easy to fix.\n\nOther languages that don\u2019t use/require semicolons: Python, Ruby, Swift, Go,\nLua\n\nV1 Confidence: 90%\n\n## No Outer Parens\n\n    \n    \n    // PHP if ($condition) { ... } // THT if $condition { ... }\n\nThis reduces visual noise, and makes it easier to balance parens that are\nwithin the condition itself.\n\nOther languages that don\u2019t require parens: Python, Ruby, Rust, Swift, Go\n\nV1 Confidence: 90%\n\n## Dollar Variables\n\n    \n    \n    // THT & PHP $myVar = 123\n\nTHT keeps the dollar \u201csigils\u201d in variables to retain its identity as a PHP-\nbased programming language.\n\nThis admittedly goes against the idea of removing visual noise, but in this\ncase, familiarity is more important.\n\nV1 Confidence: 90%\n\n## Single-Quoted Strings\n\n    \n    \n    // PHP $myString = 'Hello ' . \"World!\" // THT $myString = 'Hello ' ~ 'World!'\n\nIn PHP, the ability to choose between single or double-quotes is sometimes\nuseful.\n\nHowever, because string literals are extremely common, this leads to hundreds\n(maybe thousands) of micro-decisions per project.\n\nSingle quotes were chosen for THT because they are a little easier to type (no\nSHIFT key), and they create a little less visual noise.\n\nNote: Interpolation is TBD, but THT currently has multiple ways to insert text\nvia .fill(), the ~ stringy operator, and template functions.\n\nV1 Confidence: 90%\n\n## No for Loop\n\n> \u201cFor what it\u2019s worth, we don\u2019t have a single C style for loop in the Lyft\n> codebase.\u201d \u2014 Keith Smiley, Lyft\n    \n    \n    // PHP for ($i = 1; $i <= 10; $i++) { ... } // THT foreach range(1, 10) as $i { ... }\n\nIn any language with a foreach (or for in) construct, the C-style for loop is\nmostly unnecessary because the vast majority of loops iterate over a\ncollection or a range of numbers.\n\nFor example, the Laravel project uses foreach 638 times and for 9 times (7 of\nthose could be written as a foreach/range). That\u2019s about 300-to-1.\n\nLanguages that follow this pattern: Python, Ruby, Swift, Rust\n\nV1 Confidence: 90%\n\n## No Unary Increment ++ and --\n\n    \n    \n    // PHP if (++$myVar) { ... } // THT $myVar += 1 if $myVar { ... }\n\nFor such a simple operation (adding 1), this operator is quite complicated.\n\nIt often tempts programmers to write \u201cclever\u201d code that mixes mutation with\nevaluation, and is further complicated by behaving differently when it appears\nbefore or after the subject.\n\nYou can simply use += 1 instead.\n\nLanguages that don\u2019t use ++: Python, Ruby, Swift, Rust\n\nV1 Confidence: 90%\n\n## No while Loop\n\n    \n    \n    // PHP $status = true while ($status) { $status = doSomething(); if (!$status) { break; } } // THT loop { $status = doSomething() if !$status: break }\n\nThe while operator often leads to off-by-one errors and redundant\ninitialization.\n\nThe do/while construct complicates things further, as the only language\nfeature that turns the conventional (predicate) { block } convention upside\ndown.\n\nTHT's loop codifies the convention of a while (true) loop, giving you total\ncontrol over the order of operations and where the loop should break.\n\nKeep in mind that while isn\u2019t used very often, so this isn\u2019t a high impact\nchange. In the Laravel project, while appears in 1 out of every 680 logical\nlines of code.\n\nLanguages with loop: Rust\n\nV1 Confidence: 80%\n\n## CamelCase Names\n\n    \n    \n    // PHP $my_variable = HTTPClass::myFunction() // THT $myVariable = HttpClass.myFunction()\n\nIn THT, everything is camelCase.\n\nI realize this might be a deal-breaker for some people. I honestly don\u2019t have\na strong preference, but the consensus among professional programmers is that\nhaving a single consistent style is important, regardless of what is used.\n\nBenefits of a single language-level style:\n\n  * More consistency for novice programmers\n  * No extra complexity around mixing styles to denote different things (e.g. ClassNames vs variable_names)\n  * Less bikeshedding among teams about cosmetic concerns\n  * All code chared online is consistent\n\nCamelCase was chosen for a few reasons:\n\n  * It is familiar and mainstream, used by JavaScript and Java\n  * It requires a little less typing\n  * It creates a little less visual noise\n  * Names appear as one cohesive visual token\n  * Double-clicking selects the entire token (vs hyphen-case)\n  * It allows for lowerCamelCase and UpperCamelCase\n  * Prefixes are still possible with a single letter (e.g. $xMyVariable vs $_my_variable)\n\nIt also allows the THT compiler to do some things like:\n\n  * Use underscores internally to implement case sensitivity\n  * Use UpperCamelCase to recognize module names\n\nLanguages that use camelCase convention: JavaScript, Java, Swift\n\nV1 Confidence: 80%\n\n## No Null\n\nTony Hoare, the creator of Null, called it his \u201cBillion Dollar Mistake\u201d.\n\nNull complicates programs because it means that every variable can have a 3rd\nstate that overlaps with all other types, and it can trigger errors far from\nwhere it was set.\n\nModern languages favor the Option Type pattern instead, which THT supports via\nResult.\n\nAs THT's object system is developed further, we will examine safer ways to re-\nintroduce the concept of an uninitialized object.\n\nLanguages that favor the Option Type pattern: Rust, Swift\n\nV1 Confidence: 70%\n\n## 1-Based Indexing\n\n    \n    \n    $list = ['a', 'b', 'c'] // PHP $list[0] //= 'a' $list[1] //= 'b' $list[2] //= 'c' // THT $list[1] //= 'a' $list[2] //= 'b' $list[3] //= 'c'\n\nUnlike PHP and many other C-derived languages, THT starts at one when counting\nindexes, instead of zero.\n\nZero-indexing is a vestige of low-level languages on ancient hardware, where\nit was more efficient to count from zero.\n\nHowever, the tiny performance benefits that were needed 50 years ago are\nirrelevant on today\u2019s machines (the PDP-11 ran at about 1.2 MHz).\n\nModern high-level languages can and should reduce this cognitive load from the\nprogrammer.\n\nHere are a number of practical/cognitive benefits:\n\n  * It is more natural to humans. (Hence the term, \u201cEasy as 1-2-3\u201d.) Zero indexing requires an extra mental step, even for many of us who have been programming for a long time.\n\n    \n    \n    1: 1st 2: 2nd 3: 3rd\n\n  * It greatly reduces the need to litter -1 and +1 in our code to manually bridge the gap between human-counting and machine-counting, and reduces the chance of off-by-one errors.\n\n  * It is applicable to math and statistics. Languages like Mathematica and Julia actually use 1-indexing.\n\n  * Index-related functions can return 0 to indicate a missing item, which is conveniently falsey, and also makes semantic sense.\n\n    \n    \n    // 1-Index if !$list.indexOf('X'): return // 0-Index if $list.indexOf('X') == -1: return\n\nOther languages use out-of-band values like false or -1 to indicate a missing\nitem. This forces the programmer to use extra caution to make sure it isn\u2019t\ninterpreted as a valid index.\n\n    \n    \n    $badIndex = $list.indexOf('missing') // THT (0) $list[$badIndex] // \u2713 Immediate error (safe) // PHP (false) $list[$badIndex] // \u2715 BUG! Gets the 1st element (false == 0) // JavaScript (-1) $list[$badIndex] // \u2715 undefined\n\n  * The index of the last element is the same as the collection\u2019s length. Other languages need to offset 1.\n\n    \n    \n    // 1-Index $isLastItem = $index == $list.length() // 0-Index $isLastItem = $index == $list.length() - 1\n\nThis makes ranges a bit simpler as well, with less confusion around inclusive\nvs exclusive ranges.\n\n    \n    \n    // 1-Index foreach range(1, $list.length()) as $i { ... } // 0-Index foreach range(0, $list.length() - 1) as $i { ... }\n\n  * Negative and positive indexes are symmetrical. In other languages, each direction has a different offset.\n\n    \n    \n    $one = $list[1] $two = $list[2] $lastOne = $list[-1] $lastTwo = $list[-2]\n\n  * A note on Dijkstra, who said in 1982 that numbering should start at zero.\n\n> When starting with subscript 1, the subscript range 1 \u2264 i < N+1; starting\n> with 0, however, gives the nicer range 0 \u2264 i < N\n\nFirst, he offers no real practical benefit for programmers, only an aesthetic\nargument (One could argue that \u201c1 \u2264 i \u2264 N\u201d is even nicer.)\n\nHe mentions an anecdote about a defunct language called Mesa, but offers no\ndetails.\n\nSecond, it\u2019s less relevant nowadays, since the foreach construct means we\nrarely work with ranges directly. (The Laravel project only uses ranges 7\ntimes in 20,000 logical lines of code.)\n\nOther languages that use 1-based indexing: Smalltalk, Mathematica, R, Lua,\nJulia.\n\nV1 Confidence: 70%\n\n", "frontpage": false}
