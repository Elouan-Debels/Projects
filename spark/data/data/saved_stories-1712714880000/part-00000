{"aid": "39983661", "title": "BatBadBut: You can't securely execute commands on Windows", "url": "https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/", "domain": "flatt.tech", "votes": 16, "user": "explodingwaffle", "posted_at": "2024-04-09 20:05:38", "comments": 2, "source_title": "BatBadBut: You can't securely execute commands on Windows", "source_text": "BatBadBut: You can't securely execute commands on Windows - Flatt Security\nResearch\n\n  * Official site\n  * Shisho Cloud\n  * X (Twitter)\n  * Recruit\n\nApril 9, 2024\n\n# BatBadBut: You can't securely execute commands on Windows\n\n##### Posted on April 9, 2024 \u2022 10 minutes \u2022 2101 words\n\n# Introduction\n\nHello, I\u2019m RyotaK ( @ryotkak ), a security engineer at Flatt Security Inc.\n\nRecently, I reported multiple vulnerabilities to several programming languages\nthat allowed an attacker to perform command injection on Windows when the\nspecific conditions were satisfied. Today, affected vendors published\nadvisories of these vulnerabilities , so I\u2019m documenting the details here to\nprovide more information about the vulnerabilities and minimize the confusion\nregarding the high CVSS score.\n\n# TL;DR\n\nThe BatBadBut is a vulnerability that allows an attacker to perform command\ninjection on Windows applications that indirectly depend on the CreateProcess\nfunction when the specific conditions are satisfied.\n\nCreateProcess() implicitly spawns cmd.exe when executing batch files (.bat,\n.cmd, etc.), even if the application didn\u2019t specify them in the command line.\nThe problem is that the cmd.exe has complicated parsing rules for the command\narguments, and programming language runtimes fail to escape the command\narguments properly. Because of this, it\u2019s possible to inject commands if\nsomeone can control the part of command arguments of the batch file.\n\nThe following simple Node.js code snippet, for example, may pop calc.exe on\nthe server machine:\n\n    \n    \n    const { spawn } = require('child_process'); const child = spawn('./test.bat', ['<your-input-here>']);\n\nThis happens only if a batch file is explicitly specified in the command line\npassed to CreateProcess(), and it doesn\u2019t happen when a .exe file is\nspecified. However, since Windows includes .bat and .cmd files in the PATHEXT\nenvironment variable by default, some runtimes execute batch files against the\ndevelopers\u2019 intention if there is a batch file with the same name as the\ncommand that the developer intended to execute. So, even the following snippet\nmay lead to arbitrary command executions whereas it doesn\u2019t include .bat or\n.cmd explicitly:\n\n    \n    \n    cmd := exec.Command(\"test\", \"<your-input-here>\") cmd.Run()\n\nExploitation of these behaviors is possible when the following conditions are\nsatisfied:\n\n  * The application executes a command on Windows\n  * The application doesn\u2019t specify the file extension of the command, or the file extension is .bat or .cmd\n  * The command being executed contains user-controlled input as part of the command arguments\n  * The runtime of the programming language fails to escape the command arguments for cmd.exe properly^1\n\nBy exploiting these behaviors, arbitrary command execution might be possible.\nI created a flowchart to determine if your applications are affected by this\nvulnerability, so please refer to Appendix A if you are unsure whether you are\naffected or not, and refer to Appendix B for the status of the affected\nprogramming languages.\n\n# CVSS Score\n\nFirst of all, I have to mention that you shouldn\u2019t apply the CVSS score of\nlibrary vulnerabilities to your application directly. The user guide of CVSS\nv3.1 states that the CVSS score of a library should be calculated based on the\nworst-case scenario, and this is why the recent vulnerabilities for\nprogramming languages got high scores despite the requirement of specific\nconditions.\n\nInstead of applying the CVSS score directly, you should recalculate the score\nbased on the specific implementation: https://www.first.org/cvss/v3.1/user-\nguide#3-7-Scoring-Vulnerabilities-in-Software-Libraries-and-Similar\n\n# Technical Details\n\nWhile I\u2019m not a fan of naming vulnerabilities that are not internet-breaking,\nI\u2019m a fan of puns, so I decided to call this vulnerability BatBadBut because\nit\u2019s about batch files and bad, but not the worst.\n\nFrom this section, I\u2019ll explain the technical side of BatBadBut and why the\ncommand injection is possible. Please note that some of the code snippets\ndon\u2019t work on the latest version of runtimes, as some affected vendors already\npatched the issue.\n\n## Root Cause\n\nThe root cause of BatBadBut is the overlooked behavior of the CreateProcess\nfunction on Windows. When executing batch files with the CreateProcess\nfunction, Windows implicitly spawns cmd.exe because Windows can\u2019t execute\nbatch files without it.\n\nFor example, the following code snippet spawns C:\\Windows\\System32\\cmd.exe /c\n.\\test.bat to execute the batch file test.bat:\n\n    \n    \n    wchar_t arguments[] = L\".\\\\test.bat\"; STARTUPINFO si{}; PROCESS_INFORMATION pi{}; CreateProcessW(nullptr, arguments, nullptr, nullptr, false, 0, nullptr, nullptr, &si, &pi);\n\nWhile this isn\u2019t a problem itself, the issue arises when the programming\nlanguage wraps the CreateProcess function and adds the escaping mechanism for\nthe command arguments.\n\n## Wrapping CreateProcess\n\nMost programming languages provide a function to execute a command, and they\nwrap the CreateProcess function to provide a more user-friendly interface. For\nexample, the child_process module in Node.js^2 wraps the CreateProcess\nfunction and provides a way to execute a command with arguments like the\nfollowing:\n\n    \n    \n    const { spawn } = require('child_process'); const child = spawn('echo', ['hello', 'world']);\n\nAs you can see in the above code snippet, the spawn function takes the command\nand arguments as separate arguments. It then internally escapes arguments to\npass them to the CreateProcess function.\n\nsrc/win/process.c line 444-518\n\n    \n    \n    /* * Quotes command line arguments * Returns a pointer to the end (next char to be written) of the buffer */ WCHAR* quote_cmd_arg(const WCHAR *source, WCHAR *target) { [...] /* * Expected input/output: * input : hello\"world * output: \"hello\\\"world\" * input : hello\"\"world * output: \"hello\\\"\\\"world\" * input : hello\\world * output: hello\\world * input : hello\\\\world * output: hello\\\\world * input : hello\\\"world * output: \"hello\\\\\\\"world\" * input : hello\\\\\"world * output: \"hello\\\\\\\\\\\"world\" * input : hello world\\ * output: \"hello world\\\\\" */ *(target++) = L'\"'; start = target; quote_hit = 1; for (i = len; i > 0; --i) { *(target++) = source[i - 1]; if (quote_hit && source[i - 1] == L'\\\\') { *(target++) = L'\\\\'; } else if(source[i - 1] == L'\"') { quote_hit = 1; *(target++) = L'\\\\'; } else { quote_hit = 0; } } target[0] = L'\\0'; _wcsrev(start); *(target++) = L'\"'; return target; }\n\nMost developers expect that the spawn function properly escapes the command\narguments, and it\u2019s true in most cases.^3\n\nHowever, as I mentioned earlier, the CreateProcess function implicitly spawns\ncmd.exe when executing batch files. And unfortunately, the cmd.exe has\ndifferent escaping rules compared to the usual escaping mechanism.\n\n## Parsing rule of cmd.exe\n\nMost shells for Unix-like systems have similar (or the same) escaping rules;\nbackslashes (\\\\) are used as an escape character. So, if you want to escape a\ndouble quote (\") inside of a double-quoted string, you can use the backslash\nlike the following:\n\n    \n    \n    echo \"Hello \\\"World\\\"\"\n\nUsing backslash as the escape character seems to be a de facto standard, and\nother things like JSON or YAML also use it.\n\nHowever, when you execute the following command on the command prompt,\ncalc.exe will be executed:\n\n    \n    \n    echo \"\\\"&calc.exe\"\n\nThis is because the command prompt doesn\u2019t use the backslash as an escape\ncharacter, and uses the caret (^) instead.\n\nBack to the child_process example, it escapes the double quotes (\") in command\narguments using a backslash (\\\\). Due to the escaping rules of cmd.exe\nmentioned above, this escaping is not sufficient when executing the batch\nfile, so the following snippet spawns calc.exe even though the argument is\nseparated properly, and the shell option^4 is not enabled:\n\n    \n    \n    const { spawn } = require('child_process'); const child = spawn('./test.bat', ['\"&calc.exe']);\n\nBecause of this behavior, a malicious command line argument might be able to\nperform command injection, and this is the main problem of BatBadBut.\n\n# Mitigation\n\n## Escaping double quotes?\n\nThe problem here is that the double-quoted string is broken by the double\nquote inside of the string. So, it seems that escaping double quotes (\") with\na caret (^) is sufficient to prevent the command injection.^5\n\nBut in fact, that is not enough to prevent the command injection.\nSurprisingly, the command prompt parses and expands variables (e.g., %PATH%)\nbefore any other parsing.\n\nThis means that the following command will execute calc.exe although the\n&calc.exe is inside of the double-quoted string:\n\n    \n    \n    SET VAR=^\" echo \"%VAR%&calc.exe\"\n\nWhile the default environment variables of Windows don\u2019t contain the double\nquote (\") in their value, there is a special variable called CMDCMDLINE, that\ncontains the command line used to start the current command prompt session.\n\nAssuming that the following command is executed on the PowerShell,\n\"C:\\WINDOWS\\system32\\cmd.exe\" /c \"echo %CMDCMDLINE%\" will be printed:\n\n    \n    \n    cmd.exe /c \"echo %CMDCMDLINE%\"\n\nAnd, by using the variable substring extraction in the command prompt, it\u2019s\npossible to extract the double quote (\") from this variable. So, the following\ncommand spawns calc.exe when executed on PowerShell:\n\n    \n    \n    cmd.exe /c 'echo \"%CMDCMDLINE:~-1%&calc.exe\"'\n\nDue to this behavior, escaping double quotes with a caret is insufficient to\nprevent the command injection when executing the batch file, and requires\nfurther escaping. I\u2019ll explain about it in the next section.\n\n## As a Developer\n\nSince not all programming languages patched the issue^1, you should be careful\nwhen executing commands on Windows.\n\nAs a developer who executes commands on Windows, but doesn\u2019t want to execute\nbatch files, you should always specify the file extension of the command. For\nexample, the following code snippet may execute test.bat instead of test.exe\nif the user places test.bat in the directory included in the PATH environment\nvariable:\n\n    \n    \n    cmd := exec.Command(\"test\", \"arg1\", \"arg2\")\n\nTo prevent this, you should always specify the file extension of the command\nlike the following:\n\n    \n    \n    cmd := exec.Command(\"test.exe\", \"arg1\", \"arg2\")\n\nIf you want to execute batch files, and your runtime doesn\u2019t escape the\ncommand arguments properly for the batch file, you must escape user-controlled\ninput before using it as command arguments.\n\nSince spaces can\u2019t be escaped properly outside of the double-quoted string^6,\nyou have to use double quotes to wrap the command arguments. However, inside\nthe double-quoted string, % can\u2019t be escaped properly^7.\n\nTo solve this situation, the following tricky escaping is required:^8\n\n  1. Disable the automatic escaping that uses the backslash (\\\\) provided by the runtime.\n  2. Apply the following steps to each argument:\n\n    1. Replace percent sign (%) with %%cd:~,%.\n    2. Replace the backslash (\\\\) in front of the double quote (\") with two backslashes (\\\\\\\\).\n    3. Replace the double quote (\") with two double quotes (\"\").\n    4. Remove newline characters (\\n).\n    5. Enclose the argument with double quotes (\").\n\nBy replacing % with %%cd:~,%, %cd:~,% will be expanded to an empty string, and\nthe command prompt fails to expand the actual variable, so the % will be\ntreated as a normal character.\n\nPlease note that if delayed expansion is enabled via the registry value\nDelayedExpansion, it must be disabled by explicitly calling cmd.exe with the\n/V:OFF option. Also, note that the escaping for % requires the command\nextension to be enabled. If it\u2019s disabled via the registry value\nEnableExtensions, it must be enabled with the /E:ON option.\n\n## As a User\n\nTo prevent the unexpected execution of batch files, you should consider moving\nthe batch files to a directory that is not included in the PATH environment\nvariable. In this case, the batch files won\u2019t be executed unless the full path\nis specified, so the unexpected execution of batch files can be prevented.\n\n## As a Maintainer of the runtime\n\nIf you maintain a runtime of a programming language, I\u2019d recommend you\nimplement an additional escaping mechanism for batch files. Even if you don\u2019t\nwant to fix it on the runtime layer, you should at least document the issue\nand provide a proper warning to the users, as this problem is not well-known.\n\n# Conclusion\n\nIn this article, I explained the technical details of BatBadBut, a\nvulnerability that allows an attacker to perform command injection on Windows\nwhen the specific conditions are met. As I mentioned several times in this\narticle, this issue doesn\u2019t affect most applications, but in case you are\naffected, you should properly escape the command arguments manually.\n\nI hope that this article helps you to understand the severity of this issue\nand mitigate the issue properly.\n\n# Appendix\n\n## Appendix A: Flowchart to determine if your applications are affected\n\n## Appendix B: Status of the affected programming languages\n\nProject| Status  \n---|---  \nErlang| Patch available  \nGo| Documentation update  \nHaskell| Patch available  \nJava| Won\u2019t fix  \nNode.js| Patch available  \nPHP| Patch available  \nPython| Documentation update  \nRuby| Documentation update  \nRust| Patch available  \n  \n  1. Please refer to the Appendix B for the status of the affected programming languages. \u21a9\ufe0e \u21a9\ufe0e\n\n  2. As I use Node.js mostly, I\u2019m using it as an example here. However, the issue is not specific to Node.js, and it affects other programming languages as well. \u21a9\ufe0e\n\n  3. In fact, many programming languages guarantee that the command arguments are escaped properly, and/or don\u2019t use shell. \u21a9\ufe0e\n\n  4. When the shell option is disabled, the child_process module doesn\u2019t spawn cmd.exe and directly spawns the command instead. However, Windows implicitly spawns cmd.exe when executing batch files, so the shell option is silently ignored when executing batch files. \u21a9\ufe0e\n\n  5. Of course, you need to escape the caret itself. \u21a9\ufe0e\n\n  6. When executing .\\\\\\test.bat arg1^ arg2, arg1 and arg2 will be recognized as separate arguments. \u21a9\ufe0e\n\n  7. .\\\\\\test.bat \"100^%\" will be recognized as 100^% instead of 100%. \u21a9\ufe0e\n\n  8. While the testing shows that this prevents the command injection, I\u2019m still unsure if this escaping is the best way to prevent it, so if you are aware of a better way, please let me know. \u21a9\ufe0e\n\nCopyright \u00a9 2024 - Flatt Security Inc. \u00b7 All rights reserved - Privacy policy\n\nSearch\n\nResults\n\nNo results found\n\nTry adjusting your search query\n\n", "frontpage": true}
