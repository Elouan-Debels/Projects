{"aid": "39987658", "title": "Implement a List of Types in C++", "url": "https://www.codingwiththomas.com/blog/getting-started-with-typelists", "domain": "codingwiththomas.com", "votes": 1, "user": "abricq", "posted_at": "2024-04-10 06:45:24", "comments": 0, "source_title": "Getting Started With Typelists In C++ \u2014 Coding With Thomas", "source_text": "Getting Started With Typelists In C++ \u2014 Coding With Thomas\n\n0\n\nSkip to Content\n\nCoding With Thomas\n\nCoding With Thomas\n\n# [C++] Getting Started With Typelists\n\nApr 16\n\nWritten By Thomas\n\nFind this example here on compiler explorer.\n\nSince quite a while I started diving deeper into templates and typelists. I\ngoogled a lot and I highly recommend C++ Templates: The Complete Guide. For me\nit was and still is hard to find practical examples to understand certain\ndetails. Which is the reason I'll start from scratch and try to get one to\nbetter understand templates, typelists and metaprogramming.\n\nTo keep things simple, a typelist is just a list of different types. No\nvalues, just types. This can be done with variadic templates like this:\n\n    \n    \n    template<typename... Types> struct typelist{}; using short_bool_string_type = typelist<short, bool, std::string>;\n\nThis means our typelist is just an empty struct which accepts any number of\ntypes. Then we can define our type short_bool_string_type which represents now\nthe three types short, bool and string.\n\nPretty simple but we can't really do much with it by now. Let's create some\nfunctions to manipulate typelists.\n\n## Before we start...\n\nI will use the following style guide in this and the following articles:\n\n  * structs/classes are lower case, like struct foo {};\n  * template parameters are upper case, like template<typename Type>\n  * type alias are upper case, like using Type = int\n  * ending _t of a class/struct will represent a type\n  * ending _v of a class/struct will represent a value (probably not in this series)\n\nIn most cases when we use algorithms with templates and typelists, you will\nfind the template definition like: template<typename Head, typename... Tail>.\nThis can be sometimes confusing and to start with, consider the following\nfunction to print all types from a typelist:\n\n    \n    \n    template<typename Head, typename... Tail> void print_types(typelist<Head,Tail...>& t) { std::cout << typeid(Head).name() << '\\n'; typelist<Tail...> remaining_types; print_types(remaining_types); } template<typename Head> void print_types(typelist<Head>& t) { std::cout << typeid(Head).name() << '\\n'; }\n\nBy doing so, we'll get the first type in our list in Head and the rest in\nTail.... We can then create another list without Head and call print_types\nrecursively until only one type is left. Find this example here on compiler\nexplorer.\n\nAnd this helped me a lot to understand the basic idea behind typelist\nalgorithms, so let's get started with manipulating a typelist.\n\n## Accessing And Manipulating Front\n\nLike other containers (std::vector, std::array, etc.) we can access the first\nelement with front() and insert new elements. The same we'll do now with the\ntypelist. We create an alias front which gets the first type of our typelist.\n\n    \n    \n    template<typename... Types> class typelist{}; using short_bool_string_type = typelist<short, bool, std::string>; // class template for the first element template <typename List> struct front; // partial specialization for the front type template<typename Head, typename... Tail> struct front<typelist<Head, Tail...>> { using Type = Head; }; // front_t alias which accesses the front type from the given list template<typename List> using front_t = typename front<List>::Type; // if the first time is not short we'll get a compile error static_assert(std::is_same<short, front_t<short_bool_string_type>>());\n\nThis is all pretty static, let's create push_front and pop_front to manipulate\na typelist.\n\n    \n    \n    // class template for pop front template<typename List> struct pop_front; // partial specialization for pop front template<typename Head, typename... Tail> struct pop_front<typelist<Head, Tail...>> { using Type = typelist<Tail...>; // we create a new typelist without Head }; // pop_front_t alias to access the type of pop_front template<typename List> using pop_front_t = typename pop_front<List>::Type; // the type short_bool_string_type without short leaves a typelist with bool and string static_assert( std::is_same< typelist<bool, std::string>, pop_front_t<short_bool_string_type>>() );\n\nAnd also the implementation for push front:\n\n    \n    \n    // class template for push front template<typename Typelist, typename Element> struct push_front; // partial specialization for push front template<typename... Typelist, typename Element> struct push_front<typelist<Typelist...>, Element> { using Type = typelist<Element, Typelist...>; }; // push_front_t alias to access the type of push_front template<typename Typelist, typename Element> using push_front_t = typename push_front<Typelist, Element>::Type; // the type short_bool_string_type with a beginning int leaves a list with int short bool string static_assert( std::is_same< typelist<int, short, bool, std::string>, push_front_t<short_bool_string_type, int>>() );\n\n## Appending Types With push_back\n\nFinally we are implementing a push_back_t alias to append types to an existing\ntypelist:\n\n    \n    \n    // class template for push back template<typename Typelist, typename Element> struct push_back; // partial specialization for push back template<typename... Typelist, typename Element> struct push_back<typelist<Typelist...>, Element> { using Type = typelist<Typelist..., Element>; }; // push_back_t alias to access the type of push_back template<typename Typelist, typename Element> using push_back_t = typename push_back<Typelist, Element>::Type; // the type short_bool_string_type with a trailing int is a list with short bool string int static_assert( std::is_same< typelist<short, bool, std::string, int>, push_back_t<short_bool_string_type, int>>() );\n\n## Conclusion\n\nThis is the beginning of my typelist articles. I know this is at the beginning\npretty abstract without practical examples but we'll get to it after covering\nthe basics.\n\nIn the next articles I continue with some more typelist functions and then\nwe'll get to tuples. And ultimately I'll try to create a practical example\nwhere we use the code from here.\n\nYou can find this example here on compiler explorer.\n\nBut that's it for now.\n\nBest Thomas\n\nThomas\n\nPrevious\n\nPrevious\n\n## [C++] Tuples From Scratch\n\nNext\n\nNext\n\n## [C++] Tag Dispatching To Overload Functions\n\n2024 | Thomas Sedlmair | thomas.sedlmair@googlemail.com\n\n", "frontpage": false}
