{"aid": "39999019", "title": "If Inheritance is so bad, why does everyone use it?", "url": "https://buttondown.email/hillelwayne/archive/if-inheritance-is-so-bad-why-does-everyone-use-it/", "domain": "buttondown.email/hillelwayne", "votes": 22, "user": "harperlee", "posted_at": "2024-04-11 06:35:15", "comments": 17, "source_title": "If Inheritance is so bad, why does everyone use it?", "source_text": "If Inheritance is so bad, why does everyone use it? \u2022 Buttondown\n\nComputer Things\n\nMay 15, 2020\n\n# If Inheritance is so bad, why does everyone use it?\n\n## Alloy Workshop\n\nThere are still two slots available for the alloy workshop! I've been hard at\nwork adding a bunch of teaching innovations to the class, which I wanted to\ntalk about this time, but something more interesting came up.\n\n## If Inheritance is so bad, why does everyone use it?\n\nThis essay says that inheritance is harmful and if possible you should \"ban\ninheritance completely\". You see these arguments a lot, as well as things like\n\"prefer composition to inheritance\". A lot of these arguments argue that in\npractice inheritance has problems. But they don't preclude inheritance working\nin another context, maybe with a better language syntax. And it doesn't\nexplain why inheritance became so popular in the first place. I want to\nexplore what's fundamentally challenging about inheritance and why we all use\nit anyway.\n\nMy favorite essay on inheritance is Why inheritance never made any sense. In\nit Graham argues that there's actually three ways that we mean inheritance:\n\n>   1. Ontological inheritance is about specialisation: this thing is a\n> specific variety of that thing (a football is a sphere and it has this\n> radius)\n>   2. Abstract data type inheritance is about substitution: this thing\n> behaves in all the ways that thing does and has this behaviour (this is the\n> Liskov substitution principle)\n>   3. Implementation inheritance is about code sharing: this thing takes some\n> of the properties of that thing and overrides or augments them in this way.\n>\n\nSince conventional class-based inheritance conflates these three types of\ninheritance, it doesn't really satisfy any of them properly. This is what\nmakes it so challenging to use in practice. Things like abstract data types\nand modules and such only hit one of these kinds at a time, properly\nseparating the concerns and making them easier to use.\n\nSo then why do we use inheritance instead of ADTs and modules and stuff? And\nthat's where we need to look at the history.\n\n### History\n\nWhere did inheritance come from? As with many things in OOP, it comes from\nSIMULA-67. The creators, Dahl and Nygaard, introduced objects as a\ngeneralization of their SIMULA-I's simulation syntax. That's important to\nunderstand why inheritance works the way it does: it was originally designed\nfor use in simulation software. The first examples of inheritance are for\nmodeling customer orders and a jobshop simulation!\n\nSIMULA had a big influence on other object languages. Smalltalk credits it for\na lot of the design decisions. This meant that inheritance was pretty\nentrenched by the point that the alternative started appearing. And that's the\nkey point: inheritance came first. The idea of subtypes, or abstract data\ntypes, come from Barbara Liskov's CLU. That was six years later, in part based\non her knowledge of SIMULA. Notably, CLU was a research language, not an\nindustry language. ADTs only entered widespread industry use with Java\ninterfaces, about two decades after CLU.^1 In the intervening thirty years,\ninheritance was established by C++, Smalltalk, and Object Pascal.\n\nSimilarly, modularization was a concept for a while but modules only appeared\nas a first-class language component with Modula, which came out in 1975. Even\ntoday most industry languages don't have proper modules that encourage code\nspecialization. Most languages with \"modules\" are really just namespaces.\n\nTime to take off the Fact Hat and put on the Speculation Hat. It seems to me\nthat ADTs and modules were in part influenced by the existence of inheritance.\nPeople saw the idea and try to separate out the various concerns. This happens\nquite often in language design, and in fact any sort of technical development.\nOften people will introduce a practical innovation that sort of blends\ntogether a bunch of abstract concepts without knowing about those concepts\nbeforehand. It's only once the innovation is used in practice and people get a\nbetter \"intuition\" for it that they start to see the abstract concepts and try\nto tease them apart. Of course, once something becomes established it's very\nhard to get rid of. And because a lot of languages started out using\ninheritance, it became a common thing.\n\nSee also: everything else in software.\n\nIt's also notably the first case where we put a syntactic relationship between\ntwo classes. Surprisingly, it still remains one of the only ways to relate two\nclasses. You've basically got interfaces, traits/mixins, and inheritance, and\nthat's it. I suspect this is because most object relationships are domain-\nbased, and while language syntax tries to remain generality-based.\n\n### The better mousetrap\n\nThere is one part of the story we need to talk about though: can we do\ninheritance in a better way? The key language here is Eiffel, by Bertrand\nMeyer. Eiffel used to be a rising giant in the OOP world but has mostly faded\ninto irrelevance now. Among other things, almost all of the relationships were\ninheritance-based. There were no interfaces, no modules, no traits, etc.\nYou're even expected to use multiple inheritance quite regularly.\n\nThis isn't as bad as it sounds. Eiffel was designed from the start to avoid a\nlot of the pitfalls that you often see with inheritance. For example it\navoided the \"diamond problem\" with a robust renaming mechanism. It also had a\nreally interesting feature that made its inheritance a lot more powerful: code\ncontracts. You could place preconditions and postconditions on methods that\nwould be checked and every call. If you inherited the class, though, Eiffel\ncould guarantee that you could only weaken preconditions and only strengthen\npostconditions. This means that you can substitute a child class anywhere the\nparent class would be accepted and guarantee that all of the invariants were\nstill satisfied. That's a pretty cool language feature!\n\nIncidentally, Meyer also coined the \"open closed principle\", which is the O in\nSOLID. So his thinking on languages did have at least some effect on our\nmodern development, if somewhat indirect.\n\nUnfortunately, Eiffel also had a minor problem with inheritance. You see,\nEiffel is statically typed. The input types of a method's parameters are\neffectively preconditions. This means, to be type safe, you should only be\nable to \"weaken the preconditions\" on an inherited method's parameters' types,\nlike say \"instead of taking any natural number, this method can now take any\ninteger\". This is equivalent to replacing a type with its supertype, or\n\"contravariance\". But Meyer thought that \"wasn't useful\" and made method\nparameters covariant, replaceable with their subtypes. This makes the type\nsystem unsound.\n\nThey call this the \"CATcall\" problem and still haven't figured out how to fix\nit.^2\n\nSo yeah, inheritance has problems. I mean of course there are cases where you\ncan safely use it, and there are cases where it's the right choice, but it\ndefinitely shows signs of being a \"first-generation solution\".\n\n## Some thoughts on first-generation solutions\n\nProbably something bigger here worth exploring but that's getting further away\nfrom \"why inheritance\", so I'll leave that for another newsletter. Cheers!\n\n  1. Not 100% sure of this, C++'s Abstract Base Classes might have been earlier than interfaces, and ABCs are ADTs. But eh looking that up would be effort \u21a9\n\n  2. Changed Availability or Type. You can read more about this here. \u21a9\n\nIf you're reading this on the web, you can subscribe here. Updates are once a\nweek. My main website is here.\n\nDon't miss what's next. Subscribe to Computer Things:\n\nSubscribe\n\nBrought to you by Buttondown, the easiest way to start and grow your\nnewsletter.\n\n", "frontpage": true}
