{"aid": "39996521", "title": "ETag and HTTP Caching", "url": "https://rednafi.com/misc/etag_and_http_caching/", "domain": "rednafi.com", "votes": 6, "user": "nalgeon", "posted_at": "2024-04-10 22:51:47", "comments": 0, "source_title": "ETag and HTTP caching", "source_text": "ETag and HTTP caching | Redowan's Reflections\n\nHome \u00bb Misc\n\n# ETag and HTTP caching\n\nApril 10, 2024\n\nOne neat use case for the HTTP ETag header is client-side HTTP caching for GET\nrequests. Along with the ETag header, the caching workflow requires you to\nfiddle with other conditional HTTP headers like If-Match or If-None-Match.\nHowever, their interaction can feel a bit confusing at times.\n\nEvery time I need to tackle this, I end up spending some time browsing through\nthe relevant MDN docs^1^2^3 to jog my memory. At this point, I\u2019ve done it\nenough times to justify spending the time to write this.\n\n## Caching the response of a GET endpoint#\n\nThe basic workflow goes as follows:\n\n  * The client makes a GET request to the server.\n  * The server responds with a 200 OK status, including the content requested and an ETag header.\n  * The client caches the response and the ETag value.\n  * For subsequent requests to the same resource, the client includes the If-None-Match header with the ETag value it has cached.\n  * The server regenerates the ETag independently and checks if the ETag value sent by the client matches the generated one.\n\n    * If they match, the server responds with a 304 Not Modified status, indicating that the client\u2019s cached version is still valid, and the client serves the resource from the cache.\n    * If they don\u2019t match, the server responds with a 200 OK status, including the new content and a new ETag header, prompting the client to update its cache.\n\n    \n    \n    Client Server | | |----- GET Request -------------------->| | | |<---- Response 200 OK + ETag ----------| | (Cache response locally) | | | |----- GET Request + If-None-Match ---->| (If-None-Match == previous ETag) | | | Does ETag match? | |<---- Yes: 304 Not Modified -----------| (No body sent; Use local cache) | No: 200 OK + New ETag ----------| (Update cached response) | |\n\nWe can test this workflow with GitHub\u2019s REST API suite via the GitHub CLI^4.\nIf you\u2019ve installed the CLI and authenticated yourself, you can make a request\nlike this:\n\n    \n    \n    gh api -i /users/rednafi\n\nThis asks for the data associated with the user rednafi. The response looks as\nfollows:\n\n    \n    \n    HTTP/2.0 200 OK Etag: W/\"b8fdfabd59aed6e0e602dd140c0a0ff48a665cac791dede458c5109bf4bf9463\" { \"login\":\"rednafi\", \"id\":30027932, ... }\n\nI\u2019ve truncated the response body and omitted the headers that aren\u2019t relevant\nto this discussion. You can see that the HTTP status code is 200 OK and the\nserver has included an ETag header.\n\nThe W/ prefix indicates that a weak validator^5 is used to validate the\ncontent of the cache. Using a weak validator means when the server compares\nthe response payload to generate the hash, it doesn\u2019t do it bit-by-bit. So, if\nyour response is JSON, then changing the format of the JSON won\u2019t change the\nvalue of the ETag header since two JSON payloads with the same content but\nwith different formatting are semantically the same thing.\n\nLet\u2019s see what happens if we make the same request again while passing the\nvalue of the ETag in the If-None-Match header.\n\n    \n    \n    gh api -i -H \\ 'If-None-Match: W/\"b8fdfabd59aed6e0e602dd140c0a0ff48a665cac791dede458c5109bf4bf9463\"' \\ /users/rednafi\n\nThis returns:\n\n    \n    \n    HTTP/2.0 304 Not Modified Etag: \"b8fdfabd59aed6e0e602dd140c0a0ff48a665cac791dede458c5109bf4bf9463\" gh: HTTP 304\n\nThis means that the cached response in the client is still valid and it\ndoesn\u2019t need to refetch that from the server. So, the client can be coded to\nserve the previously cached data to the users when asked for.\n\nA few key points to keep in mind:\n\n  * Always wrap your ETag values in double quotes when sending them with the If-None-Match header, just as the spec says^6.\n\n  * Using the If-None-Match header to pass the ETag value means that the client request is considered successful when the ETag value from the client doesn\u2019t match that of the server. When the values match, the server will return 304 Not Modified with no body.\n\n  * If we\u2019re writing a compliant server, when it comes to If-None-Match, the spec tells us^7 to use a weak comparison for ETags. This means that the client will still be able to validate the cache with weak ETags, even if there have been slight changes to the representation of the data.\n\n  * If the client is a browser, it\u2019ll automatically manage the cache and send conditional requests without any extra work.\n\n## Writing a server that enables client-side caching#\n\nIf you\u2019re serving static content, you can configure your load balancer to\nenable this caching workflow. But for dynamic GET requests, the server needs\nto do a bit more work to allow client-side caching.\n\nHere\u2019s a simple server in Go that enables the above workflow for a dynamic GET\nrequest:\n\n    \n    \n    package main import ( \"crypto/sha256\" \"encoding/hex\" \"fmt\" \"net/http\" \"strings\" ) // calculateETag generates a weak ETag by SHA-256-hashing the content // and prefixing it with W/ to indicate a weak comparison func calculateETag(content string) string { hasher := sha256.New() hasher.Write([]byte(content)) hash := hex.EncodeToString(hasher.Sum(nil)) return fmt.Sprintf(\"W/\\\"%s\\\"\", hash) } func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { // Define the content within the handler content := `{\"message\": \"Hello, world!\"}` eTag := calculateETag(content) // Remove quotes and W/ prefix for If-None-Match header comparison ifNoneMatch := strings.TrimPrefix( strings.Trim(r.Header.Get(\"If-None-Match\"), \"\\\"\"), \"W/\") // Generate a hash of the content without the W/ prefix for comparison contentHash := strings.TrimPrefix(eTag, \"W/\") // Check if the ETag matches; if so, return 304 Not Modified if ifNoneMatch == strings.Trim(contentHash, \"\\\"\") { w.WriteHeader(http.StatusNotModified) return } // If ETag does not match, return the content and the ETag w.Header().Set(\"ETag\", eTag) // Send weak ETag w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(http.StatusOK) fmt.Fprint(w, content) }) fmt.Println(\"Server is running on http://localhost:8080\") http.ListenAndServe(\":8080\", nil) }\n\n  * The server generates a weak ETag for its content by creating a SHA-256 hash and adding W/ to the front, indicating it\u2019s meant for weak comparison.\n\nYou could make the calculateETag function format-agnostic, so the hash stays\nthe same if the JSON format changes but the content does not. The current\ncalculateETag implementation is susceptible to format changes, and I kept it\nthat way to keep the code shorter.\n\n  * When delivering content, the server includes this weak ETag in the response headers, allowing clients to cache the content along with the ETag.\n\n  * For subsequent requests, the server checks if the client has sent an ETag in the If-None-Match header and weakly compares it with the current content\u2019s ETag by independently generating the hash.\n\n  * If the ETags match, indicating no significant content change, the server replies with a 304 Not Modified status. Otherwise, it sends the content again with a 200 OK status and updates the ETag. When this happens, the client knows that the existing cache is still warm and can be served without any changes to it.\n\nYou can run the server by running go run main.go and from a different console\nstart making requests to it like this:\n\n    \n    \n    curl -i http://localhost:8080/foo\n\nThis will return the ETag header along with the JSON response:\n\n    \n    \n    HTTP/1.1 200 OK Content-Type: application/json Etag: W/\"1d3b4242cc9039faa663d7ca51a25798e91fbf7675c9007c2b0470b72c2ed2f3\" Date: Wed, 10 Apr 2024 15:54:33 GMT Content-Length: 28 {\"message\": \"Hello, world!\"}\n\nNow, you can make another request with the value of\n\nthe ETag in the If-None-Match header:\n\n    \n    \n    curl -i -H \\ 'If-None-Match: \"1d3b4242cc9039faa663d7ca51a25798e91fbf7675c9007c2b0470b72c2ed2f3\"' \\ http://localhost:8080/foo\n\nThis will return a 304 Not Modified response with no body:\n\n    \n    \n    HTTP/1.1 304 Not Modified Date: Wed, 10 Apr 2024 15:57:25 GMT\n\nIn a real-life scenario, you\u2019ll probably factor out the caching part in\nmiddleware so that all of your HTTP GET requests can be cached from the\nclient-side without repetition.\n\n## One thing to look out for#\n\nWhile writing a cache-enabled server, make sure the system is set up so that\nthe server always sends back the same ETag for the same content, even when\nthere are multiple servers working behind a load balancer. If these servers\ngive out different ETags for the same content, it can mess up how clients\ncache that content.\n\nClients use ETags to decide if content has changed. If the ETag value hasn\u2019t\nchanged, they know the content is the same and don\u2019t download it again, saving\nbandwidth and speeding up access. But if ETags are inconsistent across\nservers, clients might download content they already have, wasting bandwidth\nand slowing things down.\n\nThis inconsistency also means servers end up dealing with more requests for\ncontent that clients could have just used from their cache if ETags were\nconsistent.\n\n  1. Etag - MDN \u21a9\ufe0e\n\n  2. If-Match - MDN \u21a9\ufe0e\n\n  3. If-None-Match - MDN \u21a9\ufe0e\n\n  4. GitHub CLI \u21a9\ufe0e\n\n  5. Weak validation \u21a9\ufe0e\n\n  6. Double quote in conditional header values \u21a9\ufe0e\n\n  7. Use weak comparison for Etags while caching \u21a9\ufe0e\n\n## Recent posts\n\n* Crossing the CORS crossroad\n* Dysfunctional options pattern in Go\n* Einstellung effect\n* Strategy pattern in Go\n* Anemic stack traces in Go\n* Retry function in Go\n* Type assertion vs type switches in Go\n* Patching pydantic settings in pytest\n* Omitting dev dependencies in Go binaries\n* Eschewing black box API calls\n\n  * API\n  * Go\n\nblogroll \u2022 reads \u2022 uses\n\n\u00a9 2020-2024 Redowan Delowar\n\n", "frontpage": true}
