{"aid": "40045318", "title": "An unbiased evaluation of Python environment and packaging tools (2023)", "url": "https://alpopkes.com/posts/python/packaging_tools/", "domain": "alpopkes.com", "votes": 6, "user": "BerislavLopac", "posted_at": "2024-04-15 20:43:51", "comments": 0, "source_title": "An unbiased evaluation of environment management and packaging tools", "source_text": "An unbiased evaluation of environment management and packaging tools\n\n  * Posts\n\n  * Personal news\n  * My path to machine learning\n  * Books\n\n    * Personal reading List\n    * Deep work\n  * Machine Learning\n\n    * Bayesian linear regression\n    * Bayesian linear regression 2\n    * KL Divergence\n    * Principal component analysis (PCA)\n    * Support vector machines\n    * Variational Inference\n  * Python\n\n    * Mocking\n    * Packaging tools\n    * Magical Universe\n\n      * Start\n      * The Tales of Castle Kilmere\n      * Object-oriented programming\n      * Types of methods\n      * Type annotations\n      * To-string conversion\n      * Decorators\n      * Properties\n      * Underscore patterns\n      * Extending the universe\n      * Duck Typing\n      * Namedtuples\n      * Abstract Base Classes\n      * Data classes\n      * Immutable data classes\n      * Decorators in classes\n      * if __name__ == \"__main__\"\n      * Context managers\n      * Testing with pytest\n      * Iterators\n      * Multisets\n      * Extending the universe II\n      * Exception classes\n      * functools.wraps\n      * Defaultdict\n      * Config files\n      * Wrap up\n  * Software Engineering\n\n    * Intro to containers\n    * Intro to Docker\n    * Intro to virtual machines\n\n##### Anna-Lena Popkes\n\nThursday, August 24, 2023\n\n# An unbiased evaluation of environment management and packaging tools\n\n## Motivation^\n\nWhen I started with Python and created my first package I was confused.\nCreating and managing a package seemed much harder than I expected. In\naddition, multiple tools existed and I wasn\u2019t sure which one to use. I\u2019m sure\nmost of you had the very same problem in the past. Python has a zillion tools\nto manage virtual environments and create packages and it can be hard (or\nalmost impossible) to understand which one fits your needs. Several talks and\nblog post on the topic exist, but none of them gives a complete overview or\nevaluates the tools in a structured fashion. This is what this post is about.\nI want to give you a truly unbiased evaluation of existing packaging and\nenvironment management tools. In case you\u2019d rather watch a talk, take a look\nat the recording of PyCon DE 2023 or EuroPython 2023.\n\n## Categorization^\n\nFor the purpose of this article I identified five main categories that are\nimportant when it comes to environment and package management:\n\n  * Environment management (which is mostly concerned with virtual environments)\n  * Package management\n  * Python version management\n  * Package building\n  * Package publishing\n\nAs you can see in the Venn diagram below, lots of tools exist. Some can do a\nsingle thing (i.e. they are single-purpose), others can perform multiple tasks\n(hence I call them multi-purpose tools).\n\nLet\u2019s walk through the categories keeping a developers perspective in mind.\nLet\u2019s say you are working on a personal project alongside your work projects.\nAt work you\u2019re using Python 3.7 whereas your personal project should be using\nthe newest Python version (currently 3.11). In other words: you want to be\nable to install different Python versions and switch between them. That\u2019s what\nour first category, Python version management is about. Within your projects\nyou are using other packages (e.g. pandas or sklearn for data science). These\nare dependencies of your project that you have to install and manage (e.g.\nupgrade when new versions are released). This is what package management is\nabout. Because different projects might require different versions of the same\npackage you need to create (and manage) virtual environments to avoid\ndependency conflicts. Tools for this are collected in the category environment\nmanagement. Most tools use virtual environments, but some use another concept\ncalled \u201clocal packages\u201d which we will look at later. Once your code is in a\nproper state you might want to share it with fellow developers. For this you\nfirst have to build your package (package building) before you can publish it\nto PyPI or another index (package publishing).\n\nIn the following we will look at each of the categories in more detail,\nincluding a short definition, motivation and the available tools. I will\npresent some single-purpose tools in more detail and several multi-purpose\ntools in a separate section at the end. Let\u2019s get started with the first\ncategory: Python version management.\n\n## Python version management^\n\n### Definition^\n\nA tool that can perform Python version management allows you to install Python\nversions and switch between them easily.\n\n### Motivation^\n\nWhy would we want to use different Python versions? There are several reasons.\nFor example, you might be working of several projects where each projects\nrequires a different Python version. Or you might develop a project that\nsupports several Python versions and you want to test all of them. Besides\nthat it can be nice to check out what the newest Python version has to offer,\nor test a pre-release version of Python for bugs.\n\n### Tools^\n\nOur Venn diagram displays the available tools for Python version management:\npyenv, conda, rye and PyFlow. We will first look at pyenv and consider the\nmulti-purpose tools in a separate section.\n\n### pyenv^\n\nPython has one single-purpose tool that lets you install and manage Python\nversions: pyenv! Pyenv is easy to use. The most important commands are the\nfollowing:\n\n    \n    \n    # Install specific Python version pyenv install 3.10.4 # Switch between Python versions pyenv shell <version> # select version just for current shell session pyenv local <version> # automatically select version whenever you are in the current directory pyenv global <version> # select version globally for your user account\n\n## (Virtual) environment management^\n\n### Definition^\n\nA tool that can perform environment management allows you to create and manage\n(virtual) environments.\n\n### Motivation^\n\nWhy do we want to use environments in the first place? As mentioned in the\nbeginning, projects have specific requirements (i.e. they depend on other\npackages). It\u2019s often the case that different projects require different\nversions of the same package. This can cause dependency conflicts. In\naddition, problems can occur when using pip install to install a package\nbecause the package is placed with your system-wide Python installation. Some\nof these problems can be solved by using the --user flag in the pip command.\nHowever, this option might not be known to everyone, especially beginners.\n\n### Tools^\n\nMany tools allow users to create and manage environments. These are: venv,\nvirtualenv, pipenv, conda, pdm, poetry, hatch, rye and PyFlow. Only two of\nthem are single-purpose tools: venv and virtualenv. Let\u2019s look at both of them\nin more detail.\n\n### venv^\n\nVenv is the built-in Python package for creating virtual environments. This\nmeans that it is shipped with Python and does not have to be installed by the\nuser. The most important commands are the following:\n\n    \n    \n    # Create new environment python3 -m venv <env_name> # Activate an environment . <env_name>/bin/activate # Deactivate an active environment deactivate\n\n### virtualenv^\n\nVirtualenv tries to improve venv. It offers more features than venv and is\nfaster and more powerful. The most important commands are similar to the ones\nof venv, only creating a new environment is cleaner:\n\n    \n    \n    # Create new environment virtualenv <env_name> # Activate an environment . <env_name>/bin/activate # Deactivate an active environment deactivate\n\n## Recap I - pyproject.toml^\n\nBefore we can talk about packaging I want to make sure that you are aware of\nthe most important file for packaging: pyproject.toml.\n\nPackaging in Python has come a long way. Until PEP 518 setup.py files where\nused for packaging, using setuptools as a build tool. PEP 518 introduced the\nusage of a pyproject.toml file. As a consequence, you always need a\npyproject.toml file when creating a package. pyproject.toml is used to define\nthe settings of a project, define metadata and lots of other things. If you\nwould like to see an example check out the pyproject.toml file of the pandas\nlibrary. With the knowledge on pyproject.toml we can go on at take a look at\npackage management.\n\n## Package management^\n\n### Definition^\n\nA tool that can perform package management is able to download and install\nlibraries and their dependencies.\n\n### Motivation^\n\nWhy do we care about packages? Packages allow us to define a hierarchy of\nmodules and to access modules easily using the dot-syntax (from package.module\nimport my_function). In addition, they make it easy to share code with other\ndevelopers. Since each package contains a pyproject.toml file which defines\nits dependencies, other developers don\u2019t have to install the required packages\nseparately but can simply install the package from its pyproject.toml file.\n\n### Tools^\n\nLots of tools can perform package management: pip, pipx, pipenv, conda, pdm,\npoetry, rye and PyFlow. The single-purpose tool for package management is pip\nwhich is well known in the Python community.\n\n#### pip^\n\nThe standard package manager for Python is pip. It\u2019s shipped with Python and\nallows you to install packages from PyPI and other indexes. The main command\n(probably one of the first commands a Python developer learns) is pip install\n<package_name>. Of course, pip offers lots of other options. Check out the\ndocumentation for more information about available flags, etc.\n\n## Recap II - Lock file^\n\nBefore we go on to the multi-purpose tools, there is one more file that\u2019s\nimportant for packaging: the lock file. While pyproject.toml contains abstract\ndependencies, a lock file contains concrete dependencies. It records exact\nversions of all dependencies installed for a project (e.g. pandas==2.0.3).\nThis enables reproducibility of projects across multiple platforms. If you\nhave never seen a lock file before, take a look at this one from poetry:\n\n## Multi-purpose tools^\n\nKnowing about lock files we can start looking at tools that perform several\ntasks. We will start with pipenv and conda before we transition to packaging\ntools like poetry and pdm.\n\n### Pipenv^\n\nAs the name suggests, pipenv combines pip and virtualenv. It allows you to\nperform virtual environment management and package management as we can see in\nour Venn diagram:\n\npipenv introduces two additional files:\n\n  * Pipfile\n  * Pipfile.lock\n\nPipfile is a TOML file (similar to pyproject.toml) used to define project\ndependencies. It is managed by the developer when she invokes pipenv commands\n(like pipenv install). Pipfile.lock allows for deterministic builds. It\neliminates the need for a requirements.txt file and is managed automatically\nthrough locking actions .\n\nThe most important pipenv commands are:\n\n    \n    \n    # Install package pipenv install <package_name> # Run Python script within virtual env pipenv run <script_name.py> # Activate virtual env pipenv shell\n\n### Conda^\n\nConda is a general-purpose package management system. That means that it\u2019s not\nlimited to Python packages. Conda is a huge tool with lots of capabilities.\nLot\u2019s of tutorials and blog posts exist (for example the official one) so I\nwon\u2019t go into more detail here. However, I want to mention one thing: while it\nis possible to build and publish a package with conda I did not include the\ntool in the appropriate categories. That\u2019s because packaging with conda works\na little differently and the resulting packages will be conda packages.\n\n### Feature evaluation^\n\nLast but not least I want to present multi-purpose tools for packaging. I\npromised an unbiased evaluation. For this purpose I created a list of features\nthat I consider important when comparing different tools. The features are:\n\nDoes the tool manage dependencies?| ?  \n---|---  \nDoes it resolve/lock dependencies?| ?  \nIs there a clean build/publish flow?| ?  \nDoes it allow to use plugins?| ?  \nDoes it support PEP 660 (editable installs)?| ?  \nDoes it support PEP 621 (project metadata)?| ?  \n  \nRegarding the two PEPs: Python has a lot of open and closed PEPs on packaging.\nFor a full overview take a look at this page. I only included PEP 660 and PEP\n621 for specific reasons:\n\n  * PEP 660 is about editable installs for pyproject.toml based builds. When you install a package using pip you have the option to install it in editable mode using pip install -e package_name. This is an important features to have when you are developing a package and want your changes to be directly reflected in your environment.\n  * PEP 621 specifies how to write a project\u2019s core metadata in a pyproject.toml file. I added it because one package (spoiler: it\u2019s poetry) currently does not support this PEP but uses its own way for declaring metadata.\n\n### Flit^\n\nFlit tries to create a simple way to put Python packages and modules on PyPI.\nIt has a very specific use case: it\u2019s meant to be used for packaging pure\nPython packages (that is, packages without a build step). It doesn\u2019t care\nabout any of the other tasks:\n\n  * Python version management: \u274c\n  * Package management: \u274c\n  * Environment management: \u274c\n  * Building a package: \u2705\n  * Publishing a package: \u2705\n\nThis is also reflected in our Venn diagram:\n\n#### Feature evaluation^\n\nDoes the tool manage dependencies?| \u274c  \n---|---  \nDoes it resolve/lock dependencies?| \u274c  \nIs there a clean build/publish flow?| \u2705  \nDoes it allow to use plugins?| \u274c  \nDoes it support PEP 660 (editable installs)?| \u2705  \nDoes it support PEP 621 (project metadata)?| \u2705  \n  \n#### Main commands^\n\n    \n    \n    # Create new pyproject.toml flit init # Build and publish flit publish\n\n### Poetry^\n\nPoetry is a well known tool in the packaging world. As visible in the Venn\ndiagram it can do everything except for Python version management:\n\n  * Python version management: \u274c\n  * Package management: \u2705\n  * Environment management: \u2705\n  * Building a package: \u2705\n  * Publishing a package: \u2705\n\nTaking a look at the feature evaluation below you will see than Poetry does\nnot support PEP 621. There has been an open issue about this on GitHub for\nabout 1.5 years, but it hasn\u2019t been integrated into the main code base (yet).\n\n#### Feature evaluation^\n\nDoes the tool manage dependencies?| \u2705  \n---|---  \nDoes it resolve/lock dependencies?| \u2705  \nIs there a clean build/publish flow?| \u2705  \nDoes it allow to use plugins?| \u2705  \nDoes it support PEP 660 (editable installs)?| \u2705  \nDoes it support PEP 621 (project metadata)?| \u274c  \n  \n#### Main commands^\n\n    \n    \n    # Create directory structure and pyproject.toml poetry new <project_name> # Create pyproject.toml interactively poetry init # Install package from pyproject.toml poetry install\n\n#### Dependency management^\n\n    \n    \n    # Add dependency poetry add <package_name> # Display all dependencies poetry show --tree\n\n#### Running code^\n\n    \n    \n    # Activate virtual env poetry shell # Run script within virtual env poetry run python <script_name.py>\n\n#### Lock file^\n\nWhen installing a package for the first time, Poetry resolves all dependencies\nlisted in your pyproject.toml file and downloads the latest version of the\npackages. Once Poetry has finished installing, it writes all the packages and\nthe exact versions that it downloaded to a poetry.lock file, locking the\nproject to those specific versions. It\u2019s recommended to commit the lock file\nto your project repo so that all people working on the project are locked to\nthe same versions of dependencies. To update your dependencies to the latest\nversions, use the poetry update command.\n\n#### Build/publish flow^\n\n    \n    \n    # Package code (creates `.tar.gz` and `.whl` files) poetry build # Publish to PyPI poetry publish\n\n### PDM^\n\nPDM is a relatively new package and dependency manager (started in 2019) that\nis strongly inspired by Poetry and PyFlow. You will notice that I\u2019m not\ntalking about PyFlow in this article. That\u2019s because PyFlow is not actively\ndeveloped anymore - a must in the quickly evolving landscape of packaging.\nBeing a new(er) tool, PDM requires Python 3.7 or higher. Another difference to\nother tools is that PDM allows users to choose a build backend. PDM is the\nonly tool (apart from PyFlow) that implements PEP 582 on local packages, an\nalternative way of implementing environment management. Note that this PEP was\nrecently rejected.\n\nAs visible in the Venn diagram, PDM sits right next to Poetry. That means that\nit can do everything except for Python version management:\n\n  * Python version management: \u274c\n  * Package management: \u2705\n  * Environment management: \u2705\n  * Building a package: \u2705\n  * Publishing a package: \u2705\n\nThe main commands of PDM are similar to Poetry. However, less commands exist.\nFor example, there is no pdm shell or pdm new at the moment.\n\n#### Feature evaluation^\n\nDoes the tool manage dependencies?| \u2705  \n---|---  \nDoes it resolve/lock dependencies?| \u2705  \nIs there a clean build/publish flow?| \u2705  \nDoes it allow to use plugins?| \u2705  \nDoes it support PEP 660 (editable installs)?| \u2705  \nDoes it support PEP 621 (project metadata)?| \u2705  \n  \n#### Creating a new project^\n\n    \n    \n    # Create pyproject.toml interactively pdm init # Install package from pyproject.toml pdm install\n\n#### Dependency management^\n\n    \n    \n    # Add dependency pdm add <package_name> # Display all dependencies pdm list --graph\n\n#### Running code^\n\n    \n    \n    # No pdm shell command # Run script within env pdm run python <script_name.py>\n\n#### Lock file^\n\nThe locking functionality of PDM is similar to Poetry. When installing a\npackage for the first time, PDM resolves all dependencies listed in your\npyproject.toml file and downloads the latest version of the packages. Once PDM\nhas finished installing, it writes all packages and the exact versions that it\ndownloaded to a pdm.lock file, locking the project to those specific versions.\nIt\u2019s recommended to commit the lock file to your project repo so that all\npeople working on the project are locked to the same versions of dependencies.\nTo update your dependencies to the latest versions, use the pdm update\ncommand.\n\n#### Build/publish flow^\n\n    \n    \n    # Package code (creates `.tar.gz` and `.whl` files) pdm build # Publish to PyPI pdm publish\n\n### Hatch^\n\nHatch can perform the following tasks:\n\n  * Python version management: \u2705\n  * Package management: \u274c\n  * Environment management: \u2705\n  * Building a package: \u2705\n  * Publishing a package: \u2705\n\nIt should be noted that the author of Hatch promised that locking\nfunctionality will be added soon, which should also enable package management.\nPlease make sure to check the latest version of Hatch to see if this has been\nimplemented when you read this article.\n\nUpdate: Since version 1.8.0, Hatch provides the ability to manage Python\ninstallations, e.g. using hatch python install. Currently, only major.minor\nversions can be installed like 3.7 or 3.8, but not specific patches like\n3.7.4.\n\n#### Feature evaluation^\n\nDoes the tool manage dependencies?| \u274c  \n---|---  \nDoes it resolve/lock dependencies?| \u274c  \nIs there a clean build/publish flow?| \u2705  \nDoes it allow to use plugins?| \u2705  \nDoes it support PEP 660 (editable installs)?| \u2705  \nDoes it support PEP 621 (project metadata)?| \u2705  \n  \n#### Creating a new project^\n\n    \n    \n    # Create directory structure and pyproject.toml hatch new <project_name> # Interactive mode hatch new -i <project_name> # Initialize existing project / create pyproject.toml hatch new --init\n\n#### Dependency management^\n\n    \n    \n    # Packages are added manually to pyproject.toml hatch add <package_name> # This command doesn't exist! # Display dependencies hatch dep show table\n\n#### Running code^\n\n    \n    \n    # Activate virtual env hatch shell # Run script within virtual env hatch run python <script_name.py>\n\n#### Build/publish flow^\n\n    \n    \n    # Package code (creates `.tar.gz` and `.whl` files) hatch build # Publish to PyPI hatch publish\n\n#### Declarative environment management^\n\nSpecial about Hatch is that it allows you to configure your virtual\nenvironments within the pyproject.toml file. In addition it lets you define\nscripts specifically for an environment. And example use case for this is code\nformatting.\n\n### Rye^\n\nRye was recently developed by Armin Ronacher (first release May 2023), the\ncreator of the Flask framework. It is strongly inspired by rustup and cargo,\nthe packaging tools of the programming language Rust. Rye is written in Rust\nand is able to perform all tasks in our Venn diagram:\n\n  * Python version management: \u2705\n  * Package management: \u2705\n  * Environment management: \u2705\n  * Building a package: \u2705\n  * Publishing a package: \u2705\n\nCurrently, Rye does not have a plugin interface. However, since new releases\nare published on a regular basis, this might be added in the future.\n\n#### Feature evaluation^\n\nDoes the tool manage dependencies?| \u2705  \n---|---  \nDoes it resolve/lock dependencies?| \u2705  \nIs there a clean build/publish flow?| \u2705  \nDoes it allow to use plugins?| \u274c  \nDoes it support PEP 660 (editable installs)?| \u2705  \nDoes it support PEP 621 (project metadata)?| \u2705  \n  \n#### Creating a new project^\n\n    \n    \n    # Create directory structure and pyproject.toml rye init <project_name> # Pin a Python version rye pin 3.10\n\n#### Dependency management^\n\n    \n    \n    # Add dependency - this does not install the package! rye add <package_name> # Synchronize virtual envs, lock file, etc. # This install packages and Python versions rye sync\n\n#### Running code^\n\n    \n    \n    # Activate virtual env rye shell # Run script within virtual env rye run python <script_name.py>\n\n#### Build/publish flow^\n\n    \n    \n    # Package code (creates `.tar.gz` and `.whl` files) rye build # Publish to PyPI rye publish\n\n### Overview^\n\nFlit| Poetry| PDM| Hatch| Rye  \n---|---|---|---|---  \nDoes the tool manage dependencies?| \u274c| \u2705| \u2705| \u274c| \u2705  \nDoes it resolve/lock dependencies?| \u274c| \u2705| \u2705| \u274c| \u2705  \nIs there a clean build/publish flow?| \u2705| \u2705| \u2705| \u2705| \u2705  \nDoes it allow to use plugins?| \u274c| \u2705| \u2705| \u2705| \u274c  \nDoes it support PEP 660 (editable installs)?| \u2705| \u2705| \u2705| \u2705| \u2705  \nDoes it support PEP 621 (project metadata)?| \u2705| \u274c| \u2705| \u2705| \u2705  \n  \n## Tools that do not fit the categories^\n\nSome tools exist which don\u2019t fit into any of my categories. These are:\n\n  * pip-tools which helps to keep the versions of your pip-based packages up-to-date.\n  * tox and nox which are mainly used for testing but also handles virtual environments.\n\nImprove this page\n\nPrev\n\nMocking in Python\n\nNext\n\n100 Days of code - Creating my personal Magical Universe\n\n##### Table of Contents\n\n##### Navigation\n\n  * About\n  * Skills\n  * Experiences\n  * Education\n  * Projects\n  * Talks & Podcasts\n  * Recent Posts\n\n##### Contact me:\n\n  * popkes@gmx.net\n\nToha\n\n\u00a9 2020-2021 Copyright.\n\nPowered by\n\n", "frontpage": true}
