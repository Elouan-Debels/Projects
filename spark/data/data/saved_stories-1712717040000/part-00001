{"aid": "39984026", "title": "Python 3.13 starts to support Android officially", "url": "https://peps.python.org/pep-0738/", "domain": "python.org", "votes": 2, "user": "synergy20", "posted_at": "2024-04-09 20:42:23", "comments": 0, "source_title": "PEP 738 \u2013 Adding Android as a supported platform | peps.python.org", "source_text": "PEP 738 \u2013 Adding Android as a supported platform | peps.python.org\n\n# Python Enhancement Proposals\n\n  * Python \u00bb\n  * PEP Index \u00bb\n  * PEP 738\n\n# PEP 738 \u2013 Adding Android as a supported platform\n\nAuthor:\n\n    Malcolm Smith <smith at chaquo.com>\nSponsor:\n\n    Petr Viktorin <encukou at gmail.com>\nDiscussions-To:\n\n    Discourse thread\nStatus:\n\n    Accepted\nType:\n\n    Standards Track\nCreated:\n\n    12-Dec-2023\nPython-Version:\n\n    3.13\nResolution:\n\n    Discourse message\n\n## Abstract\n\nThis PEP proposes adding Android as a supported platform in CPython. The\ninitial goal is for Android to achieve Tier 3 support in Python 3.13.\n\nThis PEP is based on PEP 730 \u2013 \u201cAdding iOS as a supported platform\u201d by Russell\nKeith-Magee, and covers many of the same issues. Notable differences between\nthe two platforms can be found by searching for the word \u201ciOS\u201d.\n\n## Motivation\n\nOver the last 15 years, mobile platforms have become increasingly important\nparts of the computing landscape. Android is the operating system that runs on\nabout 70% of these devices. However, there is no official support for Android\nin CPython.\n\nThe Chaquopy, BeeWare and Kivy projects have all supported Android for many\nyears, and they have all been used to generate applications that have been\naccepted for publication in the Google Play Store. This demonstrates the\ntechnical feasibility of Android support.\n\nIt is important for the future of Python as a language that it is able to be\nused on any platform that has widespread adoption. Otherwise, potential users\nwill choose other languages that do provide support for these platforms. This\nis especially true in education, where the next generation of developers is in\nmany cases already spending more time using mobile platforms than desktop\nones.\n\n## Rationale\n\n### General\n\nAndroid is broadly a POSIX platform, based on a Linux kernel and the ELF\nbinary format. It does not use glibc, instead providing its own C library\nimplementation called Bionic. As a result, it is generally not binary-\ncompatible with any other Linux distribution, even if the architecture\nmatches. It also has its own filesystem layout which doesn\u2019t resemble any\nother Unix.\n\nHowever, Android\u2019s source-compatibility with Linux is quite good. In its early\nyears, the C library was very incomplete, but most of the gaps were filled by\naround 2014. Since then, any C code that compiles for Linux can usually be\ncompiled for Android, unless it involves direct access to hardware devices or\noperating system services.\n\nThis is also true of CPython. Although it has never officially supported\nAndroid, recent versions (since 3.6) can already be compiled for Android with\nminimal patching.\n\n### OS versions\n\nEach Android version can be identified in three ways:\n\n  * A conventional dotted version number (though recent versions have all used whole numbers)\n  * A sequential integer \u201cAPI level\u201d (the most common form in developer documentation)\n  * An alphabetic confectionery-themed code name (no longer used for marketing, but still appears in developer documentation)\n\nThere is no consistent pattern to link one of these to another; they must be\nlooked up in a table.\n\nA new major Android version is released each year, but the updates available\nto each device are entirely under the control of its manufacturer.\nUnfortunately many manufacturers stop sending updates to devices long before\ntheir users are ready to dispose of them. For example, as of October 2023, the\noldest Android version still receiving security updates was API level 30, but\naccording to Google\u2019s own statistics, only 60% of devices were on that version\nor newer.\n\nFor Python 3.13 we therefore propose the minimum Android version to be 5.0\n(API level 21), which was released in 2014. According to the statistics above,\nthis would cover 99% of active devices.\n\n### Development tools\n\nThe Android development tools are equally supported on Linux (x86_64), Windows\n(x86_64) and macOS (x86_64 and ARM64). For CPython, the most important tools\nare:\n\n  * The NDK (native development kit) contains a C and C++ compiler (clang), linker (lld), and headers for all the system libraries.\n\nBinary compatibility between libraries compiled with different versions of the\nNDK is generally very good, but for reproducibility it would be best for each\nPython version to stick with one NDK version throughout its life. For Python\n3.13, this would be the current NDK long-term support version, r26.\n\nEach NDK version can be set to target any of a wide range of Android versions.\nFor example, NDK r26 supports API levels 21 to 34. However, binaries compiled\nfor an older Android version will usually keep on working indefinitely on\nnewer versions; exceptions to this rule are only made for security reasons.\n\n  * Gradle is the tool used to build complete, deployable apps.\n  * The emulator, based on QEMU, is a simulated Android device running on a development machine. Unlike on iOS, an emulator uses the same ABI as a real device of the same architecture, and can run the same binaries.\n\nThese tools may all be used either from the command line, or through the\nAndroid Studio IDE, which is based on IntelliJ IDEA.\n\n### Architectures\n\nAndroid currently supports 4 architectures. Their names as used by the Android\ntools are:\n\n  * armeabi-v7a\n  * arm64-v8a\n  * x86\n  * x86_64\n\nVirtually all current physical devices use one of the ARM architectures. x86\nand x86_64 are supported for use in the emulator.\n\nFor Python 3.13 we propose that Tier 3 support will only cover the 64-bit\nplatforms (arm64-v8a and x86_64):\n\n  * x86 has not been supported as a development platform since 2020, and no new emulator images have been released since then.\n  * armeabi-v7a\u2019s proportion of active devices is now less than 10% and steadily falling.\n\nIt would also be more difficult to cover with a reliable buildbot, since there\nare no native hosts available for the emulator (ARM64 Macs don\u2019t have hardware\nsupport for ARM32 code). Although cross-architecture emulation is possible, it\nhas much worse performance and stability, which is why the armeabi-v7a\nemulator images have not been updated since 2016.\n\nHowever, it continues to be used for watches and ultra-low-cost phones. If\nthis persists, we may need to consider adding it in a future Python version.\n\nEven if 32-bit architectures are not officially supported, no changes should\nbe made which would impede any downstream projects which still wish to build\nthem.\n\n### App lifecycle\n\nThe primary programming language in Android apps is Java, or its modern\ndescendant Kotlin. As such, an app does not provide its own executable file.\nInstead, all apps start off as a Java virtual machine running an executable\nprovided by the operating system. The app\u2019s Java code can then add native code\nto the process by loading dynamic libraries and calling them through JNI.\n\nUnlike iOS, creating subprocesses is supported on Android. However apps may\nonly run executables in certain locations, none of which are writable at\nruntime. Long-running subprocesses are officially discouraged, and are not\nguaranteed to be supported in future Android versions.\n\nAndroid does provide a command-line shell, but this is intended only for use\nby developers, and is not available to the typical end user.\n\nFor these reasons, the recommended way of running Python on Android will be by\nloading libpython3.x.so into the main app process. A python3.x executable will\nnot be officially supported on this platform.\n\n## Specification\n\n### Scope of work\n\nThe focus of this work will be to produce an Android equivalent to the\nexisting Windows embeddable package, i.e. a set of compiled libraries which\ndevelopers can add to their apps. No installer will be required.\n\nAdding Android as a Tier 3 platform only requires adding support for compiling\nan Android-compatible build from the unpatched CPython source code. It does\nnot necessarily require there to be any officially distributed Android\nartifacts on python.org, although these could be added in the future.\n\nAndroid will be built using the same configure and Makefile system as other\nPOSIX platforms, and must therefore be built on a POSIX platform. Both Linux\nand macOS will be supported.\n\nA Gradle project will be provided for the purpose of running the CPython test\nsuite. Tooling will be provided to automate the process of building the test\nsuite app, starting the emulator, installing the test suite, and executing it.\n\n### Linkage\n\nFor the reasons discussed in App lifecycle, Python will be included in the app\nas a dynamic libpython3.x.so library which can be loaded into an app using\ndlopen.\n\nUnlike Linux, Android does not implicitly use a dlopened library to resolve\nrelocations in subsequently-loaded libraries, even if RTLD_GLOBAL is used. All\nPython extension modules must therefore be explicitly linked against\nlibpython3.x.so when building for Android.\n\nAn extension module linked against libpython3.x.so cannot be loaded by an\nexecutable that has been statically linked against libpython3.x.a. Therefore,\na static libpython3.x.a library will not be supported on Android. This is the\nsame pattern used by CPython on Windows.\n\nThis approach also allows using the -Wl,--no-undefined option to detect\nmissing symbols at build time, which can be a significant time-saver.\n\nUnlike iOS, Android allows dynamic libraries to be loaded from any location,\nso a directory tree containing co-located .py, .pyc and .so files can be\nhandled by Python\u2019s standard importer.\n\n### Standard library\n\n#### Unsupported modules\n\nA number of standard library modules will not be supported on Android because\nthe underlying C APIs are not available:\n\n  * curses and readline\n  * dbm.gnu and dbm.ndbm\n  * grp\n  * multiprocessing \u2013 although subprocesses in general are allowed (see App lifecycle), Android does not support any part of the System V IPC API.\n  * tkinter and turtle \u2013 these would require an Android build of Tk itself, which is not officially supported.\n\n#### sys\n\nsys.platform will return \"android\". Although Android is based on Linux, it\ndiffers in enough significant ways that a separate name is justified.\n\nWhen embedded in an Android app, the C-level stdio streams are not connected\nto anything. So in this mode, sys.stdout and sys.stderr will be redirected to\nthe system Logcat, which can be viewed with the Android development tools.\nsys.stdin will always return EOF.\n\n#### platform\n\nMost of the values returned by the platform module will match those returned\nby os.uname(), with the exception of:\n\n  * platform.system() - \"Android\", instead of the default \"Linux\"\n  * platform.release() - Android version number, as a string (e.g. \"14\"), instead of the Linux kernel version\n\nIn addition, a platform.android_ver() method will be added, which returns a\nnamedtuple containing the following:\n\n  * release - Android version of the device, as a string (e.g. \"14\")\n  * api_level - API level of the device, as an integer (e.g. 34)\n  * min_api_level - Minimum API level this build of Python can run on, as an integer (e.g. 23). This is the same as sys.getandroidapilevel.\n  * manufacturer - manufacturer of the device, as a string (e.g. \"Google\")\n  * model - model name of the device, as a string (e.g. \"Pixel 7\")\n  * device - device name of the device, as a string (e.g. \"panther\")\n\nWhich one of model and device is more likely to be unique, and which one is\nmore likely to resemble the marketing name, varies between different\nmanufacturers.\n\n#### os\n\nos.uname() will return the raw result of a POSIX uname() call. This will\nresult in the following values:\n\n  * sysname - \"Linux\"\n  * release - The Linux kernel version (e.g. \"5.10.157-android13-4-00003-gdfb1120f912b-ab10994928\")\n\nThis approach treats the os module as a \u201craw\u201d interface to system APIs, and\nplatform as a higher-level API providing more generally useful values.\n\n### CI resources\n\nSince Android emulators and physical devices use the same ABI, and come with\nidentical or very similar operating system binaries, testing on emulators will\nbe adequate. x86_64 emulators can be run on Linux, macOS or Windows, but ARM64\nemulators are only supported on ARM64 Macs.\n\nAnaconda has offered to provide physical hardware to run Android buildbots.\nThese will include both Linux x86_64 and macOS ARM64 machines, which would\ncover both supported runtime architectures and both supported build platforms.\n\nCPython does not currently test Tier 3 platforms on GitHub Actions, but if\nthis ever changes, their Linux and macOS runners are also able to host Android\nemulators. macOS ARM64 runners have been free to all public repositories since\nJanuary 2024.\n\n### Packaging\n\nAndroid wheels will use tags in the format android_<api-level>_<abi>. For\nexample:\n\n  * android_21_arm64_v8a\n  * android_21_x86_64\n\nFor the meaning of <api-level>, see OS versions. In the context of the wheel\ntag, it indicates the minimum Android version that was selected when the wheel\nwas compiled. Installation tools such as pip should interpret this in a\nsimilar way to the existing macOS tags, i.e. an app with a minimum API level\nof N can incorporate wheels tagged with API level N or older.\n\nThis format originates from the Chaquopy project, which currently maintains a\nwheel repository with tags varying between API levels 16 and 21.\n\nHowever, relying on a small group of Android enthusiasts to build the whole\nPython ecosystem is not a scalable solution. Until prominent libraries\nroutinely release their own Android wheels, the ability of the community to\nadopt Python on Android will be limited.\n\nTherefore, it will be necessary to clearly document how projects can add\nAndroid builds to their CI and release tooling. Adding Android support to\ntools like crossenv and cibuildwheel may be one way to achieve this.\n\nThe Android wheel tag format should also be added to the list of tags accepted\nby PyPI.\n\n### PEP 11 Update\n\nPEP 11 will be updated to include the two supported Android ABIs. Autoconf\nalready identifies them with the following triplets:\n\n  * aarch64-linux-android\n  * x86_64-linux-android\n\nPetr Viktorin will serve as the initial core team contact for these ABIs.\n\n## Backwards Compatibility\n\nAdding a new platform does not introduce any backwards compatibility concerns\nto CPython itself. However, there may be some backwards compatibility\nimplications on the projects that have historically provided CPython support\n(i.e., BeeWare and Kivy) if the final form of any CPython patches don\u2019t align\nwith the patches they have historically used.\n\n## Security Implications\n\nAdding a new platform does not add any new security implications.\n\n## How to Teach This\n\nThe education needs related to this PEP relate to two groups of developers.\n\nFirst, developers of apps need to know how to build Python into an Android\napp, along with their own Python code and any supporting packages, and how to\nuse them all at runtime. The documentation will cover this in a similar form\nto the existing Windows embeddable package. However, it will recommend most\ndevelopers to use higher-level tools such as Briefcase, Chaquopy and\nBuildozer, all of which already have comprehensive documentation.\n\nSecond, developers of packages with binary components need to know how to\nbuild and release them for Android (see Packaging).\n\n## Reference Implementation\n\nThe Chaquopy repository contains a reference patch and build scripts. These\nwill have to be decoupled from the other components of Chaquopy before they\ncan be upstreamed.\n\nBriefcase provides a reference implementation of code to execute test suites\non Android devices and emulators. The Toga Testbed is an example of a test\nsuite that is executed on the Android emulator using GitHub Actions.\n\n## Copyright\n\nThis document is placed in the public domain or under the CC0-1.0-Universal\nlicense, whichever is more permissive.\n\nSource: https://github.com/python/peps/blob/main/peps/pep-0738.rst\n\nLast modified: 2024-03-27 23:20:58 GMT\n\n", "frontpage": false}
