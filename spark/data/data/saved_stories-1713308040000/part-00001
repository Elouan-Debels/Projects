{"aid": "40054327", "title": "Type-Enforced Access Control with Go Generics", "url": "https://render.com/blog/how-render-enforces-access-controls-with-go-generics", "domain": "render.com", "votes": 1, "user": "anurag", "posted_at": "2024-04-16 16:51:58", "comments": 0, "source_title": "How Render Enforces Access Controls with Go Generics | Render Blog", "source_text": "How Render Enforces Access Controls with Go Generics | Render Blog\n\nSign In\n\nGet Started\n\nApril 16, 2024\n\n# How Render Enforces Access Controls with Go Generics\n\nShawn Moore\n\nApril 16, 2024\n\nShawn Moore\n\nRender takes your infrastructure problems away and gives you a battle-tested,\npowerful, and cost-effective cloud with an outstanding developer experience.\nFocus on building your apps, shipping fast, and delighting your customers, and\nleave your cloud infrastructure to us.\n\nTry Render Free\n\nLast year, Render introduced support for member roles, enabling admins to\nrestrict access to team-level actions (like updating payment details or\ntoggling mandatory 2FA). This week, we added the ability for admins to\nrestrict potentially destructive actions in project environments, such as\ndeleting a service. It's vital to get role enforcement right. From the day we\nkicked off the project, our priority has been to ensure that access policies\nare applied consistently, with no escape hatches that can lead to privilege\nescalation. To achieve this, we wanted compile-time guarantees in our Go\ncodebase that would prevent our engineers from creating such an escape hatch\neven by accident. Let's take a peek under the hood and explore how we\nimplemented these guarantees using Go generics.\n\n## Background\n\nPrior to the addition of member roles, Render's permissions model was as basic\nas it gets: every member of a Render team could perform every team action.\nThis usually worked fine for small teams, but our larger customers were\n(rightly) wary of granting full account access to tens or hundreds of people.\nAn improved permissions system became one of our most requested features. As\ndesign began, we knew our implementation would use the industry best practice\nof Role-Based Access Control (RBAC):\n\n  * Each team member is assigned a role (we currently support two roles: Admin and Developer).\n  * Render defines a set of individual permissions (such as \"can invite new team members\" or \"can view billing information\").\n  * Render enforces a set of policies that map roles to permissions (\"Admins can delete their team, Developers cannot\").\n\nThe question was, how could we most effectively incorporate a strictly-\nenforced, fine-grained permissions model into our existing Go codebase?\n\n## Non-starter: Basic runtime checks\n\nAs a thought experiment, we considered the simplest approach to implement:\nfolding permission checks into existing runtime logic that verifies a user's\nteam membership before authorizing an action. Every time our code made a\nmembership check, we'd make an additional check for the user's role. This\nwould enable us to differentiate protected team actions (like \"remove team\nmember\") from universal actions (like \"list team members\"):\n\nWe immediately rejected this strategy, because it was opt-in\u2014nothing would\nhave protected us from forgetting to add the correct role check for a\nparticular action. Because of this (not to mention the immense amount of\nexisting code we'd need to audit), we knew we couldn't trust that this\nsolution was fully secure.\n\n## Pivoting to compile time\n\nWe needed to enforce an invariant across our entire codebase\u2014namely, one that\nprevented engineers from accidentally circumventing permission checks. The\ntypical approach would lead to user-facing errors at runtime:\n\nBy instead enforcing this at compile time, we could surface errors to\nengineers before those errors even made it into a pull request:\n\nConveniently for us, in a strongly-typed language like Go, the type system\nitself is ideal for doing exactly this. We used the opaque type pattern, which\nbuilds on top of Go's visibility rules. Opaque types ensure at compile time\nthat the necessary permission check always occurs. Let's look at an example.\nIn the snippet below, we create a simple wrapper struct (AuthorizedProject)\naround our existing Project type:\n\n    \n    \n    package rbac type AuthorizedProject struct { // Public struct project *Project // Private field } func AuthorizeProject( project *Project, user *User, permission ProjectPermission, ) (*AuthorizedProject, error) { // [Logic to perform permission check] return &AuthorizedProject{project: project}, nil } func (t *AuthorizedProject) Project() *Project { return t.project }\n\nGo\n\n(Projects enable teams to organize their Render services by application and\nenvironment.) The AuthorizedProject struct is public so that other packages\ncan refer to it, but its project field is private. Only code in this rbac\npackage\u2014such as the AuthorizeProject constructor\u2014can directly access the inner\nProject. The only way to create an AuthorizedProject struct is via the\nAuthorizeProject() constructor, which ensures that a permission check occurs\nas part of initialization. This in turn helps us avoid needlessly re-checking\npermissions throughout our stack: by passing around an AuthorizedProject\ninstead of a plain Project, we guarantee that the original caller performed a\npermission check.\n\nNote that this design requires separate execution paths for reads and writes\nto the same entity. The snippets above show the write path for Project, where\nthe caller performs a permission check to access the opaque Project that the\nmodel layer requires. Reads are the inverse: the model layer vends an opaque\nobject, and the caller performs a permission check to gain access to it.\n\n## Pulling in generics\n\nAt this point, our design guaranteed that we made a permission check whenever\na user attempted to interact with a team resource. This was already a major\nimprovement, because it gave us a comprehensive list of codepaths that we\nneeded to update for each access policy. However, we weren't yet guaranteeing\nthat the correct permission was checked! It was still possible to perform a\npermission check for \"can update project\", then pass the resulting\nAuthorizedProject object to the \"delete project\" model method. To avoid this\nmismatch, we considered extending the AuthorizedProject struct with a\npermission field, which would be populated by the AuthorizeProject()\nconstructor. Each model method would then be able to confirm at runtime that\npermission was set to a requisite value. But again, we didn't just want to\nverify the permission level at runtime, which could result in our API\nreturning spurious errors. We wanted to do it at compile time! This would\nenable us to surface any mismatches during active development, while ensuring\nthat we avoid merging an incorrect permission check. Let's look at how Go\ngenerics made this possible. First, we defined each project-related permission\nas a distinct struct that implements a common ProjectPermission interface:\n\n    \n    \n    type ProjectPermission interface { isProjectPermission() } type ProjectUpdateT struct{} type ProjectDeleteT struct{} func (ProjectUpdateT) isProjectPermission() {} func (ProjectDeleteT) isProjectPermission() {}\n\nGo\n\nNext, we created an instance of each permission struct so we could refer to\nthem at runtime:\n\n    \n    \n    var ( ProjectUpdate = ProjectUpdateT{} ProjectDelete = ProjectDeleteT{} )\n\nGo\n\nWe then added a generic type parameter to our AuthorizedProject struct. The\nAuthorizeProject() constructor populates this parameter, which must be an\nimplementation of ProjectPermission:\n\n    \n    \n    type AuthorizedProject[T ProjectPermission] struct { // highlight-line project *Project } func AuthorizeProject[T ProjectPermission]( // highlight-line project *Project, user *User, permission T, ) (*AuthorizedProject[T], error) { // ... return &AuthorizedProject[T]{project: project}, nil }\n\nGo\n\nThe new signature for AuthorizeProject() has a subtle but important effect:\nthe type parameter T dictates which runtime permission can be passed in. This\nway, we enforce that the runtime value permission always matches the compile-\ntime type T. (For example, a caller can't accidentally ask for conflicting\npermissions, as with AuthorizeProject[ProjectDeleteT](project, user,\nProjectUpdate).) Finally, at the model layer we enforce that the type\nparameter matches the expected permission:\n\n    \n    \n    func DeleteProject(project *AuthorizedProject[ProjectDeleteT]) error { // ... } func UpdateProjectName(project *AuthorizedProject[ProjectUpdateT], name string) error { // ... }\n\nGo\n\nWith these changes, misuse of the permission system is flagged as a compile-\ntime error. This provides an ideal developer experience for Render engineers,\nbecause IDEs can find and display type errors inline at edit time:\n\nAn in-IDE generics mismatch error\n\nUnfortunately, we haven't been able to merge this last step yet. Generics are\nstill relatively new to Go, and they aren't yet supported by all of the\nindustry tools we use. We've submitted some PRs upstream to help advance the\necosystem.\n\n## Putting the \"safe\" in unsafe\n\nSome logic in our code does need to sidestep the permissions system, most\nnotably actions related to bootstrapping. For example, whenever a user creates\na new team, we need to add them to that team. But the \"add user to team\" API\nrequires the user have the Admin role for that team, which they of course\ndon't have yet. To handle these uncommon cases, we've defined an\nUnsafeAuthorize() function. The \"unsafe\" keyword declares to readers that the\ncompiler can't guarantee the permission check at compile time. Render\nengineers review all uses of this function with extra care and scrutiny, and\nwe require an accompanying comment to explain how each use maintains RBAC\nintegrity.\n\n## Building from here\n\nCompile-time permission checks are extremely helpful, but they aren't a free\nlunch. Adding a new permission does involve updating more total code than a\nruntime check would require. But in important ways, those additional updates\nare beneficial: we get a complete punch list of codepaths to update for each\nnew set of assumptions. This already exposed a couple of subtle security holes\nbefore we launched, and it will surely protect us from many more in the\nfuture. Security is non-negotiable for every feature we build\u2014our users\nrightly demand impeccable execution here. The architecture we've created for\nrole-based access control aims to minimize the opportunity for privilege\nescalation. By embedding permission checks directly into the type system, we\nminimize the vigilance required by code authors and reviewers alike. This\nenables us to spend more time building improvements to the Render platform.\n\nStart building with Render\n\nThe modern cloud for developers and teams.\n\nGet Started\n\nFeatures\n\n  * Autoscaling\n  * Private Networking\n  * Managed PostgreSQL\n  * Managed Redis\n  * Persistent Disks\n  * Infrastructure As Code\n  * Preview Environments\n  * Zero Downtime Deploys\n  * Render API\n\nServices\n\n  * Static Sites\n  * Web Services\n  * Private Services\n  * Background Workers\n  * Cron Jobs\n  * PostgreSQL\n  * Redis\u00ae\n\nCompany\n\n  * About\n  * Pricing\n  * Docs\n  * Changelog\n  * Blog\n  * Careers\n  * Privacy Policy\n  * Security\n  * Security.txt\n  * Terms Of Use\n\n  * Twitter\n  * LinkedIn\n  * GitHub\n\n  * Changelog\n  * Terms\n  * Privacy\n  * Security and Trust\n  * \u00a9 Render 2024\n\n", "frontpage": false}
