{"aid": "40043892", "title": "How to use SwiftData outside SwiftUI", "url": "https://jacobbartlett.substack.com/p/swiftdata-outside-swiftui", "domain": "jacobbartlett.substack.com", "votes": 1, "user": "jakey_bakey", "posted_at": "2024-04-15 18:16:51", "comments": 0, "source_title": "How to use SwiftData outside SwiftUI", "source_text": "How to use SwiftData outside SwiftUI - by Jacob Bartlett\n\n# Jacob\u2019s Tech Tavern\n\nShare this post\n\n#### How to use SwiftData outside SwiftUI\n\njacobbartlett.substack.com\n\n# How to use SwiftData outside SwiftUI\n\n### Because MV is crappy for anything complex\n\nJacob Bartlett\n\nApr 15, 2024\n\n\u2219 Paid\n\n3\n\nShare this post\n\n#### How to use SwiftData outside SwiftUI\n\njacobbartlett.substack.com\n\nShare\n\n99.94% of readers enjoy Jacob\u2019s Tech Tavern without subscribing for free.\nEvery 3 weeks, I\u2019ll send you ludicrously in-depth articles about iOS, Swift,\nand indie projects.\n\nPhoto by benjamin lehman on Unsplash\n\nSwiftData.\n\nThe hip, all-new persistence framework, that totally isn\u2019t just a wrapper on\nCoreData (shh!)\n\nResplendent with property wrappers such as @Environment\\\\.modelContext) and\n@Query, SwiftData is convenient for accessing and modifying persistent data\ndirectly from your SwiftUI views!\n\nThis is great for the Gen Zs who grew up with MV architecture, but what about\nus boomers still clutching onto MVVM, who insist on unit testing our crufty\nold code?\n\nI can\u2019t just delete these failing tests? Ok, boomer.\n\nFor a company where 79% of its binaries don\u2019t contain a line of SwiftUI, Apple\nis very insistent they know better than us about architecting SwiftUI apps.\n\n> I\u2019ve ranted before about Apple\u2019s resurrection of the massive view controller\n> problem. This is a continuation of the issues introduced by the navigation\n> APIs \u2014 they encourage devs to tightly couple navigation & persistence logic\n> to UI code.\n\nDirectly manipulating data from SwiftUI views is a recipe for linguine. An\nudonic plague. A pasta disaster. In a non-trivial project, factoring out your\ndata access is critical for maintainability.\n\nFortunately, it\u2019s actually quite simple to use SwiftData outside the context\nof SwiftUI views.\n\n###\n\nSwiftData outside SwiftUI\n\nFeel free to check out my open-source repo, NoSwiftDataNoUI, now.\n\n> It\u2019s... it\u2019s like a Bob Marley joke.\n\nThe app is dead basic, simply a list of stored Users. If there are no users\nstored, the app randomly generates 10,000 users.\n\n####\n\nThe Model\n\nWhat you see is what you get with our @Model object. There are no complex\nrelationships here.\n\n    \n    \n    @Model final class User { @Attribute(.unique) let id: UUID let firstName: String let surname: String let age: Int }\n\n####\n\nCreating our Database\n\nOur basic database service can be created with just a few lines:\n\n    \n    \n    final class UserDatabase { let container: ModelContainer init() throws { container = try ModelContainer(for: User.self) } }\n\nThis ModelContainer manages the underlying storage \u2014 by default, this is a\nSQLite file (default.store), but you can configure it to use an in-memory\nstore when you\u2019re running unit tests:\n\n    \n    \n    init(useInMemoryStore: Bool = false) throws { let configuration = ModelConfiguration( for: User.self, isStoredInMemoryOnly: useInMemoryStore ) container = try ModelContainer( for: User.self, configurations: configuration ) }\n\nWe can add this service to our view models via dependency injection; however\nin this really basic example I initialised it myself:\n\n    \n    \n    @Observable final class ContentViewModel { var users: [User] = [] private let database: UserDB init() { self.database = try! UserDB() } }\n\nNow that we\u2019ve proven you can use SwiftData outside SwiftUI, I\u2019ve succeeded in\nmy goal.\n\nWhile I sip on this self-congratulatory Peroni, you can take 5. While you\u2019re\nwaiting, follow me on Twitter if you like.\n\nLet\u2019s reconvene back here when you\u2019d like to learn how we can make use of our\nshiny new database.\n\n###\n\nCRUD Operations\n\nLet\u2019s begin implementing some standard CRUD operations on our UserDatabase.\n\n####\n\nCreate\n\nThe create method is pretty simple, but demonstrates a few important concepts:\n\n    \n    \n    func create(_ user: T) throws { let context = ModelContext(container) context.insert(user) try context.save() }\n\n####\n\nCreating the ModelContext\n\nWe use the container to initialise a ModelContext.\n\nWe want to create this ModelContext inline in the function, because it\u2019s not\ninherently thread-safe. Using a context as a stored property will incur lots\nof actor coordination overhead (just see how the compiler complains when using\ncontainer.mainContext!)\n\n####\n\nWhy use a Context?\n\nThis ModelContext behaves similarly to the ManagedObjectContext in Core Data:\nit tracks the changes made to data objects in memory.\n\nThese changes are committed \u2014 that is, saved \u2014 to the container\u2019s underlying\ndata store with context.save(). You might ask, what\u2019s the point of this extra\nstep?\n\nConsider this function, which behaves similarly, but creates a collection of\nUser objects:\n\n    \n    \n    func create(_ users: [T]) throws { let context = ModelContext(container) for user in users { context.insert(user) } try context.save() }\n\nIf you\u2019re an avid reader of Jacob\u2019s Tech Tavern, you\u2019ll know that there is a\nhierarchy of memory and storage which gets larger and slower with each layer\ndown. Registers are the smallest, fastest, then there are successive levels of\nCPU cache that might be a few kB to several MB. Ultimately, you get to main\nmemory (RAM) and persistent storage on disk, which is the slowest of all.\n\nIf you wanted to insert 10,000 items, then performing blocking synchronous I/O\nwith the disk for each item would be extremely slow.\n\nWhen we have a context, these 10,000 items inserted to the context may all be\nstored in the L2 cache, millimetres away from the CPU, before the commit step\ntreks across the motherboard to store everything on disk.\n\nIf there is far too much data in a transaction to store in the CPU caches,\nresource usage may spike and performance could be slow. Paul Hudson explains\nhow to batch data when inserting lots at once, to send sensibly-sized chunks\nto disk at a time.\n\n> I put a little extra work into explaining this because the people that kept\n> explaining the ManagedObjectContext as an \u201cintelligent scratchpad\u201d set me\n> back about 2 years.\n\n## Continue reading this post for free, courtesy of Jacob Bartlett.\n\nOr upgrade your subscription. Upgrade to paid\n\n\u00a9 2024 Jacob Bartlett\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n", "frontpage": false}
