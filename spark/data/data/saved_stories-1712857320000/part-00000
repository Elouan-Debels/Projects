{"aid": "40001090", "title": "To Build or to Reuse? A CDK Question", "url": "https://makingituptech.substack.com/p/to-build-or-to-reuse-a-cdk-question", "domain": "makingituptech.substack.com", "votes": 1, "user": "djlewald", "posted_at": "2024-04-11 11:41:29", "comments": 0, "source_title": "To Build or to Reuse? A CDK Question", "source_text": "To Build or to Reuse? A CDK Question - by Dakota Lewallen\n\nShare this post\n\n#### To Build or to Reuse? A CDK Question\n\nmakingituptech.substack.com\n\n#### Discover more from Making It Up\n\nTech, mostly AWS. Occasionally other fluff.\n\nContinue reading\n\nSign in\n\n# To Build or to Reuse? A CDK Question\n\n### Learn how to make your architecture more flexible, by optionally reusing\nexisting resources (Code included \ud83d\ude09).\n\nDakota Lewallen\n\nApr 11, 2024\n\nShare this post\n\n#### To Build or to Reuse? A CDK Question\n\nmakingituptech.substack.com\n\nShare\n\nUnless you are starting on a fresh application, the project you are working on\nwill likely have resources already in use. One of the benefits of using CDK\nover other Infrastructure-as-Code tools is conditionals! Along with the\nability to import resources via their ARN, we can create solutions that can\nuse existing resources, or create new ones. This means we can deploy into both\nfresh and existing environments from the same codebase!\n\n##\n\nGetting Started\n\nLet\u2019s assume you have a CDK application made and have bootstrapped the target\nRegion & Account. Starting with a new stack, we can begin to scaffold what\nwe\u2019ll need.\n\n    \n    \n    import { Stack , StackProps } from 'aws-cdk-lib'; import { Construct } from 'constructs'; export interface NewStackProps extends StackProps {}; export default class NewStack extends Stack { constructor(scope: Construct, id: string, props: NewStackProps) { super(scope, id, props); } }\n\nWorking backward, we\u2019ll say our example use case is to add a new lambda that\nprocesses data once it\u2019s dropped in a bucket. For deploying into production,\nthe bucket is already in use and managed by another project. But for the\ntesting environment, there is no bucket. So we will need to make one.\n\nTo begin let\u2019s add the lambda, as it\u2019s a constant regardless of where it\u2019s\ndeployed. So the implementation is simple.\n\n    \n    \n    import { Stack , StackProps } from 'aws-cdk-lib'; import * as node from 'aws-cdk-lib/aws-lambda-nodejs'; import { Construct } from 'constructs'; export interface NewStackProps extends StackProps {}; export default class NewStack extends Stack { public readonly bucketProcessor: node.NodeJsFunction; constructor(scope: Construct, id: string, props: NewStackProps) { super(scope, id, props); this.bucketProcessor = new node.NodeJsFunction(); } }\n\nEasy enough!\n\nNow onto the juicy stuff. We\u2019ll add a property to the NewStackProps interface\nto have the bucket ARN supplied externally.\n\n    \n    \n    import { Stack , StackProps } from 'aws-cdk-lib'; import * as node from 'aws-cdk-lib/aws-lambda-nodejs'; import { Construct } from 'constructs'; export interface NewStackProps extends StackProps { // Mark the property as optional, this way we can _optionall_ build the bucket if it's not supplied bucketArn?: string; }; export default class NewStack extends Stack { public readonly bucketProcessor: node.NodeJsFunction; constructor(scope: Construct, id: string, props: NewStackProps) { super(scope, id, props); // pull the arn out into a construct-scoped variable for later use. const { bucketArn } = props; // Tip: For ultra clean code, you would want to add validation against this `bucketArn` string to confirm it is in fact an ARN. this.bucketProcessor = new node.NodeJsFunction(); } }\n\nNow armed with the knowledge of \u201cDo we have an existing bucket\u201d, we can either\nmake a new one or reuse the old one\n\n    \n    \n    import { Stack , StackProps } from 'aws-cdk-lib'; import * as node from 'aws-cdk-lib/aws-lambda-nodejs'; import * as s3 from 'aws-cdk-lib/aws-s3'; import { Construct } from 'constructs'; export interface NewStackProps extends StackProps { // Mark the property as optional, this way we can _optionall_ build the bucket if it's not supplied bucketArn?: string; }; export default class NewStack extends Stack { public readonly bucketProcessor: node.NodeJsFunction; constructor(scope: Construct, id: string, props: NewStackProps) { super(scope, id, props); const { bucketArn } = props; this.bucketProcessor = new node.NodeJsFunction(); let bucket; if (bucketArn) { bucket = s3.Bucket.fromBucketArn(this, 'importedBucket', bucketArn); } else { bucket = s3.Bucket(this, 'createdBucket') } } }\n\nTo wrap up, we\u2019ll add a property to the stack so that the bucket can be\nreferenced elsewhere in the CDK application and hook the lambda up to the\nbucket so it can process events.\n\n    \n    \n    import { Stack , StackProps } from 'aws-cdk-lib'; import * as node from 'aws-cdk-lib/aws-lambda-nodejs'; import * as s3 from 'aws-cdk-lib/aws-s3'; import * as s3n from 'aws-cdk-lib/aws-s3-notifications'; import { Construct } from 'constructs'; export interface NewStackProps extends StackProps { // Mark the property as optional, this way we can _optionall_ build the bucket if it's not supplied bucketArn?: string; }; export default class NewStack extends Stack { public readonly bucketProcessor: node.NodeJsFunction; public readonly bucket: s3.IBucket; /** Use of the interface here is important. The `fromBucketArn` method returns an instance of the interface. But the new Bucket returns `s3.Bucket` which _implements_ the `IBucket` interface. So specificying the property as `IBucket` ensures that we can house _either_ the imported or created bucket. The tradeoff is that we lose access to some of the created buckets \"fancier\" features. **/ constructor(scope: Construct, id: string, props: NewStackProps) { super(scope, id, props); const { bucketArn } = props; this.bucketProcessor = new node.NodeJsFunction(); if (bucketArn) { this.bucket = s3.Bucket.fromBucketArn(this, 'importedBucket', bucketArn); } else { this.bucket = s3.Bucket(this, 'createdBucket') } this.bucket.addEventNotification(s3.EventType.OBJECT_CREATED, new s3n.LambdaDestination(this.bucketProcessor), {prefix: 'some/object/prefix/*'}); } }\n\n##\n\nConclusion\n\nWith CDK, it\u2019s possible now more than ever to reuse infrastructure patterns\nacross environments. No matter the state the target environment is in. I would\neven consider this the tip of the iceberg! To go even further, you could make\na custom L3 construct containing the reuse-or-build logic to simplify the\nprocess further! The possibilities are endless!\n\nFind me on LinkedIn | Github | Mastodon\n\nThanks for reading! If you\u2019ve found this useful subscribe to get notified when\nthe next piece comes out!\n\nShare this post\n\n#### To Build or to Reuse? A CDK Question\n\nmakingituptech.substack.com\n\nShare\n\nComments\n\nSplit Horizon DNS in AWS Made Easy!\n\nDrum roll...\n\nJan 30, 2023 \u2022\n\nDakota Lewallen\n\n1\n\nShare this post\n\n#### Split Horizon DNS in AWS Made Easy!\n\nmakingituptech.substack.com\n\nGetting my road series C License on IRacing\n\nA retrospective from a noob\n\nMar 3, 2023 \u2022\n\nDakota Lewallen\n\n1\n\nShare this post\n\n#### Getting my road series C License on IRacing\n\nmakingituptech.substack.com\n\nDNS in AWS Made Even Easier!\n\n\"Unbelievable\" - Anonymous\n\nFeb 27, 2023 \u2022\n\nDakota Lewallen\n\n2\n\nShare this post\n\n#### DNS in AWS Made Even Easier!\n\nmakingituptech.substack.com\n\nReady for more?\n\n\u00a9 2024 Dakota Lewallen\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great writing\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
