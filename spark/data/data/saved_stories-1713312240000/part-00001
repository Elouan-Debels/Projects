{"aid": "40055199", "title": "Building a Ticketing System with Solana Mobile and Metaplex Foundation Umi", "url": "https://monadical.com/posts/building-a-ticketing-system-with-solana-mobile-and-metaplex-foundation-umi.html", "domain": "monadical.com", "votes": 2, "user": "Firfi", "posted_at": "2024-04-16 18:03:15", "comments": 0, "source_title": "Building a Ticketing System with Solana Mobile and Metaplex Foundation Umi", "source_text": "Building a Ticketing System with Solana Mobile and Metaplex Foundation Umi -\nHedgeDoc\n\nBuilding a Ticketing System with Solana Mobile and Metaplex Foundation Umi -\nHedgeDoc\n\n4 days ago 42 views owned this note\n\n# Building a Ticketing System with Solana Mobile and Metaplex Foundation Umi\n\nLearn how to create an NFT-based application on the Solana blockchain\n\nWritten by Juan David Arias. Originally published 2024-04-12 on the Monadical\nblog.\n\n# Introduction\n\nSolana Mobile Stack (SMS) stands out as an integrated Android mobile\ndevelopment platform with hardware and software components; it unlocks Web3\ndevelopers to create mobile dApps. SMS consists of the SAGA device, the Seed\nVault to keep secret keys secure, Mobile wallet adapter to allows Wallet apps\nto provide transaction signing services for different types of apps on mobile\ndevices. Development SDKs for integration with the Solana blockchain are\navailable for native Android, React Native, Unity, and Unreal Engine. A dApp\nstore is an alternate app distribution system well suited to distributing apps\ndeveloped by the Solana ecosystem. All of the features above are supported by\na blockchain capable of processing thousands of transactions per second. This\nblockchain utilizes an innovative consensus mechanism called Proof of History\n(PoH), making it more cost-effective than other blockchains.\n\nThis post explores decentralized applications (dApps) through the Solana\nMobile Stack (SMS) capabilities, showcasing its effectiveness in delivering\nfast, secure, and scalable blockchain solutions on mobile platforms.\n\nWe\u2019ll provide a detailed tutorial on constructing a ticketing system using\nNon-Fungible Tokens (NFTs) on the Solana blockchain. Leveraging Solana Mobile,\nReact Native, Phantom Wallet, Metaplex Foundation Umi, and Sugar, this guide\nleads readers through creating a functional NFT-based ticketing application.\nThe system enables users to be verified using their Solana wallets, view\navailable events (represented as NFT collections), mint a ticket for an event,\nand generate a QR code for ticket verification.\n\nOverall, this tutorial aims to demonstrate the integration of blockchain\ntechnology into practical and real-world mobile applications, extending beyond\nthe traditional domain of NFTs and cryptocurrencies.\n\n# Overview\n\nThis tutorial outlines creating a ticketing system for event tickets or brand\ndiscounts using NFTs, specifically a Candy Machine NFT.\n\nTo do this, we\u2019ll use Solana Mobile, React Native, Phantom Wallet, Metaplex\nFoundation Umi, and Sugar.\n\nThe system flow will be:\n\n  1. The user opens the mobile application, and their Solana wallet verifies them.\n  2. The user can see the events (NFT collections) available in the system.\n  3. The user gets a new ticket for the event they wish to attend (Minting of a token).\n  4. The user generates a QR code with the ticket information.\n  5. A validator user can verify if the user possesses the ticket by scanning the generated QR code.\n\nHere\u2019s a preview of what the finished application will look like:\n\nWe won\u2019t focus on the app\u2019s design for this tutorial because the idea is to\nshow what\u2019s functional. We\u2019ll leave design and navigation improvements to the\nreader. Pre-requirements\n\n# Pre-requirements\n\nThroughout this tutorial, we\u2019ll use various technologies. The reader should\nunderstand mobile development with React Native, blockchain, Solana, and NFTs.\nHowever, I\u2019ll make it as detailed as possible so that the steps are easy to\nfollow. Now, let\u2019s see the tools to use.\n\n## Android Studio\n\nAndroid Studio is an integrated development environment for Android\napplications. In our guide, we\u2019ll be using it to build developed applications,\nhandle Android SDKs, and manage the emulator. Follow the instructions at\nhttps://developer.android.com/studio/install based on your operating system to\ninstall it.\n\nAn easy and quick way to install it is to use the JetBrains Toolbox App:\nhttps://www.jetbrains.com/toolbox-app. If you are a JetBrains user, search for\nAndroid Studio in the list of available editors in the toolbox, click on\ninstall, and then click to open, and your editor will be ready to use.\n\n## Android device or emulator\n\nOnce you install Android, the next step is to set up an Android device or an\nemulator to test the created applications. The easiest way to do this is by\ncreating an emulator with Android Studio.\n\nTo create an emulator, open Android Studio, and from the homepage, select\nVirtual Device Manager from the options menu. Once inside, follow the step-by-\nstep guide to create an emulator. Click on + to add an emulator, select the\nbase device, and ensure it includes the Play Store. We\u2019ll use it to install\nPhantom. In the system image, choose \u201cUpsideDownCake\u201d API level 34 because\nthis is the version required by React Native. Finally, name your emulator and\nclick on Finish. Once created, you can run the emulator by clicking the Run\ntriangle. Check https://developer.android.com/studio/run/managing-avds for\nmore details.\n\nTo test your applications using a physical device, make sure you have an\nAndroid device, developer mode, and USB debugging enabled. Then, connect your\nAndroid device to your computer and run a React native project. This action\nshould install and launch the app on your device. Some platforms may require\nadditional steps. For more information, check\nhttps://developer.android.com/studio/run/device.\n\nIf you\u2019re using Linux and have already configured your device, but it still\ndoes not appear in the list of available devices when executing the command\nadb devices, try the following steps to solve the problem:\n\n    \n    \n    # Add user to plugdev group sudo usermod -aG plugdev $LOGNAME # List the devices available in ADB adb devices # In case your device is not listed, run the following commands # List connected devices lsusb # >>> Bus 001 Device 002: ID 2717:ff08 Xiaomi Inc. Redmi Note 3 (ADB Interface) # Replaces with the values of idVendor and idProduct with the device ID echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"2717\", ATTR{idProduct}==\"ff08\" MODE=\"0666\", GROUP=\"plugdev\"' | sudo tee /etc/udev/rules.d/51-android-usb.rules\n\n## Phantom\n\nOnce your emulator is running, download the Phantom Wallet application from\nGoogle Play: https://play.google.com/store/apps/details?id=app.phantom. We\nwill use Phantom as the crypto wallet to verify our identity in the\napplication, sign transactions, and track our assets.\n\nLog into Phantom and follow the step-by-step process to create a new wallet.\nOnce completed, go to the settings screen -> developer settings and enable the\nTestnet mode option. We must enable this option to use the wallet while\nconducting tests on the devnet.\n\nTo sign transactions on the devnet, we will need some SOL in our wallet. To\nadd funds, copy your account\u2019s public key from the account details and perform\nan airdrop from https://faucet.solana.com.\n\n## React Native\n\nTo use React Native, you must have Node.js installed in your development\nenvironment. In addition, you must have completed the steps for installing\nAndroid Studio and configured a device or emulator for testing. Before you can\nuse React Native, you must have installed:\n\n  * Android SDK\n  * Android SDK Platform\n  * Android 14 (UpsideDownCake) API 34\n  * Android Virtual Device\n\nFor details on configuring the system, follow the official guide at\nhttps://reactnative.dev/docs/environment-setup?guide=native.\n\nAlso, ensure you set up the Android environment variables on your computer:\n\n    \n    \n    # Linux export ANDROID_HOME=$HOME/Android/Sdk export PATH=$PATH:$ANDROID_HOME/emulator export PATH=$PATH:$ANDROID_HOME/platform-tools # Mac OS export ANDROID_HOME=$HOME/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/emulator export PATH=$PATH:$ANDROID_HOME/platform-tools source ~/.zshrc\n\nTo verify that everything is correctly configured, you can execute the command\nnpx react-native@latest init AwesomeProject to create a new project, then use\nthe command npx react-native doctor\nhttps://reactnative.dev/blog/2019/11/18/react-native-doctor, which will\nprovide information on what may be missing in your setup and how to fix it.\n\nTo run the project, use the commands yarn start or npx react-native start to\nstart the development server bundler (Metro). Then, use the commands yarn\nandroid or react-native run-android to run the application on your device or\nemulator.\n\n## Solana CLI\n\nSolana is the blockchain we\u2019ll be using in our app. We chose it because of its\nunique ability to process thousands of transactions per second at a fraction\nof the cost of other blockchains due to its innovative consensus mechanism:\nProof of History (PoH).\n\nWe\u2019ll install the Solana CLI to perform tasks such as creating wallets and\nairdrops. To install the CLI, execute the commands:\n\n    \n    \n    sh -c \"$(curl -sSfL https://release.solana.com/v1.18.4/install)\" solana --version\n\nYou can also follow the instructions from its official documentation at\nhttps://docs.solanalabs.com/cli/install.\n\n## Sugar\n\nSugar is a CLI developed by Metaplex that simplifies the NFT minting process\non the Solana blockchain. This simplification allows candy machines to\nautomate and manage the minting and distribution of NFT collections. We\u2019ll use\nSugar to create a candy machine and upload the collection items that users can\nview and mint later. To install Sugar on your computer, execute the commands:\n\n    \n    \n    bash <(curl -sSf https://sugar.metaplex.com/install.sh) sugar --version\n\nNow, we have completed our development environment. Our next steps are to\ncreate an NFT collection with Sugar and Solana and develop a React Native app\nto generate event tickets by minting NFTs.\n\n# Create an NFT collection\n\nIn this section, we will prepare the assets for the NFT collection that we\u2019ll\nuse as tickets for an event. Additionally, we\u2019ll create a candy machine with\nSugar, allowing users to mint the NFTs.\n\n### Create a Solana wallet\n\nFor the candy machine, you can designate a wallet for the owner and another\nfor the treasury. Then, create a list with the creator\u2019s wallets and their\nrespective royalties. We will use the owner\u2019s wallet for all cases. First,\ncreate a working directory and generate a new Solana wallet:\n\n    \n    \n    mkdir collection && cd collection solana-keygen new --outfile ./wallets/owner.json solana config set --keypair ./wallets/owner.json solana config set --url https://api.devnet.solana.com\n\nOnce we create this new wallet, we\u2019ll set it as the default wallet for the\nSolana CLI. Finally, we\u2019ll set the Solana network to development mode to\nfacilitate testing as we develop. Copy the public key to the clipboard; we\u2019ll\nuse it soon when specifying the owner and treasury of the collection.\n\n    \n    \n    Wrote new keypair to ./wallets/owner.json ======================================================================= pubkey: GhLwJtoRbSZrzYLCL4szkhKCat5BN3FD3nXQggQaGLrd =======================================================================\n\n### Prepare the Assets\n\nCreate an assets folder inside the collection directory and save all the\nimages you want to be part of the candy machine. We should name the images\nwith numbering in the format 0.png, 1.png, ..., n.png. A JSON file containing\nthe metadata of each image is also necessary.\n\nFor this tutorial, we will generate an NFT collection for Morpheus, a\n(shameless plug) framework I built for deploying diffusion models to\nproduction.\n\nLet\u2019s look at an example of an asset:\n\n0.png\n\n0.json\n\n    \n    \n    // collection/assets/0.json { \"name\": \"Morpheus #1\", \"symbol\": \"MORPHEUS\", \"description\": \"A futuristic landscape of a city\", \"image\": \"0.png\", \"attributes\": [ { \"trait_type\": \"key\", \"value\": \"value\" } ], \"properties\": { \"category\": \"image\", \"files\": [ { \"uri\": \"0.png\", \"type\": \"image/png\" } ] } }\n\nAdding a collection.json file containing the metadata and an image\nrepresenting the collection will also be necessary. Here we will use the\nwallet owner we just created. Let\u2019s see an example of a collection.json:\n\n    \n    \n    // collection/assets/collection.json { \"image\": \"collection.png\", \"name\": \"Morpheus Art generator\", \"description\": \"Morpheus: A Dream Machine for AI Art Generation.\", \"symbol\": \"MORPHEUS\", \"attributes\": [ { \"trait_type\": \"collection\", \"value\": \"yep\" } ], \"seller_fee_basis_points\": 0, \"properties\": { \"creators\": [ { \"address\": \"GhLwJtoRbSZrzYLCL4szkhKCat5BN3FD3nXQggQaGLrd\", \"share\": 100 } ], \"files\": [ { \"type\": \"image/png\", \"uri\": \"collection.png\" } ] } }\n\nOur complete asset collection should look like this:\n\n### Upload collection to Solana\n\nExecute the sugar launch command inside the collection folder to initiate an\ninteractive CLI for configuring the candy machine and uploading the files to\nthe blockchain. Follow the CLI instructions step by step to create the\nconfiguration for the candy machine. This process will generate a config.json\nfile, validate the assets for the candy machine, and upload the collection to\nthe blockchain.\n\nRemember to airdrop some SOL to the owner\u2019s wallet. You can do this at\nhttps://faucet.solana.com by entering the owner\u2019s public key\nGhLwJtoRbSZrzYLCL4szkhKCat5BN3FD3nXQggQaGLrd or by using the Solana CLI with\nthe command solana airdrop 1 GhLwJtoRbSZrzYLCL4szkhKCat5BN3FD3nXQggQaGLrd.\n\nOnce the upload and deployment of the collection are complete, you will see\nthe mint and the candy machine ID in the console logs. Save them, as we will\nuse them later to interact with the candy machine when using Metaplex/umi.\n\n### Add Guards\n\nGuards are pieces of code that allow restrictions to be added to a token\u2019s\nminting stage. We will add a section with our guards inside the\u2019 config.json`\nfile generated by Sugar:\n\n    \n    \n    // collection/config.json { \"tokenStandard\": \"nft\", \"number\": 10, \"symbol\": \"MORPHEUS\", \"sellerFeeBasisPoints\": 0, \"isMutable\": true, \"isSequential\": true, \"creators\": [ { \"address\": \"GhLwJtoRbSZrzYLCL4szkhKCat5BN3FD3nXQggQaGLrd\", \"share\": 100 } ], \"uploadMethod\": \"bundlr\", \"ruleSet\": null, \"awsConfig\": null, \"sdriveApiKey\": null, \"nftStorageAuthToken\": null, \"shdwStorageAccount\": null, \"pinataConfig\": null, \"hiddenSettings\": null, \"guards\": { \"default\": { \"mintLimit\": { \"id\": 1, \"limit\": 1 }, \"solPayment\": { \"value\": 0.2, \"destination\": \"GhLwJtoRbSZrzYLCL4szkhKCat5BN3FD3nXQggQaGLrd\" }, \"startDate\": { \"date\": \"2024-03-23T04:00:00Z\" }, \"botTax\": { \"value\": 0.01, \"lastInstruction\": true } } }, \"maxEditionSupply\": null }\n\nFirst, we restrict the number of mints per wallet to 1. Then, we define the\nwallet receiving payments for each mint, the owner wallet we created earlier.\nWe add an initial date from which the minting stage begins, and finally, we\nintroduce a penalty of 0.01 SOL for mint attempts using bots.\n\nFor more on the different types of existing guards, check the official\ndocumentation at https://developers.metaplex.com/candy-machine/guards.\n\nFinally, run the command sugar guard and add the guards to the candy machine.\nYou should receive output similar to:\n\nLook for the ID of the candy machine in the Explorer to see its data\nhttps://explorer.solana.com/address/3Bn9DofFU6UwpjoyQyo4hFNHxbwU6zXAysKE3Vhmah9q?cluster=devnet\n\n# Create a React Native Project\n\nTo this point, we have configured and met all the prerequisites of our system,\nand it\u2019s time to continue creating the mobile application that will allow us\nto obtain tickets for events.\n\nImplementation steps:\n\n  1. Installation and setup of the Solana Mobile template with React Native\n  2. Integration of Metaplex Umi for interaction with the candy machine and NFT\n  3. Adding a page for available events\n  4. Adding a mint button to obtain a new ticket\n  5. Adding a page to list the generated tickets\n  6. Enabling QR code generation with my ticket data\n  7. Adding a page for reading and verifying a QR code\n\nYou can access the final version of the code used in this tutorial at\nhttps://github.com/Monadical-SAS/SolanaMobileTicketingSystem.\n\nThe Solana Mobile Stack is currently only available for Android platforms. To\ncreate dApps with Solana Mobile, you can choose between developing native\napplications with Android and Kotlin or using some of the frameworks for\nAndroid. You can choose between react native, which has a template with pure\nreact native and another with expo. There are also SDK versions for flutter,\nunity and unreal engine.\n\nSMS also has some example applications that serve as starting points for more\nrapid iteration. You can find them in the GitHub repository at\nhttps://github.com/solana-mobile/tutorial-apps?tab=readme-ov-file or from the\nofficial documentation at https://docs.solanamobile.com/sample-\napps/sample_app_overview. Here, you will find examples of Android and React\nNative using Anchor, Metaplex, and IPFS, among others.\n\nWe will take the React Native template as a starting point. To start the\nproject, run from a terminal.\n\n    \n    \n    npx react-native init SolanaMobileTicketSystem --template @solana-mobile/solana-mobile-dapp-scaffold --npm\n\nWhen you finish the installation process, run the command yarn install to\ninstall the project dependencies. Then, yarn start to start a Metro server for\ndevelopment. From a new terminal, yarn android to run the application on the\nemulator or the Android device.\n\n## Step 1: Connect Wallet Home Page\n\nThe first view available upon running the app is the connect wallet page,\nwhere we can use our Solana wallet as an authentication mechanism. After\nclicking the \u201cconnect wallet\u201d button, the MWA (Mobile Wallet Adapter) will\nlaunch an intent on Android to search for an application that allows the use\nof the wallet and links it with the app. We will be using the Phantom app\nsince we have already installed it. By accepting the linking from Phantom, we\ncan use the wallet to sign and send transactions:\n\n## Step 2: Main page\n\nAfter authentication, we are redirected to a main page where we find pre-\nconfigured buttons that allow actions such as signing a transaction, signing a\nmessage, requesting an airdrop, and disconnecting the wallet from the app\n(logout). In this view, we added two new buttons to enable us to navigate the\npages for events and QR code validation:\n\nTo add a navigation system to the app, follow the instructions in the official\nReact Navigation documentation. React Navigation is a widely used library for\nrouting and navigation in React Native apps. It provides a way to navigate\nbetween screens and manage the navigation stack.\n\nThe \u201cSign Transaction\u201d button transfers SOL from an active wallet in Phantom\nto a randomly generated publicKey.\n\n    \n    \n    // components/SignTransactionButton.tsx const signTransaction = useCallback(async () => { return await transact(async (wallet: Web3MobileWallet) => { // First, request for authorization from the wallet and fetch the latest // blockhash for building the transaction. const [authorizationResult, latestBlockhash] = await Promise.all([ authorizeSession(wallet), connection.getLatestBlockhash(), ]); // Construct a transaction. This transaction uses web3.js `SystemProgram` // to create a transfer that sends lamports to randomly generated address. const keypair = Keypair.generate(); const randomTransferTransaction = new Transaction({ ...latestBlockhash, feePayer: authorizationResult.publicKey, }).add( SystemProgram.transfer({ fromPubkey: authorizationResult.publicKey, toPubkey: keypair.publicKey, lamports: 1_000, }), ); // Sign a transaction and receive const signedTransactions = await wallet.signTransactions({ transactions: [randomTransferTransaction], }); return signedTransactions[0]; }); }, [authorizeSession, connection]);\n\nThe transact function allows us to sign transactions using the active MWA\n(Mobile Wallet Adapter) wallet. In the signTransaction function, we authorize\nthe wallet to sign a transfer of 1000 lamports to a randomly generated\naccount. By clicking the button, we automatically launch Phantom to sign the\ntransaction:\n\nIn the following diagram, you can see the flow carried out during the\ntransaction process:\n\nThe dApp maintains communication with the Wallet App to authorize and sign\ntransactions. The wallet app (Phantom) is an implementation of the Mobile\nWallet Adapter protocol, which allows us to interact with the wallet. On a\nSAGA device, which has a seed vault with our wallet information encrypted in a\nsecure microchip, the complete transaction flow would be as follows:\n\nOur dApp establishes a communication channel with the Wallet App, an\nimplementation of the MWA that allows interaction with the seed vault. The\ndApp requests the wallet app to sign a transaction, and the wallet app uses\nthe Seed Vault to sign the transaction. Remember, the seed vault is an\nencrypted microchip that runs at the hardware level and is inaccessible even\nto the operating system.\n\nIn Solana Mobile, there are two types of applications: dApps (decentralized\nApps) developed for the general public, which use web3 libraries and wallet\napps to perform crypto operations, and wallet apps, which are implementations\nof the MWA protocol allowing integration with the seed vault. These are the\napplications used by dApps to authorize and sign transactions. You can see the\nlist of available WalletApps at https://solanamobile.com/wallets.\n\n## Step 3: Integrate @metaplex-foundation/umi\n\nThe most standard way to interact with NFTs on Solana is using metaplex.\nMetaplex has minted nearly 78% of the NFTs available on the Solana network.\nFor this app, we will be using the Candy Machine v3 protocol from Metaplex and\nutilizing the @metaplex/umi library, a modular framework for building and\nusing JavaScript clients for Solana programs.\n\nLet\u2019s start by adding the Umi dependencies to our React Native project. From a\nterminal and at the root of your app, execute:\n\n    \n    \n    yarn add @metaplex-foundation/long \\ @metaplex-foundation/length-bundle-defaults \\ @metaplex-foundation/length-signer-wallet-adapters \\ @solana/web3.js \\ @metaplex-foundation/mpl-candy-machine@alpha \\ @metaplex-foundation/mpl-token-metadata@alpha \\ @metaplex-foundation/mpl-toolbox\n\nThen, we create an Umi object to interact with the library. We will do this by\ncreating a React context to expose a provider and a useUmi hook for easy\naccess to the context. Let\u2019s look at the implementation.\n\n    \n    \n    // components/providers/UmiProvider.tsx import {createContext, ReactNode, useContext} from 'react'; import type {Umi} from '@metaplex-foundation/umi'; import { createNoopSigner, publicKey, signerIdentity, } from '@metaplex-foundation/umi'; import {createUmi} from '@metaplex-foundation/umi-bundle-defaults'; import { walletAdapterIdentity } from '@metaplex-foundation/umi-signer-wallet-adapters'; import {mplTokenMetadata} from '@metaplex-foundation/mpl-token-metadata'; import {mplCandyMachine} from '@metaplex-foundation/mpl-candy-machine'; import {useAuthorization} from './AuthorizationProvider'; type UmiContext = { umi: Umi | null; }; const DEFAULT_CONTEXT: UmiContext = { umi: null, }; export const UmiContext = createContext<UmiContext>(DEFAULT_CONTEXT); export const UmiProvider = ({ endpoint, children, }: { endpoint: string; children: ReactNode; }) => { const {selectedAccount} = useAuthorization(); console.log('selectedAccount', selectedAccount); const umi = createUmi(endpoint) .use(mplTokenMetadata()) .use(mplCandyMachine()); if (selectedAccount === null) { const noopSigner = createNoopSigner( publicKey('11111111111111111111111111111111'), ); umi.use(signerIdentity(noopSigner)); } else { umi.use(walletAdapterIdentity(selectedAccount)); } return <UmiContext.Provider value={{umi}}>{children}</UmiContext.Provider>; }; export function useUmi(): Umi { const umi = useContext(UmiContext).umi; if (!umi) { throw new Error( 'Umi context was not initialized. ' + 'Did you forget to wrap your app with <UmiProvider />?', ); } return umi; }\n\nIn the previous script, we defined a provider using the createUmi function to\ncreate an instance of Umi. We then decorated this instance with the\nmplTokenMetadata and mplCandyMachine plugins to enable interaction with the\ncandy machine and the metadata of the NFTs through the object. Finally, we set\nthe Solana Mobile wallet as the Umi identity.\n\nWe must wrap our application with the <UmiProvider/> provider to use the Umi\ncontext from our components:\n\n    \n    \n    // App.tsx import {clusterApiUrl} from '@solana/web3.js'; import React from 'react'; import {SafeAreaView, StyleSheet} from 'react-native'; import {NavigationContainer} from '@react-navigation/native'; import {createNativeStackNavigator} from '@react-navigation/native-stack'; import { ConnectionProvider, RPC_ENDPOINT, } from './components/providers/ConnectionProvider'; import { AuthorizationProvider } from './components/providers/AuthorizationProvider'; import {UmiProvider} from './components/providers/UmiProvider'; import constants from './util/constants'; const Stack = createNativeStackNavigator(); const endpoint = constants.PUBLIC_RPC || 'https://api.devnet.solana.com'; export default function App() { return ( <NavigationContainer> <ConnectionProvider config={{commitment: 'processed'}} endpoint={clusterApiUrl(RPC_ENDPOINT)}> <AuthorizationProvider> <UmiProvider endpoint={endpoint}> <SafeAreaView style={styles.shell}> // omitted for simplicity, check the full file in the repository </SafeAreaView> </UmiProvider> </AuthorizationProvider> </ConnectionProvider> </NavigationContainer> ); }\n\nWarning We encountered an import issue with the @metaplex-\nfoundation/umi/serializers library when writing this article.\n\nYou can find details of the issue at https://github.com/metaplex-\nfoundation/umi/issues/94#issuecomment-2014069571. A workaround for this\nproblem, and the only one that worked for me, is the one proposed by\n@mordonez-me at https://github.com/metaplex-\nfoundation/umi/issues/94#issuecomment-1815527247. It involves overwriting all\nfiles where @metaplex-foundation/umi/serializers is imported with @metaplex-\nfoundation/umi-serializers. This imperfect solution will allow us to use the\nlibrary for now.\n\nCreate a metaplex-fixer subdirectory within the root of your application.\nPaste the following script in a fixer.mjs file:\n\n    \n    \n    // metaplex-fixer/fixer.mjs import * as fs from \"fs\"; import { globSync } from \"glob\"; const found = globSync( \"./../node_modules/@metaplex-foundation/**/*.{ts,js,cjs}\" ); found.forEach((file) => { console.log(\"file\", file); const data = fs.readFileSync(file, \"utf8\"); const result = data.replace( /@metaplex-foundation\\/umi\\/serializers/g, \"@metaplex-foundation/umi-serializers\", ); console.log(\"writing\", file); fs.writeFileSync(file, result, \"utf8\"); });\n\nThe above script replaces all occurrences of umi/serializer with umi-\nserializer within all @metaplex-foundation files, which solves the import\nerror. To apply the patch, run the commands:\n\n    \n    \n    cd metaplex-fixer yarn install node fixer.mjs\n\nWith the above, we have completed the integration of @metaplex-foundation/umi\nwithin our app. Run the Metro server and yarn android again; your application\nshould work again.\n\n## Step 4: Collection Preview Events Page\n\nWe will need a page in our application displaying information about available\nevents, that means, the candy machine and its items. Users can also generate\nthe mint from this page for a new ticket. Remember, each candy machine\nrepresents an event within our system, and every minted NFT represents a\nticket. We will simplify using a single sample event, but if desired, the\napproach can be generalized to support multiple events. To support multiple\nevents, create a new candy machine for each event, and add a view that allows\nan admin-type user to enter events into the app using a form.\n\nLet\u2019s start by adding a component to render the items belonging to a\ncollection:\n\n    \n    \n    // components/CollectionNFTs.tsx import React, {useEffect, use Memo, useState} from 'react'; import {Image, StyleSheet, Text, View} from 'react-native'; import {publicKey} from '@metaplex-foundation/umi'; import {fetchCandyMachine} from '@metaplex-foundation/mpl-candy-machine'; import {useUmi} from './providers/UmiProvider'; import {fetchNFTData} from '../util/metaplex'; import constants from '../util/constants'; const collectionId = constants.PUBLIC_CANDY_MACHINE_ID; const CollectionNFTs = () => { const length= useUmi(); const [collectionData, setCollectionData] = useState<any>(null); const [itemsData, setItemsData]: any = useState(null); const candyMachineId = use Memo(() => { return publicKey(collectionId); }, []); useEffect(() => { async function loadCandyMachineData() { try { const candyData = await fetchCandyMachine(length, candyMachineId); const newItems = await Promise.all( candyData.items.map(item => fetchNFTData(item.type)), ); setCollectionData(candyData); setItemsData(newItems); } catch (error) { console.log('Error fetching candy machine ' + error); } } loadCandyMachineData().catch(() => { console.log('Error fetching candy machine'); }); }, [candyMachineId, length]); return ( <View style={styles.container}> <Text style={styles.title}> {collectionData?.data?.symbol || 'NFTs'} Collection </Text> {itemsData && itemsData.map((nft: any, index: number) => ( <View key={index}> <Image source={{type: nft.image}} style={styles.image} everything={nft.name} /> <Text style={styles.name}>{nft.name}</Text> </View> ))} </View> ); }; const styles = StyleSheet.create({ // omitted for simplicity, check the full file in the repository }); export default CollectionNFTs;\n\nThe loadCandyMachineData function takes the Candy Machine ID of the previously\ncreated collection as a parameter and returns the metadata of the collection\nand its items. To do this, it retrieves data from the blockchain with\nfetchCandyMachine and then obtains the metadata for each item by fetching the\nitem.uri property. We save the candy machine item data in the itemsData state\nand then render the image and name of each item on the screen.\n\nNow, let\u2019s add a new screen where we can use the component and display\ninformation about the event and the list of items in the collection:\n\n    \n    \n    // screens/EventsScreen.tsx import React, {FC} from 'react'; import {ScrollView, StyleSheet, View} from 'react-native'; import {NativeStackNavigationProp} from '@react-navigation/native-stack'; import {RootStackParamList} from '../util/types'; import CollectionNFTs from '../components/CollectionNFTs'; import {Header} from '../components/Header'; import MintButton from '../components/MintButton'; import AppButton from '../components/AppButton'; type NFTsScreenProps = { navigation: NativeStackNavigationProp<RootStackParamList, 'Events'>; }; const EventsScreen: FC<NFTsScreenProps> = ({navigation}) => { return ( <ScrollView style={styles.mainContainer}> <Header title=\"NFT Events\" subtitle=\"Collection NFTs\" /> <View style={styles.actionButtons}> <MintButton /> <AppButton text={'View my tickets'} onPress={() => navigation.navigate('MyTickets')} /> </View> <CollectionNFTs /> </ScrollView> ); }; const styles = StyleSheet.create({ // omitted for simplicity, check the full file in the repository }); export default EventsScreen;\n\nAfter updating our application, we will see a list of collection items, a\nbutton to create a mint of the collection to get a new ticket, and a button to\nview a list of tickets in the user\u2019s wallet.\n\n## Step 5: Generate a Ticket\n\nIn our system, getting a new ticket for an event means creating a mint from a\ncollection, thus obtaining a new NFT. To enable users to get event tickets, we\nwill add a new component containing a button to highlight the mint:\n\n    \n    \n    // components/MintButton.tsx import React, { ActivityIndicator, Image, Linking, StyleSheet, Text, View, } from 'react-native'; import {FC, useCallback, useMemo, useState} from 'react'; import { generateSigner, publicKey, PublicKey, some, transactionBuilder, } from '@metaplex-foundation/umi'; import { fetchCandyMachine, mintV2, safeFetchCandyGuard, } from '@metaplex-foundation/mpl-candy-machine'; import { DigitalAsset, fetchDigitalAsset, fetchJsonMetadata, JsonMetadata, } from '@metaplex-foundation/mpl-token-metadata'; import {setComputeUnitLimit} from '@metaplex-foundation/mpl-toolbox'; import { transact, Web3MobileWallet, } from '@solana-mobile/mobile-wallet-adapter-protocol-web3js'; import {toWeb3JsLegacyTransaction} from '@metaplex-foundation/umi-web3js-adapters'; import {Buffer} from 'buffer'; import {Keypair, VersionedTransaction} from '@solana/web3.js'; import {base58} from '@metaplex-foundation/umi-serializers'; import {useUmi} from './providers/UmiProvider'; import constants from '../util/constants'; import {useConnection} from './providers/ConnectionProvider'; import {useAuthorization} from './providers/AuthorizationProvider'; import AppButton from './AppButton'; const CANDY_MACHINE_ID = constants.PUBLIC_CANDY_MACHINE_ID; const TREASURY = constants.PUBLIC_TREASURY; const MintButton: FC = () => { const umi = useUmi(); const {connection} = useConnection(); const {authorizeSession} = useAuthorization(); const [loading, setLoading] = useState(false); const [digitalAsset, setDigitalAsset] = useState<DigitalAsset | null>(null); const [jsonMetadata, setJsonMetadata] = useState<JsonMetadata | null>(null); const candyMachineId = useMemo(() => { return publicKey(CANDY_MACHINE_ID); }, []); const treasury = publicKey(TREASURY); const handleMintNFT = useCallback(async () => { setLoading(true); if (!publicKey) { throw new Error('Wallet not connected'); } const candyMachine = await fetchCandyMachine(umi, candyMachineId); const latestBlockhash = (await umi.rpc.getLatestBlockhash()).blockhash; const candyGuard = await safeFetchCandyGuard( umi, candyMachine.mintAuthority, ); try { const nftMint = generateSigner(umi); let tx = transactionBuilder().add( mintV2(umi, { candyMachine: candyMachine.publicKey, collectionMint: candyMachine.collectionMint, collectionUpdateAuthority: candyMachine.authority, nftMint: nftMint, candyGuard: candyGuard ? candyGuard.publicKey : undefined, mintArgs: { mintLimit: some({id: 1}), solPayment: some({destination: treasury}), }, tokenStandard: candyMachine.tokenStandard, }), ); tx = tx.prepend(setComputeUnitLimit(umi, {units: 800_000})); tx = tx.setBlockhash(latestBlockhash); const transaction = tx.build(umi); const signedTransaction = await signTransaction(transaction, nftMint); const txSignature = await connection.sendTransaction( VersionedTransaction.deserialize(signedTransaction.serialize()), ); const mint = await verifySignature(txSignature); const {asset, metadata} = await fetchNft(publicKey(mint)); setDigitalAsset(asset); setJsonMetadata(metadata); setLoading(false); } catch (error) { console.error('Error creating NFT', error); setLoading(false); } }, [ umi, candyMachineId, treasury, connection, signTransaction, verifySignature, fetchNft, ]); return ( <View style={styles.mainContainer}> {loading ? ( <ActivityIndicator /> ) : ( <AppButton text={'Mint a new NFT Ticket'} onPress={handleMintNFT} /> )} {digitalAsset && ( <View> <Text style={styles.title}>{digitalAsset.metadata.name}</Text> <Text style={styles.mint}>{digitalAsset.mint.publicKey}</Text> {jsonMetadata && ( <Image source={{uri: jsonMetadata?.image || ''}} style={styles.image} /> )} <AppButton text={'Open in Solana Explorer'} onPress={openInSolanaExplorer} /> </View> )} </View> ); }; const styles = StyleSheet.create({ // omitted for simplicity, check the full file in the repository }); export default MintButton;\n\nIn the handleMintNFT function, we have instructions for minting an NFT with\n@metaplex-foundation/umi and signing the transaction using the mobile-wallet-\nadapter.\n\nFirst, we construct the mint transaction to be executed on the Solana\nblockchain. We build the transaction using the mintV2 function from @metaplex-\nfoundation https://developers.metaplex.com/candy-machine/mint, passing it the\npreviously generated candy machine, the transaction signer from the candy\nmachine, and the guards for the candy machine as parameters.\n\nOnce we have built the transaction, we must sign it with our wallet to send it\nto the Solana blockchain. The @metaplex-foundation/umi library provides\nfunctions for signing and sending transactions using the wallet-adapter.\nHowever, some modifications are required since we must use the mobile-wallet-\nadapter instead.\n\nAdd the following function to the component to sign mint transactions with the\nmobile wallet adapter:\n\n    \n    \n    // components/MintButton.tsx const signTransaction = useCallback( async (transaction: any, signer: any) => { return await transact(async (wallet: Web3MobileWallet) => { const authorizationResult = await authorizeSession(wallet); const newTransaction = { ...transaction, feePayer: authorizationResult.publicKey, }; const web3Transaction = toWeb3JsLegacyTransaction(newTransaction); web3Transaction.partialSign( Keypair.fromSecretKey(Buffer.from(signer.secretKey)), ); const signedTransactions = await wallet.signTransactions({ transactions: [web3Transaction], }); return signedTransactions[0]; }); }, [authorizeSession], );\n\nsignTransaction receives a transaction generated with Umi and a signer for the\nmint. Using the transact function from the mobile wallet adapter, we initiate\na transaction with the wallet app:\n\n  1. The wallet session is authorized, and the transaction is modified to specify the wallet owner as the fee payer.\n  2. It is transformed into a web3LegacyTransaction to perform the partial sign with the candy machine\u2019s wallet.\n  3. The transaction is signed with the active wallet in Phantom and returned as a signed transaction.\n\nAfter the transaction is signed, it\u2019s sent to the Solana blockchain using the\nconnection.sendTransaction call, registering the transaction in the network\u2019s\nblocks. The mint process also uses a function to verify the transaction\nsignature against the blockchain. Let\u2019s see the implementation:\n\n    \n    \n    // components/MintButton.tsx const verifySignature = useCallback( async (signature: string): Promise<any> => { let transaction; const u8signature = base58.serialize(signature); for (let i = 0; i < 30; i++) { transaction = await umi.rpc.getTransaction(u8signature); if (transaction) { break; } await new Promise(resolve => setTimeout(resolve, 3000)); } if (!transaction) { throw new Error('Transaction not found'); } return transaction.message.accounts[1]; }, [umi.rpc], );\n\nverifySignature searches for the transaction within the Solana blockchain and\nconfirms that the transaction was completed successfully. The function\nimplements a loop that attempts to retrieve the transaction results up to 30\ntimes, with a waiting time of 3 seconds per attempt. If the function finds the\ntransaction before the 30 attempts, it breaks the loop and returns the mint\nvalue. If the transaction is not found within the 30 attempts, an error is\nthrown, indicating the transaction was not found.\n\nLastly, the mint function obtains the metadata of the newly minted NFT. The\nimplementation is as follows:\n\n    \n    \n    const fetchNft = useCallback( async (nftAddress: PublicKey): Promise<any> => { const asset = await fetchDigitalAsset(umi, nftAddress); const metadata = await fetchJsonMetadata(umi, asset.metadata.uri); if (!asset || !metadata) { throw new Error('NFT not found'); } return {asset, metadata}; }, [umi], );\n\nWith the publicKey of the mint, we can find the NFT\u2019s data using the\nfetchDigitalAsset function from Umi. Then, using fetchJsonMetadata and the\nasset\u2019s URI, we obtain the NFT\u2019s metadata to display the name.\n\nOnce the mint button component is completed, we can generate a new NFT. After\npressing the button and waiting while the transaction is processed in the\nblockchain network, we should see the new NFT generated on the screen.\n\nFinally, you will see the newly created NFT in the Solana explorer. Add the\nopenInSolanaExplorer function, which will launch an intent to open the URL\ncreated with the mint in a browser:\n\n    \n    \n    const openInSolanaExplorer = useCallback(async () => { if (digitalAsset) { const url = `https://explorer.solana.com/address/${digitalAsset.mint.publicKey}/?cluster=devnet`; Linking.openURL(url); } }, [digitalAsset]);\n\n## Step 6: NFT Ticket Ownership\n\nWith the implementation for generating new event tickets completed, it\u2019s time\nto create a new screen where the user can view the available tickets, that is,\nthe list of NFTs that have been minted. For this, we add a new component,\nMyTicketsScreen within the screens folder and add the following code:\n\n    \n    \n    // screens/MyTicketsScreen.tsx import React, {FC, useEffect, useState} from 'react'; import {Image, ScrollView, StyleSheet, Text, View} from 'react-native'; import {Header} from '../components/Header'; import {useUmi} from '../components/providers/UmiProvider'; import { fetchAllDigitalAssetByOwner, fetchJsonMetadata, } from '@metaplex-foundation/mpl-token-metadata'; import QRGenerator from '../components/QRGenerator'; import AppModal from '../components/Modal'; import AppButton from '../components/AppButton'; const MyTicketsScreen: FC = () => { const umi = useUmi(); const [events, setEvents] = useState<any[]>([]); const [showQR, setShowQR] = useState<boolean>(false); useEffect(() => { const fetchEventsByOwner = async (): Promise<any[]> => { try { const assets = await fetchAllDigitalAssetByOwner( umi, umi.payer.publicKey, ); return await Promise.all( assets.map(async asset => { const metadata = await fetchJsonMetadata(umi, asset.metadata.uri); return { ...asset, metadata, }; }), ); } catch (error) { console.error('fetchEventsByOwner', error); throw new Error('Error fetching my events'); } }; fetchEventsByOwner().then(data => { setEvents(data); }); }, [umi]); return ( <ScrollView style={styles.mainContainer}> <Header title=\"My Tickets\" subtitle={'See all your tickets'} /> <View style={styles.mainContent}> {events.map(event => ( <View key={event.edition.publicKey} style={styles.card}> <Text style={styles.title}>{event.metadata.name}</Text> <Image source={{uri: event.metadata.image}} style={styles.image} alt={event.name} /> <View style={styles.qrButton}> {showQR ? ( <AppModal modalVisible={showQR} setModalVisible={setShowQR}> <View style={styles.qrView}> <Text style={styles.title}>{event.metadata.name}</Text> <QRGenerator value={`${umi.payer.publicKey}:${event.mint.publicKey}`} /> </View> </AppModal> ) : ( <AppButton text={'Show QR'} onPress={() => setShowQR(true)} /> )} </View> </View> ))} </View> </ScrollView> ); }; const styles = StyleSheet.create({ // omitted for simplicity, check the full file in the repository }); export default MyTicketsScreen;\n\nOnce the screen loads, we request the list of NFTs associated with the wallet\nusing Umi\u2019s fetchAllDigitalAssetByOwner function. Then, we obtain the metadata\nfor each asset and add a button to generate a QR code with the user\u2019s wallet\nand the NFT\u2019s mint. The data passed to the QR generator is in the form of\nwallet:mint since we want to verify if a user with a particular wallet owns an\nNFT with the searched mint value.\n\nTo add support for generating QR codes within React Native, we will use the\nlibrary react-native-qrcode-svg. To install it, run the commands:\n\n    \n    \n    yarn add react-native-svg yarn add react-native-qrcode-svg\n\nAnd we create a new component that receives a string to generate the QR as\nparameters:\n\n    \n    \n    // components/QRGenerator.tsx import React from 'react'; import QRCode from 'react-native-qrcode-svg'; type QRGeneratorProps = { value: string; }; const QRGenerator = ({value}: QRGeneratorProps) => { return <QRCode value={value} size={300} />; }; export default QRGenerator;\n\nAfter updating the application, we can see the tickets associated with the\naccount and their respective button to generate the QR code. As soon as we\npress the button, we can see the QR code associated with the ticket, which we\ncan present to the validator to prove our ownership of a ticket for the event:\n\n## Step 7: Validate Ticket with QR Scanner\n\nThe final step of our process is to create a new screen that allows an\nadministrator to validate a user\u2019s ownership of a ticket. Let\u2019s add a new\ncomponent, TicketScannerScreen, within our screens folder:\n\n    \n    \n    // screens/TicketScannerScreen.tsx import React, {FC, useEffect} from 'react'; import {ScrollView, StyleSheet, Text, View} from 'react-native'; import {Header} from '../components/Header'; import QRScanner from '../components/QRScanner'; import Modal from '../components/Modal'; import {useUmi} from '../components/providers/UmiProvider'; import { fetchCandyMachineData, fetchEventsByOwner, fetchMetadataByMint, } from '../util/metaplex'; import {publicKey} from '@metaplex-foundation/umi'; const TicketScannerScreen: FC = () => { const length= useUmi(); const [scanned, setScanned] = React.useState(''); const [result, setResult] = React.useState(''); const [showModal, setShowModal] = React.useState(false); const [collectionMint, setCollectionMint] = React.useState(''); useEffect(() => { fetchCandyMachineData(length).then(data => { setCollectionMint(data.collectionMint); }); }, [length]); useEffect(() => { if (!scanned) { return; } const [userPublicKey, as] = scanned.split(':'); try { publicKey(userPublicKey); publicKey(as); } catch (error) { setResult('Invalid ticket'); setShowModal(true); return; } fetchMetadataByMint(length, publicKey(as)).then(mintData => { if (!mintData) { setResult('Ticket metadata not found'); return; } if (mintData.metadata.collection.value.key !== collectionMint) { setResult('Ticket not found in collection'); return; } fetchEventsByOwner(length, publicKey(userPublicKey)).then( (ownerData: any) => { const foundInWallet = ownerData.find( (event: any) => event.publicKey === as, ); if (!foundInWallet) { setResult('Ticket not found in user wallet'); return; } setResult('Ticket found in user wallet and collection'); }, ); setShowModal(true); }); }, [length, collectionMint, scanned]); const handleClose = () => { setScanned(''); setResult(''); setShowModal(false); }; return ( <ScrollView> <Header title=\"Ticket Scanner\" subtitle=\"Validate your NFT ticket\" /> <View style={styles.mintButton}> <QRScanner setScanned={setScanned} /> <Modal modalVisible={showModal} setModalVisible={handleClose}> <View style={styles.result}> <Text style={styles.title}>Scanner Result</Text> <Text style={styles.text}>{scanned}</Text> <Text style={styles.text}>{result}</Text> </View> </Modal> </View> </ScrollView> ); }; const styles = StyleSheet.create({ // omitted for simplicity, check the full file in the repository }); export default TicketScannerScreen;\n\nTo verify that a user holds a ticket for a specific event, we will first\nverify that the NFT\u2019s collection mint matches the mint of the event\u2019s\ncollection. Secondly, we will confirm that the NFT the user claims to own\nexists in their wallet.\n\nTo achieve this, TicketScannerScreen first loads the data from the candy\nmachine to obtain the collection\u2019s mint. To load the data, TicketScannerScreen\nuses the fetchCandyMachineData function, which looks like this:\n\n    \n    \n    // util/metaplex.ts export async function fetchCandyMachineData(umi: Umi): Promise<CandyMachine> { try { const candyMachineId = publicKey(collectionId); return await fetchCandyMachine(umi, candyMachineId); } catch (error) { console.error('fetchCandyMachineData', error); throw new Error('Error fetching candy machine data'); } }\n\nEvery time the setScanned event of the <QRScanner> component is executed, we\ncan perform the validation whenever the scan data changes. To perform the\nvalidation, we use the fetchMetadataByMint function, which uses Umi\u2019s\nfetchDigitalAsset function to obtain an asset\u2019s data based on the mint value.\nThen, we use fetch to get the NFT\u2019s metadata and compare if the mint value of\nthe candy machine matches the `nft.collection.mint value:\n\n    \n    \n    // util/metaplex.ts export async function fetchMetadataByMint( umi: Umi, mintPublicKey: PublicKey, ): Promise<any> { try { const asset = await fetchDigitalAsset(umi, mintPublicKey); const response = await fetch(asset.metadata.uri); const metadata = await response.json(); return {...asset, ...metadata}; } catch (error) { console.error('fetchMetadataByMint', error); throw new Error('Error fetching NFT metadata'); } }\n\nSecondly, we obtain the NFTs available in the user\u2019s wallet with the\nfetchEventsByOwner function and check if the mint the user claims to own\nexists in the list of available NFTs:\n\n    \n    \n    // util/metaplex.ts export async function fetchEventsByOwner( umi: Umi, ownerPublicKey: PublicKey, ): Promise<any[]> { try { return await fetchAllDigitalAssetByOwner(umi, ownerPublicKey); } catch (error) { console.error('fetchEventsByOwner', error); throw new Error('Error fetching my events'); } }\n\nIf both previous conditions are met, an alert message indicating whether the\noperation was completed is displayed in a modal.\n\nWe create the component to read the QR codes using the [VisionCamera]\n(https://react-native-vision-camera.com/docs/guides) library. This component\nallows us to use the camera in React Native and includes functionalities such\nas photo taking, video recording, QR and Barcode scanning, and video\nstabilization.\n\nTo add the dependency, run the command:\n\n    \n    \n    yarn add react-native-vision-camera\n    \n    \n    # android/gradle.properties # omitted for simplicity, check the full file in the repository # Enable code scanner VisionCamera_enableCodeScanner=true\n\nTo complete this, we add a new <QRScanner> component responsible for using the\ncamera, scanning for present QR codes, and returning the result to a parent\ncomponent:\n\n    \n    \n    import React, {Fragment, useCallback} from 'react'; import {StyleSheet, Text} from 'react-native'; import { Camera, Code, useCameraDevice, useCameraPermission, useCodeScanner, } from 'react-native-vision-camera'; type QRScannerProps = { setScanned: (value: string) => void; }; const QRScanner = ({setScanned}: QRScannerProps) => { const {hasPermission, requestPermission} = useCameraPermission(); const device = useCameraDevice('back'); const onCodeScanned = useCallback( (codes: Code[]) => { const value = codes[0]?.value; if (value == null) { return; } setScanned(value); }, [setScanned], ); const codeScanner = useCodeScanner({ codeTypes: ['qr', 'ean-13'], onCodeScanned: onCodeScanned, }); if (!hasPermission) { return <Text onPress={requestPermission}>Request camera permission</Text>; } if (device == null) { return <Text>No camera device available</Text>; } return ( <Fragment> <Camera style={styles.camera} device={device} isActive={true} codeScanner={codeScanner} enableZoomGesture={true} /> </Fragment> ); }; export default QRScanner; const styles = StyleSheet.create({ camera: { flex: 1, width: '100%', height: undefined, aspect: 1, }, });\n\nOnce the ticket validator scans a QR code generated with the wallet: mint\npair, they can verify if the ticket is valid.\n\nWith the above, we conclude the implementation of our NFT ticketing app. You\ncan check the repository https://github.com/Monadical-\nSAS/SolanaMobileTicketingSystem if you want to use the source code for this\ntutorial. The developed system is still far from being considered ready for\nproduction, but it exemplifies the flow we should follow for a ticketing\nsystem.\n\nIf the reader wishes to complete the implementation, they must ensure the\nentry of new collections by admin-type users. Additionally, they must be more\nrigorous with validations in the system, such as verifying that a ticket has\nbeen used previously in the system or displaying error messages when no more\nitems are available to mint in the application.\n\n# Conclusion\n\nThis article provides a comprehensive guide to developing an NFT ticketing\nsystem on the Solana blockchain, demonstrating the practical applications of\nNFTs beyond art and collectibles. Key takeaways include:\n\n  * The versatility of NFTs: The project illustrates the innovative use of NFTs for ticketing, highlighting their potential in various sectors, including events management and brand engagement through discounts and special offers.\n\n  * Solana\u2019s Ecosystem: The choice of Solana underscores the blockchain\u2019s capabilities in handling high throughput and low-cost transactions, essential for the scalability and efficiency of NFT-based applications.\n\n  * Ease of Cryptocurrency Management: Integrating mobile wallet adapters like Phantom and Solflare into the project highlights Solana\u2019s growing ecosystem of wallet apps. These applications facilitate easier management and transaction of cryptocurrencies and NFTs, enhancing user experience and security. The Mobile Wallet Adapter protocol simplifies connecting dApps with mobile wallets, bridging the gap between blockchain applications and mobile devices.\n\n# Final Thoughts\n\nThe development of an NFT ticketing system using Solana, React Native, and\nassociated technologies exemplifies the practical application of blockchain\ntechnology in everyday use cases. The integration of mobile wallet adapters\nand the launch of the Solana dApp store are significant milestones that\nhighlight the ecosystem\u2019s maturity and readiness for mainstream adoption.\n\nThe recent advancements in Solana\u2019s blockchain technology have not only\nimproved the user experience but also opened up new opportunities for\ndevelopers to create innovative and value-added services. We encourage you to\ndevelop new applications that will further enhance the user experience and\nshare these ideas in the comments section below. By working together, we can\nestablish blockchain\u2019s role in modern technology landscapes!\n\n# Resources\n\n  * https://github.com/solana-mobile/solana-mobile-dapp-scaffold\n  * https://developers.metaplex.com/candy-machine/sugar\n  * https://developers.metaplex.com/candy-machine\n  * https://developers.metaplex.com/candy-machine/guards\n  * https://developers.metaplex.com/umi\n  * https://docs.solanamobile.com/getting-started/overview\n  * https://docs.solanamobile.com/getting-started/mobile-dapp-architecture\n  * https://docs.solanamobile.com/sample-apps/sample_app_overview\n  * https://github.com/solana-mobile/dapp-publishing\n  * https://medium.com/@varghesejoel6/how-to-mint-an-nft-using-metaplex-umi-and-candymachine-7c3880691ff2\n  * https://github.com/wearekite/candy-machine-v3-ui/blob/main/src/hooks/useCandyMachineV3.tsx\n  * https://porcupineplaygroundpals.com/how-to-create-a-minting-ui-for-collection-deployed-with-metaplex-sugar-2-1-1/\n  * https://faucet.solana.com/\n  * https://github.com/metaplex-foundation/umi/issues/94\n  * https://discord.com/channels/848060988636921856/1159962886744059944\n\n    * Introduction\n    * Overview\n    * Pre-requirements\n\n      * Android Studio\n      * Android device or emulator\n      * Phantom\n      * React Native\n      * Solana CLI\n      * Sugar\n    * Create an NFT collection\n\n      *         * Create a Solana wallet\n        * Prepare the Assets\n        * Upload collection to Solana\n        * Add Guards\n    * Create a React Native Project\n\n      * Step 1: Connect Wallet Home Page\n      * Step 2: Main page\n      * Step 3: Integrate @metaplex-foundation/umi\n      * Step 4: Collection Preview Events Page\n      * Step 5: Generate a Ticket\n      * Step 6: NFT Ticket Ownership\n      * Step 7: Validate Ticket with QR Scanner\n    * Conclusion\n    * Final Thoughts\n    * Resources\n\nExpand allGo to topGo to comments\n\n  * Introduction\n  * Overview\n  * Pre-requirements\n\n    * Android Studio\n    * Android device or emulator\n    * Phantom\n    * React Native\n    * Solana CLI\n    * Sugar\n  * Create an NFT collection\n\n    *       * Create a Solana wallet\n      * Prepare the Assets\n      * Upload collection to Solana\n      * Add Guards\n  * Create a React Native Project\n\n    * Step 1: Connect Wallet Home Page\n    * Step 2: Main page\n    * Step 3: Integrate @metaplex-foundation/umi\n    * Step 4: Collection Preview Events Page\n    * Step 5: Generate a Ticket\n    * Step 6: NFT Ticket Ownership\n    * Step 7: Validate Ticket with QR Scanner\n  * Conclusion\n  * Final Thoughts\n  * Resources\n\nExpand allGo to topGo to comments\n\n### Juan David Arias\n\n##### Full-stack dev/PM @juanArias8\n\n##### Published on 2024-04-15\n\nWe are hiring! Subscribe to our newsletter\n\nRecent posts:\n\n  * Building a Ticketing System with Solana Mobile and Metaplex Foundation Umi\n  * Kraken the Code: How to Build a Talking Avatar\n  * The AI Evolution: Transforming Zulip Bots, Part 3\n  * How to Make LLMs Speak Your Language\n  * View more posts...\n\nBack to top\n\n  * Montr\u00e9al\n  * Vancouver\n  * Medell\u00edn\n  * Cali\n\n  * Monadical\n\nBlog\n\n  * Services\n  * Projects\n\n  * About Us\n  * About\n  * Team\n  * Principles\n\n  * Contact Us\n  * Get a Quote\n  * Careers\n  * Contact us\n\n  * Monadical Inc. \u00a9 2024 All rights reserved.\n\n  * hello@example.commonadical.com \u2709\ufe0f Email us with your project idea.\n\n", "frontpage": false}
