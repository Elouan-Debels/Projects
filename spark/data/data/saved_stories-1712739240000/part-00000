{"aid": "39986519", "title": "C Compilers Disprove Fermat's Last Theorem", "url": "https://blog.regehr.org/archives/140", "domain": "regehr.org", "votes": 1, "user": "signa11", "posted_at": "2024-04-10 02:53:28", "comments": 0, "source_title": "C Compilers Disprove Fermat\u2019s Last Theorem \u2013 Embedded in Academia", "source_text": "C Compilers Disprove Fermat\u2019s Last Theorem \u2013 Embedded in Academia\n\nSkip to content\n\n# Embedded in Academia\n\n# C Compilers Disprove Fermat\u2019s Last Theorem\n\n[Update: I wrote another post on this topic that may explain the underlying\nissues more clearly.]\n\nObviously I\u2019m not serious: compilers are bad at solving high-level math\nproblems and also there is good reason to believe this theorem cannot be\ndisproved. But I\u2019m getting ahead of myself. Recently \u2014 for reasons that do not\nmatter here \u2014 I wanted to write C code for an infinite loop, but where the\ncompiler was not to understand that the loop was infinite. In contrast, if I\nhad merely written\n\n    \n    \n    while (1) { }\n\nor\n\n    \n    \n    for (;;) { }\n\nmost optimizing compilers would see the loop\u2019s inability to exit and generate\ncode accordingly. For example, given this C code:\n\n    \n    \n    void foo (void) { for (;;) { } open_pod_bay_doors(); }\n\nMost compilers will emit something like this:\n\n    \n    \n    foo: L2: jmp L2\n\nIn this case the compiler emits neither the call to open_pod_bay_doors() nor\nthe final return instruction because both are provably not executed.\n\nPerhaps interestingly, LLVM/Clang recognizes that this slightly obfuscated\ninfinite loop never exits:\n\n    \n    \n    unsigned int i = 0; do { i+=2; } while (0==(i&1));\n\nFaced with a loop optimizer that has some brains, I decided to stop messing\naround and wrote a loop that should thwart any compiler\u2019s termination\nanalysis:\n\n    \n    \n    const int MAX = 1000; int a=1,b=1,c=1; while ((c*c*c) != ((a*a*a)+(b*b*b))) { a++; if (a>MAX) { a=1; b++; } if (b>MAX) { b=1; c++; } if (c>MAX) { c=1; } }\n\nThis loop only terminates if it finds a counterexample to a special case of\nFermat\u2019s Last Theorem. Fermat\u2019s Last Theorem, of course, states that no\nsolution exists for the equation a^n + b^n = c^n for positive integers a, b,\nand c and for integer n>2\\. Here n=3 and a,b,c are in the range [1..1000]. On\na platform with 32-bit integers 1000 is a reasonable maximum because 2*1000^3\nis not much less than 2^31.\n\nIt turns out that when optimizations are enabled, several compilers\n(LLVM/Clang 2.7, Open64-x86 4.2.3, Sun CC 5.10, and Intel CC 11.1.072) go\nahead and permit this loop to terminate. Specifically, when the loop is\nenclosed in a function, the compilers emit x86 assembly which looks something\nlike this:\n\n    \n    \n    fermat: ret\n\nThe implication, of course, is that the compiler has disproved Fermat\u2019s Last\nTheorem. Faced with this incredible mathematical discovery, I held my breath\nand added a line of code at the end of the function to print the\ncounterexample: the values of a, b, and c. Unfortunately, with their bluffs\ncalled in this fashion, all of the compilers emitted code that actually\nperformed the requested computation, which of course does not terminate. I got\nthe feeling that these tools \u2014 like Fermat himself \u2014 had not enough room in\nthe margin to explain their reasoning.\n\nWhat is really going on here is that compiler optimizations and termination\nanalysis have long been at odds. In other words, if compilers were obligated\nto preserve the termination properties of the code they translate, they would\nbe unable to perform (or would have more difficulty performing) some of the\noptimizations that they use to create efficient code. A choice is being made\nby compiler developers \u2014 probably consciously, though it\u2019s hard to be sure \u2014\nto prefer speed over correctness. The news, however, is not all bad:\nMicrosoft\u2019s C compiler, the Wind River Diab C compiler, and several versions\nof GCC all did the right thing, changing the termination properties of none of\nthe examples I tried.\n\nUpdate from Sat 5/1: It turns out the LLVM folks have been working on this\nproblem lately and their latest SVN now does not contain this bug. Very nice!\n\nUpdate from Sat 5/1: Someone on Reddit noticed (and one of my students\nconfirmed) that the Microsoft compilers do have termination bugs. The\ncompilers in both Visual Studio 2008 and 2010 generate code for the Fermat\nfunction, but then calls to this function are dropped because it is believed\nto be free of side effects (this was exactly what LLVM did before they fixed\nthe problem).\n\n# Update from Friday 4/30\n\nI\u2019ll try to clarify a few of the questions that have come up on Reddit and in\nthe comments here. Also I fixed a mistake in the statement of Fermat\u2019s Last\nTheorem that someone on Reddit pointed out. Thanks!\n\nQ: Does this actually matter at all?\n\nA: Yes, but in very specialized situations that usually only come up when\ndeveloping embedded software. One example is described here: the poster wants\nthe program being simulated to hang when main() exits, but LLVM deletes the\nloop that was intended to hang up the processor. The workaround was to compile\nthe code with optimizations turned off. Another example happens when an\nembedded system has updated its firmware and wants to do nothing until the\nwatchdog timer reboots the processor into the new version. It\u2019s no coincidence\nthat gcc and the Wind River C compiler \u2014 both of which are heavily used in the\nembedded world \u2014 get termination right.\n\nQ: Since infinite loops are bad style, isn\u2019t it OK for the compiler to\nterminate them? Shouldn\u2019t people be putting the CPU to sleep, blocking the\nrunning thread, or whatever?\n\nA: First, not all programs have an operating system or even a threading system\nto call out to. Embedded software commonly runs on the bare metal. Second, the\nmeaning of a program is defined by the language standard and style has nothing\nto do with it. See my earlier post The Compiler Doesn\u2019t Care About Your\nIntent.\n\nQ: Does the C standard permit/forbid the compiler to terminate infinite loops?\n\nA: The compiler is given considerable freedom in how it implements the C\nprogram, but its output must have the same externally visible behavior that\nthe program would have when interpreted by the \u201cC abstract machine\u201d that is\ndescribed in the standard. Many knowledgeable people (including me) read this\nas saying that the termination behavior of a program must not be changed.\nObviously some compiler writers disagree, or else don\u2019t believe that it\nmatters. The fact that reasonable people disagree on the interpretation would\nseem to indicate that the C standard is flawed. In contrast, the Java language\ndefinition is quite clear that infinite loops may not be terminated by the\nJVM.\n\nQ: Are you saying the compiler should do termination analysis? That\u2019s\nimpossible by trivial reduction to the halting problem.\n\nA: Termination analysis does not need to be part of the compiler at all.\nHowever, I (and others) would claim that the compiler should perform a\ntermination analysis of any useless loop before deleting it. Although the\ngeneral problem is not computable, many specific instances can be easily\nsolved.\n\nQ: Does the Fermat code in this post execute any signed integer overflows or\nother undefined behaviors?\n\nA: I don\u2019t believe so.\n\n# Update from Saturday 5/1\n\nQ: Didn\u2019t you know Fermat\u2019s Last Theorem was proved in 1995?\n\nA: I did know that. Since I got my math degree in 1995, it would have been\nvery difficult for me to miss this event :). I was making a weak joke and also\nreferring to the fact that proofs, especially complicated ones, can contain\nerrors. In fact, as someone noted in the comments, Wiles\u2019 initial proof was\nwrong. Also note that the n=3 special case was proved much earlier, in 1770.\n\nQ: What\u2019s the best workaround if you really want an infinite loop in C?\n\nA: As several people have pointed out, looping on a volatile-qualified\nvariable is probably the best choice. But keep in mind that compilers don\u2019t\nalways respect volatile....\n\n# One more update from Saturday 5/1\n\nHere\u2019s a fun complete program that is more compelling than the code above\nbecause it explicitly uses a return value from the \u201ctheorem disproved\u201d branch\nof the code:\n\n    \n    \n    int fermat (void) { const int MAX = 1000; int a=1,b=1,c=1; while (1) { if (((a*a*a) == ((b*b*b)+(c*c*c)))) return 1; a++; if (a>MAX) { a=1; b++; } if (b>MAX) { b=1; c++; } if (c>MAX) { c=1; } } return 0; } #include <stdio.h> int main (void) { if (fermat()) { printf (\"Fermat's Last Theorem has been disproved.\\n\"); } else { printf (\"Fermat's Last Theorem has not been disproved.\\n\"); } return 0; }\n\nHere\u2019s what the Intel and Sun compilers have to say:\n\n    \n    \n    regehr@john-home:~$ icc fermat2.c -o fermat2 regehr@john-home:~$ ./fermat2 Fermat's Last Theorem has been disproved. regehr@john-home:~$ suncc -O fermat2.c -o fermat2 \"fermat2.c\", line 20: warning: statement not reached regehr@john-home:~$ ./fermat2 Fermat's Last Theorem has been disproved.\n\nOpen64-x86 and LLVM/Clang 2.7 have the same behavior. Although plenty of folks\nin the peanut gallery disagree, it seems perfectly clear to me that this is a\nserious error in these compilers. I mean, why return 1? Is that worse or\nbetter than returning 0? Neither result makes any sense.\n\nApril 28, 2010\n\nregehr\n\nComputer Science, Software Correctness\n\n### 49 responses to \u201cC Compilers Disprove Fermat\u2019s Last Theorem\u201d\n\n  1. Justin Smith says:\n\nApril 28, 2010 at 11:29 pm\n\n(You probably already have realized this.) The reason the compiler produced\ncode that terminated was based upon the fact that the values being altered\n(i.e., a, b and c) within the \u201cwhile\u201d loop are never referenced again after\nthe loop. But, once you added code which printed the resulting values it was\nforced to actually generate the code for the loop.\n\n  2. Justin Smith says:\n\nApril 28, 2010 at 11:33 pm\n\nI suspect your earlier \u201cdo...while\u201d loop would also compile to a program which\nindefinitely iterated if you were to utilize the value \u201ci\u201d (in a non-trivial\nway) after the loop.\n\n  3. regehr says:\n\nApril 29, 2010 at 8:51 am\n\nHi Justin- Yeah, it\u2019s the lack of side effects that lets the compiler get rid\nof these loops. The problem is whether non-termination is considered a side\neffect!\n\nRegarding the do..while loop, you\u2019re right, the Intel compiler for example no\nlonger eliminates the loop.\n\n  4. Cyrus Omar says:\n\nApril 30, 2010 at 10:49 am\n\nA compiler could prove that that does not terminate.\n\nTrivially, you can run it for a while (10^9 iterations) and you\u2019ll end up back\nat your initial conditions, guaranteeing it will never terminate.\n\nI\u2019m sure one could conceive of a more general class of termination conditions\nand a more efficient way to detect those that would also include this loop.\n\nProblem is computer arithmetic is finite so any \u201cfor-all\u201d type statement in\nmath will be problematic to use to thwart a compiler.\n\n  5. pdw says:\n\nApril 30, 2010 at 4:25 pm\n\nIt\u2019s important to remember that C ints are not mathematical ints. In\nparticular, C ints have an upper limit and overflow is undefined behavior.\n\nThere are two cases to consider:\n\n1\\. There\u2019s a solution. The loop terminates and it can be omitted as the\nresults are unused.\n\n2\\. There\u2019s no solution. The int a will eventually overflow, and the behavior\nof the code is undefined. Thus the compiler is allowed to do anything,\nincluding omitting the loop. At least gcc 4.1 and later will perform such\noptimizations.\n\n  6. pdw says:\n\nApril 30, 2010 at 4:26 pm\n\nScratch that, I misread the code. You do check all three variables for\noverflow.\n\n  7. Gareth C says:\n\nApril 30, 2010 at 4:38 pm\n\n\u201cgood reason to believe this theorem cannot be disproved\u201d\n\nLike the fact it was finally proved in 1995?\nhttp://en.wikipedia.org/wiki/Fermat's_Last_Theorem\n\n  8. Reid says:\n\nApril 30, 2010 at 5:13 pm\n\n*shrug* I\u2019m with the LLVM/Clang developers on this one. Being able to delete useless loops like this one without proving termination is useful.\n\nAlso, I\u2019d echo the previous comments that signed integer overflow in C is\nundefined. I wonder what happens if you make your integers unsigned. I\u2019d guess\nit produces the same code.\n\n  9. regehr says:\n\nApril 30, 2010 at 5:31 pm\n\nHi Reid and others,\n\nThis bug in LLVM \u2018s optimizer has already caused problems for a group using it\nto compile embedded software. This is in LLVM\u2019s bugzilla somewhere but I don\u2019t\nhave the link handy. They had to compile the module containing the infinite\nloop w/o optimizations to make their system work properly!\n\nJohn\n\n  10. regehr says:\n\nApril 30, 2010 at 5:33 pm\n\nAh, here it is:\n\nhttp://llvm.org/bugs/show_bug.cgi?id=965\n\nLook for the comment by Pekka J\u00c3\u00a4\u00c3\u00a4skel\u00c3\u00a4inen.\n\nJohn\n\n  11. a says:\n\nApril 30, 2010 at 5:45 pm\n\nI assume for each compiler you are using the default settings and optimization\nlevels? Did you try different compiler flags and find that these are the\nresults across the board.\n\n  12. regehr says:\n\nApril 30, 2010 at 6:06 pm\n\nHi A,\n\nThis wasn\u2019t using the default optimization level, which I think is \u201cno\noptimization\u201d for all of these compilers. I used -O2, I believe. No, I didn\u2019t\ndo any kind of systematic survey.\n\nJohn\n\n  13. Al says:\n\nApril 30, 2010 at 8:55 pm\n\nYou missed the real interesting way to approach this. You can use the c\npreprocessor to write a program that will compile at all only if the theorem\nis false. How long a program, IDK.\n\n  14. Jer says:\n\nApril 30, 2010 at 9:42 pm\n\nI think if you were to declare the variables a, b, and c as \u2018volatile int\u2019\ninstead of just \u2018int\u2019, the compiler would be forced to read the value of the\nvariable each time it is accessed. In that case, the generated code will\nprobably contain the loop instructions because the variable manipulations\nshouldn\u2019t be optimized out.\n\n  15. ridiculous_fish says:\n\nApril 30, 2010 at 11:00 pm\n\nI can\u2019t reproduce these results with LLVM at the page here:\nhttp://llvm.org/demo/index.cgi . Can you show the code you compiled and how\nyou compiled it?\n\n  16. regehr says:\n\nApril 30, 2010 at 11:30 pm\n\nHi Fish- Please try the program below. The emitted code for fermat() does the\nspecified computation, but main() never calls it! The optimizer concludes that\nfermat() is free of side effects and drops the call.\n\nvoid fermat (void) { const int MAX = 1000; int a=1,b=1,c=1; while ((a*a*a) !=\n((b*b*b)+(c*c*c))) { a++; if (a>MAX) { a=1; b++; } if (b>MAX) { b=1; c++; } if\n(c>MAX) { c=1; } } }\n\nint main (void) { fermat(); return 0; }\n\n  17. regehr says:\n\nApril 30, 2010 at 11:32 pm\n\nFish\u2013 If you turn on LTO, the code below is the entire output.\n\n; ModuleID = \u2018/tmp/webcompile/_4199_0.bc\u2019 target datalayout =\n\u201ce-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64\u201d\ntarget triple = \u201cx86_64-linux-gnu\u201d\n\ndefine i32 @main() nounwind readnone { entry: ret i32 0 }\n\n  18. Josiah Worcester says:\n\nApril 30, 2010 at 11:41 pm\n\n\u201d while ((c*c*c) != ((a*a*a)+(b*b*b))) {\u201d This will overflow, and the compiler\ncan tell that it will. Signed overflow is undefined. Thus, a compiler would be\nperfectly correct to replace your program with an instruction that causes\nmonkeybats to fly out of your nose.\n\n  19. Josiah Worcester says:\n\nApril 30, 2010 at 11:45 pm\n\nErm. No. Stupid comment. rm?\n\n  20. ridiculous_fish says:\n\nMay 1, 2010 at 12:02 am\n\nOk, I can reproduce that. So it\u2019s not quite right to say it generates no code\nfor the loop \u2013 it does, as you can verify by compiling a function containing\nthe loop.\n\nWhat clang apparently does do is elide the function call. I would guess the\nreason you have to turn on LTO to see the loop disappear is the dead code\nstripping.\n\n  21. Stephen Waits says:\n\nMay 1, 2010 at 1:50 am\n\nTry making your variables volatile, or in a greater scope. You compiler\ndetermines, properly, that they aren\u2019t needed down the line and the loop has\nno side effects.\n\n  22. sysprv says:\n\nMay 1, 2010 at 4:17 am\n\nThis reminds me of the super computer viruses that Arthur C. Clarke described\nin his book, 3001. The protagonists use a similar technique to force an\nalmost-sentient alien computer to go into a never-ending routine, thereby\nsaving humanity from premature judgement.\n\nWell done!\n\n  23. Owen Anderson says:\n\nMay 1, 2010 at 4:20 am\n\nActually, it was a recently introduced bug in the inliner, that I\u2019ve just\ncommitted a fix for to LLVM HEAD. I had previously tracked down all these\nissues in LLVM\u2019s dead code elimination passes a couple of years ago, but it\nlooks like a new one got introduced while I wasn\u2019t looking.\n\n  24. Mans says:\n\nMay 1, 2010 at 5:19 am\n\nThe interesting discussion aside, an infinite loop invisible to the compiler\nis easy to do with gcc:\n\nint i = 1; while (i) __asm__ volatile (\u201c\u201d : \u201c+r\u201d(i));\n\n  25. Semi Essessi says:\n\nMay 1, 2010 at 5:52 am\n\nI don\u2019t see why this behaviour would be a problem. If you want a non-\nterminating loop that can be used then just do something with side-effects\ninside of it so that the compiler doesn\u2019t optimise it away. I\u2019d much rather a\ncompiler remove a huge loop that has no effect rather than waste clock cycles\ndoing nothing... if anything it would be nicer if this generated warnings to I\ncould find the offending code and fix/remove it.\n\n  26. Domonoky says:\n\nMay 1, 2010 at 6:32 am\n\nHa, this is normal compiler optimisation. It drops the code because the\ncompiler detects that all results are never used. This is allowed for C/C++\ncompilers and every embedded developer (should) know that he has to force the\ncompiler to not drop it if he writes infinite or delay loops. A common\nsolution with gcc is to insert \u201cvolatile asm(\u201cnop\u201d)\u201d into a delay loop to\nforce the compiler to not drop the loop. Other ways are using volatile\nvariables and other compiler hints.\n\nSo there is no termination analysis done at all.\n\n  27. matt byrd says:\n\nMay 1, 2010 at 7:13 am\n\nUm, might be being a bit pedantic but surely you must have heard :\n\n\u201c\u201d\u201dThe final proof of the conjecture for all n came in the late 20th century.\nIn 1984, Gerhard Frey suggested the approach of proving the conjecture through\nthe modularity conjecture for elliptic curves. Building on work of Ken Ribet,\nAndrew Wiles succeeded in proving enough of the modularity conjecture to prove\nFermat\u2019s Last Theorem, with the assistance of Richard Taylor. Wiles\u2019s\nachievement was reported widely in the popular press, and has been popularized\nin books and television programs. \u201c\u201d\u201d\n(http://en.wikipedia.org/wiki/Fermat's_Last_Theorem)\n\n  28. regehr says:\n\nMay 1, 2010 at 9:41 am\n\nThanks Owen! I have updated the post.\n\n  29. Will Pearson says:\n\nMay 1, 2010 at 9:48 am\n\nI can see your point that non-termination of loops might be a desired side-\neffect at some point and shouldn\u2019t be optimised out. But similarly you might\nadd in dummy instructions to delay a program briefly, should those be\noptimised out as well?\n\nLets say you have a bit of network code that you want to take over X\nmicroseconds to respond, but you don\u2019t want to use heavy weight timers.\n\nIn the real world there is no such thing as code without side-effects (all\ninstructions use electricity and warm up the CPU); it is just often we don\u2019t\nwant the side effects that code comes with.\n\n  30. Rupak says:\n\nMay 1, 2010 at 10:19 am\n\n\u201cAre you saying the compiler should do termination analysis? That\u00e2\u20acTMs\nimpossible by trivial reduction to the halting problem.\u201d So is every compiler\noptimization, BTW.\n\nVery interesting observation, John! You may also have seen this:\nhttp://pho.ucsd.edu/rjhala/koenig.pdf\n\n  31. chocolateboy says:\n\nMay 1, 2010 at 11:31 am\n\nGareth C and matt byrd: http://en.wikipedia.org/wiki/Humour\n\n  32. regehr says:\n\nMay 1, 2010 at 12:37 pm\n\nHi Will- A C compiler is definitely permitted to delete a terminating loop (or\nother sequence of dummy instructions) that is free of side effects. Note that\nthe definition of side effects here is from the C standard and does not\ninclude timing or power.\n\n  33. regehr says:\n\nMay 1, 2010 at 2:19 pm\n\nRupak\u2013 Good to hear from you. I hadn\u2019t seen that writeup, thanks!\n\n  34. Compiler theory, quantum physics and Fermat\u2019s theorem \u00ab Otaku, Cedric's weblog says:\n\nMay 2, 2010 at 2:42 pm\n\n[...] come across a post that talks about math and programming that is both\nclever and fun to read. Well, here is one, which attempts to use a compiler\noptimizer to disprove Fermat\u2019s [...]\n\n  35. roy_hu says:\n\nMay 2, 2010 at 9:35 pm\n\nI can understand the argument for removing the loops because they have no side\neffects, but I\u2019m curious about why all compilers assume fermat() returns 1\ninstead of 0?\n\n  36. regehr says:\n\nMay 2, 2010 at 9:52 pm\n\nHi Roy- I have no idea why these compilers return \u201c1\u201d. It makes no sense, the\nbehavior is absurd and should be fixed.\n\n  37. veky says:\n\nMay 3, 2010 at 3:01 am\n\nIt\u2019s very easy to see why they return 1. \u201creturn 0;\u201d is discarded as\nunreachable code, and after that \u201creturn 1;\u201d is the only way left to exit the\nfunction. Since optimizing compilers assume the function will terminate, it\n_must_ do so through \u201creturn 1;\u201d.\n\n  38. Achilleas Margaritis says:\n\nMay 3, 2010 at 7:24 am\n\nAcademics are usually disconnected from reality, and this article is a fine\nexample of this. Computers exist to manipulate real world objects and not to\nprove theorems. It\u2019s much more important for a compiler to do compile-time\nmemoization than to try to prove that a piece of code will never terminate.\n\nThe real problem here is not the elimination of the redundant loop, but the\nlack of any meaningful infinite loop instruction for the C programming\nlanguage that is supposed to be used in bare metal systems. C programmers have\nto simulate infinite loops and timed loops using a series of instructions that\ncompilers may remove them.\n\nThe solution would be to augment C with infinite loop instructions. For\nexample:\n\nloop; //infinite loop loop for 1000; //timed loop for 1000 millseconds\n\nIn the end, it\u2019s a matter of language specifications, not of correctness. The\ncorrect thing to do in a compiler is to replace any piece of code that\nproduces a constant expression with the result of that expression. Performance\nis incredibly important, even in this day, age, economic and environmental\nsituation.\n\n  39. regehr says:\n\nMay 3, 2010 at 8:33 am\n\nVeky\u2013 Right, but what I mean is, it\u2019s hard to understand why the compiler\ndesigners would permit their tool to execute an infeasible branch in the code,\nparticularly when this has observable side effects. Generally compilers do not\ndo this.\n\n  40. regehr says:\n\nMay 3, 2010 at 8:36 am\n\nAchilleas\u2013 You have misunderstood. The compiler has improperly changed the\nobservable behavior of a strictly conforming C program. Both of these terms\nare defined in the C standard.\n\n  41. Laszlo Ersek says:\n\nMay 3, 2010 at 12:09 pm\n\nThe compiler generating such code for this program that terminates is clearly\nwrong. (Knowing that your \u201cint\u201ds have 31 value bits.)\n\nThe fermat() function has two exit points. The \u201creturn 0\u201d statement cannot be\nreached, indeed. The compiler infers that the \u201creturn 1\u201d statement must be the\none that leaves the function, and since it determines fermat() not to have any\nside effects, it simply eliminates the loop. This *directly* violates the\nsemantics of the \u201cif\u201d selection statement, C99 6.8.4.1 p2: \u201c[...] the first\nsubstatement is executed if the expression compares unequal to 0 [...]\u201d\n\nThe code is completely well-defined, thus the compiler has no excuse for this\noverzealous optimization. The standard doesn\u2019t say anything about the\nselection statement *having* to evaluate to nonzero, and the compiler errs\nwhen it still assumes so.\n\n  42. roy_hu says:\n\nMay 3, 2010 at 1:20 pm\n\n@Veky, I still fail to see why \u201creturn 0;\u201d is considered unreachable. For that\nto be true, the loop has to either a) return 1 from within the loop, which is\na circular argument for why fermat() returns 1, or b) run infinitely, which\ncontradicts what we see.\n\n  43. roy_hu says:\n\nMay 3, 2010 at 1:23 pm\n\nAh, I see why \u201creturn 0;\u201d is unreachable now, because those two cases are the\nonly possible cases.\n\n  44. leon says:\n\nMay 6, 2010 at 4:25 am\n\nThis is indeed an infinite loop. \u2013 and the compilers see that. in fact the\ncode does nothing but enumerating the variables. try writing to /dev/null an\nit will do the trick. In case of a non operating system run, you can defiantly\ntry to access some libs for checking the time and hang until T+x. In any case:\nhave you ever hear about the sleep function?\n\n  45. zertrat says:\n\nMay 8, 2010 at 5:09 pm\n\nI know you mathemeticians are into mathematical proofs, which are beyond my\nexpertise or interest, but of course this is a dimensional problem, and you\ncannot express something with fewer variables than dimensions. That is my\nproof. Let you mathemeticians waste more centuries on this.\n\n  46. Ernie Cohen says:\n\nMay 30, 2010 at 3:37 am\n\nI tried these with the 64-bit Microsoft compiler in VS2008 and the programs\nabove all seem to loop appropriately. Which test did you have it failing?\n\n  47. regehr says:\n\nMay 30, 2010 at 8:39 am\n\nHi Ernie-\n\nYou can find source code and compiler options for VS 2008 and 2010 in a post\nin this thread here:\n\nhttp://groups.google.com/group/comp.std.c/browse_thread/thread/bc57eedf030cd192\n\n  48. Sean Parker says:\n\nAugust 11, 2010 at 8:42 am\n\nThis is a fascinating conversation. However if I put in a math operation, I\nwant it to be executed. (Perhaps this is a program for seeing how much power\nthe math chip consumes when fully loaded?) I shouldn\u2019t have to know\nhow/when/why a compiler might remove my perfectly valid code. If it wants to\noptimize the MATH, great, but it shouldn\u2019t optimize away my intent. For\nexample I\u2019m debugging a while loop (thus my research into this topic and\ncoming across this VERY HELPFUL discussion) that increments an integer by\nreference. Even though the while-condition involved the integer (by ref) the\ncompiler still optimized away the while (but not a single iteration of the\ncontents of the while) (It behaves like an \u2018if\u2019 not a \u2018while\u2019) This is simply\none of those issues that makes software \u201chard\u201d, and thus makes S/W engineering\nexpensive. Why does it have to be so damn hard?\n\nPerhaps an optimization level of \u20184\u2019 could be used to remove ridiculous-\ninfinite-loops-with-no-consequences, then those that care about it can use\nthat. (But then why are they using such silly constructs to require optimizing\nthem?)\n\nCheers\n\n  49. Two articles worth reading | Real-Time Systems Design says:\n\nFebruary 9, 2011 at 1:31 pm\n\n[...] \u2013 C compilers disprove Fermat\u2019s Last Theorem\n<http://blog.regehr.org/archives/140&gt; [...]\n\nEmbedded in Academia\n\nProudly powered by WordPress\n\n", "frontpage": false}
