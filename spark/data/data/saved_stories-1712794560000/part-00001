{"aid": "39993976", "title": "Code Search Is Hard", "url": "https://blog.val.town/blog/search-notes/", "domain": "val.town", "votes": 29, "user": "stevekrouse", "posted_at": "2024-04-10 18:15:08", "comments": 13, "source_title": "Code Search is Hard", "source_text": "Code Search is Hard\n\n# Code Search is Hard\n\nTom MacWright on Apr 10, 2024\n\nVal Town\u2019s search functionality isn\u2019t very good. Right now it\u2019s built on the\nPostgres ILIKE functionality, which just performs a substring search: if your\nsearch term is in the code, it appears in search results. There\u2019s virtually no\nranking involved, and queries with multiple words are pretty poorly supported.\nBetter search is one of our most-requested features.\n\nI\u2019m working on improving this, but we haven\u2019t found a solution that fits our\nneeds yet. Here are some notes from our research. So far what we\u2019ve learned is\nthat:\n\n  * Mainstream search solutions are designed for natural language, not code.\n  * Big companies with code search needs have spent a lot of time and money building their own custom solutions.\n  * We have a lot of data already, and need a solution that scales well.\n  * The infrastructure and complexity tradeoffs involved in using a separate search service instead of a database extension are important.\n\n### Code search versus natural language search\n\nA common issue with off-the shelf search solutions is that they\u2019re designed to\nwork with English and other natural languages. For example, here are some of\nthe algorithms you get by default with a usual FTS setup:\n\n  * Stop words removal: words like \u201cthe\u201d and \u201cit\u201d are removed from text before it is indexed, because they\u2019re so common that they cause more problems for performance than they\u2019re worth.\n  * Stemming: this mostly reverses conjugation, turning a word like \u201crunning\u201d into \u201crun\u201d before it is added to the index, and doing the same for search queries, so that you can search for \u201cruns\u201d and get a search result for a document with the term \u201crunning.\u201d\n  * Lemmatization: some search indexes are even fancy enough to substitute synonyms for more common words, so that you can search for \u201cexcellent\u201d and get results for documents including \u201cgreat.\u201d\n\nAll together, this means that the vector derived from a document that you\u2019re\nstoring in the index does not look like the document at all:\n\n    \n    \n    select * from to_tsvector('english', 'I am writing this example sentence');\n    \n    --- 'exampl':5 'sentenc':6 'write':3\n\nThe problem with all of these rules is that they wreak havoc on code. the is\nnot a stop-word in TypeScript: it\u2019s a valid variable name that you might want\nto search for. Word boundaries aren\u2019t the same, and stemming function names\ndoesn\u2019t make much sense.\n\n    \n    \n    select * from to_tsvector('english',\n    \n    'function stringifyNumber(a: number): string { return a.toString() }');\n    \n    -- 'a.tostring':7 'function':1 'number':4 'return':6 'string':5 'stringifynumb':2\n\nThis is a pretty bad index: it has words that should be stop words, like\nfunction, and won\u2019t split a.toString() into two tokens because . is not a\ndefault word boundary.\n\n### Full Text Search\n\nPostgres has a Full Text Search extension which is supported by our hosting\nprovider, Render. I\u2019ve used FTS in previous projects, and for certain scales,\nit works great. You can try and use Postgres for everything, and frankly, so\nfar we have: we\u2019ve been using the heck out of Postgres. It\u2019s a fantastic piece\nof technology with great documentation that is well-supported by our hosting\nprovider.\n\nIf we can use Postgres for something, we will: keeping infrastructure as\nsimple as possible is essential with a small team.\n\nHowever, the previous projects I\u2019ve used FTS for have run into performance\nproblems and struggled to scale - Observable ended up moving to Elasticsearch.\nWe have a ton of vals, and are testing the limits of a single-node Postgres\ncluster. It\u2019s hard to find any accounts of code-search using FTS, though\npeople might be quietly succeeding with it. I wanted to avoid this as a first\noption but keep it in my back pocket.\n\n### pg_trgrm\n\nThe solution that we\u2019ve soft-launched as the v2 search algorithm is based on\npg_trgrm, which implements trigram search in Postgres. Code search does seem\nto succeed with trigrams: Russ Cox\u2019s famous (to me?) piece from 2012 tells the\nstory of how Google Code Search used trigram indexes and a special regex\nimplementation to succeed, technically. GitHub\u2019s new search system uses\ntrigram search too, in addition to a lot of technology that I\u2019m jealous of.\nSourcegraph has a trigram-based search tool that they\u2019ve inherited from\nGoogle, too.\n\nOur work with the Postgres pg_trgrm approach has been heavily informed by\nStephen Gutekanst\u2019s blog post series about indexing repositories locally in\nPostgres. We\u2019ve created a GIN index with gin_trgm_ops on a column containing\nsearch text.\n\nThe conclusion so far is that this is a great solution for regex search, but\nwe\u2019re not doing regex search: most searches are more freeform. We\u2019re using\nword_similarity for search ranking, and it has been very hard to coax the\nalgorithm into giving us anything like a reasonable ranking.\n\n### The universe of options\n\nOption| Architecture| Language| Stars  \n---|---|---|---  \nMeilisearch| Standalone| Rust| 41k  \nTypesense| Standalone| C++| 17k  \nZoekt| Standalone| Go| 406  \nParadeDB| Postgres extension| Rust| 3.2k  \nSonic| Standalone| Rust| 19.4k  \n  \nThere are code-specific tools that exist, but most of them are closed-source:\nGitHub\u2019s search is excellent, but is obviously the work of a dedicated team\nwith a real time budget.\n\n  * Sourcegraph\u2019s maintained fork of Zoekt is pretty cool, but is pretty fearfully niche and would be a big, new infrastructure commitment.\n  * Elasticsearch might be the eventual, unavoidable solution to this problem. It doesn\u2019t have code-specific handling, but can be customized in nearly infinite ways. We\u2019re not excited to start learning about Java memory tuning and to introduce the first persistent disk storage to our application, as well as an additional source of truth for our data. Possibly we could use Elasticsearch Cloud to avoid the maintenance overhead.\n  * Meilisearch seems like a promising ES alternative with the shininess of \u2728Rust\u2728, but they seem to emphasize latency over scalability, and we\u2019re not sure if the infrastructure commitment would be any lower.\n  * ParadeDB promises to be like Elasticsearch but \u201cjust Postgres,\u201d which is very appealing, but we can\u2019t use their extension in Render yet.\n\nIn short, we\u2019re still working on it. Searching code instead of English makes\nthe difficulty level a bit higher. For a small team, with an incentive to keep\ninfrastructure simple, development environments easy to set up, and data in\nthe same place, we\u2019re trying to be careful not to commit to something that\nrequires constant upkeep. There\u2019s a reason why most mid and large-sized\ncompanies have a search \u201cteam,\u201d not just a search service.\n\nEdit this page\n\n\u00a9 2024 Val Town. All rights reserved.\n\nRSS Follow Val Town on Twitter Go to Val Town's GitHub repos\n\n", "frontpage": true}
